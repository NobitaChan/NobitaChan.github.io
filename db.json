{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/assets/background.jfif","path":"assets/background.jfif","modified":1,"renderable":1},{"_id":"themes/next/source/assets/background_1.png","path":"assets/background_1.png","modified":1,"renderable":1},{"_id":"themes/next/source/assets/background_2.jpg","path":"assets/background_2.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"source/_data/styles.styl","hash":"938b8a0e518a951460942d74d0e6f76e51fc9658","modified":1631445805173},{"_id":"source/_posts/2021-07-04-搭建个人博客总结.md","hash":"90d517326942ad4b8f814abc06c76ab5ed51a831","modified":1642868295910},{"_id":"source/_posts/2021-07-06-《Speed Down》Unity2d游戏开发（一）.md","hash":"ba4212c8ec782b9f80789d40074f39d7708729fa","modified":1626596697256},{"_id":"source/_posts/2021-07-06-解决Github无法访问.md","hash":"899ecd2535906eb1ee3d70ac3fa2c1ea31a86a86","modified":1626345860825},{"_id":"source/_posts/2021-07-08-【LeetCode.930】和相同的二元子数组.md","hash":"76fe646017906a5e219f14962e83cb14ae4e381c","modified":1627024095137},{"_id":"source/_posts/2021-07-08-再临Unity.md","hash":"6679e68090bb3b793406a907287e72c24ad46c01","modified":1632032274683},{"_id":"source/_posts/2021-07-14-《Speed Down》Unity2d游戏开发（四）.md","hash":"abb0f6c32f1a800038b1cdf457b298ee69c06007","modified":1626344810794},{"_id":"source/_posts/2021-07-15-《Speed Down》Unity2d游戏开发（五）.md","hash":"14585f8e2019103367675b30c77a84b7f56ddf6e","modified":1626357515350},{"_id":"source/_posts/2021-07-13-《Speed Down》Unity2d游戏开发（二）.md","hash":"09caad4a8ca562e21f88de3626e13efbdd13011a","modified":1626441107940},{"_id":"source/_posts/2021-07-14-《Speed Down》Unity2d游戏开发（三）.md","hash":"b1f6484eeed52f17cfee9119dbc2052e38c8592c","modified":1626344804171},{"_id":"source/_posts/2021-07-15-《Speed Down》Unity2d游戏开发（六）.md","hash":"37466148b507c0df79119ccf2767b4ba0e0ddf1f","modified":1626515987909},{"_id":"source/_posts/2021-07-17-【LeetCode.剑指Offer.42】连续子数组的最大和.md","hash":"7d8781899c9da321b51037452df93adf1d367997","modified":1627024071633},{"_id":"source/_posts/2021-07-16-《Speed Down》Unity2d游戏开发（完）.md","hash":"a0e9a5f001a5f637ed3200dc9a5bd5fd7516b4d1","modified":1632032224993},{"_id":"source/_posts/2021-07-18-《Robbie Swifthand》Unity2d独立游戏学习（一）.md","hash":"d16d1120e58f7b733223a7f8320a2590e4dacc6e","modified":1628938622779},{"_id":"source/_posts/2021-07-19-《Robbie Swifthand》Unity2d独立游戏学习（二）.md","hash":"866c3cadc36fab7c29be57b4921707c8a1b7193f","modified":1628938612982},{"_id":"source/_posts/2021-07-20-《Robbie Swifthand》Unity2d独立游戏学习（三）.md","hash":"9e958bf80743ea7abb359ecf6fe32a2e2fb4bf88","modified":1626855438832},{"_id":"source/_posts/2021-07-23-《Robbie Swifthand》Unity2d独立游戏学习（四）.md","hash":"8cfe60fe719d8463c291f01711e13ebead2dc89d","modified":1627631601103},{"_id":"source/_posts/2021-07-22-【LeetCode.138】 复制带随机指针的链表.md","hash":"d9deae8ac413c7da76a88766de69e39c8362b224","modified":1627024669852},{"_id":"source/_posts/2021-07-26-【LeetCode.1143】最长公共子序列.md","hash":"26e9f0e2b3d84b4d059060371b977f53bd0ebbb3","modified":1627315268266},{"_id":"source/_posts/2021-07-30-《Robbie Swifthand》Unity2d独立游戏学习（五）.md","hash":"f0dfb923a1688afbaf4a45d2c2093705e5d7976c","modified":1628419554139},{"_id":"source/_posts/2021-08-04-【LeetCode.611】有效三角形的个数.md","hash":"2a9325ef38b4acb1736efd5f73d615e33e59589d","modified":1628065566806},{"_id":"source/_posts/2021-08-08-【LeetCode.457】环形数组是否存在循环.md","hash":"ad8e9aa712c25a63962ae7c4657765943d7b4a4d","modified":1628419143920},{"_id":"source/_posts/2021-08-11-C++中map和unordered_map的区别和使用.md","hash":"976314c874cd26e6bb1aa97f3fd2695716019f23","modified":1628753873001},{"_id":"source/_posts/2021-08-11-【LeetCode.446】等差数列划分 II - 子序列.md","hash":"6fe7cc5ad276c91a37feb97fc56451c172a539f9","modified":1628705384399},{"_id":"source/_posts/2021-09-12-《Robbie Swifthand》Unity2d独立游戏学习（七）.md","hash":"308f7dee7f27dbb506515773383826b46bc78fa5","modified":1644409974003},{"_id":"source/_posts/2021-08-14-《Robbie Swifthand》Unity2d独立游戏学习（六）.md","hash":"badc6b4e18e0596471fdd433cba0d11f0c222b06","modified":1628941043721},{"_id":"source/_posts/2021-08-18-【LeetCode.552】学生出勤记录 II.md","hash":"d5e6905034960166324befaf795ae0c26f11540c","modified":1629292354063},{"_id":"source/_posts/2021-09-12-《多视角深度相机的猪体三维点云重构及体尺测量》阅读笔记.md","hash":"41fef13def61b52f0fa0858cc1ccf93d38b20656","modified":1635332490404},{"_id":"source/_posts/2021-09-19-【LeetCode.650】只有两个键的键盘.md","hash":"5d576d4f0e5ded70742e6e16f5f541aabc1208a6","modified":1633504188243},{"_id":"source/_posts/2021-09-29-Pytorch深度学习环境配置.md","hash":"5ffd5691b5087aa946c0371d597d7111e59698a6","modified":1634208743446},{"_id":"source/_posts/2021-09-30-Python学习日志Day1.md","hash":"f20b166492c23b1778794426e7ae1628a188563a","modified":1632980258611},{"_id":"source/_posts/2021-10-05-【LeetCode.284】顶端迭代器.md","hash":"b02bf0787f81de6dc2556e2896e38fcbd3deee4f","modified":1633510800742},{"_id":"source/_posts/2021-10-05-Python学习日志Day2.md","hash":"e3cdf361e460068e26f2e11c28ebbae9f7bde323","modified":1633503939339},{"_id":"source/_posts/2021-10-06-Python学习日志Day3.md","hash":"a3dfce4d7e960f3eadfbc5f7bf9d665ee4f38d0b","modified":1634197196117},{"_id":"source/_posts/2021-10-14-Jupyter Notebook修改默认路径.md","hash":"631d0e9a35b2109c9f1ebca35c67aa6bac91a92a","modified":1635746293581},{"_id":"source/_posts/2021-10-16-八爪鱼零编程爬虫入门.md","hash":"832706e5c9b94d3e766e6b137b77530930e68145","modified":1634701294172},{"_id":"source/_posts/2021-10-30-《Computational Methods of Acquisition and Processing of 3D Point Cloud Data for Construction Applications》阅读笔记.md","hash":"be8550564145074a27379a5c0afd630fd63eb418","modified":1642916124012},{"_id":"source/_posts/2022-01-21-算法题方法总结（数组基础）.md","hash":"7a850229c69d6dd0eb56f723beb24c52593b3e9e","modified":1643876440194},{"_id":"source/_posts/2022-04-03-Ubuntu锐捷认证校园网并设置开机自启动.md","hash":"c6d458d0b78a7040ec2d376437e7d9f37e835f06","modified":1648969173249},{"_id":"source/_posts/更2021-07-09-C++STL.md","hash":"6c4d1ca92b69265077f1c9f1f86c426421397db6","modified":1629371252470},{"_id":"source/_posts/更2021-09-13-《Robbie Swifthand》Unity2d独立游戏学习（八）.md","hash":"3fa0474ae0527047938ac3f6c7cbf32a1db63b6d","modified":1632044971301},{"_id":"source/_posts/更2022-01-31-三维重建综述.md","hash":"85c856af1f984a3ee225f92f8d6dd72d5bce2398","modified":1645453068806},{"_id":"source/_posts/更2022-02-03-算法题方法总结（链表基础）.md","hash":"6ce93b84052ee446bda6be73435dda4693e84c1e","modified":1644127014133},{"_id":"source/_posts/置顶页面Top.md","hash":"f0bab6760b0bf3e44eeb1dde4e44ed629f737d56","modified":1633504810598},{"_id":"source/tags/index.md","hash":"f51e5d45846b5a6b2c5313303ebf650556e25bff","modified":1625490765443},{"_id":"source/categories/index.md","hash":"dea7db88b4e81bdccdf5a866f27655d8fb623d02","modified":1625500055970},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1625474600082},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1625474600082},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1625474600086},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1625474600083},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1625474600086},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1625474600087},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1625474600087},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1625474600087},{"_id":"themes/next/_config.yml","hash":"5e39a15f4f5ceffa0f0be143c54a9512f184847e","modified":1625903939048},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1625474600088},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1625474600093},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1625474600116},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1625474600083},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1625474600083},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1625474600085},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1625474600085},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1625474600085},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1625474600085},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1625474600085},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1625474600086},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1625474600086},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1625474600086},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1625474600086},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1625474600088},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1625474600088},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1625474600089},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1625474600089},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1625474600089},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1625474600089},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1625474600089},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1625474600090},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1625474600090},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1625474600094},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1625474600094},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1625474600094},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1625474600094},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1625474600094},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1625474600095},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1625474600095},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1625474600095},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1625474600095},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1625474600096},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1625474600096},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1625474600096},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1625474600096},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1625474600097},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1625474600096},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1625474600097},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1625474600097},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1625474600097},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1625474600097},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1625474600098},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1625474600098},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1625474600098},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1625474600098},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1625474600115},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1625474600115},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1625474600115},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1625474600115},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1625474600115},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1625474600116},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1625474600122},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1625474600084},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1625474600084},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1625474600084},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1625474600084},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1625474600090},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1625474600090},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1625474600091},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1625474600091},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1625474600091},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1625474600092},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1625474600092},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1625474600092},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1625474600092},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1625474600093},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1625474600093},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1625474600093},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1625474600093},{"_id":"themes/next/layout/_macro/post.swig","hash":"60aa59b746995d8baa4a0c5b0d78eb5fe52f4ae4","modified":1625905178677},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1625474600099},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1625474600099},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1625474600099},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4369b313cbbeae742cb35f86d23d99d4285f7359","modified":1625474600100},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1625474600102},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1625474600102},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1625474600105},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1625474600105},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1625474600105},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1625474600106},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1625474600107},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1625474600107},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1625474600108},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1625474600110},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1625474600111},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1625474600111},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1625474600125},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1625474600141},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1625474600147},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1625474600148},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1625474600148},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1625474600148},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1625474600148},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1625474600149},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1625474600149},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1625474600149},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1625474600149},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1625474600150},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1625474600150},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1625474600150},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1625474600150},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1625474600150},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1625474600151},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1625474600151},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1625474600151},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1625474600151},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1625474600152},{"_id":"themes/next/source/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1625474600152},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1625474600153},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1625474600117},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1625474600120},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1625474600120},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1625474600120},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1625474600120},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1625474600121},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1625474600121},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1625474600121},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1625474600122},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1625474600122},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1625474600122},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1625474600123},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1625474600123},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1625474600123},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1625474600123},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1625474600124},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1625474600124},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1625474600124},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1625474600124},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1625474600124},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1625474600100},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1625474600100},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1625474600101},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1625474600101},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1625474600101},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1625474600101},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1625474600102},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1625474600102},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1625474600102},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1625474600103},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1625474600103},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1625474600103},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1625474600103},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1625474600103},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1625474600104},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1625474600104},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1625474600104},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1625474600104},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1625474600105},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1625474600106},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1625474600106},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1625474600106},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1625474600106},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1625474600107},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1625474600108},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1625474600108},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1625474600108},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1625474600108},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1625474600109},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1625474600109},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1625474600109},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1625474600109},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1625474600109},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1625474600110},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1625474600110},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1625474600110},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1625474600111},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1625474600111},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1625474600112},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1625474600112},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1625474600112},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1625474600113},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1625474600113},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1625474600113},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1625474600113},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1625474600114},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1625474600114},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1625474600114},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1625474600146},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1625474600146},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1625474600146},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1625474600147},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1625474600147},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1625474600152},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1625474600152},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1625474600155},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1625474600156},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1625474600117},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1625474600117},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1625474600117},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1625474600118},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1625474600118},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1625474600118},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1625474600119},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1625474600118},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1625474600119},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1625474600119},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1625474600119},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1625474600125},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1625474600126},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1625474600126},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1625474600130},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1625474600134},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1625474600134},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1625474600137},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1625474600137},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1625474600137},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1625474600139},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1625474600139},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1625474600139},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1625474600139},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1625474600141},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1625474600142},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1625474600142},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1625474600142},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1625474600142},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1625474600143},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1625474600143},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1625474600143},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1625474600143},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1625474600144},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1625474600144},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1625474600144},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1625474600144},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1625474600145},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1625474600145},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1625474600145},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1625474600145},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1625474600145},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1625474600146},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1625474600154},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1625474600154},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1625474600126},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1625474600126},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1625474600127},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1625474600127},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1625474600127},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1625474600127},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1625474600128},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1625474600128},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1625474600128},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1625474600128},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1625474600129},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1625474600129},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1625474600129},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1625474600129},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1625474600129},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1625474600130},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1625474600130},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"78207f1d136bf750a265566f05999febb18ba39e","modified":1625904371368},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1625474600131},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1625474600131},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1625474600131},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1625474600131},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1625474600132},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1625474600132},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1625474600132},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1625474600133},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1625474600133},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1625474600133},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1625474600133},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1625474600134},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1625474600133},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1625474600135},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1625474600134},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1625474600135},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1625474600135},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1625474600135},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1625474600136},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1625474600136},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1625474600136},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1625474600136},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1625474600136},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1625474600138},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1625474600138},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1625474600138},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1625474600138},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1625474600140},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1625474600140},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1625474600140},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1625474600140},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1625474600140},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1625474600141},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1625474600141},{"_id":"themes/next/source/images/avatar.jpg","hash":"acdc7d95a97b1c233e787bfc9d7b321c52a2cf3c","modified":1625497456410},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1625474600154},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1625474600155},{"_id":"themes/next/source/assets/background.jfif","hash":"09260eb21de38df98bc0b807bcf4e9418e788bb4","modified":1631445770837},{"_id":"themes/next/source/assets/background_1.png","hash":"6cea513ac9097638ccc8c70bd3b0b9e1eb2a84da","modified":1625911300502},{"_id":"themes/next/source/assets/background_2.jpg","hash":"593cc719af02a196e794ca8b6f061d8027b97c5b","modified":1628939254435},{"_id":"public/search.xml","hash":"09e04cbbbb131edc6a2d55eb2102a0fd4ff6cd64","modified":1648970054452},{"_id":"public/tags/index.html","hash":"52d84f9de3cce38232163abc022f8ed05d6d9bbc","modified":1648970054452},{"_id":"public/categories/index.html","hash":"0a21b40963fed524ef77f5e7987e26313e465d3d","modified":1648970054452},{"_id":"public/2022/02/03/更2022-02-03-算法题方法总结（链表基础）/index.html","hash":"1e09f4979502797d39dfa442af90916e244e0fa3","modified":1648970054452},{"_id":"public/2021/10/14/2021-10-14-Jupyter Notebook修改默认路径/index.html","hash":"de7d6e03b3ce260d896f4767fa45d21b8bf42e47","modified":1648970054452},{"_id":"public/2021/07/09/置顶页面Top/index.html","hash":"158feeeaaf97f94805dddb09fedb528cfdae8d5b","modified":1648970054452},{"_id":"public/archives/page/5/index.html","hash":"db96a453a9a1265aa100e39b3a8c574133dca6bb","modified":1648970054452},{"_id":"public/archives/2021/07/page/3/index.html","hash":"18d46e6ece2dc95f736aa193f13ef8545c2b0f5d","modified":1648970054452},{"_id":"public/archives/2021/08/index.html","hash":"b1383d439f20c2d82e9d9ae1eca3d1554e11e8ad","modified":1648970054452},{"_id":"public/archives/2021/09/index.html","hash":"82ed0292619c2b1dea2f3432ba4d857ad32eca2b","modified":1648970054452},{"_id":"public/archives/2021/10/index.html","hash":"4e4c00f103fb9c0e00f42b05ea47411c6e9943a4","modified":1648970054452},{"_id":"public/archives/2022/index.html","hash":"19c638bfdbdb571081292dae11416f36db15af9e","modified":1648970054452},{"_id":"public/archives/2022/01/index.html","hash":"02ab28fd68fd84ad1bc5911a3c80ea60f41b18a1","modified":1648970054452},{"_id":"public/archives/2022/02/index.html","hash":"4090e8fd437f5d1923628edd429c85d0e51bce45","modified":1648970054452},{"_id":"public/archives/2022/04/index.html","hash":"550d952908bcfd195604aacc82479b40f14aa983","modified":1648970054452},{"_id":"public/categories/琐碎/index.html","hash":"fc2b6f14454565c628925e02d74e44aea1be0533","modified":1648970054452},{"_id":"public/categories/unity/page/2/index.html","hash":"da942c5fe3e7a517cf0c5e454d26d2a4670f105f","modified":1648970054452},{"_id":"public/categories/算法/page/2/index.html","hash":"6b3f90b1728d7a90ae4eb18060a2eb5803c44994","modified":1648970054452},{"_id":"public/categories/c/index.html","hash":"a85718fe8f801cff7be77f74b8194ddd3236ad47","modified":1648970054452},{"_id":"public/categories/阅读笔记/index.html","hash":"b762b94eb77d1ec9b854986e8339dcd91a4133ea","modified":1648970054452},{"_id":"public/categories/python/index.html","hash":"87ebf6863a6e0d3b18826148cdc5ac55caf2195b","modified":1648970054452},{"_id":"public/categories/linux/index.html","hash":"c782a8c533675b0aa8b09f4387b8bb2bc0e9344f","modified":1648970054452},{"_id":"public/tags/hexo/index.html","hash":"ff50b0eba342e7da732e98f76eb976f294b40dd5","modified":1648970054452},{"_id":"public/tags/git/index.html","hash":"3bae3f3441bce2cdb4d6f885fa46510fca922530","modified":1648970054452},{"_id":"public/tags/github/index.html","hash":"123912143764abe3d7868638481b85287d9cdd0b","modified":1648970054452},{"_id":"public/tags/typora/index.html","hash":"c36634b97f5f92475d0e65b21a83866d97e582ab","modified":1648970054452},{"_id":"public/tags/next/index.html","hash":"a825dd5cbeb44b9818816f2450ebea83df36b888","modified":1648970054452},{"_id":"public/tags/unity/page/2/index.html","hash":"bcc66bf3c8d16746e8e4b91000f59ac4167d9526","modified":1648970054452},{"_id":"public/tags/c/page/2/index.html","hash":"cfbddf41da05ee8cd0f47a7c3f23f071f509202c","modified":1648970054452},{"_id":"public/tags/unityhub/index.html","hash":"97fb0d2a9a44c6c86ef4ff9723be20eef9fbf43c","modified":1648970054452},{"_id":"public/tags/2d/index.html","hash":"369c951da6cd566e056beb8ce3c311a6b75f75e5","modified":1648970054452},{"_id":"public/tags/windows/index.html","hash":"ff146aa72de658d9918d9d000d22192e6efca783","modified":1648970054452},{"_id":"public/tags/滑动窗口法/index.html","hash":"0f39358b8ff3ac2a8b56a09811a17e8e2632be91","modified":1648970054452},{"_id":"public/tags/数组/index.html","hash":"5a286130074f66d5998ba3d6fafa0cf453dd364a","modified":1648970054452},{"_id":"public/tags/ps/index.html","hash":"5820d8859611d9c2544a95e7e6ff72d354b1a7cc","modified":1648970054452},{"_id":"public/tags/像素/index.html","hash":"b616924407a10420c1bd78f56847eb16e639eb5e","modified":1648970054452},{"_id":"public/tags/prefab/index.html","hash":"9d950ecc1c89654823111697ad8f1f5613dc0942","modified":1648970054452},{"_id":"public/tags/trigger/index.html","hash":"034ea78d0e9b2333f11f1d4ff1fe193086725589","modified":1648970054452},{"_id":"public/tags/collision/index.html","hash":"ce99708b8891b30fa308fe95557f0fe8e8b51422","modified":1648970054452},{"_id":"public/tags/animator/index.html","hash":"8ed771f89911587c7cfcf56be168c4743532a82e","modified":1648970054452},{"_id":"public/tags/collider/index.html","hash":"a3aa69c2d2aaa1710716955492f2cc12fcd6b4b3","modified":1648970054452},{"_id":"public/tags/awake/index.html","hash":"aeabab557f986444d5c16abf95c529647843edd9","modified":1648970054452},{"_id":"public/tags/canvas/index.html","hash":"15345e7bf0ed067d9e2880f5234b361407fa8320","modified":1648970054452},{"_id":"public/tags/joint/index.html","hash":"cb8bc438fb43e8e59e5af7e88a3c4033fb0b3a3e","modified":1648970054452},{"_id":"public/tags/动态规划/index.html","hash":"b75c0a254a3bce9de7abac3dc09c0db62142d173","modified":1648970054452},{"_id":"public/tags/tilemap/index.html","hash":"1d83d6d64f35ab7c07a24fe6c890608c0e3d990a","modified":1648970054452},{"_id":"public/tags/raycast/index.html","hash":"8fbbcc332693f12c23cee0979d220d68298f8d37","modified":1648970054452},{"_id":"public/tags/update/index.html","hash":"fed34106369a97c8a35c3a3e079940c120743fae","modified":1648970054452},{"_id":"public/tags/camera/index.html","hash":"fe911d2e4e6bc2aebe1900d13fac85b0bed6e3cc","modified":1648970054452},{"_id":"public/tags/原地算法/index.html","hash":"271746296247509260616415b69e32a80a56874a","modified":1648970054452},{"_id":"public/tags/链表/index.html","hash":"6d0edb8d0c80616929420d40299b701e6c1f6936","modified":1648970054452},{"_id":"public/tags/vector/index.html","hash":"9f25d7eb5cdb290e0dd438d8bced514147df718d","modified":1648970054452},{"_id":"public/tags/audio/index.html","hash":"028a6108115cd71c14be75f3d3476801c19aeead","modified":1648970054452},{"_id":"public/tags/双指针法/index.html","hash":"51a12dbce8dd4fdee47e2d2e2b9f6dfda868dddc","modified":1648970054452},{"_id":"public/tags/快慢指针/index.html","hash":"1d73fb5750b0004b412a82f8e58ecf231b6ff966","modified":1648970054452},{"_id":"public/tags/map/index.html","hash":"236c23d94b8f4e62bfc7a1fea7190404ef29eb66","modified":1648970054452},{"_id":"public/tags/三维重构/index.html","hash":"f6ffcc1a0162ec801ca03ed255f35c32be2db59d","modified":1648970054452},{"_id":"public/tags/图像处理/index.html","hash":"f937d216a2ab1f169869824cd499807254de60fe","modified":1648970054452},{"_id":"public/tags/三维点云/index.html","hash":"cdc0a56f98184da176d728f9f36ad340930f389f","modified":1648970054452},{"_id":"public/tags/体尺测量/index.html","hash":"5d79352824ef42d2fb3457afa66c0128db2f8906","modified":1648970054452},{"_id":"public/tags/pytorch/index.html","hash":"6441f71d581bf0f76e1e94060e7b6d1ef45a468b","modified":1648970054452},{"_id":"public/tags/python/index.html","hash":"46a5495920699674e5475343df3890873d76fb9f","modified":1648970054452},{"_id":"public/tags/anaconda/index.html","hash":"e2d3e95c660cd4f88074f2ac2f08b21dcc3f8f8b","modified":1648970054452},{"_id":"public/tags/迭代器/index.html","hash":"d32eb9df9394b05f2ca55ce9f13679274aab98a2","modified":1648970054452},{"_id":"public/tags/pyhton/index.html","hash":"869bc5af7e5134802135b6b5036fcfdca886fa5f","modified":1648970054452},{"_id":"public/tags/数据结构/index.html","hash":"e7afd333c74a516a8c4403c5a3cf1fef456d93a9","modified":1648970054452},{"_id":"public/tags/jupyter/index.html","hash":"9fa568d14846ae6fb8ea7a2ff4abda9dc2bb1213","modified":1648970054452},{"_id":"public/tags/爬虫/index.html","hash":"323b8dec551b97bf5c8e38c417506e4beb9d9c64","modified":1648970054452},{"_id":"public/tags/linux/index.html","hash":"b26add9bc2bc2dbc6e8ae9e642fd27996008dc57","modified":1648970054452},{"_id":"public/tags/ubuntu/index.html","hash":"1a7a7f53afcf720ee941a8398b0e836363e13cea","modified":1648970054452},{"_id":"public/tags/stack/index.html","hash":"9c7b0c17cfbac807ab2656a78507f3d5872aa13a","modified":1648970054452},{"_id":"public/2022/04/03/2022-04-03-Ubuntu锐捷认证校园网并设置开机自启动/index.html","hash":"245a87ef692f61ff2445a7ce7bcc47d64a0aba00","modified":1648970054452},{"_id":"public/2022/01/31/更2022-01-31-三维重建综述/index.html","hash":"c43d65c7ad1499a1d046eb941bbc9ba85edc7996","modified":1648970054452},{"_id":"public/2022/01/21/2022-01-21-算法题方法总结（数组基础）/index.html","hash":"b80168368fcf10a0bdd8199107dd5e3a1af97c37","modified":1648970054452},{"_id":"public/2021/10/30/2021-10-30-《Computational Methods of Acquisition and Processing of 3D Point Cloud Data for Construction Applications》阅读笔记/index.html","hash":"666efeaa6bc5f69368274a606565f9e791b28d04","modified":1648970054452},{"_id":"public/2021/10/16/2021-10-16-八爪鱼零编程爬虫入门/index.html","hash":"3c12b8c2b9fde6b7cd3167b6698225930ba67eca","modified":1648970054452},{"_id":"public/2021/10/06/2021-10-06-Python学习日志Day3/index.html","hash":"ceb717bab1981206d114500129e05d454869f282","modified":1648970054452},{"_id":"public/2021/10/05/2021-10-05-【LeetCode.284】顶端迭代器/index.html","hash":"ee8d015ad4fa49338d919f491f5d52cac98f7b32","modified":1648970054452},{"_id":"public/2021/10/05/2021-10-05-Python学习日志Day2/index.html","hash":"6afeb531b73c8dd346d776dcaf40c08c516fbbc3","modified":1648970054452},{"_id":"public/2021/09/30/2021-09-30-Python学习日志Day1/index.html","hash":"7c831f6914926a4a655cff77beb3db70ecf78af2","modified":1648970054452},{"_id":"public/2021/09/29/2021-09-29-Pytorch深度学习环境配置/index.html","hash":"4c86b7855961fecdc561c19d603a84ae2871045d","modified":1648970054452},{"_id":"public/2021/09/19/2021-09-19-【LeetCode.650】只有两个键的键盘/index.html","hash":"931789aace2fc72ae789a9297167b1d7ee69c8fc","modified":1648970054452},{"_id":"public/2021/09/13/更2021-09-13-《Robbie Swifthand》Unity2d独立游戏学习（八）/index.html","hash":"ea665a98c9374d2e628b55a4344931f221139c66","modified":1648970054452},{"_id":"public/2021/09/12/2021-09-12-《多视角深度相机的猪体三维点云重构及体尺测量》阅读笔记/index.html","hash":"0c91f8ddc84bb276b3604a85336b67d0f3e73072","modified":1648970054452},{"_id":"public/2021/09/12/2021-09-12-《Robbie Swifthand》Unity2d独立游戏学习（七）/index.html","hash":"c92644baca61de350f79c14e0f70fe46d3190cb3","modified":1648970054452},{"_id":"public/2021/08/18/2021-08-18-【LeetCode.552】学生出勤记录 II/index.html","hash":"2db53c3f0254aae008c57a95ec3c7aa8484cfe5b","modified":1648970054452},{"_id":"public/2021/08/14/2021-08-14-《Robbie Swifthand》Unity2d独立游戏学习（六）/index.html","hash":"6f86a6a6bd98cb4642937e776f5db517f8fae0d4","modified":1648970054452},{"_id":"public/2021/08/11/2021-08-11-C++中map和unordered_map的区别和使用/index.html","hash":"de269011ad9f9b7cf27cb715a4e73e23d84a6c00","modified":1648970054452},{"_id":"public/2021/08/11/2021-08-11-【LeetCode.446】等差数列划分 II - 子序列/index.html","hash":"d7fb81c5bbd1140be52908d2c627b764ffe1ef6d","modified":1648970054452},{"_id":"public/2021/08/08/2021-08-08-【LeetCode.457】环形数组是否存在循环/index.html","hash":"36d0b7fa7e7426cbe16f659bff71da8766d3c5b3","modified":1648970054452},{"_id":"public/2021/08/04/2021-08-04-【LeetCode.611】有效三角形的个数/index.html","hash":"c0f42e7d2d5dafb9f2ce49d8fbac05a2b447c38c","modified":1648970054452},{"_id":"public/2021/07/30/2021-07-30-《Robbie Swifthand》Unity2d独立游戏学习（五）/index.html","hash":"101329c595384f276a158c6c4bca780329a522c0","modified":1648970054452},{"_id":"public/2021/07/26/2021-07-26-【LeetCode.1143】最长公共子序列/index.html","hash":"7b1f263d171618a8b46a0349c7b005432c69a646","modified":1648970054452},{"_id":"public/2021/07/23/2021-07-23-《Robbie Swifthand》Unity2d独立游戏学习（四）/index.html","hash":"8eb0902ca5a0af4cc6c56f37d1b8ce5dfcece1ba","modified":1648970054452},{"_id":"public/2021/07/22/2021-07-22-【LeetCode.138】 复制带随机指针的链表/index.html","hash":"81d2e43076199a899e7f663bef46d90d89d81ee9","modified":1648970054452},{"_id":"public/2021/07/20/2021-07-20-《Robbie Swifthand》Unity2d独立游戏学习（三）/index.html","hash":"43bd4bd47b830ca9abc52761a62720e4a9c3977f","modified":1648970054452},{"_id":"public/2021/07/19/2021-07-19-《Robbie Swifthand》Unity2d独立游戏学习（二）/index.html","hash":"2d13a53331c7ffdd5cb89f65af4e7eeefc959170","modified":1648970054452},{"_id":"public/2021/07/18/2021-07-18-《Robbie Swifthand》Unity2d独立游戏学习（一）/index.html","hash":"fbe52e8a903c81d065e0c8ccf46841e7d0ddc322","modified":1648970054452},{"_id":"public/2021/07/17/2021-07-17-【LeetCode.剑指Offer.42】连续子数组的最大和/index.html","hash":"ce182cebf64730127c3bf09d962fbcb4009044c9","modified":1648970054452},{"_id":"public/2021/07/16/2021-07-16-《Speed Down》Unity2d游戏开发（完）/index.html","hash":"a7669331bc5699b13ab0290dbbd5c9a7fa65e3e3","modified":1648970054452},{"_id":"public/2021/07/15/2021-07-15-《Speed Down》Unity2d游戏开发（六）/index.html","hash":"28979d42fd67a7d40ed86e20fe0ff666c2b17605","modified":1648970054452},{"_id":"public/2021/07/15/2021-07-15-《Speed Down》Unity2d游戏开发（五）/index.html","hash":"4280aa32e46ab66c1a44c3b17687b7c236232df5","modified":1648970054452},{"_id":"public/2021/07/14/2021-07-14-《Speed Down》Unity2d游戏开发（四）/index.html","hash":"81cb4432fe6ca5ce7d64089fc82993c957b35862","modified":1648970054452},{"_id":"public/2021/07/14/2021-07-14-《Speed Down》Unity2d游戏开发（三）/index.html","hash":"24f271aaa2d1e89e2ccdb3e67bd086d6d870954c","modified":1648970054452},{"_id":"public/2021/07/13/2021-07-13-《Speed Down》Unity2d游戏开发（二）/index.html","hash":"a91d5275913c1c1b2a482f81827aab8dd36e0e8e","modified":1648970054452},{"_id":"public/2021/07/09/更2021-07-09-C++STL/index.html","hash":"5ba95d384f2f6628690ca1a5b61407eee703b1e1","modified":1648970054452},{"_id":"public/2021/07/08/2021-07-08-再临Unity/index.html","hash":"3b9d2ccab5b3bf9a70066f46b64bdecbb9f39635","modified":1648970054452},{"_id":"public/2021/07/08/2021-07-08-【LeetCode.930】和相同的二元子数组/index.html","hash":"7050f59d7349142bf90d142838fc46ba8ef6a14a","modified":1648970054452},{"_id":"public/2021/07/06/2021-07-06-《Speed Down》Unity2d游戏开发（一）/index.html","hash":"78adc7c365efbab873eb66804b8bebd2646ab41a","modified":1648970054452},{"_id":"public/2021/07/06/2021-07-06-解决Github无法访问/index.html","hash":"cc4f9a7b697a5b14238190e51e3b4649178705c4","modified":1648970054452},{"_id":"public/2021/07/04/2021-07-04-搭建个人博客总结/index.html","hash":"fe27c9a546e7057bafddb4ebd4769b63508bebfc","modified":1648970054452},{"_id":"public/archives/index.html","hash":"d8b64dc1654952db66fe3f863524e81073c47d9d","modified":1648970054452},{"_id":"public/archives/page/2/index.html","hash":"ce03ca20273986a8952b4eb8b80a97d737288300","modified":1648970054452},{"_id":"public/archives/page/3/index.html","hash":"f18a8d9162df200ea9f1e792a2560e335564842f","modified":1648970054452},{"_id":"public/archives/page/4/index.html","hash":"12915d8e755b803464ffd479ba5965bd3078ac25","modified":1648970054452},{"_id":"public/archives/2021/index.html","hash":"1334e40abccfdfe12250c8cd4c9bb45023b4df51","modified":1648970054452},{"_id":"public/archives/2021/page/2/index.html","hash":"90a0f7f8e981318c83b09cece2f21f96ede1d97c","modified":1648970054452},{"_id":"public/archives/2021/page/3/index.html","hash":"986fe16b716af647540665e93c2cebb2c9b1437b","modified":1648970054452},{"_id":"public/archives/2021/page/4/index.html","hash":"16f6eba2521b85f620453113d0b4c3e7c5e7626d","modified":1648970054452},{"_id":"public/archives/2021/07/index.html","hash":"ad78c178262967ec4e44af419d538a65ffeb365a","modified":1648970054452},{"_id":"public/archives/2021/07/page/2/index.html","hash":"b7e86ec4fdc38d6cea6fb73c0a8bbb65f0246bc8","modified":1648970054452},{"_id":"public/categories/unity/index.html","hash":"7e3d48f0b5ad5ae2404d6c37cf379785f995dad1","modified":1648970054452},{"_id":"public/categories/算法/index.html","hash":"5a7e69c4a1127d29c57da3326921b54bc7b15224","modified":1648970054452},{"_id":"public/index.html","hash":"41fa8d14bf74a35c05b2ca4189c694e2f2fe42a7","modified":1648970054452},{"_id":"public/page/2/index.html","hash":"88f34789fd26f710d625b4ea13cc5c7cd194bdd1","modified":1648970054452},{"_id":"public/page/3/index.html","hash":"20bdf39dbb70dd6853317fbf46b457cc290e8bb6","modified":1648970054452},{"_id":"public/page/4/index.html","hash":"4bcd747702733fb93e9959b02617274c19d9e296","modified":1648970054452},{"_id":"public/page/5/index.html","hash":"9201a360ac2f516272a3200171237aa33b118f25","modified":1648970054452},{"_id":"public/tags/unity/index.html","hash":"6695aeb147e49bbb71c635e007e9c06ee31d5434","modified":1648970054452},{"_id":"public/tags/c/index.html","hash":"e2e5fcc34a7ff941ed04369a87f2c2ce70d4885b","modified":1648970054452},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1648970054452},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1648970054452},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1648970054452},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1648970054452},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1648970054452},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1648970054452},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1648970054452},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1648970054452},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1648970054452},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1648970054452},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1648970054452},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1648970054452},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1648970054452},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1648970054452},{"_id":"public/images/avatar.jpg","hash":"acdc7d95a97b1c233e787bfc9d7b321c52a2cf3c","modified":1648970054452},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1648970054452},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1648970054452},{"_id":"public/assets/background.jfif","hash":"09260eb21de38df98bc0b807bcf4e9418e788bb4","modified":1648970054452},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1648970054452},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1648970054452},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1648970054452},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1648970054452},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1648970054452},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1648970054452},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1648970054452},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1648970054452},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1648970054452},{"_id":"public/css/main.css","hash":"af5d3e41257244a0dab96c95cc56dd0198cf3828","modified":1648970054452},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1648970054452},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1648970054452},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1648970054452},{"_id":"public/assets/background_1.png","hash":"6cea513ac9097638ccc8c70bd3b0b9e1eb2a84da","modified":1648970054452},{"_id":"public/assets/background_2.jpg","hash":"593cc719af02a196e794ca8b6f061d8027b97c5b","modified":1648970054452}],"Category":[{"name":"琐碎","_id":"cl1iy71h200041ou0b11r3z3o"},{"name":"unity","_id":"cl1iy71h500091ou00td50wx8"},{"name":"算法","_id":"cl1iy71hb000k1ou06pxt273w"},{"name":"c++","_id":"cl1iy71hs001s1ou075qfhmsa"},{"name":"阅读笔记","_id":"cl1iy71hx00271ou059mxc450"},{"name":"python","_id":"cl1iy71i4002i1ou0h8rk2t5v"},{"name":"linux","_id":"cl1iy71io00381ou04iow1gvb"}],"Data":[{"_id":"styles","data":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}],"Page":[{"title":"标签","date":"2021-07-05T13:11:11.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2021-07-05 21:11:11\ntype: \"tags\"\n---\n","updated":"2021-07-05T13:12:45.443Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cl1iy71gv00001ou06f2979ih","content":"","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"","more":""},{"title":"分类","date":"2021-07-05T13:22:54.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2021-07-05 21:22:54\ntype: \"categories\"\n---\n","updated":"2021-07-05T15:47:35.970Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cl1iy71h000021ou0dliqfaa8","content":"","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"","more":""}],"Post":[{"title":"搭建个人博客总结","date":"2021-07-03T16:00:00.000Z","_content":"\n\n\n### \t始、报错汇总\n\n1.输入`git g -d`后报错：**fatal:  unable to access 'h...://github.com/....github.io.git/**\n\n解决方法1：重置一下git的代理：\n\n```\ngit config --global --unset git.proxy\n```\n\n解决方法2：删掉`node_modules`文件夹\n\n解决方法3：`git g` 和 `git d` 分两步输入\n\n解决方法4：挂梯子\n\n\n\n\n\n <!--more-->\n\n---\n\n\n\n### \t一、用Hexo在本地生成博客并部署（白嫖）到github\n\n后半部分个性化博客的教学先不看：\n\n[GitHub+Hexo 搭建个人网站详细教程](https://zhuanlan.zhihu.com/p/26625249)\n\n\n\n------\n\n\n\n### \t二、将博客的源代码也放到github托管\n\n文章最后面还有作者引用的原文，两篇文章结合一起看：\n\n[Hexo | 怎么去备份你的Hexo博客](https://www.jianshu.com/p/baab04284923)\n\n\n\n------\n\n\n\n### \t三、最后就是用我们的Typora来写作啦\n\n\n\n**注：在2021年11月23日，Typora 正式发布 1.0 版本，进入了付费时代。1.0 版本是一次性付费而非订阅的，只要支付人民币 89 元，可以在 3 台设备里使用。**\n\n**如果不想付费，可以使用付费前的最新版本0.11.17，但无法享受之后的更新和维护**\n\n\n\n快捷键记不记无所谓，typora工具栏全都有：\n\n[Hexo博客写文章及基本操作](https://zhuanlan.zhihu.com/p/156915260)\n\n\n\n------\n\n\n\n### 四、应用next主题以及个性化\n\nnext和hexo好像还有版本适配的问题，我用旧版的next会把博客变成乱码，最终是这篇文章中的新版本适合我：\n\n[hexo的next主题个性化配置](https://zhuanlan.zhihu.com/p/60424755 )\n\n\n\n------\n\n\n\n","source":"_posts/2021-07-04-搭建个人博客总结.md","raw":"---\ntitle: 搭建个人博客总结\ndate: 2021-07-04\ncategories: 琐碎\ntags:\n  - hexo\n  - git\n  - github\n  - typora\n  - next\n\n---\n\n\n\n### \t始、报错汇总\n\n1.输入`git g -d`后报错：**fatal:  unable to access 'h...://github.com/....github.io.git/**\n\n解决方法1：重置一下git的代理：\n\n```\ngit config --global --unset git.proxy\n```\n\n解决方法2：删掉`node_modules`文件夹\n\n解决方法3：`git g` 和 `git d` 分两步输入\n\n解决方法4：挂梯子\n\n\n\n\n\n <!--more-->\n\n---\n\n\n\n### \t一、用Hexo在本地生成博客并部署（白嫖）到github\n\n后半部分个性化博客的教学先不看：\n\n[GitHub+Hexo 搭建个人网站详细教程](https://zhuanlan.zhihu.com/p/26625249)\n\n\n\n------\n\n\n\n### \t二、将博客的源代码也放到github托管\n\n文章最后面还有作者引用的原文，两篇文章结合一起看：\n\n[Hexo | 怎么去备份你的Hexo博客](https://www.jianshu.com/p/baab04284923)\n\n\n\n------\n\n\n\n### \t三、最后就是用我们的Typora来写作啦\n\n\n\n**注：在2021年11月23日，Typora 正式发布 1.0 版本，进入了付费时代。1.0 版本是一次性付费而非订阅的，只要支付人民币 89 元，可以在 3 台设备里使用。**\n\n**如果不想付费，可以使用付费前的最新版本0.11.17，但无法享受之后的更新和维护**\n\n\n\n快捷键记不记无所谓，typora工具栏全都有：\n\n[Hexo博客写文章及基本操作](https://zhuanlan.zhihu.com/p/156915260)\n\n\n\n------\n\n\n\n### 四、应用next主题以及个性化\n\nnext和hexo好像还有版本适配的问题，我用旧版的next会把博客变成乱码，最终是这篇文章中的新版本适合我：\n\n[hexo的next主题个性化配置](https://zhuanlan.zhihu.com/p/60424755 )\n\n\n\n------\n\n\n\n","slug":"2021-07-04-搭建个人博客总结","published":1,"updated":"2022-01-22T16:18:15.910Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71gy00011ou05hht30b8","content":"<h3 id=\"始、报错汇总\"><a href=\"#始、报错汇总\" class=\"headerlink\" title=\"始、报错汇总\"></a>始、报错汇总</h3><p>1.输入<code>git g -d</code>后报错：<strong>fatal:  unable to access ‘h…://github.com/….github.io.git/</strong></p>\n<p>解决方法1：重置一下git的代理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global --unset git.proxy</span><br></pre></td></tr></table></figure>\n\n<p>解决方法2：删掉<code>node_modules</code>文件夹</p>\n<p>解决方法3：<code>git g</code> 和 <code>git d</code> 分两步输入</p>\n<p>解决方法4：挂梯子</p>\n <span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、用Hexo在本地生成博客并部署（白嫖）到github\"><a href=\"#一、用Hexo在本地生成博客并部署（白嫖）到github\" class=\"headerlink\" title=\"一、用Hexo在本地生成博客并部署（白嫖）到github\"></a>一、用Hexo在本地生成博客并部署（白嫖）到github</h3><p>后半部分个性化博客的教学先不看：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/26625249\">GitHub+Hexo 搭建个人网站详细教程</a></p>\n<hr>\n<h3 id=\"二、将博客的源代码也放到github托管\"><a href=\"#二、将博客的源代码也放到github托管\" class=\"headerlink\" title=\"二、将博客的源代码也放到github托管\"></a>二、将博客的源代码也放到github托管</h3><p>文章最后面还有作者引用的原文，两篇文章结合一起看：</p>\n<p><a href=\"https://www.jianshu.com/p/baab04284923\">Hexo | 怎么去备份你的Hexo博客</a></p>\n<hr>\n<h3 id=\"三、最后就是用我们的Typora来写作啦\"><a href=\"#三、最后就是用我们的Typora来写作啦\" class=\"headerlink\" title=\"三、最后就是用我们的Typora来写作啦\"></a>三、最后就是用我们的Typora来写作啦</h3><p><strong>注：在2021年11月23日，Typora 正式发布 1.0 版本，进入了付费时代。1.0 版本是一次性付费而非订阅的，只要支付人民币 89 元，可以在 3 台设备里使用。</strong></p>\n<p><strong>如果不想付费，可以使用付费前的最新版本0.11.17，但无法享受之后的更新和维护</strong></p>\n<p>快捷键记不记无所谓，typora工具栏全都有：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/156915260\">Hexo博客写文章及基本操作</a></p>\n<hr>\n<h3 id=\"四、应用next主题以及个性化\"><a href=\"#四、应用next主题以及个性化\" class=\"headerlink\" title=\"四、应用next主题以及个性化\"></a>四、应用next主题以及个性化</h3><p>next和hexo好像还有版本适配的问题，我用旧版的next会把博客变成乱码，最终是这篇文章中的新版本适合我：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/60424755\">hexo的next主题个性化配置</a></p>\n<hr>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、报错汇总\"><a href=\"#始、报错汇总\" class=\"headerlink\" title=\"始、报错汇总\"></a>始、报错汇总</h3><p>1.输入<code>git g -d</code>后报错：<strong>fatal:  unable to access ‘h…://github.com/….github.io.git/</strong></p>\n<p>解决方法1：重置一下git的代理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global --unset git.proxy</span><br></pre></td></tr></table></figure>\n\n<p>解决方法2：删掉<code>node_modules</code>文件夹</p>\n<p>解决方法3：<code>git g</code> 和 <code>git d</code> 分两步输入</p>\n<p>解决方法4：挂梯子</p>","more":"<hr>\n<h3 id=\"一、用Hexo在本地生成博客并部署（白嫖）到github\"><a href=\"#一、用Hexo在本地生成博客并部署（白嫖）到github\" class=\"headerlink\" title=\"一、用Hexo在本地生成博客并部署（白嫖）到github\"></a>一、用Hexo在本地生成博客并部署（白嫖）到github</h3><p>后半部分个性化博客的教学先不看：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/26625249\">GitHub+Hexo 搭建个人网站详细教程</a></p>\n<hr>\n<h3 id=\"二、将博客的源代码也放到github托管\"><a href=\"#二、将博客的源代码也放到github托管\" class=\"headerlink\" title=\"二、将博客的源代码也放到github托管\"></a>二、将博客的源代码也放到github托管</h3><p>文章最后面还有作者引用的原文，两篇文章结合一起看：</p>\n<p><a href=\"https://www.jianshu.com/p/baab04284923\">Hexo | 怎么去备份你的Hexo博客</a></p>\n<hr>\n<h3 id=\"三、最后就是用我们的Typora来写作啦\"><a href=\"#三、最后就是用我们的Typora来写作啦\" class=\"headerlink\" title=\"三、最后就是用我们的Typora来写作啦\"></a>三、最后就是用我们的Typora来写作啦</h3><p><strong>注：在2021年11月23日，Typora 正式发布 1.0 版本，进入了付费时代。1.0 版本是一次性付费而非订阅的，只要支付人民币 89 元，可以在 3 台设备里使用。</strong></p>\n<p><strong>如果不想付费，可以使用付费前的最新版本0.11.17，但无法享受之后的更新和维护</strong></p>\n<p>快捷键记不记无所谓，typora工具栏全都有：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/156915260\">Hexo博客写文章及基本操作</a></p>\n<hr>\n<h3 id=\"四、应用next主题以及个性化\"><a href=\"#四、应用next主题以及个性化\" class=\"headerlink\" title=\"四、应用next主题以及个性化\"></a>四、应用next主题以及个性化</h3><p>next和hexo好像还有版本适配的问题，我用旧版的next会把博客变成乱码，最终是这篇文章中的新版本适合我：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/60424755\">hexo的next主题个性化配置</a></p>\n<hr>"},{"title":"《Speed Down》Unity2d游戏开发（一）","date":"2021-07-06T09:45:05.000Z","_content":"\n\n\n### \t\t\t始、前言\n\n跟随M大学习unity2d游戏开发，先来一个简单的下100层游戏！\n\n\n\n版本：\n\nunity 2021.1.12f1c1\n\nunityhub 2.4.13\n\nvs 2019\n\n<!--more-->\n\n---\n\n\n\n### \t\t\t\t一、导入素材\n\n1.新建unity2d项目\n\n2.在assetstore中查找 Pixel Adventure 1并添加到我的资源\n\n3.在unity中打开Package Manager → My Assets → Pixel Adventure 1，下载并导入项目中\n\n资源栏就出现这个包啦！\n\n\n\n---\n\n\n\n### \t\t\t二、切换发布平台\n\n1.点击file → build setting → Android → switch platform\n\n2.发现自己unity没有这个模块，要手动在unityhub安装模块\n\n3.发现没有添加模块的按钮，要移除版本，前往官网找到改版本并选择从unityhub中下载\n\n4.添加下载Android Target Support\n\n\n\n---\n\n\n\n### \t\t\t三、背景图案设置\n\n1.新建3d object → quad，reset位置，设置scale中x为9，y为16\n\n2.调整主摄像机，包裹场景\n\n3.新建材质球background，修改shader为unlit → texture\n\n4.选择喜欢的背景图案，更改pixel per unit为64，拖到材质球中\n\n5.添加材质球到quad中\n\n6.相机中没有图片，因为相机和场景重叠了，修改相机z轴位置为-10\n\n简单的背景图片出现了，现在想要背景图案变成多个重复的图案，并且可以循环移动：\n\n7.设置图案advanced → wrap mode → repeat，表示图案是可以循环重复的（记得apply）\n\n8.更改材质球的tilling就可以看到场景图案铺垫的样子，可以看到改变offset的值就可以让场景移动\n\n\n\n---\n\n\n\n### \t\t四、脚本实现背景移动\n\n1.新建c#脚本，等unity加载完毕（右下角有转圈标识，没加载完就操作会出现奇怪的错误）\n\n2.编写脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class BackgroundMove : MonoBehaviour\n{\n    Material material;\n    Vector2 movement;\n\n    public Vector2 speed;\n    void Start()\n    {\n        material = GetComponent<Renderer>().material;\n    }\n\n    void Update()\n    {\n        movement += speed * Time.deltaTime;\n        material.mainTextureOffset = movement;\n    }\n}\n```\n\n注意：获取material时是获取组件Renderer中的material，即“material是Renderer的material”\n\n这样就可以通过改变背景脚本一栏中的speed来改变背景移动速度\n\n\n\n---\n\n\n\n### \t五、添加顶部尖刺\n\n1.找到素材中的spikes，修改pixel per unit 为16\n\n2.新建空物体TopSpikes用来存储所有的顶部尖刺\n\n3.将尖刺图案拖拽到TopSpikes下方成为子物体\n\n4.修改尖刺的rotation → z 为18翻转尖刺，修改scale → y为2延长图案\n\n5.按住`V`可以选择锚点对齐放置，`ctrl + d`复制物体，重复步骤直到填满顶部\n\n6.全选尖刺，添加组件polygon collider 2d 多边形碰撞体，打勾used by composite，即把这些尖刺的碰撞体合并起来\n\n7.添加组件composite collider 2d ，此时会自动添加rigibody 2d\n\n8.将rigibody 2d → body type改为static，这样尖刺就保持在原地不会掉下去\n\n9.调整composite collider 2d → offset 可以改变碰撞体的位置\n\n\n\n---\n\n\n\n### \t终、未完待续\n\n基本的场景搭建已经完成！\n","source":"_posts/2021-07-06-《Speed Down》Unity2d游戏开发（一）.md","raw":"---\ntitle: 《Speed Down》Unity2d游戏开发（一）\ndate: 2021-07-06 17:45:05\ncategories: unity\ntags:\n  - unity\n  - c#\n  - unityhub\n  - 2d\n---\n\n\n\n### \t\t\t始、前言\n\n跟随M大学习unity2d游戏开发，先来一个简单的下100层游戏！\n\n\n\n版本：\n\nunity 2021.1.12f1c1\n\nunityhub 2.4.13\n\nvs 2019\n\n<!--more-->\n\n---\n\n\n\n### \t\t\t\t一、导入素材\n\n1.新建unity2d项目\n\n2.在assetstore中查找 Pixel Adventure 1并添加到我的资源\n\n3.在unity中打开Package Manager → My Assets → Pixel Adventure 1，下载并导入项目中\n\n资源栏就出现这个包啦！\n\n\n\n---\n\n\n\n### \t\t\t二、切换发布平台\n\n1.点击file → build setting → Android → switch platform\n\n2.发现自己unity没有这个模块，要手动在unityhub安装模块\n\n3.发现没有添加模块的按钮，要移除版本，前往官网找到改版本并选择从unityhub中下载\n\n4.添加下载Android Target Support\n\n\n\n---\n\n\n\n### \t\t\t三、背景图案设置\n\n1.新建3d object → quad，reset位置，设置scale中x为9，y为16\n\n2.调整主摄像机，包裹场景\n\n3.新建材质球background，修改shader为unlit → texture\n\n4.选择喜欢的背景图案，更改pixel per unit为64，拖到材质球中\n\n5.添加材质球到quad中\n\n6.相机中没有图片，因为相机和场景重叠了，修改相机z轴位置为-10\n\n简单的背景图片出现了，现在想要背景图案变成多个重复的图案，并且可以循环移动：\n\n7.设置图案advanced → wrap mode → repeat，表示图案是可以循环重复的（记得apply）\n\n8.更改材质球的tilling就可以看到场景图案铺垫的样子，可以看到改变offset的值就可以让场景移动\n\n\n\n---\n\n\n\n### \t\t四、脚本实现背景移动\n\n1.新建c#脚本，等unity加载完毕（右下角有转圈标识，没加载完就操作会出现奇怪的错误）\n\n2.编写脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class BackgroundMove : MonoBehaviour\n{\n    Material material;\n    Vector2 movement;\n\n    public Vector2 speed;\n    void Start()\n    {\n        material = GetComponent<Renderer>().material;\n    }\n\n    void Update()\n    {\n        movement += speed * Time.deltaTime;\n        material.mainTextureOffset = movement;\n    }\n}\n```\n\n注意：获取material时是获取组件Renderer中的material，即“material是Renderer的material”\n\n这样就可以通过改变背景脚本一栏中的speed来改变背景移动速度\n\n\n\n---\n\n\n\n### \t五、添加顶部尖刺\n\n1.找到素材中的spikes，修改pixel per unit 为16\n\n2.新建空物体TopSpikes用来存储所有的顶部尖刺\n\n3.将尖刺图案拖拽到TopSpikes下方成为子物体\n\n4.修改尖刺的rotation → z 为18翻转尖刺，修改scale → y为2延长图案\n\n5.按住`V`可以选择锚点对齐放置，`ctrl + d`复制物体，重复步骤直到填满顶部\n\n6.全选尖刺，添加组件polygon collider 2d 多边形碰撞体，打勾used by composite，即把这些尖刺的碰撞体合并起来\n\n7.添加组件composite collider 2d ，此时会自动添加rigibody 2d\n\n8.将rigibody 2d → body type改为static，这样尖刺就保持在原地不会掉下去\n\n9.调整composite collider 2d → offset 可以改变碰撞体的位置\n\n\n\n---\n\n\n\n### \t终、未完待续\n\n基本的场景搭建已经完成！\n","slug":"2021-07-06-《Speed Down》Unity2d游戏开发（一）","published":1,"updated":"2021-07-18T08:24:57.256Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71h000031ou0fsls9fty","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>跟随M大学习unity2d游戏开发，先来一个简单的下100层游戏！</p>\n<p>版本：</p>\n<p>unity 2021.1.12f1c1</p>\n<p>unityhub 2.4.13</p>\n<p>vs 2019</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、导入素材\"><a href=\"#一、导入素材\" class=\"headerlink\" title=\"一、导入素材\"></a>一、导入素材</h3><p>1.新建unity2d项目</p>\n<p>2.在assetstore中查找 Pixel Adventure 1并添加到我的资源</p>\n<p>3.在unity中打开Package Manager → My Assets → Pixel Adventure 1，下载并导入项目中</p>\n<p>资源栏就出现这个包啦！</p>\n<hr>\n<h3 id=\"二、切换发布平台\"><a href=\"#二、切换发布平台\" class=\"headerlink\" title=\"二、切换发布平台\"></a>二、切换发布平台</h3><p>1.点击file → build setting → Android → switch platform</p>\n<p>2.发现自己unity没有这个模块，要手动在unityhub安装模块</p>\n<p>3.发现没有添加模块的按钮，要移除版本，前往官网找到改版本并选择从unityhub中下载</p>\n<p>4.添加下载Android Target Support</p>\n<hr>\n<h3 id=\"三、背景图案设置\"><a href=\"#三、背景图案设置\" class=\"headerlink\" title=\"三、背景图案设置\"></a>三、背景图案设置</h3><p>1.新建3d object → quad，reset位置，设置scale中x为9，y为16</p>\n<p>2.调整主摄像机，包裹场景</p>\n<p>3.新建材质球background，修改shader为unlit → texture</p>\n<p>4.选择喜欢的背景图案，更改pixel per unit为64，拖到材质球中</p>\n<p>5.添加材质球到quad中</p>\n<p>6.相机中没有图片，因为相机和场景重叠了，修改相机z轴位置为-10</p>\n<p>简单的背景图片出现了，现在想要背景图案变成多个重复的图案，并且可以循环移动：</p>\n<p>7.设置图案advanced → wrap mode → repeat，表示图案是可以循环重复的（记得apply）</p>\n<p>8.更改材质球的tilling就可以看到场景图案铺垫的样子，可以看到改变offset的值就可以让场景移动</p>\n<hr>\n<h3 id=\"四、脚本实现背景移动\"><a href=\"#四、脚本实现背景移动\" class=\"headerlink\" title=\"四、脚本实现背景移动\"></a>四、脚本实现背景移动</h3><p>1.新建c#脚本，等unity加载完毕（右下角有转圈标识，没加载完就操作会出现奇怪的错误）</p>\n<p>2.编写脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class BackgroundMove : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Material material;</span><br><span class=\"line\">    Vector2 movement;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Vector2 speed;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        material = GetComponent&lt;Renderer&gt;().material;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        movement += speed * Time.deltaTime;</span><br><span class=\"line\">        material.mainTextureOffset = movement;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：获取material时是获取组件Renderer中的material，即“material是Renderer的material”</p>\n<p>这样就可以通过改变背景脚本一栏中的speed来改变背景移动速度</p>\n<hr>\n<h3 id=\"五、添加顶部尖刺\"><a href=\"#五、添加顶部尖刺\" class=\"headerlink\" title=\"五、添加顶部尖刺\"></a>五、添加顶部尖刺</h3><p>1.找到素材中的spikes，修改pixel per unit 为16</p>\n<p>2.新建空物体TopSpikes用来存储所有的顶部尖刺</p>\n<p>3.将尖刺图案拖拽到TopSpikes下方成为子物体</p>\n<p>4.修改尖刺的rotation → z 为18翻转尖刺，修改scale → y为2延长图案</p>\n<p>5.按住<code>V</code>可以选择锚点对齐放置，<code>ctrl + d</code>复制物体，重复步骤直到填满顶部</p>\n<p>6.全选尖刺，添加组件polygon collider 2d 多边形碰撞体，打勾used by composite，即把这些尖刺的碰撞体合并起来</p>\n<p>7.添加组件composite collider 2d ，此时会自动添加rigibody 2d</p>\n<p>8.将rigibody 2d → body type改为static，这样尖刺就保持在原地不会掉下去</p>\n<p>9.调整composite collider 2d → offset 可以改变碰撞体的位置</p>\n<hr>\n<h3 id=\"终、未完待续\"><a href=\"#终、未完待续\" class=\"headerlink\" title=\"终、未完待续\"></a>终、未完待续</h3><p>基本的场景搭建已经完成！</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>跟随M大学习unity2d游戏开发，先来一个简单的下100层游戏！</p>\n<p>版本：</p>\n<p>unity 2021.1.12f1c1</p>\n<p>unityhub 2.4.13</p>\n<p>vs 2019</p>","more":"<hr>\n<h3 id=\"一、导入素材\"><a href=\"#一、导入素材\" class=\"headerlink\" title=\"一、导入素材\"></a>一、导入素材</h3><p>1.新建unity2d项目</p>\n<p>2.在assetstore中查找 Pixel Adventure 1并添加到我的资源</p>\n<p>3.在unity中打开Package Manager → My Assets → Pixel Adventure 1，下载并导入项目中</p>\n<p>资源栏就出现这个包啦！</p>\n<hr>\n<h3 id=\"二、切换发布平台\"><a href=\"#二、切换发布平台\" class=\"headerlink\" title=\"二、切换发布平台\"></a>二、切换发布平台</h3><p>1.点击file → build setting → Android → switch platform</p>\n<p>2.发现自己unity没有这个模块，要手动在unityhub安装模块</p>\n<p>3.发现没有添加模块的按钮，要移除版本，前往官网找到改版本并选择从unityhub中下载</p>\n<p>4.添加下载Android Target Support</p>\n<hr>\n<h3 id=\"三、背景图案设置\"><a href=\"#三、背景图案设置\" class=\"headerlink\" title=\"三、背景图案设置\"></a>三、背景图案设置</h3><p>1.新建3d object → quad，reset位置，设置scale中x为9，y为16</p>\n<p>2.调整主摄像机，包裹场景</p>\n<p>3.新建材质球background，修改shader为unlit → texture</p>\n<p>4.选择喜欢的背景图案，更改pixel per unit为64，拖到材质球中</p>\n<p>5.添加材质球到quad中</p>\n<p>6.相机中没有图片，因为相机和场景重叠了，修改相机z轴位置为-10</p>\n<p>简单的背景图片出现了，现在想要背景图案变成多个重复的图案，并且可以循环移动：</p>\n<p>7.设置图案advanced → wrap mode → repeat，表示图案是可以循环重复的（记得apply）</p>\n<p>8.更改材质球的tilling就可以看到场景图案铺垫的样子，可以看到改变offset的值就可以让场景移动</p>\n<hr>\n<h3 id=\"四、脚本实现背景移动\"><a href=\"#四、脚本实现背景移动\" class=\"headerlink\" title=\"四、脚本实现背景移动\"></a>四、脚本实现背景移动</h3><p>1.新建c#脚本，等unity加载完毕（右下角有转圈标识，没加载完就操作会出现奇怪的错误）</p>\n<p>2.编写脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class BackgroundMove : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Material material;</span><br><span class=\"line\">    Vector2 movement;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Vector2 speed;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        material = GetComponent&lt;Renderer&gt;().material;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        movement += speed * Time.deltaTime;</span><br><span class=\"line\">        material.mainTextureOffset = movement;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：获取material时是获取组件Renderer中的material，即“material是Renderer的material”</p>\n<p>这样就可以通过改变背景脚本一栏中的speed来改变背景移动速度</p>\n<hr>\n<h3 id=\"五、添加顶部尖刺\"><a href=\"#五、添加顶部尖刺\" class=\"headerlink\" title=\"五、添加顶部尖刺\"></a>五、添加顶部尖刺</h3><p>1.找到素材中的spikes，修改pixel per unit 为16</p>\n<p>2.新建空物体TopSpikes用来存储所有的顶部尖刺</p>\n<p>3.将尖刺图案拖拽到TopSpikes下方成为子物体</p>\n<p>4.修改尖刺的rotation → z 为18翻转尖刺，修改scale → y为2延长图案</p>\n<p>5.按住<code>V</code>可以选择锚点对齐放置，<code>ctrl + d</code>复制物体，重复步骤直到填满顶部</p>\n<p>6.全选尖刺，添加组件polygon collider 2d 多边形碰撞体，打勾used by composite，即把这些尖刺的碰撞体合并起来</p>\n<p>7.添加组件composite collider 2d ，此时会自动添加rigibody 2d</p>\n<p>8.将rigibody 2d → body type改为static，这样尖刺就保持在原地不会掉下去</p>\n<p>9.调整composite collider 2d → offset 可以改变碰撞体的位置</p>\n<hr>\n<h3 id=\"终、未完待续\"><a href=\"#终、未完待续\" class=\"headerlink\" title=\"终、未完待续\"></a>终、未完待续</h3><p>基本的场景搭建已经完成！</p>"},{"title":"解决Github无法访问","date":"2021-07-05T16:00:00.000Z","_content":"\n\n\n### \t一、修改host文件\n\n​\t在**C:\\Windows\\System32\\drivers\\etc**中打开**host**文件（可以用记事本打开），在该文件中添加如下内容：\n\n```\n# GitHub Start \n140.82.114.4 github.com\n140.82.114.4 gist.github.com\n185.199.108.153 assets-cdn.github.com\n151.101.64.133 raw.githubusercontent.com\n151.101.108.133 gist.githubusercontent.com\n151.101.108.133 cloud.githubusercontent.com\n151.101.108.133 camo.githubusercontent.com\n151.101.108.133 avatars0.githubusercontent.com\n151.101.108.133 avatars1.githubusercontent.com\n151.101.108.133 avatars2.githubusercontent.com\n151.101.108.133 avatars3.githubusercontent.com\n151.101.108.133 avatars4.githubusercontent.com\n151.101.108.133 avatars5.githubusercontent.com\n151.101.108.133 avatars6.githubusercontent.com\n151.101.108.133 avatars7.githubusercontent.com\n151.101.108.133 avatars8.githubusercontent.com \n# GitHub End\n```\n\n保存文件，再次打开github速度飞快\n\n<!--more-->\n\n------\n\n\n\n### \t二、win10修改文件读写的权限\n\n​\twindows系统可能遇到无法修改系统文件的问题\n\n​\t1.找到要修改的文件\n\n​\t2.右键→属性→安全→编辑→user\n\n​\t3.在允许编辑那一栏打勾\n","source":"_posts/2021-07-06-解决Github无法访问.md","raw":"---\ntitle: 解决Github无法访问\ndate: 2021-07-06\ncategories: 琐碎\ntags:\n  - github\t\n  - windows\n---\n\n\n\n### \t一、修改host文件\n\n​\t在**C:\\Windows\\System32\\drivers\\etc**中打开**host**文件（可以用记事本打开），在该文件中添加如下内容：\n\n```\n# GitHub Start \n140.82.114.4 github.com\n140.82.114.4 gist.github.com\n185.199.108.153 assets-cdn.github.com\n151.101.64.133 raw.githubusercontent.com\n151.101.108.133 gist.githubusercontent.com\n151.101.108.133 cloud.githubusercontent.com\n151.101.108.133 camo.githubusercontent.com\n151.101.108.133 avatars0.githubusercontent.com\n151.101.108.133 avatars1.githubusercontent.com\n151.101.108.133 avatars2.githubusercontent.com\n151.101.108.133 avatars3.githubusercontent.com\n151.101.108.133 avatars4.githubusercontent.com\n151.101.108.133 avatars5.githubusercontent.com\n151.101.108.133 avatars6.githubusercontent.com\n151.101.108.133 avatars7.githubusercontent.com\n151.101.108.133 avatars8.githubusercontent.com \n# GitHub End\n```\n\n保存文件，再次打开github速度飞快\n\n<!--more-->\n\n------\n\n\n\n### \t二、win10修改文件读写的权限\n\n​\twindows系统可能遇到无法修改系统文件的问题\n\n​\t1.找到要修改的文件\n\n​\t2.右键→属性→安全→编辑→user\n\n​\t3.在允许编辑那一栏打勾\n","slug":"2021-07-06-解决Github无法访问","published":1,"updated":"2021-07-15T10:44:20.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71h300061ou01x7z0fe5","content":"<h3 id=\"一、修改host文件\"><a href=\"#一、修改host文件\" class=\"headerlink\" title=\"一、修改host文件\"></a>一、修改host文件</h3><p>​    在<strong>C:\\Windows\\System32\\drivers\\etc</strong>中打开<strong>host</strong>文件（可以用记事本打开），在该文件中添加如下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># GitHub Start </span><br><span class=\"line\">140.82.114.4 github.com</span><br><span class=\"line\">140.82.114.4 gist.github.com</span><br><span class=\"line\">185.199.108.153 assets-cdn.github.com</span><br><span class=\"line\">151.101.64.133 raw.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 gist.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 cloud.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 camo.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars0.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars1.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars2.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars3.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars4.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars5.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars6.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars7.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars8.githubusercontent.com </span><br><span class=\"line\"># GitHub End</span><br></pre></td></tr></table></figure>\n\n<p>保存文件，再次打开github速度飞快</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"二、win10修改文件读写的权限\"><a href=\"#二、win10修改文件读写的权限\" class=\"headerlink\" title=\"二、win10修改文件读写的权限\"></a>二、win10修改文件读写的权限</h3><p>​    windows系统可能遇到无法修改系统文件的问题</p>\n<p>​    1.找到要修改的文件</p>\n<p>​    2.右键→属性→安全→编辑→user</p>\n<p>​    3.在允许编辑那一栏打勾</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"一、修改host文件\"><a href=\"#一、修改host文件\" class=\"headerlink\" title=\"一、修改host文件\"></a>一、修改host文件</h3><p>​    在<strong>C:\\Windows\\System32\\drivers\\etc</strong>中打开<strong>host</strong>文件（可以用记事本打开），在该文件中添加如下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># GitHub Start </span><br><span class=\"line\">140.82.114.4 github.com</span><br><span class=\"line\">140.82.114.4 gist.github.com</span><br><span class=\"line\">185.199.108.153 assets-cdn.github.com</span><br><span class=\"line\">151.101.64.133 raw.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 gist.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 cloud.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 camo.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars0.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars1.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars2.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars3.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars4.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars5.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars6.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars7.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars8.githubusercontent.com </span><br><span class=\"line\"># GitHub End</span><br></pre></td></tr></table></figure>\n\n<p>保存文件，再次打开github速度飞快</p>","more":"<hr>\n<h3 id=\"二、win10修改文件读写的权限\"><a href=\"#二、win10修改文件读写的权限\" class=\"headerlink\" title=\"二、win10修改文件读写的权限\"></a>二、win10修改文件读写的权限</h3><p>​    windows系统可能遇到无法修改系统文件的问题</p>\n<p>​    1.找到要修改的文件</p>\n<p>​    2.右键→属性→安全→编辑→user</p>\n<p>​    3.在允许编辑那一栏打勾</p>"},{"title":"【LeetCode.930】和相同的二元子数组","date":"2021-07-08T09:14:17.000Z","_content":"\n\n\n\n\n### \t题目：和相同的二元子数组\n\n​\t给你一个二元数组 `nums` ，和一个整数 `goal` ，请你统计并返回有多少个和为 `goal` 的 **非空** 子数组。\n\n​\t**子数组** 是数组的一段连续部分。\n\n \n\n示例 1：\n\n```\n输入：nums = [1,0,1,0,1], goal = 2\n输出：4\n解释：\n有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]\n```\n\n<!--more-->\n\n示例 2：\n\n```\n输入：nums = [0,0,0,0,0], goal = 0\n输出：15\n```\n\n\n提示：\n\n`1 <= nums.length <= 3 * 104`\n\n`nums[i]` 不是 `0` 就是 `1`\n\n`0 <= goal <= nums.length`\n\n\n\n------\n\n\n\n### \t题解：\n\n```\nclass Solution {\npublic:\n    //滑动窗口法\n    //右指针逐渐向右，左一指针找到第一个符合的位置，左二指针找到最后一个符合的位置\n    int numSubarraysWithSum(vector<int>& nums, int goal) {\n        int left1 = 0, left2 = 0;\n        int n = nums.size();\n        int sum1 = 0, sum2 = 0;\n        int ret = 0;\n\n        for(int right = 0; right < n; right++){\n            sum2 += nums[right];\n            sum1 += nums[right];\n            while(left2 <= right && sum2 >= goal){\n                sum2 -= nums[left2];\n                left2++;\n            }\n\n            while(left1 < left2 && sum1 > goal){\n                sum1 -= nums[left1];\n                left1++;\n            }\n\n            ret += left2 - left1;\n        }\n\n        return ret;\n    }\n};\n```\n\n\n\n------\n\n\n\n### \t易错点：\n\n1.提示2`nums[i]` 不是 `0` 就是 `1`，所以不用判断相等的情况`if(sum == goal)`\n\n2.三个只指针对应的大小关系，其中`left1 <= left2 <= right <= nums.size()`\n\n","source":"_posts/2021-07-08-【LeetCode.930】和相同的二元子数组.md","raw":"---\ntitle: 【LeetCode.930】和相同的二元子数组\ndate: 2021-07-08 17:14:17\ncategories: 算法\ntags:\n  - c++\n  - 滑动窗口法\n  - 数组\n---\n\n\n\n\n\n### \t题目：和相同的二元子数组\n\n​\t给你一个二元数组 `nums` ，和一个整数 `goal` ，请你统计并返回有多少个和为 `goal` 的 **非空** 子数组。\n\n​\t**子数组** 是数组的一段连续部分。\n\n \n\n示例 1：\n\n```\n输入：nums = [1,0,1,0,1], goal = 2\n输出：4\n解释：\n有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]\n```\n\n<!--more-->\n\n示例 2：\n\n```\n输入：nums = [0,0,0,0,0], goal = 0\n输出：15\n```\n\n\n提示：\n\n`1 <= nums.length <= 3 * 104`\n\n`nums[i]` 不是 `0` 就是 `1`\n\n`0 <= goal <= nums.length`\n\n\n\n------\n\n\n\n### \t题解：\n\n```\nclass Solution {\npublic:\n    //滑动窗口法\n    //右指针逐渐向右，左一指针找到第一个符合的位置，左二指针找到最后一个符合的位置\n    int numSubarraysWithSum(vector<int>& nums, int goal) {\n        int left1 = 0, left2 = 0;\n        int n = nums.size();\n        int sum1 = 0, sum2 = 0;\n        int ret = 0;\n\n        for(int right = 0; right < n; right++){\n            sum2 += nums[right];\n            sum1 += nums[right];\n            while(left2 <= right && sum2 >= goal){\n                sum2 -= nums[left2];\n                left2++;\n            }\n\n            while(left1 < left2 && sum1 > goal){\n                sum1 -= nums[left1];\n                left1++;\n            }\n\n            ret += left2 - left1;\n        }\n\n        return ret;\n    }\n};\n```\n\n\n\n------\n\n\n\n### \t易错点：\n\n1.提示2`nums[i]` 不是 `0` 就是 `1`，所以不用判断相等的情况`if(sum == goal)`\n\n2.三个只指针对应的大小关系，其中`left1 <= left2 <= right <= nums.size()`\n\n","slug":"2021-07-08-【LeetCode.930】和相同的二元子数组","published":1,"updated":"2021-07-23T07:08:15.137Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71h400071ou088zv022b","content":"<h3 id=\"题目：和相同的二元子数组\"><a href=\"#题目：和相同的二元子数组\" class=\"headerlink\" title=\"题目：和相同的二元子数组\"></a>题目：和相同的二元子数组</h3><p>​    给你一个二元数组 <code>nums</code> ，和一个整数 <code>goal</code> ，请你统计并返回有多少个和为 <code>goal</code> 的 <strong>非空</strong> 子数组。</p>\n<p>​    <strong>子数组</strong> 是数组的一段连续部分。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,0,1,0,1], goal = 2</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：</span><br><span class=\"line\">有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,0,0,0,0], goal = 0</span><br><span class=\"line\">输出：15</span><br></pre></td></tr></table></figure>\n\n\n<p>提示：</p>\n<p><code>1 &lt;= nums.length &lt;= 3 * 104</code></p>\n<p><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></p>\n<p><code>0 &lt;= goal &lt;= nums.length</code></p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    //滑动窗口法</span><br><span class=\"line\">    //右指针逐渐向右，左一指针找到第一个符合的位置，左二指针找到最后一个符合的位置</span><br><span class=\"line\">    int numSubarraysWithSum(vector&lt;int&gt;&amp; nums, int goal) &#123;</span><br><span class=\"line\">        int left1 = 0, left2 = 0;</span><br><span class=\"line\">        int n = nums.size();</span><br><span class=\"line\">        int sum1 = 0, sum2 = 0;</span><br><span class=\"line\">        int ret = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">        for(int right = 0; right &lt; n; right++)&#123;</span><br><span class=\"line\">            sum2 += nums[right];</span><br><span class=\"line\">            sum1 += nums[right];</span><br><span class=\"line\">            while(left2 &lt;= right &amp;&amp; sum2 &gt;= goal)&#123;</span><br><span class=\"line\">                sum2 -= nums[left2];</span><br><span class=\"line\">                left2++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            while(left1 &lt; left2 &amp;&amp; sum1 &gt; goal)&#123;</span><br><span class=\"line\">                sum1 -= nums[left1];</span><br><span class=\"line\">                left1++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ret += left2 - left1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"易错点：\"><a href=\"#易错点：\" class=\"headerlink\" title=\"易错点：\"></a>易错点：</h3><p>1.提示2<code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code>，所以不用判断相等的情况<code>if(sum == goal)</code></p>\n<p>2.三个只指针对应的大小关系，其中<code>left1 &lt;= left2 &lt;= right &lt;= nums.size()</code></p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"题目：和相同的二元子数组\"><a href=\"#题目：和相同的二元子数组\" class=\"headerlink\" title=\"题目：和相同的二元子数组\"></a>题目：和相同的二元子数组</h3><p>​    给你一个二元数组 <code>nums</code> ，和一个整数 <code>goal</code> ，请你统计并返回有多少个和为 <code>goal</code> 的 <strong>非空</strong> 子数组。</p>\n<p>​    <strong>子数组</strong> 是数组的一段连续部分。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,0,1,0,1], goal = 2</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：</span><br><span class=\"line\">有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]</span><br></pre></td></tr></table></figure>","more":"<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,0,0,0,0], goal = 0</span><br><span class=\"line\">输出：15</span><br></pre></td></tr></table></figure>\n\n\n<p>提示：</p>\n<p><code>1 &lt;= nums.length &lt;= 3 * 104</code></p>\n<p><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></p>\n<p><code>0 &lt;= goal &lt;= nums.length</code></p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    //滑动窗口法</span><br><span class=\"line\">    //右指针逐渐向右，左一指针找到第一个符合的位置，左二指针找到最后一个符合的位置</span><br><span class=\"line\">    int numSubarraysWithSum(vector&lt;int&gt;&amp; nums, int goal) &#123;</span><br><span class=\"line\">        int left1 = 0, left2 = 0;</span><br><span class=\"line\">        int n = nums.size();</span><br><span class=\"line\">        int sum1 = 0, sum2 = 0;</span><br><span class=\"line\">        int ret = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">        for(int right = 0; right &lt; n; right++)&#123;</span><br><span class=\"line\">            sum2 += nums[right];</span><br><span class=\"line\">            sum1 += nums[right];</span><br><span class=\"line\">            while(left2 &lt;= right &amp;&amp; sum2 &gt;= goal)&#123;</span><br><span class=\"line\">                sum2 -= nums[left2];</span><br><span class=\"line\">                left2++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            while(left1 &lt; left2 &amp;&amp; sum1 &gt; goal)&#123;</span><br><span class=\"line\">                sum1 -= nums[left1];</span><br><span class=\"line\">                left1++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ret += left2 - left1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"易错点：\"><a href=\"#易错点：\" class=\"headerlink\" title=\"易错点：\"></a>易错点：</h3><p>1.提示2<code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code>，所以不用判断相等的情况<code>if(sum == goal)</code></p>\n<p>2.三个只指针对应的大小关系，其中<code>left1 &lt;= left2 &lt;= right &lt;= nums.size()</code></p>"},{"title":"再临Unity","date":"2021-07-08T10:29:49.000Z","_content":"\n\n\n### \t\t始、整理\n\n​\t闲来无事，想捣鼓一下unity，打开界面一脸懵逼。明明大学玩过一段时间的，这知识咋就不进脑子呢，又得重新学习\n\n<!--more-->\n\n------\n\n\n\n### \t\t一、Unity快速入门\n\n​\tunity的布局和一些用过的工具多少有些联系，搞懂界面还是不难的，先从常用操作入手吧！正好找到一个最近的精简unity入门视频：\n\n[游戏开发-Unity 光速入门](ttps://www.bilibili.com/video/BV1Yh411h7zk?p=2)\n\n\n\n------\n\n\n\n### \t\t二、C#\n\n​\tunity脚本编写用到c#，这语言光说入门还是比较轻松的：\n\n[快速学完C#编程](https://www.bilibili.com/video/BV1sy4y1u7cw)\n\n\n\n------\n\n\n\n### \t\t三、像素画资源\n\n​\t做点2D像素风练练手，资源就用PS自己画吧：\n\n[使用Photoshop绘制像素画](https://www.bilibili.com/video/BV1o4411V7dv)\n\n\n\n------\n\n\n\n### \t四、教程视频\n\nM大的教学对新手玩家真的友好，不愧是unity官方认证\n\n[M_Studio的个人空间](https://space.bilibili.com/370283072?spm_id_from=333.788.b_636f6d6d656e74.1)\n\n","source":"_posts/2021-07-08-再临Unity.md","raw":"---\ntitle: 再临Unity\ndate: 2021-07-08 18:29:49\ncategories: 琐碎\ntags:\n  - unity\n  - c#\n  - ps\n  - 像素\n---\n\n\n\n### \t\t始、整理\n\n​\t闲来无事，想捣鼓一下unity，打开界面一脸懵逼。明明大学玩过一段时间的，这知识咋就不进脑子呢，又得重新学习\n\n<!--more-->\n\n------\n\n\n\n### \t\t一、Unity快速入门\n\n​\tunity的布局和一些用过的工具多少有些联系，搞懂界面还是不难的，先从常用操作入手吧！正好找到一个最近的精简unity入门视频：\n\n[游戏开发-Unity 光速入门](ttps://www.bilibili.com/video/BV1Yh411h7zk?p=2)\n\n\n\n------\n\n\n\n### \t\t二、C#\n\n​\tunity脚本编写用到c#，这语言光说入门还是比较轻松的：\n\n[快速学完C#编程](https://www.bilibili.com/video/BV1sy4y1u7cw)\n\n\n\n------\n\n\n\n### \t\t三、像素画资源\n\n​\t做点2D像素风练练手，资源就用PS自己画吧：\n\n[使用Photoshop绘制像素画](https://www.bilibili.com/video/BV1o4411V7dv)\n\n\n\n------\n\n\n\n### \t四、教程视频\n\nM大的教学对新手玩家真的友好，不愧是unity官方认证\n\n[M_Studio的个人空间](https://space.bilibili.com/370283072?spm_id_from=333.788.b_636f6d6d656e74.1)\n\n","slug":"2021-07-08-再临Unity","published":1,"updated":"2021-09-19T06:17:54.683Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71h500081ou040recmue","content":"<h3 id=\"始、整理\"><a href=\"#始、整理\" class=\"headerlink\" title=\"始、整理\"></a>始、整理</h3><p>​    闲来无事，想捣鼓一下unity，打开界面一脸懵逼。明明大学玩过一段时间的，这知识咋就不进脑子呢，又得重新学习</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、Unity快速入门\"><a href=\"#一、Unity快速入门\" class=\"headerlink\" title=\"一、Unity快速入门\"></a>一、Unity快速入门</h3><p>​    unity的布局和一些用过的工具多少有些联系，搞懂界面还是不难的，先从常用操作入手吧！正好找到一个最近的精简unity入门视频：</p>\n<p><a href=\"ttps://www.bilibili.com/video/BV1Yh411h7zk?p=2\">游戏开发-Unity 光速入门</a></p>\n<hr>\n<h3 id=\"二、C\"><a href=\"#二、C\" class=\"headerlink\" title=\"二、C#\"></a>二、C#</h3><p>​    unity脚本编写用到c#，这语言光说入门还是比较轻松的：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1sy4y1u7cw\">快速学完C#编程</a></p>\n<hr>\n<h3 id=\"三、像素画资源\"><a href=\"#三、像素画资源\" class=\"headerlink\" title=\"三、像素画资源\"></a>三、像素画资源</h3><p>​    做点2D像素风练练手，资源就用PS自己画吧：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1o4411V7dv\">使用Photoshop绘制像素画</a></p>\n<hr>\n<h3 id=\"四、教程视频\"><a href=\"#四、教程视频\" class=\"headerlink\" title=\"四、教程视频\"></a>四、教程视频</h3><p>M大的教学对新手玩家真的友好，不愧是unity官方认证</p>\n<p><a href=\"https://space.bilibili.com/370283072?spm_id_from=333.788.b_636f6d6d656e74.1\">M_Studio的个人空间</a></p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、整理\"><a href=\"#始、整理\" class=\"headerlink\" title=\"始、整理\"></a>始、整理</h3><p>​    闲来无事，想捣鼓一下unity，打开界面一脸懵逼。明明大学玩过一段时间的，这知识咋就不进脑子呢，又得重新学习</p>","more":"<hr>\n<h3 id=\"一、Unity快速入门\"><a href=\"#一、Unity快速入门\" class=\"headerlink\" title=\"一、Unity快速入门\"></a>一、Unity快速入门</h3><p>​    unity的布局和一些用过的工具多少有些联系，搞懂界面还是不难的，先从常用操作入手吧！正好找到一个最近的精简unity入门视频：</p>\n<p><a href=\"ttps://www.bilibili.com/video/BV1Yh411h7zk?p=2\">游戏开发-Unity 光速入门</a></p>\n<hr>\n<h3 id=\"二、C\"><a href=\"#二、C\" class=\"headerlink\" title=\"二、C#\"></a>二、C#</h3><p>​    unity脚本编写用到c#，这语言光说入门还是比较轻松的：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1sy4y1u7cw\">快速学完C#编程</a></p>\n<hr>\n<h3 id=\"三、像素画资源\"><a href=\"#三、像素画资源\" class=\"headerlink\" title=\"三、像素画资源\"></a>三、像素画资源</h3><p>​    做点2D像素风练练手，资源就用PS自己画吧：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1o4411V7dv\">使用Photoshop绘制像素画</a></p>\n<hr>\n<h3 id=\"四、教程视频\"><a href=\"#四、教程视频\" class=\"headerlink\" title=\"四、教程视频\"></a>四、教程视频</h3><p>M大的教学对新手玩家真的友好，不愧是unity官方认证</p>\n<p><a href=\"https://space.bilibili.com/370283072?spm_id_from=333.788.b_636f6d6d656e74.1\">M_Studio的个人空间</a></p>"},{"title":"《Speed Down》Unity2d游戏开发（四）","date":"2021-07-14T12:55:23.000Z","_content":"\n\n\n### \t始、阶段调整\n\n这次不做新功能，先停一停把之前的东西调整一下，细节~太细了~\n\n<!--more-->\n\n---\n\n\n\n### 一、图案模糊\n\n顶部尖刺看起来有些模糊\n\n1.找到尖刺的图案，将Advanced → Filter Mode 修改成Point\n\n检查所有的图案是否模糊，套用这个方法\n\n\n\n---\n\n\n\n### 二、修改背景颜色\n\n1.选择主相机，修改Camera → Background 到喜欢的颜色\n\n\n\n---\n\n\n\n### 三、给链锤添加链子？\n\n听起来有点奇怪，但是我的链锤现在确实是没有链子，看起来像是原力驱动\n\n1.给链锤整体添加组件Line Renderer，选择喜欢材质、颜色、粗细，并把Position → Size改成2\n\n2.添加脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class SpikeBallLine : MonoBehaviour\n{\n\n    LineRenderer line;\n    public Transform begin;\n    public Transform end;\n\n    void Start()\n    {\n        line = GetComponent<LineRenderer>();\n\n    }\n\n    void Update()\n    {\n        line.SetPosition(0, begin.position);\n        line.SetPosition(1, end.position);\n    }\n}\n```\n\n挂载到链锤父物体上，注意脚本和线组件是同一级别的\n\n\n\n---\n\n\n\n### 四、保存预制体\n\n为了可以持续不断地随机生成平台，需要将平台保存为预制体\n\n1.创建prefabs文件夹，并把平台和人物添加到其中\n\n**Prefab是什么？**\n\n当制作好了游戏组件（场景中的任意一个gameobject）,我们希望将它制作成一个组件模版，用于批量的套用工作，例如说场景中本质上要重复使用的东西，比如：敌人、士兵、子弹或者一个砖块完全相同的墙体。这里说本质是因为默认生成的prefab其实和模版是一模一样的。就像是克隆体，但生成的位置、角度或者一些属性不同（这个就好像c++里边的类一样）；\n\n","source":"_posts/2021-07-14-《Speed Down》Unity2d游戏开发（四）.md","raw":"---\ntitle: 《Speed Down》Unity2d游戏开发（四）\ndate: 2021-07-14 20:55:23\ncategories:\tunity\ntags:\n  - unity\n  - c#\n  - prefab\n---\n\n\n\n### \t始、阶段调整\n\n这次不做新功能，先停一停把之前的东西调整一下，细节~太细了~\n\n<!--more-->\n\n---\n\n\n\n### 一、图案模糊\n\n顶部尖刺看起来有些模糊\n\n1.找到尖刺的图案，将Advanced → Filter Mode 修改成Point\n\n检查所有的图案是否模糊，套用这个方法\n\n\n\n---\n\n\n\n### 二、修改背景颜色\n\n1.选择主相机，修改Camera → Background 到喜欢的颜色\n\n\n\n---\n\n\n\n### 三、给链锤添加链子？\n\n听起来有点奇怪，但是我的链锤现在确实是没有链子，看起来像是原力驱动\n\n1.给链锤整体添加组件Line Renderer，选择喜欢材质、颜色、粗细，并把Position → Size改成2\n\n2.添加脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class SpikeBallLine : MonoBehaviour\n{\n\n    LineRenderer line;\n    public Transform begin;\n    public Transform end;\n\n    void Start()\n    {\n        line = GetComponent<LineRenderer>();\n\n    }\n\n    void Update()\n    {\n        line.SetPosition(0, begin.position);\n        line.SetPosition(1, end.position);\n    }\n}\n```\n\n挂载到链锤父物体上，注意脚本和线组件是同一级别的\n\n\n\n---\n\n\n\n### 四、保存预制体\n\n为了可以持续不断地随机生成平台，需要将平台保存为预制体\n\n1.创建prefabs文件夹，并把平台和人物添加到其中\n\n**Prefab是什么？**\n\n当制作好了游戏组件（场景中的任意一个gameobject）,我们希望将它制作成一个组件模版，用于批量的套用工作，例如说场景中本质上要重复使用的东西，比如：敌人、士兵、子弹或者一个砖块完全相同的墙体。这里说本质是因为默认生成的prefab其实和模版是一模一样的。就像是克隆体，但生成的位置、角度或者一些属性不同（这个就好像c++里边的类一样）；\n\n","slug":"2021-07-14-《Speed Down》Unity2d游戏开发（四）","published":1,"updated":"2021-07-15T10:26:50.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71h6000b1ou0crl8g6c2","content":"<h3 id=\"始、阶段调整\"><a href=\"#始、阶段调整\" class=\"headerlink\" title=\"始、阶段调整\"></a>始、阶段调整</h3><p>这次不做新功能，先停一停把之前的东西调整一下，细节<del>太细了</del></p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、图案模糊\"><a href=\"#一、图案模糊\" class=\"headerlink\" title=\"一、图案模糊\"></a>一、图案模糊</h3><p>顶部尖刺看起来有些模糊</p>\n<p>1.找到尖刺的图案，将Advanced → Filter Mode 修改成Point</p>\n<p>检查所有的图案是否模糊，套用这个方法</p>\n<hr>\n<h3 id=\"二、修改背景颜色\"><a href=\"#二、修改背景颜色\" class=\"headerlink\" title=\"二、修改背景颜色\"></a>二、修改背景颜色</h3><p>1.选择主相机，修改Camera → Background 到喜欢的颜色</p>\n<hr>\n<h3 id=\"三、给链锤添加链子？\"><a href=\"#三、给链锤添加链子？\" class=\"headerlink\" title=\"三、给链锤添加链子？\"></a>三、给链锤添加链子？</h3><p>听起来有点奇怪，但是我的链锤现在确实是没有链子，看起来像是原力驱动</p>\n<p>1.给链锤整体添加组件Line Renderer，选择喜欢材质、颜色、粗细，并把Position → Size改成2</p>\n<p>2.添加脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class SpikeBallLine : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LineRenderer line;</span><br><span class=\"line\">    public Transform begin;</span><br><span class=\"line\">    public Transform end;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line = GetComponent&lt;LineRenderer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line.SetPosition(0, begin.position);</span><br><span class=\"line\">        line.SetPosition(1, end.position);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>挂载到链锤父物体上，注意脚本和线组件是同一级别的</p>\n<hr>\n<h3 id=\"四、保存预制体\"><a href=\"#四、保存预制体\" class=\"headerlink\" title=\"四、保存预制体\"></a>四、保存预制体</h3><p>为了可以持续不断地随机生成平台，需要将平台保存为预制体</p>\n<p>1.创建prefabs文件夹，并把平台和人物添加到其中</p>\n<p><strong>Prefab是什么？</strong></p>\n<p>当制作好了游戏组件（场景中的任意一个gameobject）,我们希望将它制作成一个组件模版，用于批量的套用工作，例如说场景中本质上要重复使用的东西，比如：敌人、士兵、子弹或者一个砖块完全相同的墙体。这里说本质是因为默认生成的prefab其实和模版是一模一样的。就像是克隆体，但生成的位置、角度或者一些属性不同（这个就好像c++里边的类一样）；</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、阶段调整\"><a href=\"#始、阶段调整\" class=\"headerlink\" title=\"始、阶段调整\"></a>始、阶段调整</h3><p>这次不做新功能，先停一停把之前的东西调整一下，细节<del>太细了</del></p>","more":"<hr>\n<h3 id=\"一、图案模糊\"><a href=\"#一、图案模糊\" class=\"headerlink\" title=\"一、图案模糊\"></a>一、图案模糊</h3><p>顶部尖刺看起来有些模糊</p>\n<p>1.找到尖刺的图案，将Advanced → Filter Mode 修改成Point</p>\n<p>检查所有的图案是否模糊，套用这个方法</p>\n<hr>\n<h3 id=\"二、修改背景颜色\"><a href=\"#二、修改背景颜色\" class=\"headerlink\" title=\"二、修改背景颜色\"></a>二、修改背景颜色</h3><p>1.选择主相机，修改Camera → Background 到喜欢的颜色</p>\n<hr>\n<h3 id=\"三、给链锤添加链子？\"><a href=\"#三、给链锤添加链子？\" class=\"headerlink\" title=\"三、给链锤添加链子？\"></a>三、给链锤添加链子？</h3><p>听起来有点奇怪，但是我的链锤现在确实是没有链子，看起来像是原力驱动</p>\n<p>1.给链锤整体添加组件Line Renderer，选择喜欢材质、颜色、粗细，并把Position → Size改成2</p>\n<p>2.添加脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class SpikeBallLine : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LineRenderer line;</span><br><span class=\"line\">    public Transform begin;</span><br><span class=\"line\">    public Transform end;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line = GetComponent&lt;LineRenderer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line.SetPosition(0, begin.position);</span><br><span class=\"line\">        line.SetPosition(1, end.position);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>挂载到链锤父物体上，注意脚本和线组件是同一级别的</p>\n<hr>\n<h3 id=\"四、保存预制体\"><a href=\"#四、保存预制体\" class=\"headerlink\" title=\"四、保存预制体\"></a>四、保存预制体</h3><p>为了可以持续不断地随机生成平台，需要将平台保存为预制体</p>\n<p>1.创建prefabs文件夹，并把平台和人物添加到其中</p>\n<p><strong>Prefab是什么？</strong></p>\n<p>当制作好了游戏组件（场景中的任意一个gameobject）,我们希望将它制作成一个组件模版，用于批量的套用工作，例如说场景中本质上要重复使用的东西，比如：敌人、士兵、子弹或者一个砖块完全相同的墙体。这里说本质是因为默认生成的prefab其实和模版是一模一样的。就像是克隆体，但生成的位置、角度或者一些属性不同（这个就好像c++里边的类一样）；</p>"},{"title":"《Speed Down》Unity2d游戏开发（五）","date":"2021-07-15T07:34:28.000Z","_content":"\n\n\n### \t一、随机生成平台\n\n1.可以删除其他平台，只留下一个开局的平台\n\n2.新建一个空物体作为平台出生点，调整大小，添加碰撞体，勾选is trigger，修改标签为spike\n\n<!--more-->\n\n3.新建脚本挂载到平台出生点：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Spawner : MonoBehaviour\n{\n    public List<GameObject> platform = new List<GameObject>();\n\n    public float spawnTime;\n    float countTime;\n    Vector3 spawnPosition;\n\n\n    void Update()\n    {\n        SpawnPlatform();\n    }\n\n    public void SpawnPlatform()\n    {\n        countTime += Time.deltaTime;\n        spawnPosition = transform.position;\n        spawnPosition.x = Random.Range(-3f, 3f);\n\n        if(countTime > spawnTime)\n        {\n            CreatePlatform();\n            countTime = 0;\n        }\n\n    }\n\n    public void CreatePlatform()\n    {\n        int index = Random.Range(0, platform.Count);\n        Instantiate(platform[index], spawnPosition, Quaternion.identity );\n    }\n}\n```\n\n4.回到unity设置脚本中平台列表的大小为3并且拖入三种基础平台\n\n5.设置好生成速度Spawn Time就可以开始玩啦！\n\n\n\n---\n\n\n\n### \t二、细节调整\n\n1.将链锤的锤子设置标签为spike（不小心删了链锤的预制体，我是sb，以后碰到警告操作不可撤回的要万分小心）\n\n2.角色检测碰到尖刺死亡的代码是在OnTriggerEnter2D中的，而顶部尖刺是触发器，链锤是碰撞器，需要将死亡代码复制到OnCollisionEnter2D中。注意两个函数接收的变量不同，需要按照提示修改一下\n\n3.改变平台列表的大小并拖入不同的平台，这样就可以调整游戏难度以及未来新增其他平台或者陷阱\n\n4.在平台出生点中修改代码，添加：\n\n```\n        GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );\n        newPlatform.transform.SetParent(transform);\n```\n\n这样就可以让新生成的平台作为平台出生点的子物体\n\n5.为了不让链锤连续生成太多以至于游戏难度过大，修改spawn代码：\n\n```\n    int spikeBallNum = 0;\n    \n        public void CreatePlatform()\n    {\n        int index = Random.Range(0, platform.Count);\n\n        if (index == 3)\n        {\n            spikeBallNum++;\n            if(spikeBallNum > 2)\n            {\n                index = 0;\n                spikeBallNum = 0;\n            }\n        }\n\n        GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );\n        newPlatform.transform.SetParent(transform);\n    }\n```\n\n当连续出现链锤时变成普通平台，免得出现必死局\n\n\n\n---\n\n\n\n### \t终、总结\n\n到此为止主要游戏内容都已经完成啦！最后就是制作一些UI管理游戏\n","source":"_posts/2021-07-15-《Speed Down》Unity2d游戏开发（五）.md","raw":"---\ntitle: 《Speed Down》Unity2d游戏开发（五）\ndate: 2021-07-15 15:34:28\ncategories:\tunity\ntags:\n  - unity\n  - c#\n  - trigger\n  - collision\n---\n\n\n\n### \t一、随机生成平台\n\n1.可以删除其他平台，只留下一个开局的平台\n\n2.新建一个空物体作为平台出生点，调整大小，添加碰撞体，勾选is trigger，修改标签为spike\n\n<!--more-->\n\n3.新建脚本挂载到平台出生点：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Spawner : MonoBehaviour\n{\n    public List<GameObject> platform = new List<GameObject>();\n\n    public float spawnTime;\n    float countTime;\n    Vector3 spawnPosition;\n\n\n    void Update()\n    {\n        SpawnPlatform();\n    }\n\n    public void SpawnPlatform()\n    {\n        countTime += Time.deltaTime;\n        spawnPosition = transform.position;\n        spawnPosition.x = Random.Range(-3f, 3f);\n\n        if(countTime > spawnTime)\n        {\n            CreatePlatform();\n            countTime = 0;\n        }\n\n    }\n\n    public void CreatePlatform()\n    {\n        int index = Random.Range(0, platform.Count);\n        Instantiate(platform[index], spawnPosition, Quaternion.identity );\n    }\n}\n```\n\n4.回到unity设置脚本中平台列表的大小为3并且拖入三种基础平台\n\n5.设置好生成速度Spawn Time就可以开始玩啦！\n\n\n\n---\n\n\n\n### \t二、细节调整\n\n1.将链锤的锤子设置标签为spike（不小心删了链锤的预制体，我是sb，以后碰到警告操作不可撤回的要万分小心）\n\n2.角色检测碰到尖刺死亡的代码是在OnTriggerEnter2D中的，而顶部尖刺是触发器，链锤是碰撞器，需要将死亡代码复制到OnCollisionEnter2D中。注意两个函数接收的变量不同，需要按照提示修改一下\n\n3.改变平台列表的大小并拖入不同的平台，这样就可以调整游戏难度以及未来新增其他平台或者陷阱\n\n4.在平台出生点中修改代码，添加：\n\n```\n        GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );\n        newPlatform.transform.SetParent(transform);\n```\n\n这样就可以让新生成的平台作为平台出生点的子物体\n\n5.为了不让链锤连续生成太多以至于游戏难度过大，修改spawn代码：\n\n```\n    int spikeBallNum = 0;\n    \n        public void CreatePlatform()\n    {\n        int index = Random.Range(0, platform.Count);\n\n        if (index == 3)\n        {\n            spikeBallNum++;\n            if(spikeBallNum > 2)\n            {\n                index = 0;\n                spikeBallNum = 0;\n            }\n        }\n\n        GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );\n        newPlatform.transform.SetParent(transform);\n    }\n```\n\n当连续出现链锤时变成普通平台，免得出现必死局\n\n\n\n---\n\n\n\n### \t终、总结\n\n到此为止主要游戏内容都已经完成啦！最后就是制作一些UI管理游戏\n","slug":"2021-07-15-《Speed Down》Unity2d游戏开发（五）","published":1,"updated":"2021-07-15T13:58:35.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71h7000c1ou0a5y63f5h","content":"<h3 id=\"一、随机生成平台\"><a href=\"#一、随机生成平台\" class=\"headerlink\" title=\"一、随机生成平台\"></a>一、随机生成平台</h3><p>1.可以删除其他平台，只留下一个开局的平台</p>\n<p>2.新建一个空物体作为平台出生点，调整大小，添加碰撞体，勾选is trigger，修改标签为spike</p>\n<span id=\"more\"></span>\n\n<p>3.新建脚本挂载到平台出生点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Spawner : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public List&lt;GameObject&gt; platform = new List&lt;GameObject&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public float spawnTime;</span><br><span class=\"line\">    float countTime;</span><br><span class=\"line\">    Vector3 spawnPosition;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SpawnPlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void SpawnPlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        countTime += Time.deltaTime;</span><br><span class=\"line\">        spawnPosition = transform.position;</span><br><span class=\"line\">        spawnPosition.x = Random.Range(-3f, 3f);</span><br><span class=\"line\"></span><br><span class=\"line\">        if(countTime &gt; spawnTime)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            CreatePlatform();</span><br><span class=\"line\">            countTime = 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void CreatePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int index = Random.Range(0, platform.Count);</span><br><span class=\"line\">        Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.回到unity设置脚本中平台列表的大小为3并且拖入三种基础平台</p>\n<p>5.设置好生成速度Spawn Time就可以开始玩啦！</p>\n<hr>\n<h3 id=\"二、细节调整\"><a href=\"#二、细节调整\" class=\"headerlink\" title=\"二、细节调整\"></a>二、细节调整</h3><p>1.将链锤的锤子设置标签为spike（不小心删了链锤的预制体，我是sb，以后碰到警告操作不可撤回的要万分小心）</p>\n<p>2.角色检测碰到尖刺死亡的代码是在OnTriggerEnter2D中的，而顶部尖刺是触发器，链锤是碰撞器，需要将死亡代码复制到OnCollisionEnter2D中。注意两个函数接收的变量不同，需要按照提示修改一下</p>\n<p>3.改变平台列表的大小并拖入不同的平台，这样就可以调整游戏难度以及未来新增其他平台或者陷阱</p>\n<p>4.在平台出生点中修改代码，添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class=\"line\">newPlatform.transform.SetParent(transform);</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以让新生成的平台作为平台出生点的子物体</p>\n<p>5.为了不让链锤连续生成太多以至于游戏难度过大，修改spawn代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int spikeBallNum = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void CreatePlatform()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int index = Random.Range(0, platform.Count);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (index == 3)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        spikeBallNum++;</span><br><span class=\"line\">        if(spikeBallNum &gt; 2)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            index = 0;</span><br><span class=\"line\">            spikeBallNum = 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class=\"line\">    newPlatform.transform.SetParent(transform);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当连续出现链锤时变成普通平台，免得出现必死局</p>\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>到此为止主要游戏内容都已经完成啦！最后就是制作一些UI管理游戏</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"一、随机生成平台\"><a href=\"#一、随机生成平台\" class=\"headerlink\" title=\"一、随机生成平台\"></a>一、随机生成平台</h3><p>1.可以删除其他平台，只留下一个开局的平台</p>\n<p>2.新建一个空物体作为平台出生点，调整大小，添加碰撞体，勾选is trigger，修改标签为spike</p>","more":"<p>3.新建脚本挂载到平台出生点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Spawner : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public List&lt;GameObject&gt; platform = new List&lt;GameObject&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public float spawnTime;</span><br><span class=\"line\">    float countTime;</span><br><span class=\"line\">    Vector3 spawnPosition;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SpawnPlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void SpawnPlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        countTime += Time.deltaTime;</span><br><span class=\"line\">        spawnPosition = transform.position;</span><br><span class=\"line\">        spawnPosition.x = Random.Range(-3f, 3f);</span><br><span class=\"line\"></span><br><span class=\"line\">        if(countTime &gt; spawnTime)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            CreatePlatform();</span><br><span class=\"line\">            countTime = 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void CreatePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int index = Random.Range(0, platform.Count);</span><br><span class=\"line\">        Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.回到unity设置脚本中平台列表的大小为3并且拖入三种基础平台</p>\n<p>5.设置好生成速度Spawn Time就可以开始玩啦！</p>\n<hr>\n<h3 id=\"二、细节调整\"><a href=\"#二、细节调整\" class=\"headerlink\" title=\"二、细节调整\"></a>二、细节调整</h3><p>1.将链锤的锤子设置标签为spike（不小心删了链锤的预制体，我是sb，以后碰到警告操作不可撤回的要万分小心）</p>\n<p>2.角色检测碰到尖刺死亡的代码是在OnTriggerEnter2D中的，而顶部尖刺是触发器，链锤是碰撞器，需要将死亡代码复制到OnCollisionEnter2D中。注意两个函数接收的变量不同，需要按照提示修改一下</p>\n<p>3.改变平台列表的大小并拖入不同的平台，这样就可以调整游戏难度以及未来新增其他平台或者陷阱</p>\n<p>4.在平台出生点中修改代码，添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class=\"line\">newPlatform.transform.SetParent(transform);</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以让新生成的平台作为平台出生点的子物体</p>\n<p>5.为了不让链锤连续生成太多以至于游戏难度过大，修改spawn代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int spikeBallNum = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void CreatePlatform()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int index = Random.Range(0, platform.Count);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (index == 3)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        spikeBallNum++;</span><br><span class=\"line\">        if(spikeBallNum &gt; 2)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            index = 0;</span><br><span class=\"line\">            spikeBallNum = 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class=\"line\">    newPlatform.transform.SetParent(transform);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当连续出现链锤时变成普通平台，免得出现必死局</p>\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>到此为止主要游戏内容都已经完成啦！最后就是制作一些UI管理游戏</p>"},{"title":"《Speed Down》Unity2d游戏开发（三）","date":"2021-07-14T08:16:29.000Z","_content":"\n\n\n### \t始、前言\n\n背景和障碍物都搭建完毕了，现在来制作我们操作的主角！（洗个衣服先...）\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、添加动画及组件\n\n1.先选中资源中喜欢的角色，修改所有精灵图的ppu为32\n\n2.制作动画，idle、run、jump、hit\n\n3.添加组件rigidbody 2d并且勾选constraints → freeze rotation → z 以此锁定z轴，防止碰撞时产生z轴翻转\n\n4.添加碰撞组件box collider 2d\n\n\n\n---\n\n\n\n### \t二、脚本控制主角\n\n添加脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerController : MonoBehaviour\n{\n    Rigidbody2D rb;\n    Animator anim;\n    public float speed;\n    float xVelocity;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        anim = GetComponent<Animator>();\n    }\n\n    void Update()\n    {\n        Movement();\n    }\n\n    void Movement()\n    {\n        xVelocity = Input.GetAxisRaw(\"Horizontal\");\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n\n        if(xVelocity != 0)\n        {\n            transform.localScale = new Vector3(xVelocity, 1, 1);\n        }\n    }\n}\n```\n\n挂载到角色上，就可以用方向键控制左右移动了（wsad也可以）\n\n并且`transform.localScale = new Vector3(xVelocity, 1, 1);`还实现了图案的左右翻转（之前我还傻傻地自己画各个方向的图）\n\n\n\n---\n\n\n\n### \t三、切换跑步动画\n\n1.打开player的Animator界面，相互连接idle和run，新建speed变量，设置idle转换为run的条件为speed大于0.1，run转换为idle的条件为speed小于0.1，同时记得调整转换时间和混合时间等设置（这里全部取消）\n\n2.在`void Movement()`中添加代码：\n\n```\nanim.SetFloat(\"speed\", Mathf.Abs(rb.velocity.x));\n```\n\n\n\n---\n\n\n\n### \t四、切换下落动画\n\n1.动画all和idle相互连接，创建isOnGround变量来检测是否在平台上，把所有平台的Layer都改成新的Platform\n\n2.添加代码：\n\n```\n    public bool isOnGround;\n    public float checkRadius;\n    public LayerMask layer;\n    public GameObject groundCheck;\n    \n    void Update()\n    {\n        Movement();\n        isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);\n        anim.SetBool(\"isOnGround\", isOnGround);\n    } \n```\n\n3.在角色物体下方添加子物体CheckPoint并拖拽入角色的检测点位置\n\n4.修改参数就可以实现踩到平台时触发isOnGround，并且由fall动画转换到idle动画\n\n但是现在看不见检测范围，只能大致估计，怎么办呢？\n\n小技巧：添加代码：\n\n```\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);\n    }\n```\n\n上述代码是unity内置的方法，可以把检测范围可视化\n\n---\n\n\n\n### \t五、切换死亡动画\n\n1.修改尖刺的tag为新的Spike，状态机新建trigger型变量isDead，将Any State 连接到hit调整转换条件，这样就可以从任何状态转换到死亡状态\n\n2.添加代码：\n\n```\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if (collision.CompareTag(\"Spike\"))\n        {\n            anim.SetTrigger(\"isDead\");\n        }\n    }\n```\n\n这样就实现了播放死亡动画，接下来再加一个表示角色死亡的标志\n\n3.添加代码：\n\n```\n    public bool playerDead;\n    \n    public void PlayerDead()\n    {\n        playerDead = true;\n    }\n```\n\n4.找到玩家死亡的动画效果，在最后一帧添加函数`PlayerDead()`\n\n\n\n---\n\n\n\n### \t六、实现跳跃平台的跳跃效果\n\n1.设置跳跃平台的tag为新的Fan\n\n2.添加代码：\n\n```\n    public float bounceH;\n    \n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Fan\"))\n        {\n            rb.velocity = new Vector2(rb.velocity.x, bounceH);\n        }\n    }\n```\n\n这样以来，角色碰到跳跃平台时就会给rigidbody产生向上的大小为bounceH的力（就是被打飞了）\n\n发现之前说好的跳跃平台碰到角色会转起来现在好像没有转，原来是主角的tag没有设置成Player\n\n完美！\n\n\n\n---\n\n\n\n### \t终、吐槽\n\n角色的各种动画转换也太复杂了！难道每次添加一个新的动作就要和所有的动作一起调整吗，天啊！有没有简单的方法啊，快浇浇我吧！\n\n","source":"_posts/2021-07-14-《Speed Down》Unity2d游戏开发（三）.md","raw":"---\ntitle: 《Speed Down》Unity2d游戏开发（三）\ndate: 2021-07-14 16:16:29\ncategories:\tunity\ntags:\n  - unity\n  - c#\n  - animator\n  - trigger\n  - collider\n---\n\n\n\n### \t始、前言\n\n背景和障碍物都搭建完毕了，现在来制作我们操作的主角！（洗个衣服先...）\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、添加动画及组件\n\n1.先选中资源中喜欢的角色，修改所有精灵图的ppu为32\n\n2.制作动画，idle、run、jump、hit\n\n3.添加组件rigidbody 2d并且勾选constraints → freeze rotation → z 以此锁定z轴，防止碰撞时产生z轴翻转\n\n4.添加碰撞组件box collider 2d\n\n\n\n---\n\n\n\n### \t二、脚本控制主角\n\n添加脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerController : MonoBehaviour\n{\n    Rigidbody2D rb;\n    Animator anim;\n    public float speed;\n    float xVelocity;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        anim = GetComponent<Animator>();\n    }\n\n    void Update()\n    {\n        Movement();\n    }\n\n    void Movement()\n    {\n        xVelocity = Input.GetAxisRaw(\"Horizontal\");\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n\n        if(xVelocity != 0)\n        {\n            transform.localScale = new Vector3(xVelocity, 1, 1);\n        }\n    }\n}\n```\n\n挂载到角色上，就可以用方向键控制左右移动了（wsad也可以）\n\n并且`transform.localScale = new Vector3(xVelocity, 1, 1);`还实现了图案的左右翻转（之前我还傻傻地自己画各个方向的图）\n\n\n\n---\n\n\n\n### \t三、切换跑步动画\n\n1.打开player的Animator界面，相互连接idle和run，新建speed变量，设置idle转换为run的条件为speed大于0.1，run转换为idle的条件为speed小于0.1，同时记得调整转换时间和混合时间等设置（这里全部取消）\n\n2.在`void Movement()`中添加代码：\n\n```\nanim.SetFloat(\"speed\", Mathf.Abs(rb.velocity.x));\n```\n\n\n\n---\n\n\n\n### \t四、切换下落动画\n\n1.动画all和idle相互连接，创建isOnGround变量来检测是否在平台上，把所有平台的Layer都改成新的Platform\n\n2.添加代码：\n\n```\n    public bool isOnGround;\n    public float checkRadius;\n    public LayerMask layer;\n    public GameObject groundCheck;\n    \n    void Update()\n    {\n        Movement();\n        isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);\n        anim.SetBool(\"isOnGround\", isOnGround);\n    } \n```\n\n3.在角色物体下方添加子物体CheckPoint并拖拽入角色的检测点位置\n\n4.修改参数就可以实现踩到平台时触发isOnGround，并且由fall动画转换到idle动画\n\n但是现在看不见检测范围，只能大致估计，怎么办呢？\n\n小技巧：添加代码：\n\n```\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);\n    }\n```\n\n上述代码是unity内置的方法，可以把检测范围可视化\n\n---\n\n\n\n### \t五、切换死亡动画\n\n1.修改尖刺的tag为新的Spike，状态机新建trigger型变量isDead，将Any State 连接到hit调整转换条件，这样就可以从任何状态转换到死亡状态\n\n2.添加代码：\n\n```\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if (collision.CompareTag(\"Spike\"))\n        {\n            anim.SetTrigger(\"isDead\");\n        }\n    }\n```\n\n这样就实现了播放死亡动画，接下来再加一个表示角色死亡的标志\n\n3.添加代码：\n\n```\n    public bool playerDead;\n    \n    public void PlayerDead()\n    {\n        playerDead = true;\n    }\n```\n\n4.找到玩家死亡的动画效果，在最后一帧添加函数`PlayerDead()`\n\n\n\n---\n\n\n\n### \t六、实现跳跃平台的跳跃效果\n\n1.设置跳跃平台的tag为新的Fan\n\n2.添加代码：\n\n```\n    public float bounceH;\n    \n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Fan\"))\n        {\n            rb.velocity = new Vector2(rb.velocity.x, bounceH);\n        }\n    }\n```\n\n这样以来，角色碰到跳跃平台时就会给rigidbody产生向上的大小为bounceH的力（就是被打飞了）\n\n发现之前说好的跳跃平台碰到角色会转起来现在好像没有转，原来是主角的tag没有设置成Player\n\n完美！\n\n\n\n---\n\n\n\n### \t终、吐槽\n\n角色的各种动画转换也太复杂了！难道每次添加一个新的动作就要和所有的动作一起调整吗，天啊！有没有简单的方法啊，快浇浇我吧！\n\n","slug":"2021-07-14-《Speed Down》Unity2d游戏开发（三）","published":1,"updated":"2021-07-15T10:26:44.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71h9000g1ou0egxyhrdo","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>背景和障碍物都搭建完毕了，现在来制作我们操作的主角！（洗个衣服先…）</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、添加动画及组件\"><a href=\"#一、添加动画及组件\" class=\"headerlink\" title=\"一、添加动画及组件\"></a>一、添加动画及组件</h3><p>1.先选中资源中喜欢的角色，修改所有精灵图的ppu为32</p>\n<p>2.制作动画，idle、run、jump、hit</p>\n<p>3.添加组件rigidbody 2d并且勾选constraints → freeze rotation → z 以此锁定z轴，防止碰撞时产生z轴翻转</p>\n<p>4.添加碰撞组件box collider 2d</p>\n<hr>\n<h3 id=\"二、脚本控制主角\"><a href=\"#二、脚本控制主角\" class=\"headerlink\" title=\"二、脚本控制主角\"></a>二、脚本控制主角</h3><p>添加脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerController : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Rigidbody2D rb;</span><br><span class=\"line\">    Animator anim;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">        anim = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Movement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Movement()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\"></span><br><span class=\"line\">        if(xVelocity != 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            transform.localScale = new Vector3(xVelocity, 1, 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>挂载到角色上，就可以用方向键控制左右移动了（wsad也可以）</p>\n<p>并且<code>transform.localScale = new Vector3(xVelocity, 1, 1);</code>还实现了图案的左右翻转（之前我还傻傻地自己画各个方向的图）</p>\n<hr>\n<h3 id=\"三、切换跑步动画\"><a href=\"#三、切换跑步动画\" class=\"headerlink\" title=\"三、切换跑步动画\"></a>三、切换跑步动画</h3><p>1.打开player的Animator界面，相互连接idle和run，新建speed变量，设置idle转换为run的条件为speed大于0.1，run转换为idle的条件为speed小于0.1，同时记得调整转换时间和混合时间等设置（这里全部取消）</p>\n<p>2.在<code>void Movement()</code>中添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">anim.SetFloat(&quot;speed&quot;, Mathf.Abs(rb.velocity.x));</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"四、切换下落动画\"><a href=\"#四、切换下落动画\" class=\"headerlink\" title=\"四、切换下落动画\"></a>四、切换下落动画</h3><p>1.动画all和idle相互连接，创建isOnGround变量来检测是否在平台上，把所有平台的Layer都改成新的Platform</p>\n<p>2.添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public bool isOnGround;</span><br><span class=\"line\">public float checkRadius;</span><br><span class=\"line\">public LayerMask layer;</span><br><span class=\"line\">public GameObject groundCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">void Update()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Movement();</span><br><span class=\"line\">    isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);</span><br><span class=\"line\">    anim.SetBool(&quot;isOnGround&quot;, isOnGround);</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>3.在角色物体下方添加子物体CheckPoint并拖拽入角色的检测点位置</p>\n<p>4.修改参数就可以实现踩到平台时触发isOnGround，并且由fall动画转换到idle动画</p>\n<p>但是现在看不见检测范围，只能大致估计，怎么办呢？</p>\n<p>小技巧：添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void OnDrawGizmosSelected()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Gizmos.color = Color.green;</span><br><span class=\"line\">    Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码是unity内置的方法，可以把检测范围可视化</p>\n<hr>\n<h3 id=\"五、切换死亡动画\"><a href=\"#五、切换死亡动画\" class=\"headerlink\" title=\"五、切换死亡动画\"></a>五、切换死亡动画</h3><p>1.修改尖刺的tag为新的Spike，状态机新建trigger型变量isDead，将Any State 连接到hit调整转换条件，这样就可以从任何状态转换到死亡状态</p>\n<p>2.添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (collision.CompareTag(&quot;Spike&quot;))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        anim.SetTrigger(&quot;isDead&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就实现了播放死亡动画，接下来再加一个表示角色死亡的标志</p>\n<p>3.添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public bool playerDead;</span><br><span class=\"line\"></span><br><span class=\"line\">public void PlayerDead()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    playerDead = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.找到玩家死亡的动画效果，在最后一帧添加函数<code>PlayerDead()</code></p>\n<hr>\n<h3 id=\"六、实现跳跃平台的跳跃效果\"><a href=\"#六、实现跳跃平台的跳跃效果\" class=\"headerlink\" title=\"六、实现跳跃平台的跳跃效果\"></a>六、实现跳跃平台的跳跃效果</h3><p>1.设置跳跃平台的tag为新的Fan</p>\n<p>2.添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public float bounceH;</span><br><span class=\"line\"></span><br><span class=\"line\">private void OnCollisionEnter2D(Collision2D collision)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (collision.gameObject.CompareTag(&quot;Fan&quot;))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb.velocity = new Vector2(rb.velocity.x, bounceH);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样以来，角色碰到跳跃平台时就会给rigidbody产生向上的大小为bounceH的力（就是被打飞了）</p>\n<p>发现之前说好的跳跃平台碰到角色会转起来现在好像没有转，原来是主角的tag没有设置成Player</p>\n<p>完美！</p>\n<hr>\n<h3 id=\"终、吐槽\"><a href=\"#终、吐槽\" class=\"headerlink\" title=\"终、吐槽\"></a>终、吐槽</h3><p>角色的各种动画转换也太复杂了！难道每次添加一个新的动作就要和所有的动作一起调整吗，天啊！有没有简单的方法啊，快浇浇我吧！</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>背景和障碍物都搭建完毕了，现在来制作我们操作的主角！（洗个衣服先…）</p>","more":"<hr>\n<h3 id=\"一、添加动画及组件\"><a href=\"#一、添加动画及组件\" class=\"headerlink\" title=\"一、添加动画及组件\"></a>一、添加动画及组件</h3><p>1.先选中资源中喜欢的角色，修改所有精灵图的ppu为32</p>\n<p>2.制作动画，idle、run、jump、hit</p>\n<p>3.添加组件rigidbody 2d并且勾选constraints → freeze rotation → z 以此锁定z轴，防止碰撞时产生z轴翻转</p>\n<p>4.添加碰撞组件box collider 2d</p>\n<hr>\n<h3 id=\"二、脚本控制主角\"><a href=\"#二、脚本控制主角\" class=\"headerlink\" title=\"二、脚本控制主角\"></a>二、脚本控制主角</h3><p>添加脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerController : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Rigidbody2D rb;</span><br><span class=\"line\">    Animator anim;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">        anim = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Movement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Movement()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\"></span><br><span class=\"line\">        if(xVelocity != 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            transform.localScale = new Vector3(xVelocity, 1, 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>挂载到角色上，就可以用方向键控制左右移动了（wsad也可以）</p>\n<p>并且<code>transform.localScale = new Vector3(xVelocity, 1, 1);</code>还实现了图案的左右翻转（之前我还傻傻地自己画各个方向的图）</p>\n<hr>\n<h3 id=\"三、切换跑步动画\"><a href=\"#三、切换跑步动画\" class=\"headerlink\" title=\"三、切换跑步动画\"></a>三、切换跑步动画</h3><p>1.打开player的Animator界面，相互连接idle和run，新建speed变量，设置idle转换为run的条件为speed大于0.1，run转换为idle的条件为speed小于0.1，同时记得调整转换时间和混合时间等设置（这里全部取消）</p>\n<p>2.在<code>void Movement()</code>中添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">anim.SetFloat(&quot;speed&quot;, Mathf.Abs(rb.velocity.x));</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"四、切换下落动画\"><a href=\"#四、切换下落动画\" class=\"headerlink\" title=\"四、切换下落动画\"></a>四、切换下落动画</h3><p>1.动画all和idle相互连接，创建isOnGround变量来检测是否在平台上，把所有平台的Layer都改成新的Platform</p>\n<p>2.添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public bool isOnGround;</span><br><span class=\"line\">public float checkRadius;</span><br><span class=\"line\">public LayerMask layer;</span><br><span class=\"line\">public GameObject groundCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">void Update()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Movement();</span><br><span class=\"line\">    isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);</span><br><span class=\"line\">    anim.SetBool(&quot;isOnGround&quot;, isOnGround);</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>3.在角色物体下方添加子物体CheckPoint并拖拽入角色的检测点位置</p>\n<p>4.修改参数就可以实现踩到平台时触发isOnGround，并且由fall动画转换到idle动画</p>\n<p>但是现在看不见检测范围，只能大致估计，怎么办呢？</p>\n<p>小技巧：添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void OnDrawGizmosSelected()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Gizmos.color = Color.green;</span><br><span class=\"line\">    Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码是unity内置的方法，可以把检测范围可视化</p>\n<hr>\n<h3 id=\"五、切换死亡动画\"><a href=\"#五、切换死亡动画\" class=\"headerlink\" title=\"五、切换死亡动画\"></a>五、切换死亡动画</h3><p>1.修改尖刺的tag为新的Spike，状态机新建trigger型变量isDead，将Any State 连接到hit调整转换条件，这样就可以从任何状态转换到死亡状态</p>\n<p>2.添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (collision.CompareTag(&quot;Spike&quot;))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        anim.SetTrigger(&quot;isDead&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就实现了播放死亡动画，接下来再加一个表示角色死亡的标志</p>\n<p>3.添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public bool playerDead;</span><br><span class=\"line\"></span><br><span class=\"line\">public void PlayerDead()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    playerDead = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.找到玩家死亡的动画效果，在最后一帧添加函数<code>PlayerDead()</code></p>\n<hr>\n<h3 id=\"六、实现跳跃平台的跳跃效果\"><a href=\"#六、实现跳跃平台的跳跃效果\" class=\"headerlink\" title=\"六、实现跳跃平台的跳跃效果\"></a>六、实现跳跃平台的跳跃效果</h3><p>1.设置跳跃平台的tag为新的Fan</p>\n<p>2.添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public float bounceH;</span><br><span class=\"line\"></span><br><span class=\"line\">private void OnCollisionEnter2D(Collision2D collision)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (collision.gameObject.CompareTag(&quot;Fan&quot;))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb.velocity = new Vector2(rb.velocity.x, bounceH);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样以来，角色碰到跳跃平台时就会给rigidbody产生向上的大小为bounceH的力（就是被打飞了）</p>\n<p>发现之前说好的跳跃平台碰到角色会转起来现在好像没有转，原来是主角的tag没有设置成Player</p>\n<p>完美！</p>\n<hr>\n<h3 id=\"终、吐槽\"><a href=\"#终、吐槽\" class=\"headerlink\" title=\"终、吐槽\"></a>终、吐槽</h3><p>角色的各种动画转换也太复杂了！难道每次添加一个新的动作就要和所有的动作一起调整吗，天啊！有没有简单的方法啊，快浇浇我吧！</p>"},{"title":"《Speed Down》Unity2d游戏开发（六）","date":"2021-07-15T10:22:45.000Z","_content":"\n\n\n### \t始、前言\n\n《Speed Down》开发已经接近尾声啦！最后再来完善一下，变成真正能玩的游戏！\n\n<!--more-->\n\n---\n\n\n\n### \t一、分数统计\n\n1.新建UI → Text 物体，发现自动创建了Canvas并将Text作为子物体添加\n\n2.调整Text的位置大小等参数直到满意\n\n3.新建空物体命名GameManage，新建脚本也命名GameManage并挂载到空物体GameManage上：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\n\npublic class GameManage : MonoBehaviour\n{\n    static GameManage instance;\n    public Text score;\n\n    private void Awake()\n    {\n        if(instance != null)\n        {\n            Destroy(gameObject);\n        }\n        instance = this;\n    }\n\n    void Update()\n    {\n        score.text = Time.time.ToString(\"000\");\n    }\n}\n```\n\nAwake会在所有的Start之前调用，适合用作游戏的初始化\n\n返回unity就可以看到随时间增加分数\n\n\n\n---\n\n\n\n### \t二、失败界面\n\n1.在Canvas下添加Panel并按自己喜欢布置界面，添加两个按钮用作重新开始游戏和退出游戏\n\n2.在GameManage脚本中添加：\n\n```\n    public void RestartGame()\n    {\n        SceneManager.LoadScene(SceneManager.GetActiveScene().name);\n        Time.timeScale = 1;\n    }\n    \n        public void Exit()\n    {\n        Application.Quit();\n    }\n```\n\n3.给两个按钮添加刚刚新建的方法\n\n按钮的功能已经设置好，其中退出游戏的功能需要在项目build之后才能看到效果。现在我们希望游戏失败界面在失败后出现\n\n4.取消勾选Panel的标签上面的框，这样就平时就不会显示Panel\n\n5.在GameManage中添加：\n\n```\n    public static void GameOver(bool dead)\n    {\n        if (dead)\n        {\n            Time.timeScale = 0f;\n            instance.gameOverUI.SetActive(true);\n        }\n    }\n```\n\n注意：想要在其他脚本中调用方法，需要定义方法成static类型\n\n6.在PlayerController脚本中修改PlayerDead方法：\n\n```\n    public void PlayerDead()\n    {\n        playerDead = true;\n        GameManage.GameOver(playerDead);\n    }\n```\n\n当角色死亡时就会弹出失败界面\n\n\n\n---\n\n\n\n### \t终、测试\n\n最后测试了一下，发现重新开始游戏时不会将分数重置，需要将GameManage脚本中的`Time.time.ToString`改成`Time.timeSinceLevelLoad.ToString`，这样一来时间计数就会在场景重置时重置。\n","source":"_posts/2021-07-15-《Speed Down》Unity2d游戏开发（六）.md","raw":"---\ntitle: 《Speed Down》Unity2d游戏开发（六）\ndate: 2021-07-15 18:22:45\ncategories: unity\ntags:\n  - unity\n  - c#\n  - awake\n  - canvas\n---\n\n\n\n### \t始、前言\n\n《Speed Down》开发已经接近尾声啦！最后再来完善一下，变成真正能玩的游戏！\n\n<!--more-->\n\n---\n\n\n\n### \t一、分数统计\n\n1.新建UI → Text 物体，发现自动创建了Canvas并将Text作为子物体添加\n\n2.调整Text的位置大小等参数直到满意\n\n3.新建空物体命名GameManage，新建脚本也命名GameManage并挂载到空物体GameManage上：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\n\npublic class GameManage : MonoBehaviour\n{\n    static GameManage instance;\n    public Text score;\n\n    private void Awake()\n    {\n        if(instance != null)\n        {\n            Destroy(gameObject);\n        }\n        instance = this;\n    }\n\n    void Update()\n    {\n        score.text = Time.time.ToString(\"000\");\n    }\n}\n```\n\nAwake会在所有的Start之前调用，适合用作游戏的初始化\n\n返回unity就可以看到随时间增加分数\n\n\n\n---\n\n\n\n### \t二、失败界面\n\n1.在Canvas下添加Panel并按自己喜欢布置界面，添加两个按钮用作重新开始游戏和退出游戏\n\n2.在GameManage脚本中添加：\n\n```\n    public void RestartGame()\n    {\n        SceneManager.LoadScene(SceneManager.GetActiveScene().name);\n        Time.timeScale = 1;\n    }\n    \n        public void Exit()\n    {\n        Application.Quit();\n    }\n```\n\n3.给两个按钮添加刚刚新建的方法\n\n按钮的功能已经设置好，其中退出游戏的功能需要在项目build之后才能看到效果。现在我们希望游戏失败界面在失败后出现\n\n4.取消勾选Panel的标签上面的框，这样就平时就不会显示Panel\n\n5.在GameManage中添加：\n\n```\n    public static void GameOver(bool dead)\n    {\n        if (dead)\n        {\n            Time.timeScale = 0f;\n            instance.gameOverUI.SetActive(true);\n        }\n    }\n```\n\n注意：想要在其他脚本中调用方法，需要定义方法成static类型\n\n6.在PlayerController脚本中修改PlayerDead方法：\n\n```\n    public void PlayerDead()\n    {\n        playerDead = true;\n        GameManage.GameOver(playerDead);\n    }\n```\n\n当角色死亡时就会弹出失败界面\n\n\n\n---\n\n\n\n### \t终、测试\n\n最后测试了一下，发现重新开始游戏时不会将分数重置，需要将GameManage脚本中的`Time.time.ToString`改成`Time.timeSinceLevelLoad.ToString`，这样一来时间计数就会在场景重置时重置。\n","slug":"2021-07-15-《Speed Down》Unity2d游戏开发（六）","published":1,"updated":"2021-07-17T09:59:47.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71ha000i1ou0667ogl90","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>《Speed Down》开发已经接近尾声啦！最后再来完善一下，变成真正能玩的游戏！</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、分数统计\"><a href=\"#一、分数统计\" class=\"headerlink\" title=\"一、分数统计\"></a>一、分数统计</h3><p>1.新建UI → Text 物体，发现自动创建了Canvas并将Text作为子物体添加</p>\n<p>2.调整Text的位置大小等参数直到满意</p>\n<p>3.新建空物体命名GameManage，新建脚本也命名GameManage并挂载到空物体GameManage上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">using UnityEngine.UI;</span><br><span class=\"line\">using UnityEngine.SceneManagement;</span><br><span class=\"line\"></span><br><span class=\"line\">public class GameManage : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static GameManage instance;</span><br><span class=\"line\">    public Text score;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void Awake()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(instance != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        instance = this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        score.text = Time.time.ToString(&quot;000&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Awake会在所有的Start之前调用，适合用作游戏的初始化</p>\n<p>返回unity就可以看到随时间增加分数</p>\n<hr>\n<h3 id=\"二、失败界面\"><a href=\"#二、失败界面\" class=\"headerlink\" title=\"二、失败界面\"></a>二、失败界面</h3><p>1.在Canvas下添加Panel并按自己喜欢布置界面，添加两个按钮用作重新开始游戏和退出游戏</p>\n<p>2.在GameManage脚本中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void RestartGame()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SceneManager.LoadScene(SceneManager.GetActiveScene().name);</span><br><span class=\"line\">    Time.timeScale = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void Exit()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Application.Quit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.给两个按钮添加刚刚新建的方法</p>\n<p>按钮的功能已经设置好，其中退出游戏的功能需要在项目build之后才能看到效果。现在我们希望游戏失败界面在失败后出现</p>\n<p>4.取消勾选Panel的标签上面的框，这样就平时就不会显示Panel</p>\n<p>5.在GameManage中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void GameOver(bool dead)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (dead)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Time.timeScale = 0f;</span><br><span class=\"line\">        instance.gameOverUI.SetActive(true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：想要在其他脚本中调用方法，需要定义方法成static类型</p>\n<p>6.在PlayerController脚本中修改PlayerDead方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void PlayerDead()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    playerDead = true;</span><br><span class=\"line\">    GameManage.GameOver(playerDead);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当角色死亡时就会弹出失败界面</p>\n<hr>\n<h3 id=\"终、测试\"><a href=\"#终、测试\" class=\"headerlink\" title=\"终、测试\"></a>终、测试</h3><p>最后测试了一下，发现重新开始游戏时不会将分数重置，需要将GameManage脚本中的<code>Time.time.ToString</code>改成<code>Time.timeSinceLevelLoad.ToString</code>，这样一来时间计数就会在场景重置时重置。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>《Speed Down》开发已经接近尾声啦！最后再来完善一下，变成真正能玩的游戏！</p>","more":"<hr>\n<h3 id=\"一、分数统计\"><a href=\"#一、分数统计\" class=\"headerlink\" title=\"一、分数统计\"></a>一、分数统计</h3><p>1.新建UI → Text 物体，发现自动创建了Canvas并将Text作为子物体添加</p>\n<p>2.调整Text的位置大小等参数直到满意</p>\n<p>3.新建空物体命名GameManage，新建脚本也命名GameManage并挂载到空物体GameManage上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">using UnityEngine.UI;</span><br><span class=\"line\">using UnityEngine.SceneManagement;</span><br><span class=\"line\"></span><br><span class=\"line\">public class GameManage : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static GameManage instance;</span><br><span class=\"line\">    public Text score;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void Awake()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(instance != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        instance = this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        score.text = Time.time.ToString(&quot;000&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Awake会在所有的Start之前调用，适合用作游戏的初始化</p>\n<p>返回unity就可以看到随时间增加分数</p>\n<hr>\n<h3 id=\"二、失败界面\"><a href=\"#二、失败界面\" class=\"headerlink\" title=\"二、失败界面\"></a>二、失败界面</h3><p>1.在Canvas下添加Panel并按自己喜欢布置界面，添加两个按钮用作重新开始游戏和退出游戏</p>\n<p>2.在GameManage脚本中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void RestartGame()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SceneManager.LoadScene(SceneManager.GetActiveScene().name);</span><br><span class=\"line\">    Time.timeScale = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void Exit()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Application.Quit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.给两个按钮添加刚刚新建的方法</p>\n<p>按钮的功能已经设置好，其中退出游戏的功能需要在项目build之后才能看到效果。现在我们希望游戏失败界面在失败后出现</p>\n<p>4.取消勾选Panel的标签上面的框，这样就平时就不会显示Panel</p>\n<p>5.在GameManage中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void GameOver(bool dead)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (dead)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Time.timeScale = 0f;</span><br><span class=\"line\">        instance.gameOverUI.SetActive(true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：想要在其他脚本中调用方法，需要定义方法成static类型</p>\n<p>6.在PlayerController脚本中修改PlayerDead方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void PlayerDead()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    playerDead = true;</span><br><span class=\"line\">    GameManage.GameOver(playerDead);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当角色死亡时就会弹出失败界面</p>\n<hr>\n<h3 id=\"终、测试\"><a href=\"#终、测试\" class=\"headerlink\" title=\"终、测试\"></a>终、测试</h3><p>最后测试了一下，发现重新开始游戏时不会将分数重置，需要将GameManage脚本中的<code>Time.time.ToString</code>改成<code>Time.timeSinceLevelLoad.ToString</code>，这样一来时间计数就会在场景重置时重置。</p>"},{"title":"《Speed Down》Unity2d游戏开发（二）","date":"2021-07-13T07:50:11.000Z","_content":"\n\n\n### \t始、前言\n\n上一次已经完成了场景搭建，那么这次的主要任务就是制作跳跃平台\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、普通平台\n\n1.选中pixel adventure 1 → assets → traps → falling platform 设置pixels per unit为16\n\n2.拖拽第一张图案到场景中，命名为BasePlatform\n\n3.新建BasePlatform的动画，将四个图案拖拽进动画中并调整采样率\n\n4.为BasePlatform添加碰撞器box collider 2d 并调整碰撞体积\n\n\n\n---\n\n\n\n### \t二、旋转平台\n\n1.前面的操作与上述普通平台相同，设置大小，命名，新建动画，添加碰撞器\n\n2.为了实现平台被碰撞时发生翻转，添加组件hinge joint 2d，可以设置旋转角度和速度等\n\n自动添加了rigidbody 2d，但是不取消也不会掉下来，为什么呢？\n\n猜测是joint关节会固定在背景里，超过一定的力才会 “脱臼”\n\n\n\n---\n\n\n\n### \t三、弹跳平台\n\n1.找到pixel adventure 1 → assets → traps → fan ，设置大小，命名，添加碰撞器\n\n2.这里新建两个动画，一个是静止时的动画，一个是启动时的动画（弹跳）\n\n3.新建脚本，实现碰撞时平台切换到弹跳动画：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class FanRun : MonoBehaviour\n{\n    Animator animator;\n    void Start()\n    {\n        animator = GetComponent<Animator>();\n    }\n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            animator.Play(\"Fan_run\");\n        }\n    }\n}\n```\n\n当标签为Player的物体碰撞到此平台时就会切换到启动动画啦\n\n\n\n---\n\n\n\n### \t四、摆动链锤\n\n1.新建空物体SpikeBall，分别添加两个子物体pixel adventure 1 → assets → traps → spiked ball → 轴心和大锤\n\n2.调整父子物体的相对位置\n\n3.给大锤添加组件Distance Joint 2D，给轴心添加rigid body 2d并拖拽到大锤的链接体\n\n4.给大锤添加碰撞体circle collider 2d\n\n\n\n---\n\n\n\n### \t五、脚本实现平台上升\n\n新建脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlatformUp : MonoBehaviour\n{\n    Vector3 movement;\n    public float speed;\n    void Start()\n    {\n        movement.y = speed;\n    }\n    void Update()\n    {\n        MovePlatform();\n    }\n    void MovePlatform()\n    {\n        transform.position += movement * Time.deltaTime;\n    }\n}\n```\n\n并挂载到所有的平台建筑下，这样就实现了平台的持续上升\n\n\n\n---\n\n\n\n### \t六、设置平台天花板\n\n平台总不能一直上升，要设置一个天花板，当平台到达天花板时就摧毁物体\n\n1.新建空物体TopLine移动到上方合适的位置，作为天花板\n\n2.在平台的上升代码中添加判断到达天花板的检测：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlatformUp : MonoBehaviour\n{\n    Vector3 movement;\n    public float speed;\n    GameObject topLine;\n\n    void Start()\n    {\n        movement.y = speed;\n        topLine = GameObject.Find(\"TopLine\");\n    }\n    void Update()\n    {\n        MovePlatform();\n    }\n\n    void MovePlatform()\n    {\n        transform.position += movement * Time.deltaTime;\n        if(transform.position.y > topLine.transform.position.y)\n        {\n            Destroy(gameObject);\n        }\n    }\n}\n```\n\n完成！平台到位自动销毁\n\n\n\n---\n\n\n\n### \t终、总结\n\n平台的制作到这就结束了！用到了几个joint组件，十分有趣\n\n","source":"_posts/2021-07-13-《Speed Down》Unity2d游戏开发（二）.md","raw":"---\ntitle: 《Speed Down》Unity2d游戏开发（二）\ndate: 2021-07-13 15:50:11\ncategories: unity\ntags:\n  - unity\n  - c#\n  - joint\n  - collider\n---\n\n\n\n### \t始、前言\n\n上一次已经完成了场景搭建，那么这次的主要任务就是制作跳跃平台\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、普通平台\n\n1.选中pixel adventure 1 → assets → traps → falling platform 设置pixels per unit为16\n\n2.拖拽第一张图案到场景中，命名为BasePlatform\n\n3.新建BasePlatform的动画，将四个图案拖拽进动画中并调整采样率\n\n4.为BasePlatform添加碰撞器box collider 2d 并调整碰撞体积\n\n\n\n---\n\n\n\n### \t二、旋转平台\n\n1.前面的操作与上述普通平台相同，设置大小，命名，新建动画，添加碰撞器\n\n2.为了实现平台被碰撞时发生翻转，添加组件hinge joint 2d，可以设置旋转角度和速度等\n\n自动添加了rigidbody 2d，但是不取消也不会掉下来，为什么呢？\n\n猜测是joint关节会固定在背景里，超过一定的力才会 “脱臼”\n\n\n\n---\n\n\n\n### \t三、弹跳平台\n\n1.找到pixel adventure 1 → assets → traps → fan ，设置大小，命名，添加碰撞器\n\n2.这里新建两个动画，一个是静止时的动画，一个是启动时的动画（弹跳）\n\n3.新建脚本，实现碰撞时平台切换到弹跳动画：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class FanRun : MonoBehaviour\n{\n    Animator animator;\n    void Start()\n    {\n        animator = GetComponent<Animator>();\n    }\n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            animator.Play(\"Fan_run\");\n        }\n    }\n}\n```\n\n当标签为Player的物体碰撞到此平台时就会切换到启动动画啦\n\n\n\n---\n\n\n\n### \t四、摆动链锤\n\n1.新建空物体SpikeBall，分别添加两个子物体pixel adventure 1 → assets → traps → spiked ball → 轴心和大锤\n\n2.调整父子物体的相对位置\n\n3.给大锤添加组件Distance Joint 2D，给轴心添加rigid body 2d并拖拽到大锤的链接体\n\n4.给大锤添加碰撞体circle collider 2d\n\n\n\n---\n\n\n\n### \t五、脚本实现平台上升\n\n新建脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlatformUp : MonoBehaviour\n{\n    Vector3 movement;\n    public float speed;\n    void Start()\n    {\n        movement.y = speed;\n    }\n    void Update()\n    {\n        MovePlatform();\n    }\n    void MovePlatform()\n    {\n        transform.position += movement * Time.deltaTime;\n    }\n}\n```\n\n并挂载到所有的平台建筑下，这样就实现了平台的持续上升\n\n\n\n---\n\n\n\n### \t六、设置平台天花板\n\n平台总不能一直上升，要设置一个天花板，当平台到达天花板时就摧毁物体\n\n1.新建空物体TopLine移动到上方合适的位置，作为天花板\n\n2.在平台的上升代码中添加判断到达天花板的检测：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlatformUp : MonoBehaviour\n{\n    Vector3 movement;\n    public float speed;\n    GameObject topLine;\n\n    void Start()\n    {\n        movement.y = speed;\n        topLine = GameObject.Find(\"TopLine\");\n    }\n    void Update()\n    {\n        MovePlatform();\n    }\n\n    void MovePlatform()\n    {\n        transform.position += movement * Time.deltaTime;\n        if(transform.position.y > topLine.transform.position.y)\n        {\n            Destroy(gameObject);\n        }\n    }\n}\n```\n\n完成！平台到位自动销毁\n\n\n\n---\n\n\n\n### \t终、总结\n\n平台的制作到这就结束了！用到了几个joint组件，十分有趣\n\n","slug":"2021-07-13-《Speed Down》Unity2d游戏开发（二）","published":1,"updated":"2021-07-16T13:11:47.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hb000m1ou046u4ax80","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>上一次已经完成了场景搭建，那么这次的主要任务就是制作跳跃平台</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、普通平台\"><a href=\"#一、普通平台\" class=\"headerlink\" title=\"一、普通平台\"></a>一、普通平台</h3><p>1.选中pixel adventure 1 → assets → traps → falling platform 设置pixels per unit为16</p>\n<p>2.拖拽第一张图案到场景中，命名为BasePlatform</p>\n<p>3.新建BasePlatform的动画，将四个图案拖拽进动画中并调整采样率</p>\n<p>4.为BasePlatform添加碰撞器box collider 2d 并调整碰撞体积</p>\n<hr>\n<h3 id=\"二、旋转平台\"><a href=\"#二、旋转平台\" class=\"headerlink\" title=\"二、旋转平台\"></a>二、旋转平台</h3><p>1.前面的操作与上述普通平台相同，设置大小，命名，新建动画，添加碰撞器</p>\n<p>2.为了实现平台被碰撞时发生翻转，添加组件hinge joint 2d，可以设置旋转角度和速度等</p>\n<p>自动添加了rigidbody 2d，但是不取消也不会掉下来，为什么呢？</p>\n<p>猜测是joint关节会固定在背景里，超过一定的力才会 “脱臼”</p>\n<hr>\n<h3 id=\"三、弹跳平台\"><a href=\"#三、弹跳平台\" class=\"headerlink\" title=\"三、弹跳平台\"></a>三、弹跳平台</h3><p>1.找到pixel adventure 1 → assets → traps → fan ，设置大小，命名，添加碰撞器</p>\n<p>2.这里新建两个动画，一个是静止时的动画，一个是启动时的动画（弹跳）</p>\n<p>3.新建脚本，实现碰撞时平台切换到弹跳动画：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class FanRun : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Animator animator;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        animator = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void OnCollisionEnter2D(Collision2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.gameObject.CompareTag(&quot;Player&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            animator.Play(&quot;Fan_run&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当标签为Player的物体碰撞到此平台时就会切换到启动动画啦</p>\n<hr>\n<h3 id=\"四、摆动链锤\"><a href=\"#四、摆动链锤\" class=\"headerlink\" title=\"四、摆动链锤\"></a>四、摆动链锤</h3><p>1.新建空物体SpikeBall，分别添加两个子物体pixel adventure 1 → assets → traps → spiked ball → 轴心和大锤</p>\n<p>2.调整父子物体的相对位置</p>\n<p>3.给大锤添加组件Distance Joint 2D，给轴心添加rigid body 2d并拖拽到大锤的链接体</p>\n<p>4.给大锤添加碰撞体circle collider 2d</p>\n<hr>\n<h3 id=\"五、脚本实现平台上升\"><a href=\"#五、脚本实现平台上升\" class=\"headerlink\" title=\"五、脚本实现平台上升\"></a>五、脚本实现平台上升</h3><p>新建脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlatformUp : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector3 movement;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        movement.y = speed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MovePlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void MovePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        transform.position += movement * Time.deltaTime;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并挂载到所有的平台建筑下，这样就实现了平台的持续上升</p>\n<hr>\n<h3 id=\"六、设置平台天花板\"><a href=\"#六、设置平台天花板\" class=\"headerlink\" title=\"六、设置平台天花板\"></a>六、设置平台天花板</h3><p>平台总不能一直上升，要设置一个天花板，当平台到达天花板时就摧毁物体</p>\n<p>1.新建空物体TopLine移动到上方合适的位置，作为天花板</p>\n<p>2.在平台的上升代码中添加判断到达天花板的检测：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlatformUp : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector3 movement;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    GameObject topLine;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        movement.y = speed;</span><br><span class=\"line\">        topLine = GameObject.Find(&quot;TopLine&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MovePlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void MovePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        transform.position += movement * Time.deltaTime;</span><br><span class=\"line\">        if(transform.position.y &gt; topLine.transform.position.y)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完成！平台到位自动销毁</p>\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>平台的制作到这就结束了！用到了几个joint组件，十分有趣</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>上一次已经完成了场景搭建，那么这次的主要任务就是制作跳跃平台</p>","more":"<hr>\n<h3 id=\"一、普通平台\"><a href=\"#一、普通平台\" class=\"headerlink\" title=\"一、普通平台\"></a>一、普通平台</h3><p>1.选中pixel adventure 1 → assets → traps → falling platform 设置pixels per unit为16</p>\n<p>2.拖拽第一张图案到场景中，命名为BasePlatform</p>\n<p>3.新建BasePlatform的动画，将四个图案拖拽进动画中并调整采样率</p>\n<p>4.为BasePlatform添加碰撞器box collider 2d 并调整碰撞体积</p>\n<hr>\n<h3 id=\"二、旋转平台\"><a href=\"#二、旋转平台\" class=\"headerlink\" title=\"二、旋转平台\"></a>二、旋转平台</h3><p>1.前面的操作与上述普通平台相同，设置大小，命名，新建动画，添加碰撞器</p>\n<p>2.为了实现平台被碰撞时发生翻转，添加组件hinge joint 2d，可以设置旋转角度和速度等</p>\n<p>自动添加了rigidbody 2d，但是不取消也不会掉下来，为什么呢？</p>\n<p>猜测是joint关节会固定在背景里，超过一定的力才会 “脱臼”</p>\n<hr>\n<h3 id=\"三、弹跳平台\"><a href=\"#三、弹跳平台\" class=\"headerlink\" title=\"三、弹跳平台\"></a>三、弹跳平台</h3><p>1.找到pixel adventure 1 → assets → traps → fan ，设置大小，命名，添加碰撞器</p>\n<p>2.这里新建两个动画，一个是静止时的动画，一个是启动时的动画（弹跳）</p>\n<p>3.新建脚本，实现碰撞时平台切换到弹跳动画：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class FanRun : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Animator animator;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        animator = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void OnCollisionEnter2D(Collision2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.gameObject.CompareTag(&quot;Player&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            animator.Play(&quot;Fan_run&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当标签为Player的物体碰撞到此平台时就会切换到启动动画啦</p>\n<hr>\n<h3 id=\"四、摆动链锤\"><a href=\"#四、摆动链锤\" class=\"headerlink\" title=\"四、摆动链锤\"></a>四、摆动链锤</h3><p>1.新建空物体SpikeBall，分别添加两个子物体pixel adventure 1 → assets → traps → spiked ball → 轴心和大锤</p>\n<p>2.调整父子物体的相对位置</p>\n<p>3.给大锤添加组件Distance Joint 2D，给轴心添加rigid body 2d并拖拽到大锤的链接体</p>\n<p>4.给大锤添加碰撞体circle collider 2d</p>\n<hr>\n<h3 id=\"五、脚本实现平台上升\"><a href=\"#五、脚本实现平台上升\" class=\"headerlink\" title=\"五、脚本实现平台上升\"></a>五、脚本实现平台上升</h3><p>新建脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlatformUp : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector3 movement;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        movement.y = speed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MovePlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void MovePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        transform.position += movement * Time.deltaTime;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并挂载到所有的平台建筑下，这样就实现了平台的持续上升</p>\n<hr>\n<h3 id=\"六、设置平台天花板\"><a href=\"#六、设置平台天花板\" class=\"headerlink\" title=\"六、设置平台天花板\"></a>六、设置平台天花板</h3><p>平台总不能一直上升，要设置一个天花板，当平台到达天花板时就摧毁物体</p>\n<p>1.新建空物体TopLine移动到上方合适的位置，作为天花板</p>\n<p>2.在平台的上升代码中添加判断到达天花板的检测：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlatformUp : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector3 movement;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    GameObject topLine;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        movement.y = speed;</span><br><span class=\"line\">        topLine = GameObject.Find(&quot;TopLine&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MovePlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void MovePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        transform.position += movement * Time.deltaTime;</span><br><span class=\"line\">        if(transform.position.y &gt; topLine.transform.position.y)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完成！平台到位自动销毁</p>\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>平台的制作到这就结束了！用到了几个joint组件，十分有趣</p>"},{"title":"《Speed Down》Unity2d游戏开发（完）","date":"2021-07-16T10:02:46.000Z","_content":"\n\n\n### \t始、前言\n\n”《Speed Down》Unity2d游戏开发“系列已经完结，这篇文章主要是复盘这次学习中遇到的问题和一些名词的解释，以供未来的我快速回顾，最后还会附上所有的脚本\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、素材\n\n素材这块完全不用自己制作嘛，光是这个Assetstore就有挺多素材的，而且很多无限制商用的，有空要收集一些可以白嫖的网站\n\n\n\n---\n\n\n\n### 二、2D 复合碰撞体 (Composite Collider 2D)\n\n2D 复合碰撞体组件是用于 2D 物理的碰撞体。与大多数碰撞体不同，此碰撞体没有定义固有的形状。相反，此碰撞体将合并所设置的 2D 盒型碰撞体 (Box Collider 2D) 或 2D 多边形碰撞体 (Polygon Collider 2D) 的形状。2D 复合碰撞体使用所有此类碰撞体的顶点（几何体），并将这些顶点合并为由 2D 复合碰撞体本身控制的新几何体。\n\n2D 盒型碰撞体和 2D 多边形碰撞体组件具有 Used By Composite 复选框。勾选此复选框即可将这些碰撞体附加到 2D 复合碰撞体。这些碰撞体还与 2D 复合碰撞体附加到同一 2D 刚体。启用 Used by Composite 时，其他属性会从该组件中消失，因为这些属性现在由附加的 2D 复合碰撞体控制。\n\n\n\n---\n\n\n\n### 三、Pixels Per Unit（PPU）\n\n在Inspector面板的图像设置中有一个Pixels Per Unit参数。它代表Unity的一个单位长度包含本图片多少个像素\n 在Unity中创建的Cube等基本图形默认就是一个Unity单位长度，一个单位长度在unity世界坐标中代表1米\n 例如默认值为100，则代表一个Unity单位包含本图片中100个像素\n\n\n\n---\n\n\n\n### 四、关节（joint）\n\n关节组件可以添加至多个游戏对象中，而添加关节的游戏对象将通过关节连接在一起并且感觉连带的物理效果。需要注意的是：关节必须依赖于刚体组件。所有 2D 关节的名称都以“2D”结尾。名称不以“2D”结尾的关节是 3D 关节。2D 关节用于 2D 游戏对象，而 3D 关节用于 3D 游戏对象。\n\n\n\n**3D关节**：\n\n**链条关节（hinge joint）**：将两个物体以链条的形式绑在一起，当力量大于链条的固定力矩时，两个物体就会产生相互的拉力。\n\n**固定关节（fixed joint）**：将两个物体永远以相对的位置固定在一起，即使发生物理改变，它们之间的相对位置也将不变。\n\n**弹簧关节（spring joint）**：将两个物体以弹簧的形式绑定在一起，挤压它们会得到向外的力，拉伸它们将得到向里的力。\n\n**角色关节（character joint）**：可以模拟角色的骨骼关节。\n\n**可配置关节（configurable joint）**：可以模拟任意关节的效果。\n\n\n\n**2D关节**：\n\n**2D 距离关节 (Distance Joint 2D)** - 连接由刚体物理组件控制的两个游戏对象，使这两个对象保持一定距离。\n\n**2D 固定关节 (Fixed Joint 2D)** - 将两个对象保持在相对于彼此的位置，确保对象始终以给定位置和角度偏移。例如，对象好像是采用刚性连接方式相连一样：对象不能彼此远离，不能相互靠近，也不能相对于彼此旋转。还可以使用此关节来创建刚度稍低的柔性连接。\n\n**2D 摩擦关节 (Friction Joint 2D)** - 将刚体物理组件控制的两个游戏对象之间的线速度和角速度降低到零（即：此关节使对象减速并停止）。例如，一个平台在旋转但抵抗该运动。\n\n**2D 铰链关节 (Hinge Joint 2D)** - 允许由刚体物理组件控制的游戏对象连接到空间中的一个点，使游戏对象可围绕该点旋转。例如，一把剪刀上的轴心。\n\n**2D 相对关节 (Relative Joint 2D)** - 允许由刚体物理组件控制的两个游戏对象基于彼此的位置来保持相对位置。使用此关节可将两个对象保持相互偏移。例如，在空间射击游戏中，玩家身后有额外的排炮。\n\n**2D 滑动关节 (Slider Joint 2D)** - 允许由刚体物理组件控制的游戏对象沿着空间中的一条线滑动（例如滑门）。\n\n**2D 弹簧关节 (Spring Joint 2D)** - 允许由刚体物理组件控制的两个游戏对象就像通过弹簧连接在一起一样。\n\n**2D 目标关节 (Target Joint 2D)** - 连接到指定目标，而不是像其他关节那样连接到另一个刚体对象。这是一种弹簧式关节，例如可将其用于拾取和移动处于重力作用下的对象。\n\n**2D 车轮关节 (Wheel Joint 2D)** - 模拟车轮和悬架。\n\n\n\n在关节这方面2D的花样比3D多\n\n\n\n---\n\n\n\n### 五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）\n\n要产生碰撞必须为游戏对象添加刚体（Rigidbody）和碰撞器，刚体可以让物体在物理影响下运动。碰撞体是物理组件的一类，它要与刚体一起添加到游戏对象上才能触发碰撞。如果两个刚体相互撞在一起，除非两个对象有碰撞体时物理引擎才会计算碰撞，在物理模拟中，没有碰撞体的刚体会彼此相互穿过。\n\n**物体发生碰撞的必要条件**：\n\n两个物体都必须带有碰撞器(Collider)，其中一个物体还必须带有Rigidbody刚体。\n\n在unity3d中，能检测碰撞发生的方式有两种，一种是利用碰撞器，另一种则是利用触发器。\n\n碰撞器：一群组件，它包含了很多种类，比如：Box Collider（盒碰撞体），Mesh Collider（网格碰撞体）等，这些碰撞器应用的场合不同，但都必须加到GameObjecet身上。\n\n触发器：只需要在检视面板中的碰撞器组件中勾选IsTrigger属性选择框。\n\n**触发信息检测**：\n\n1.MonoBehaviour.OnTriggerEnter(Collider collider)当进入触发器\n\n2.MonoBehaviour.OnTriggerExit(Collider collider)当退出触发器\n\n3.MonoBehaviour.OnTriggerStay(Collider collider)当逗留触发器\n\n**碰撞信息检测**：\n\n1.MonoBehaviour.OnCollisionEnter(Collision collision) 当进入碰撞器\n\n2.MonoBehaviour.OnCollisionExit(Collision collision) 当退出碰撞器\n\n3.MonoBehaviour.OnCollisionStay(Collision collision) 当逗留碰撞器\n\n**碰撞器和触发器的区别？**\n\n碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性\n\n当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；\n\n当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。\n\n也就是说在一次碰撞中，碰撞函数和触发函数只能二选一\n\n\n\n---\n\n\n\n### 六、预制体（Prefab）\n\n什么是预制体：\n\n在进行一些功能开发的时候, 我们常常将一些能够复用的对象制作成.prefab的预制体，然后将预制体存放到 Resources 目录之下, 使用时再动态加载到场景中并进行实例化. 例如 : 子弹、特效甚至音频等, 都能制作成预制体.\n\n预制体英文名称即 Prefab 是一种资源类型 —— 存储在项目视图中的一种可重复使用的游戏对象.\n\n预制体的优点：\n预制体可以多次放入到多个场景中;\n当你添加一个预制体到场景中, 就创建了它的一个实例;\n所有的预制体实例链接到原始预制, 基本上等于就是它的克隆;\n不管你的项目存在多少实例, 当你对预制体进行任何更改, 你将看到这些更改将应用于所有的实例上;\n\n\n\n---\n\n\n\n### 七、画布（Canvas）\n\nCanvas (画布) 是所有 UI 组件的父物体 , 也就是说每一个 UI 组件都必须在 Canvas 下 , 作为 Canvas 的子物体 , 当你创建一个 UI 控件时 , 如果在 Hierarchy 视图没有 Canvas 组件的话 , unity会自动帮你创建一个 Canvas , 并将你想创建的 UI 控件置于 Canvas 下.\n\nCanvas 的 Render Mode (渲染模式) 有三种 ：\n\n1.**Screen Space - Overlay**\n\n这种渲染模式表示 Canvas 下的所有的 UI 控件永远位于屏幕的前面 , 不管有没有相机 , UI元素永远在屏幕最前面\n\n2.**Screen Space - Camera**\n\n这种渲染模式 Canvas 和 摄像机之间有一定的距离 , 可以在摄像机和 Canvas 之间播放一些粒子特效\n\n3.**World Space**\n\n这种模式下 Canvas 就和普通的 3D 物体一样了 , 可以控制它的大小,旋转,缩放等 , 一般用来做血条\n\n\n\n---\n\n\n\n### 终、总结\n\n作为unity回坑第一课收获还是蛮丰富的，以前一直没有做笔记的习惯，东西学了又忘，忘了还没地方复习，以后要养成写学习日记的习惯。\n\n这次写的脚本都没有写注释，希望未来的我回来看的时候不会头大吧哈哈哈（这么简单的代码应该不至于吧吧吧吧🐷）\n\n\n\n---\n\n\n\n### \t附录、脚本\n\n1.角色控制脚本，控制角色移动和检测角色状态：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerController : MonoBehaviour\n{\n    Rigidbody2D rb;\n    Animator anim;\n    public float speed;\n    float xVelocity;\n\n    public bool isOnGround;\n    public float checkRadius;\n    public LayerMask layer;\n    public GameObject groundCheck;\n\n    public bool playerDead;\n\n    public float bounceH;\n    \n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        anim = GetComponent<Animator>();\n    }\n\n    void Update()\n    {\n        Movement();\n        isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);\n        anim.SetBool(\"isOnGround\", isOnGround);\n    }\n\n    void Movement()\n    {\n        xVelocity = Input.GetAxisRaw(\"Horizontal\");\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n        anim.SetFloat(\"speed\", Mathf.Abs(rb.velocity.x));\n\n        if(xVelocity != 0)\n        {\n            transform.localScale = new Vector3(xVelocity, 1, 1);\n        }\n    }\n\n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Fan\"))\n        {\n            rb.velocity = new Vector2(rb.velocity.x, bounceH);\n        }\n        if (collision.gameObject.CompareTag(\"Spike\"))\n        {\n            anim.SetTrigger(\"isDead\");\n        }\n    }\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if (collision.CompareTag(\"Spike\"))\n        {\n            anim.SetTrigger(\"isDead\");\n        }\n    }\n\n    public void PlayerDead()\n    {\n        playerDead = true;\n        GameManage.GameOver(playerDead);\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);\n    }\n}\n```\n\n\n\n2.游戏管理脚本，涉及游戏重开和退出，以及控制界面：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\n\npublic class GameManage : MonoBehaviour\n{\n    static GameManage instance;\n    public Text score;\n\n    public GameObject gameOverUI;\n\n    private void Awake()\n    {\n        if(instance != null)\n        {\n            Destroy(gameObject);\n        }\n        instance = this;\n    }\n\n    void Update()\n    {\n        score.text = Time.timeSinceLevelLoad.ToString(\"000\");\n    }\n\n    public void RestartGame()\n    {\n        SceneManager.LoadScene(SceneManager.GetActiveScene().name);\n        Time.timeScale = 1;\n    }\n\n    public void Exit()\n    {\n        Application.Quit();\n    }\n\n    public static void GameOver(bool dead)\n    {\n        if (dead)\n        {\n            Time.timeScale = 0f;\n            instance.gameOverUI.SetActive(true);\n        }\n    }\n}\n```\n\n\n\n3.平台生成脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Spawner : MonoBehaviour\n{\n    public List<GameObject> platform = new List<GameObject>();\n\n    public float spawnTime;\n    float countTime;\n    Vector3 spawnPosition;\n\n    int spikeBallNum = 0;\n\n    void Update()\n    {\n        SpawnPlatform();\n    }\n\n    public void SpawnPlatform()\n    {\n        countTime += Time.deltaTime;\n        spawnPosition = transform.position;\n        spawnPosition.x = Random.Range(-3f, 3f);\n\n        if(countTime > spawnTime)\n        {\n            CreatePlatform();\n            countTime = 0;\n        }\n\n    }\n\n    public void CreatePlatform()\n    {\n        int index = Random.Range(0, platform.Count);\n\n        if (index == 3)\n        {\n            spikeBallNum++;\n            if(spikeBallNum > 2)\n            {\n                index = 0;\n                spikeBallNum = 0;\n            }\n        }\n\n        GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );\n        newPlatform.transform.SetParent(transform);\n    }\n}\n```\n\n\n\n4.平台上升脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlatformUp : MonoBehaviour\n{\n    Vector3 movement;\n    public float speed;\n    GameObject topLine;\n\n    void Start()\n    {\n        movement.y = speed;\n        topLine = GameObject.Find(\"TopLine\");\n    }\n\n\n    void Update()\n    {\n        MovePlatform();\n    }\n\n    void MovePlatform()\n    {\n        transform.position += movement * Time.deltaTime;\n        if(transform.position.y > topLine.transform.position.y)\n        {\n            Destroy(gameObject);\n        }\n    }\n}\n\n```\n\n\n\n5.链锤画线脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class SpikeBallLine : MonoBehaviour\n{\n\n    LineRenderer line;\n    public Transform begin;\n    public Transform end;\n\n    void Start()\n    {\n        line = GetComponent<LineRenderer>();\n\n    }\n\n    void Update()\n    {\n        line.SetPosition(0, begin.position);\n        line.SetPosition(1, end.position);\n    }\n}\n```\n\n\n\n6.跳跃平台旋转动画脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class FanRun : MonoBehaviour\n{\n    Animator animator;\n    void Start()\n    {\n        animator = GetComponent<Animator>();\n    }\n\n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            animator.Play(\"Fan_run\");\n        }\n    }\n\n}\n```\n\n","source":"_posts/2021-07-16-《Speed Down》Unity2d游戏开发（完）.md","raw":"---\ntitle: 《Speed Down》Unity2d游戏开发（完）\ndate: 2021-07-16 18:02:46\ncategories: unity\ntags:\n  - unity\n  - c#\n  - collider\n  - joint\n  - trigger\n  - prefab\n  - canvas\n---\n\n\n\n### \t始、前言\n\n”《Speed Down》Unity2d游戏开发“系列已经完结，这篇文章主要是复盘这次学习中遇到的问题和一些名词的解释，以供未来的我快速回顾，最后还会附上所有的脚本\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、素材\n\n素材这块完全不用自己制作嘛，光是这个Assetstore就有挺多素材的，而且很多无限制商用的，有空要收集一些可以白嫖的网站\n\n\n\n---\n\n\n\n### 二、2D 复合碰撞体 (Composite Collider 2D)\n\n2D 复合碰撞体组件是用于 2D 物理的碰撞体。与大多数碰撞体不同，此碰撞体没有定义固有的形状。相反，此碰撞体将合并所设置的 2D 盒型碰撞体 (Box Collider 2D) 或 2D 多边形碰撞体 (Polygon Collider 2D) 的形状。2D 复合碰撞体使用所有此类碰撞体的顶点（几何体），并将这些顶点合并为由 2D 复合碰撞体本身控制的新几何体。\n\n2D 盒型碰撞体和 2D 多边形碰撞体组件具有 Used By Composite 复选框。勾选此复选框即可将这些碰撞体附加到 2D 复合碰撞体。这些碰撞体还与 2D 复合碰撞体附加到同一 2D 刚体。启用 Used by Composite 时，其他属性会从该组件中消失，因为这些属性现在由附加的 2D 复合碰撞体控制。\n\n\n\n---\n\n\n\n### 三、Pixels Per Unit（PPU）\n\n在Inspector面板的图像设置中有一个Pixels Per Unit参数。它代表Unity的一个单位长度包含本图片多少个像素\n 在Unity中创建的Cube等基本图形默认就是一个Unity单位长度，一个单位长度在unity世界坐标中代表1米\n 例如默认值为100，则代表一个Unity单位包含本图片中100个像素\n\n\n\n---\n\n\n\n### 四、关节（joint）\n\n关节组件可以添加至多个游戏对象中，而添加关节的游戏对象将通过关节连接在一起并且感觉连带的物理效果。需要注意的是：关节必须依赖于刚体组件。所有 2D 关节的名称都以“2D”结尾。名称不以“2D”结尾的关节是 3D 关节。2D 关节用于 2D 游戏对象，而 3D 关节用于 3D 游戏对象。\n\n\n\n**3D关节**：\n\n**链条关节（hinge joint）**：将两个物体以链条的形式绑在一起，当力量大于链条的固定力矩时，两个物体就会产生相互的拉力。\n\n**固定关节（fixed joint）**：将两个物体永远以相对的位置固定在一起，即使发生物理改变，它们之间的相对位置也将不变。\n\n**弹簧关节（spring joint）**：将两个物体以弹簧的形式绑定在一起，挤压它们会得到向外的力，拉伸它们将得到向里的力。\n\n**角色关节（character joint）**：可以模拟角色的骨骼关节。\n\n**可配置关节（configurable joint）**：可以模拟任意关节的效果。\n\n\n\n**2D关节**：\n\n**2D 距离关节 (Distance Joint 2D)** - 连接由刚体物理组件控制的两个游戏对象，使这两个对象保持一定距离。\n\n**2D 固定关节 (Fixed Joint 2D)** - 将两个对象保持在相对于彼此的位置，确保对象始终以给定位置和角度偏移。例如，对象好像是采用刚性连接方式相连一样：对象不能彼此远离，不能相互靠近，也不能相对于彼此旋转。还可以使用此关节来创建刚度稍低的柔性连接。\n\n**2D 摩擦关节 (Friction Joint 2D)** - 将刚体物理组件控制的两个游戏对象之间的线速度和角速度降低到零（即：此关节使对象减速并停止）。例如，一个平台在旋转但抵抗该运动。\n\n**2D 铰链关节 (Hinge Joint 2D)** - 允许由刚体物理组件控制的游戏对象连接到空间中的一个点，使游戏对象可围绕该点旋转。例如，一把剪刀上的轴心。\n\n**2D 相对关节 (Relative Joint 2D)** - 允许由刚体物理组件控制的两个游戏对象基于彼此的位置来保持相对位置。使用此关节可将两个对象保持相互偏移。例如，在空间射击游戏中，玩家身后有额外的排炮。\n\n**2D 滑动关节 (Slider Joint 2D)** - 允许由刚体物理组件控制的游戏对象沿着空间中的一条线滑动（例如滑门）。\n\n**2D 弹簧关节 (Spring Joint 2D)** - 允许由刚体物理组件控制的两个游戏对象就像通过弹簧连接在一起一样。\n\n**2D 目标关节 (Target Joint 2D)** - 连接到指定目标，而不是像其他关节那样连接到另一个刚体对象。这是一种弹簧式关节，例如可将其用于拾取和移动处于重力作用下的对象。\n\n**2D 车轮关节 (Wheel Joint 2D)** - 模拟车轮和悬架。\n\n\n\n在关节这方面2D的花样比3D多\n\n\n\n---\n\n\n\n### 五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）\n\n要产生碰撞必须为游戏对象添加刚体（Rigidbody）和碰撞器，刚体可以让物体在物理影响下运动。碰撞体是物理组件的一类，它要与刚体一起添加到游戏对象上才能触发碰撞。如果两个刚体相互撞在一起，除非两个对象有碰撞体时物理引擎才会计算碰撞，在物理模拟中，没有碰撞体的刚体会彼此相互穿过。\n\n**物体发生碰撞的必要条件**：\n\n两个物体都必须带有碰撞器(Collider)，其中一个物体还必须带有Rigidbody刚体。\n\n在unity3d中，能检测碰撞发生的方式有两种，一种是利用碰撞器，另一种则是利用触发器。\n\n碰撞器：一群组件，它包含了很多种类，比如：Box Collider（盒碰撞体），Mesh Collider（网格碰撞体）等，这些碰撞器应用的场合不同，但都必须加到GameObjecet身上。\n\n触发器：只需要在检视面板中的碰撞器组件中勾选IsTrigger属性选择框。\n\n**触发信息检测**：\n\n1.MonoBehaviour.OnTriggerEnter(Collider collider)当进入触发器\n\n2.MonoBehaviour.OnTriggerExit(Collider collider)当退出触发器\n\n3.MonoBehaviour.OnTriggerStay(Collider collider)当逗留触发器\n\n**碰撞信息检测**：\n\n1.MonoBehaviour.OnCollisionEnter(Collision collision) 当进入碰撞器\n\n2.MonoBehaviour.OnCollisionExit(Collision collision) 当退出碰撞器\n\n3.MonoBehaviour.OnCollisionStay(Collision collision) 当逗留碰撞器\n\n**碰撞器和触发器的区别？**\n\n碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性\n\n当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；\n\n当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。\n\n也就是说在一次碰撞中，碰撞函数和触发函数只能二选一\n\n\n\n---\n\n\n\n### 六、预制体（Prefab）\n\n什么是预制体：\n\n在进行一些功能开发的时候, 我们常常将一些能够复用的对象制作成.prefab的预制体，然后将预制体存放到 Resources 目录之下, 使用时再动态加载到场景中并进行实例化. 例如 : 子弹、特效甚至音频等, 都能制作成预制体.\n\n预制体英文名称即 Prefab 是一种资源类型 —— 存储在项目视图中的一种可重复使用的游戏对象.\n\n预制体的优点：\n预制体可以多次放入到多个场景中;\n当你添加一个预制体到场景中, 就创建了它的一个实例;\n所有的预制体实例链接到原始预制, 基本上等于就是它的克隆;\n不管你的项目存在多少实例, 当你对预制体进行任何更改, 你将看到这些更改将应用于所有的实例上;\n\n\n\n---\n\n\n\n### 七、画布（Canvas）\n\nCanvas (画布) 是所有 UI 组件的父物体 , 也就是说每一个 UI 组件都必须在 Canvas 下 , 作为 Canvas 的子物体 , 当你创建一个 UI 控件时 , 如果在 Hierarchy 视图没有 Canvas 组件的话 , unity会自动帮你创建一个 Canvas , 并将你想创建的 UI 控件置于 Canvas 下.\n\nCanvas 的 Render Mode (渲染模式) 有三种 ：\n\n1.**Screen Space - Overlay**\n\n这种渲染模式表示 Canvas 下的所有的 UI 控件永远位于屏幕的前面 , 不管有没有相机 , UI元素永远在屏幕最前面\n\n2.**Screen Space - Camera**\n\n这种渲染模式 Canvas 和 摄像机之间有一定的距离 , 可以在摄像机和 Canvas 之间播放一些粒子特效\n\n3.**World Space**\n\n这种模式下 Canvas 就和普通的 3D 物体一样了 , 可以控制它的大小,旋转,缩放等 , 一般用来做血条\n\n\n\n---\n\n\n\n### 终、总结\n\n作为unity回坑第一课收获还是蛮丰富的，以前一直没有做笔记的习惯，东西学了又忘，忘了还没地方复习，以后要养成写学习日记的习惯。\n\n这次写的脚本都没有写注释，希望未来的我回来看的时候不会头大吧哈哈哈（这么简单的代码应该不至于吧吧吧吧🐷）\n\n\n\n---\n\n\n\n### \t附录、脚本\n\n1.角色控制脚本，控制角色移动和检测角色状态：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerController : MonoBehaviour\n{\n    Rigidbody2D rb;\n    Animator anim;\n    public float speed;\n    float xVelocity;\n\n    public bool isOnGround;\n    public float checkRadius;\n    public LayerMask layer;\n    public GameObject groundCheck;\n\n    public bool playerDead;\n\n    public float bounceH;\n    \n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        anim = GetComponent<Animator>();\n    }\n\n    void Update()\n    {\n        Movement();\n        isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);\n        anim.SetBool(\"isOnGround\", isOnGround);\n    }\n\n    void Movement()\n    {\n        xVelocity = Input.GetAxisRaw(\"Horizontal\");\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n        anim.SetFloat(\"speed\", Mathf.Abs(rb.velocity.x));\n\n        if(xVelocity != 0)\n        {\n            transform.localScale = new Vector3(xVelocity, 1, 1);\n        }\n    }\n\n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Fan\"))\n        {\n            rb.velocity = new Vector2(rb.velocity.x, bounceH);\n        }\n        if (collision.gameObject.CompareTag(\"Spike\"))\n        {\n            anim.SetTrigger(\"isDead\");\n        }\n    }\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if (collision.CompareTag(\"Spike\"))\n        {\n            anim.SetTrigger(\"isDead\");\n        }\n    }\n\n    public void PlayerDead()\n    {\n        playerDead = true;\n        GameManage.GameOver(playerDead);\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);\n    }\n}\n```\n\n\n\n2.游戏管理脚本，涉及游戏重开和退出，以及控制界面：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\n\npublic class GameManage : MonoBehaviour\n{\n    static GameManage instance;\n    public Text score;\n\n    public GameObject gameOverUI;\n\n    private void Awake()\n    {\n        if(instance != null)\n        {\n            Destroy(gameObject);\n        }\n        instance = this;\n    }\n\n    void Update()\n    {\n        score.text = Time.timeSinceLevelLoad.ToString(\"000\");\n    }\n\n    public void RestartGame()\n    {\n        SceneManager.LoadScene(SceneManager.GetActiveScene().name);\n        Time.timeScale = 1;\n    }\n\n    public void Exit()\n    {\n        Application.Quit();\n    }\n\n    public static void GameOver(bool dead)\n    {\n        if (dead)\n        {\n            Time.timeScale = 0f;\n            instance.gameOverUI.SetActive(true);\n        }\n    }\n}\n```\n\n\n\n3.平台生成脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Spawner : MonoBehaviour\n{\n    public List<GameObject> platform = new List<GameObject>();\n\n    public float spawnTime;\n    float countTime;\n    Vector3 spawnPosition;\n\n    int spikeBallNum = 0;\n\n    void Update()\n    {\n        SpawnPlatform();\n    }\n\n    public void SpawnPlatform()\n    {\n        countTime += Time.deltaTime;\n        spawnPosition = transform.position;\n        spawnPosition.x = Random.Range(-3f, 3f);\n\n        if(countTime > spawnTime)\n        {\n            CreatePlatform();\n            countTime = 0;\n        }\n\n    }\n\n    public void CreatePlatform()\n    {\n        int index = Random.Range(0, platform.Count);\n\n        if (index == 3)\n        {\n            spikeBallNum++;\n            if(spikeBallNum > 2)\n            {\n                index = 0;\n                spikeBallNum = 0;\n            }\n        }\n\n        GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );\n        newPlatform.transform.SetParent(transform);\n    }\n}\n```\n\n\n\n4.平台上升脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlatformUp : MonoBehaviour\n{\n    Vector3 movement;\n    public float speed;\n    GameObject topLine;\n\n    void Start()\n    {\n        movement.y = speed;\n        topLine = GameObject.Find(\"TopLine\");\n    }\n\n\n    void Update()\n    {\n        MovePlatform();\n    }\n\n    void MovePlatform()\n    {\n        transform.position += movement * Time.deltaTime;\n        if(transform.position.y > topLine.transform.position.y)\n        {\n            Destroy(gameObject);\n        }\n    }\n}\n\n```\n\n\n\n5.链锤画线脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class SpikeBallLine : MonoBehaviour\n{\n\n    LineRenderer line;\n    public Transform begin;\n    public Transform end;\n\n    void Start()\n    {\n        line = GetComponent<LineRenderer>();\n\n    }\n\n    void Update()\n    {\n        line.SetPosition(0, begin.position);\n        line.SetPosition(1, end.position);\n    }\n}\n```\n\n\n\n6.跳跃平台旋转动画脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class FanRun : MonoBehaviour\n{\n    Animator animator;\n    void Start()\n    {\n        animator = GetComponent<Animator>();\n    }\n\n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            animator.Play(\"Fan_run\");\n        }\n    }\n\n}\n```\n\n","slug":"2021-07-16-《Speed Down》Unity2d游戏开发（完）","published":1,"updated":"2021-09-19T06:17:04.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hd000o1ou0crtb6dbh","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>”《Speed Down》Unity2d游戏开发“系列已经完结，这篇文章主要是复盘这次学习中遇到的问题和一些名词的解释，以供未来的我快速回顾，最后还会附上所有的脚本</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、素材\"><a href=\"#一、素材\" class=\"headerlink\" title=\"一、素材\"></a>一、素材</h3><p>素材这块完全不用自己制作嘛，光是这个Assetstore就有挺多素材的，而且很多无限制商用的，有空要收集一些可以白嫖的网站</p>\n<hr>\n<h3 id=\"二、2D-复合碰撞体-Composite-Collider-2D\"><a href=\"#二、2D-复合碰撞体-Composite-Collider-2D\" class=\"headerlink\" title=\"二、2D 复合碰撞体 (Composite Collider 2D)\"></a>二、2D 复合碰撞体 (Composite Collider 2D)</h3><p>2D 复合碰撞体组件是用于 2D 物理的碰撞体。与大多数碰撞体不同，此碰撞体没有定义固有的形状。相反，此碰撞体将合并所设置的 2D 盒型碰撞体 (Box Collider 2D) 或 2D 多边形碰撞体 (Polygon Collider 2D) 的形状。2D 复合碰撞体使用所有此类碰撞体的顶点（几何体），并将这些顶点合并为由 2D 复合碰撞体本身控制的新几何体。</p>\n<p>2D 盒型碰撞体和 2D 多边形碰撞体组件具有 Used By Composite 复选框。勾选此复选框即可将这些碰撞体附加到 2D 复合碰撞体。这些碰撞体还与 2D 复合碰撞体附加到同一 2D 刚体。启用 Used by Composite 时，其他属性会从该组件中消失，因为这些属性现在由附加的 2D 复合碰撞体控制。</p>\n<hr>\n<h3 id=\"三、Pixels-Per-Unit（PPU）\"><a href=\"#三、Pixels-Per-Unit（PPU）\" class=\"headerlink\" title=\"三、Pixels Per Unit（PPU）\"></a>三、Pixels Per Unit（PPU）</h3><p>在Inspector面板的图像设置中有一个Pixels Per Unit参数。它代表Unity的一个单位长度包含本图片多少个像素<br> 在Unity中创建的Cube等基本图形默认就是一个Unity单位长度，一个单位长度在unity世界坐标中代表1米<br> 例如默认值为100，则代表一个Unity单位包含本图片中100个像素</p>\n<hr>\n<h3 id=\"四、关节（joint）\"><a href=\"#四、关节（joint）\" class=\"headerlink\" title=\"四、关节（joint）\"></a>四、关节（joint）</h3><p>关节组件可以添加至多个游戏对象中，而添加关节的游戏对象将通过关节连接在一起并且感觉连带的物理效果。需要注意的是：关节必须依赖于刚体组件。所有 2D 关节的名称都以“2D”结尾。名称不以“2D”结尾的关节是 3D 关节。2D 关节用于 2D 游戏对象，而 3D 关节用于 3D 游戏对象。</p>\n<p><strong>3D关节</strong>：</p>\n<p><strong>链条关节（hinge joint）</strong>：将两个物体以链条的形式绑在一起，当力量大于链条的固定力矩时，两个物体就会产生相互的拉力。</p>\n<p><strong>固定关节（fixed joint）</strong>：将两个物体永远以相对的位置固定在一起，即使发生物理改变，它们之间的相对位置也将不变。</p>\n<p><strong>弹簧关节（spring joint）</strong>：将两个物体以弹簧的形式绑定在一起，挤压它们会得到向外的力，拉伸它们将得到向里的力。</p>\n<p><strong>角色关节（character joint）</strong>：可以模拟角色的骨骼关节。</p>\n<p><strong>可配置关节（configurable joint）</strong>：可以模拟任意关节的效果。</p>\n<p><strong>2D关节</strong>：</p>\n<p><strong>2D 距离关节 (Distance Joint 2D)</strong> - 连接由刚体物理组件控制的两个游戏对象，使这两个对象保持一定距离。</p>\n<p><strong>2D 固定关节 (Fixed Joint 2D)</strong> - 将两个对象保持在相对于彼此的位置，确保对象始终以给定位置和角度偏移。例如，对象好像是采用刚性连接方式相连一样：对象不能彼此远离，不能相互靠近，也不能相对于彼此旋转。还可以使用此关节来创建刚度稍低的柔性连接。</p>\n<p><strong>2D 摩擦关节 (Friction Joint 2D)</strong> - 将刚体物理组件控制的两个游戏对象之间的线速度和角速度降低到零（即：此关节使对象减速并停止）。例如，一个平台在旋转但抵抗该运动。</p>\n<p><strong>2D 铰链关节 (Hinge Joint 2D)</strong> - 允许由刚体物理组件控制的游戏对象连接到空间中的一个点，使游戏对象可围绕该点旋转。例如，一把剪刀上的轴心。</p>\n<p><strong>2D 相对关节 (Relative Joint 2D)</strong> - 允许由刚体物理组件控制的两个游戏对象基于彼此的位置来保持相对位置。使用此关节可将两个对象保持相互偏移。例如，在空间射击游戏中，玩家身后有额外的排炮。</p>\n<p><strong>2D 滑动关节 (Slider Joint 2D)</strong> - 允许由刚体物理组件控制的游戏对象沿着空间中的一条线滑动（例如滑门）。</p>\n<p><strong>2D 弹簧关节 (Spring Joint 2D)</strong> - 允许由刚体物理组件控制的两个游戏对象就像通过弹簧连接在一起一样。</p>\n<p><strong>2D 目标关节 (Target Joint 2D)</strong> - 连接到指定目标，而不是像其他关节那样连接到另一个刚体对象。这是一种弹簧式关节，例如可将其用于拾取和移动处于重力作用下的对象。</p>\n<p><strong>2D 车轮关节 (Wheel Joint 2D)</strong> - 模拟车轮和悬架。</p>\n<p>在关节这方面2D的花样比3D多</p>\n<hr>\n<h3 id=\"五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）\"><a href=\"#五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）\" class=\"headerlink\" title=\"五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）\"></a>五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）</h3><p>要产生碰撞必须为游戏对象添加刚体（Rigidbody）和碰撞器，刚体可以让物体在物理影响下运动。碰撞体是物理组件的一类，它要与刚体一起添加到游戏对象上才能触发碰撞。如果两个刚体相互撞在一起，除非两个对象有碰撞体时物理引擎才会计算碰撞，在物理模拟中，没有碰撞体的刚体会彼此相互穿过。</p>\n<p><strong>物体发生碰撞的必要条件</strong>：</p>\n<p>两个物体都必须带有碰撞器(Collider)，其中一个物体还必须带有Rigidbody刚体。</p>\n<p>在unity3d中，能检测碰撞发生的方式有两种，一种是利用碰撞器，另一种则是利用触发器。</p>\n<p>碰撞器：一群组件，它包含了很多种类，比如：Box Collider（盒碰撞体），Mesh Collider（网格碰撞体）等，这些碰撞器应用的场合不同，但都必须加到GameObjecet身上。</p>\n<p>触发器：只需要在检视面板中的碰撞器组件中勾选IsTrigger属性选择框。</p>\n<p><strong>触发信息检测</strong>：</p>\n<p>1.MonoBehaviour.OnTriggerEnter(Collider collider)当进入触发器</p>\n<p>2.MonoBehaviour.OnTriggerExit(Collider collider)当退出触发器</p>\n<p>3.MonoBehaviour.OnTriggerStay(Collider collider)当逗留触发器</p>\n<p><strong>碰撞信息检测</strong>：</p>\n<p>1.MonoBehaviour.OnCollisionEnter(Collision collision) 当进入碰撞器</p>\n<p>2.MonoBehaviour.OnCollisionExit(Collision collision) 当退出碰撞器</p>\n<p>3.MonoBehaviour.OnCollisionStay(Collision collision) 当逗留碰撞器</p>\n<p><strong>碰撞器和触发器的区别？</strong></p>\n<p>碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性</p>\n<p>当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；</p>\n<p>当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。</p>\n<p>也就是说在一次碰撞中，碰撞函数和触发函数只能二选一</p>\n<hr>\n<h3 id=\"六、预制体（Prefab）\"><a href=\"#六、预制体（Prefab）\" class=\"headerlink\" title=\"六、预制体（Prefab）\"></a>六、预制体（Prefab）</h3><p>什么是预制体：</p>\n<p>在进行一些功能开发的时候, 我们常常将一些能够复用的对象制作成.prefab的预制体，然后将预制体存放到 Resources 目录之下, 使用时再动态加载到场景中并进行实例化. 例如 : 子弹、特效甚至音频等, 都能制作成预制体.</p>\n<p>预制体英文名称即 Prefab 是一种资源类型 —— 存储在项目视图中的一种可重复使用的游戏对象.</p>\n<p>预制体的优点：<br>预制体可以多次放入到多个场景中;<br>当你添加一个预制体到场景中, 就创建了它的一个实例;<br>所有的预制体实例链接到原始预制, 基本上等于就是它的克隆;<br>不管你的项目存在多少实例, 当你对预制体进行任何更改, 你将看到这些更改将应用于所有的实例上;</p>\n<hr>\n<h3 id=\"七、画布（Canvas）\"><a href=\"#七、画布（Canvas）\" class=\"headerlink\" title=\"七、画布（Canvas）\"></a>七、画布（Canvas）</h3><p>Canvas (画布) 是所有 UI 组件的父物体 , 也就是说每一个 UI 组件都必须在 Canvas 下 , 作为 Canvas 的子物体 , 当你创建一个 UI 控件时 , 如果在 Hierarchy 视图没有 Canvas 组件的话 , unity会自动帮你创建一个 Canvas , 并将你想创建的 UI 控件置于 Canvas 下.</p>\n<p>Canvas 的 Render Mode (渲染模式) 有三种 ：</p>\n<p>1.<strong>Screen Space - Overlay</strong></p>\n<p>这种渲染模式表示 Canvas 下的所有的 UI 控件永远位于屏幕的前面 , 不管有没有相机 , UI元素永远在屏幕最前面</p>\n<p>2.<strong>Screen Space - Camera</strong></p>\n<p>这种渲染模式 Canvas 和 摄像机之间有一定的距离 , 可以在摄像机和 Canvas 之间播放一些粒子特效</p>\n<p>3.<strong>World Space</strong></p>\n<p>这种模式下 Canvas 就和普通的 3D 物体一样了 , 可以控制它的大小,旋转,缩放等 , 一般用来做血条</p>\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>作为unity回坑第一课收获还是蛮丰富的，以前一直没有做笔记的习惯，东西学了又忘，忘了还没地方复习，以后要养成写学习日记的习惯。</p>\n<p>这次写的脚本都没有写注释，希望未来的我回来看的时候不会头大吧哈哈哈（这么简单的代码应该不至于吧吧吧吧🐷）</p>\n<hr>\n<h3 id=\"附录、脚本\"><a href=\"#附录、脚本\" class=\"headerlink\" title=\"附录、脚本\"></a>附录、脚本</h3><p>1.角色控制脚本，控制角色移动和检测角色状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerController : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Rigidbody2D rb;</span><br><span class=\"line\">    Animator anim;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    public bool isOnGround;</span><br><span class=\"line\">    public float checkRadius;</span><br><span class=\"line\">    public LayerMask layer;</span><br><span class=\"line\">    public GameObject groundCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">    public bool playerDead;</span><br><span class=\"line\"></span><br><span class=\"line\">    public float bounceH;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">        anim = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Movement();</span><br><span class=\"line\">        isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);</span><br><span class=\"line\">        anim.SetBool(&quot;isOnGround&quot;, isOnGround);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Movement()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\">        anim.SetFloat(&quot;speed&quot;, Mathf.Abs(rb.velocity.x));</span><br><span class=\"line\"></span><br><span class=\"line\">        if(xVelocity != 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            transform.localScale = new Vector3(xVelocity, 1, 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnCollisionEnter2D(Collision2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.gameObject.CompareTag(&quot;Fan&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rb.velocity = new Vector2(rb.velocity.x, bounceH);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (collision.gameObject.CompareTag(&quot;Spike&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            anim.SetTrigger(&quot;isDead&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.CompareTag(&quot;Spike&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            anim.SetTrigger(&quot;isDead&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void PlayerDead()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        playerDead = true;</span><br><span class=\"line\">        GameManage.GameOver(playerDead);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnDrawGizmosSelected()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Gizmos.color = Color.green;</span><br><span class=\"line\">        Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.游戏管理脚本，涉及游戏重开和退出，以及控制界面：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">using UnityEngine.UI;</span><br><span class=\"line\">using UnityEngine.SceneManagement;</span><br><span class=\"line\"></span><br><span class=\"line\">public class GameManage : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static GameManage instance;</span><br><span class=\"line\">    public Text score;</span><br><span class=\"line\"></span><br><span class=\"line\">    public GameObject gameOverUI;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void Awake()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(instance != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        instance = this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        score.text = Time.timeSinceLevelLoad.ToString(&quot;000&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void RestartGame()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SceneManager.LoadScene(SceneManager.GetActiveScene().name);</span><br><span class=\"line\">        Time.timeScale = 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void Exit()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Application.Quit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void GameOver(bool dead)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (dead)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Time.timeScale = 0f;</span><br><span class=\"line\">            instance.gameOverUI.SetActive(true);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>3.平台生成脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Spawner : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public List&lt;GameObject&gt; platform = new List&lt;GameObject&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public float spawnTime;</span><br><span class=\"line\">    float countTime;</span><br><span class=\"line\">    Vector3 spawnPosition;</span><br><span class=\"line\"></span><br><span class=\"line\">    int spikeBallNum = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SpawnPlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void SpawnPlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        countTime += Time.deltaTime;</span><br><span class=\"line\">        spawnPosition = transform.position;</span><br><span class=\"line\">        spawnPosition.x = Random.Range(-3f, 3f);</span><br><span class=\"line\"></span><br><span class=\"line\">        if(countTime &gt; spawnTime)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            CreatePlatform();</span><br><span class=\"line\">            countTime = 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void CreatePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int index = Random.Range(0, platform.Count);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (index == 3)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            spikeBallNum++;</span><br><span class=\"line\">            if(spikeBallNum &gt; 2)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                index = 0;</span><br><span class=\"line\">                spikeBallNum = 0;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class=\"line\">        newPlatform.transform.SetParent(transform);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>4.平台上升脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlatformUp : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector3 movement;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    GameObject topLine;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        movement.y = speed;</span><br><span class=\"line\">        topLine = GameObject.Find(&quot;TopLine&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MovePlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void MovePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        transform.position += movement * Time.deltaTime;</span><br><span class=\"line\">        if(transform.position.y &gt; topLine.transform.position.y)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>5.链锤画线脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class SpikeBallLine : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LineRenderer line;</span><br><span class=\"line\">    public Transform begin;</span><br><span class=\"line\">    public Transform end;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line = GetComponent&lt;LineRenderer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line.SetPosition(0, begin.position);</span><br><span class=\"line\">        line.SetPosition(1, end.position);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>6.跳跃平台旋转动画脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class FanRun : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Animator animator;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        animator = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnCollisionEnter2D(Collision2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.gameObject.CompareTag(&quot;Player&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            animator.Play(&quot;Fan_run&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>”《Speed Down》Unity2d游戏开发“系列已经完结，这篇文章主要是复盘这次学习中遇到的问题和一些名词的解释，以供未来的我快速回顾，最后还会附上所有的脚本</p>","more":"<hr>\n<h3 id=\"一、素材\"><a href=\"#一、素材\" class=\"headerlink\" title=\"一、素材\"></a>一、素材</h3><p>素材这块完全不用自己制作嘛，光是这个Assetstore就有挺多素材的，而且很多无限制商用的，有空要收集一些可以白嫖的网站</p>\n<hr>\n<h3 id=\"二、2D-复合碰撞体-Composite-Collider-2D\"><a href=\"#二、2D-复合碰撞体-Composite-Collider-2D\" class=\"headerlink\" title=\"二、2D 复合碰撞体 (Composite Collider 2D)\"></a>二、2D 复合碰撞体 (Composite Collider 2D)</h3><p>2D 复合碰撞体组件是用于 2D 物理的碰撞体。与大多数碰撞体不同，此碰撞体没有定义固有的形状。相反，此碰撞体将合并所设置的 2D 盒型碰撞体 (Box Collider 2D) 或 2D 多边形碰撞体 (Polygon Collider 2D) 的形状。2D 复合碰撞体使用所有此类碰撞体的顶点（几何体），并将这些顶点合并为由 2D 复合碰撞体本身控制的新几何体。</p>\n<p>2D 盒型碰撞体和 2D 多边形碰撞体组件具有 Used By Composite 复选框。勾选此复选框即可将这些碰撞体附加到 2D 复合碰撞体。这些碰撞体还与 2D 复合碰撞体附加到同一 2D 刚体。启用 Used by Composite 时，其他属性会从该组件中消失，因为这些属性现在由附加的 2D 复合碰撞体控制。</p>\n<hr>\n<h3 id=\"三、Pixels-Per-Unit（PPU）\"><a href=\"#三、Pixels-Per-Unit（PPU）\" class=\"headerlink\" title=\"三、Pixels Per Unit（PPU）\"></a>三、Pixels Per Unit（PPU）</h3><p>在Inspector面板的图像设置中有一个Pixels Per Unit参数。它代表Unity的一个单位长度包含本图片多少个像素<br> 在Unity中创建的Cube等基本图形默认就是一个Unity单位长度，一个单位长度在unity世界坐标中代表1米<br> 例如默认值为100，则代表一个Unity单位包含本图片中100个像素</p>\n<hr>\n<h3 id=\"四、关节（joint）\"><a href=\"#四、关节（joint）\" class=\"headerlink\" title=\"四、关节（joint）\"></a>四、关节（joint）</h3><p>关节组件可以添加至多个游戏对象中，而添加关节的游戏对象将通过关节连接在一起并且感觉连带的物理效果。需要注意的是：关节必须依赖于刚体组件。所有 2D 关节的名称都以“2D”结尾。名称不以“2D”结尾的关节是 3D 关节。2D 关节用于 2D 游戏对象，而 3D 关节用于 3D 游戏对象。</p>\n<p><strong>3D关节</strong>：</p>\n<p><strong>链条关节（hinge joint）</strong>：将两个物体以链条的形式绑在一起，当力量大于链条的固定力矩时，两个物体就会产生相互的拉力。</p>\n<p><strong>固定关节（fixed joint）</strong>：将两个物体永远以相对的位置固定在一起，即使发生物理改变，它们之间的相对位置也将不变。</p>\n<p><strong>弹簧关节（spring joint）</strong>：将两个物体以弹簧的形式绑定在一起，挤压它们会得到向外的力，拉伸它们将得到向里的力。</p>\n<p><strong>角色关节（character joint）</strong>：可以模拟角色的骨骼关节。</p>\n<p><strong>可配置关节（configurable joint）</strong>：可以模拟任意关节的效果。</p>\n<p><strong>2D关节</strong>：</p>\n<p><strong>2D 距离关节 (Distance Joint 2D)</strong> - 连接由刚体物理组件控制的两个游戏对象，使这两个对象保持一定距离。</p>\n<p><strong>2D 固定关节 (Fixed Joint 2D)</strong> - 将两个对象保持在相对于彼此的位置，确保对象始终以给定位置和角度偏移。例如，对象好像是采用刚性连接方式相连一样：对象不能彼此远离，不能相互靠近，也不能相对于彼此旋转。还可以使用此关节来创建刚度稍低的柔性连接。</p>\n<p><strong>2D 摩擦关节 (Friction Joint 2D)</strong> - 将刚体物理组件控制的两个游戏对象之间的线速度和角速度降低到零（即：此关节使对象减速并停止）。例如，一个平台在旋转但抵抗该运动。</p>\n<p><strong>2D 铰链关节 (Hinge Joint 2D)</strong> - 允许由刚体物理组件控制的游戏对象连接到空间中的一个点，使游戏对象可围绕该点旋转。例如，一把剪刀上的轴心。</p>\n<p><strong>2D 相对关节 (Relative Joint 2D)</strong> - 允许由刚体物理组件控制的两个游戏对象基于彼此的位置来保持相对位置。使用此关节可将两个对象保持相互偏移。例如，在空间射击游戏中，玩家身后有额外的排炮。</p>\n<p><strong>2D 滑动关节 (Slider Joint 2D)</strong> - 允许由刚体物理组件控制的游戏对象沿着空间中的一条线滑动（例如滑门）。</p>\n<p><strong>2D 弹簧关节 (Spring Joint 2D)</strong> - 允许由刚体物理组件控制的两个游戏对象就像通过弹簧连接在一起一样。</p>\n<p><strong>2D 目标关节 (Target Joint 2D)</strong> - 连接到指定目标，而不是像其他关节那样连接到另一个刚体对象。这是一种弹簧式关节，例如可将其用于拾取和移动处于重力作用下的对象。</p>\n<p><strong>2D 车轮关节 (Wheel Joint 2D)</strong> - 模拟车轮和悬架。</p>\n<p>在关节这方面2D的花样比3D多</p>\n<hr>\n<h3 id=\"五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）\"><a href=\"#五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）\" class=\"headerlink\" title=\"五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）\"></a>五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）</h3><p>要产生碰撞必须为游戏对象添加刚体（Rigidbody）和碰撞器，刚体可以让物体在物理影响下运动。碰撞体是物理组件的一类，它要与刚体一起添加到游戏对象上才能触发碰撞。如果两个刚体相互撞在一起，除非两个对象有碰撞体时物理引擎才会计算碰撞，在物理模拟中，没有碰撞体的刚体会彼此相互穿过。</p>\n<p><strong>物体发生碰撞的必要条件</strong>：</p>\n<p>两个物体都必须带有碰撞器(Collider)，其中一个物体还必须带有Rigidbody刚体。</p>\n<p>在unity3d中，能检测碰撞发生的方式有两种，一种是利用碰撞器，另一种则是利用触发器。</p>\n<p>碰撞器：一群组件，它包含了很多种类，比如：Box Collider（盒碰撞体），Mesh Collider（网格碰撞体）等，这些碰撞器应用的场合不同，但都必须加到GameObjecet身上。</p>\n<p>触发器：只需要在检视面板中的碰撞器组件中勾选IsTrigger属性选择框。</p>\n<p><strong>触发信息检测</strong>：</p>\n<p>1.MonoBehaviour.OnTriggerEnter(Collider collider)当进入触发器</p>\n<p>2.MonoBehaviour.OnTriggerExit(Collider collider)当退出触发器</p>\n<p>3.MonoBehaviour.OnTriggerStay(Collider collider)当逗留触发器</p>\n<p><strong>碰撞信息检测</strong>：</p>\n<p>1.MonoBehaviour.OnCollisionEnter(Collision collision) 当进入碰撞器</p>\n<p>2.MonoBehaviour.OnCollisionExit(Collision collision) 当退出碰撞器</p>\n<p>3.MonoBehaviour.OnCollisionStay(Collision collision) 当逗留碰撞器</p>\n<p><strong>碰撞器和触发器的区别？</strong></p>\n<p>碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性</p>\n<p>当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；</p>\n<p>当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。</p>\n<p>也就是说在一次碰撞中，碰撞函数和触发函数只能二选一</p>\n<hr>\n<h3 id=\"六、预制体（Prefab）\"><a href=\"#六、预制体（Prefab）\" class=\"headerlink\" title=\"六、预制体（Prefab）\"></a>六、预制体（Prefab）</h3><p>什么是预制体：</p>\n<p>在进行一些功能开发的时候, 我们常常将一些能够复用的对象制作成.prefab的预制体，然后将预制体存放到 Resources 目录之下, 使用时再动态加载到场景中并进行实例化. 例如 : 子弹、特效甚至音频等, 都能制作成预制体.</p>\n<p>预制体英文名称即 Prefab 是一种资源类型 —— 存储在项目视图中的一种可重复使用的游戏对象.</p>\n<p>预制体的优点：<br>预制体可以多次放入到多个场景中;<br>当你添加一个预制体到场景中, 就创建了它的一个实例;<br>所有的预制体实例链接到原始预制, 基本上等于就是它的克隆;<br>不管你的项目存在多少实例, 当你对预制体进行任何更改, 你将看到这些更改将应用于所有的实例上;</p>\n<hr>\n<h3 id=\"七、画布（Canvas）\"><a href=\"#七、画布（Canvas）\" class=\"headerlink\" title=\"七、画布（Canvas）\"></a>七、画布（Canvas）</h3><p>Canvas (画布) 是所有 UI 组件的父物体 , 也就是说每一个 UI 组件都必须在 Canvas 下 , 作为 Canvas 的子物体 , 当你创建一个 UI 控件时 , 如果在 Hierarchy 视图没有 Canvas 组件的话 , unity会自动帮你创建一个 Canvas , 并将你想创建的 UI 控件置于 Canvas 下.</p>\n<p>Canvas 的 Render Mode (渲染模式) 有三种 ：</p>\n<p>1.<strong>Screen Space - Overlay</strong></p>\n<p>这种渲染模式表示 Canvas 下的所有的 UI 控件永远位于屏幕的前面 , 不管有没有相机 , UI元素永远在屏幕最前面</p>\n<p>2.<strong>Screen Space - Camera</strong></p>\n<p>这种渲染模式 Canvas 和 摄像机之间有一定的距离 , 可以在摄像机和 Canvas 之间播放一些粒子特效</p>\n<p>3.<strong>World Space</strong></p>\n<p>这种模式下 Canvas 就和普通的 3D 物体一样了 , 可以控制它的大小,旋转,缩放等 , 一般用来做血条</p>\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>作为unity回坑第一课收获还是蛮丰富的，以前一直没有做笔记的习惯，东西学了又忘，忘了还没地方复习，以后要养成写学习日记的习惯。</p>\n<p>这次写的脚本都没有写注释，希望未来的我回来看的时候不会头大吧哈哈哈（这么简单的代码应该不至于吧吧吧吧🐷）</p>\n<hr>\n<h3 id=\"附录、脚本\"><a href=\"#附录、脚本\" class=\"headerlink\" title=\"附录、脚本\"></a>附录、脚本</h3><p>1.角色控制脚本，控制角色移动和检测角色状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerController : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Rigidbody2D rb;</span><br><span class=\"line\">    Animator anim;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    public bool isOnGround;</span><br><span class=\"line\">    public float checkRadius;</span><br><span class=\"line\">    public LayerMask layer;</span><br><span class=\"line\">    public GameObject groundCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">    public bool playerDead;</span><br><span class=\"line\"></span><br><span class=\"line\">    public float bounceH;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">        anim = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Movement();</span><br><span class=\"line\">        isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);</span><br><span class=\"line\">        anim.SetBool(&quot;isOnGround&quot;, isOnGround);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Movement()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\">        anim.SetFloat(&quot;speed&quot;, Mathf.Abs(rb.velocity.x));</span><br><span class=\"line\"></span><br><span class=\"line\">        if(xVelocity != 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            transform.localScale = new Vector3(xVelocity, 1, 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnCollisionEnter2D(Collision2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.gameObject.CompareTag(&quot;Fan&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rb.velocity = new Vector2(rb.velocity.x, bounceH);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (collision.gameObject.CompareTag(&quot;Spike&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            anim.SetTrigger(&quot;isDead&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.CompareTag(&quot;Spike&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            anim.SetTrigger(&quot;isDead&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void PlayerDead()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        playerDead = true;</span><br><span class=\"line\">        GameManage.GameOver(playerDead);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnDrawGizmosSelected()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Gizmos.color = Color.green;</span><br><span class=\"line\">        Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.游戏管理脚本，涉及游戏重开和退出，以及控制界面：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">using UnityEngine.UI;</span><br><span class=\"line\">using UnityEngine.SceneManagement;</span><br><span class=\"line\"></span><br><span class=\"line\">public class GameManage : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static GameManage instance;</span><br><span class=\"line\">    public Text score;</span><br><span class=\"line\"></span><br><span class=\"line\">    public GameObject gameOverUI;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void Awake()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(instance != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        instance = this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        score.text = Time.timeSinceLevelLoad.ToString(&quot;000&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void RestartGame()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SceneManager.LoadScene(SceneManager.GetActiveScene().name);</span><br><span class=\"line\">        Time.timeScale = 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void Exit()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Application.Quit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void GameOver(bool dead)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (dead)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Time.timeScale = 0f;</span><br><span class=\"line\">            instance.gameOverUI.SetActive(true);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>3.平台生成脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Spawner : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public List&lt;GameObject&gt; platform = new List&lt;GameObject&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public float spawnTime;</span><br><span class=\"line\">    float countTime;</span><br><span class=\"line\">    Vector3 spawnPosition;</span><br><span class=\"line\"></span><br><span class=\"line\">    int spikeBallNum = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SpawnPlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void SpawnPlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        countTime += Time.deltaTime;</span><br><span class=\"line\">        spawnPosition = transform.position;</span><br><span class=\"line\">        spawnPosition.x = Random.Range(-3f, 3f);</span><br><span class=\"line\"></span><br><span class=\"line\">        if(countTime &gt; spawnTime)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            CreatePlatform();</span><br><span class=\"line\">            countTime = 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void CreatePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int index = Random.Range(0, platform.Count);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (index == 3)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            spikeBallNum++;</span><br><span class=\"line\">            if(spikeBallNum &gt; 2)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                index = 0;</span><br><span class=\"line\">                spikeBallNum = 0;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class=\"line\">        newPlatform.transform.SetParent(transform);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>4.平台上升脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlatformUp : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector3 movement;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    GameObject topLine;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        movement.y = speed;</span><br><span class=\"line\">        topLine = GameObject.Find(&quot;TopLine&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MovePlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void MovePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        transform.position += movement * Time.deltaTime;</span><br><span class=\"line\">        if(transform.position.y &gt; topLine.transform.position.y)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>5.链锤画线脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class SpikeBallLine : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LineRenderer line;</span><br><span class=\"line\">    public Transform begin;</span><br><span class=\"line\">    public Transform end;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line = GetComponent&lt;LineRenderer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line.SetPosition(0, begin.position);</span><br><span class=\"line\">        line.SetPosition(1, end.position);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>6.跳跃平台旋转动画脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class FanRun : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Animator animator;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        animator = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnCollisionEnter2D(Collision2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.gameObject.CompareTag(&quot;Player&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            animator.Play(&quot;Fan_run&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"【LeetCode.剑指Offer.42】连续子数组的最大和","date":"2021-07-17T07:01:11.000Z","_content":"\n\n\n\n\n### \t题目：连续子数组的最大和\n\n输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的**最大值**。\n\n要求时间复杂度为**O(n)**。\n\n \n\n示例1:\n\n```\n输入: nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n```\n\n<!--more-->\n\n提示：\n\n`1 <= arr.length <= 10^5`\n`-100 <= arr[i] <= 100`\n\n\n\n---\n\n\n\n### 分析：\n\n我们用` f(i)`代表以第` i `个数结尾的「连续子数组的最大和」\n\n只需要求出每个位置的` f(i)`，然后返回 `f `数组中的最大值即可。那么我们如何求` f(i) `呢？\n\n我们可以考虑 `nums[i] `单独成为一段还是加入` f(i-1) `对应的那一段，这取决于` nums[i] `和`f(i−1) + nums[i] `的大小，我们希望获得一个比较大的\n\n于是可以写出这样的动态规划转移方程：\n`f(i) = max{ f(i−1) + nums[i], nums[i] }`\n\n\n\n---\n\n\n\n### 题解：\n\n```\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> f(n);\n        f[0] = nums[0];\n        int ret = nums[0];\n\n        for (int i =  1; i < n; i++) {\n            f[i] = max(f[i - 1] + nums[i], nums[i]);\n            ret = max(f[i], ret);\n        }\n        return ret;\n    }\n};\n```\n\n时间复杂度O(n)，空间复杂度O(n)\n\n\n\n---\n\n\n\n### 改进：\n\n由于 `f[i]` 只是与 `f[i - 1]` 和 `nums[i]` 有关，且 `ret` 只与当前的 `f[i]` 有关，不需要存储整个数组\n\n```\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int nowMax = 0;\n        int ret = nums[0];\n        for (auto x : nums) {\n            nowMax = max(nowMax + x, x);\n            ret = max(nowMax, ret);\n        }\n        return ret;\n    }\n};\n```\n\n时间复杂度O(n)，空间复杂度O(1)\n\n\n\n---\n\n\n\n### 细节：\n\n1.只需求出最大值，不用求出最大的子数组\n\n","source":"_posts/2021-07-17-【LeetCode.剑指Offer.42】连续子数组的最大和.md","raw":"---\ntitle: 【LeetCode.剑指Offer.42】连续子数组的最大和\ndate: 2021-07-17 15:01:11\ncategories: 算法\ntags:\n  - c++\n  - 动态规划\n  - 数组\n---\n\n\n\n\n\n### \t题目：连续子数组的最大和\n\n输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的**最大值**。\n\n要求时间复杂度为**O(n)**。\n\n \n\n示例1:\n\n```\n输入: nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n```\n\n<!--more-->\n\n提示：\n\n`1 <= arr.length <= 10^5`\n`-100 <= arr[i] <= 100`\n\n\n\n---\n\n\n\n### 分析：\n\n我们用` f(i)`代表以第` i `个数结尾的「连续子数组的最大和」\n\n只需要求出每个位置的` f(i)`，然后返回 `f `数组中的最大值即可。那么我们如何求` f(i) `呢？\n\n我们可以考虑 `nums[i] `单独成为一段还是加入` f(i-1) `对应的那一段，这取决于` nums[i] `和`f(i−1) + nums[i] `的大小，我们希望获得一个比较大的\n\n于是可以写出这样的动态规划转移方程：\n`f(i) = max{ f(i−1) + nums[i], nums[i] }`\n\n\n\n---\n\n\n\n### 题解：\n\n```\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> f(n);\n        f[0] = nums[0];\n        int ret = nums[0];\n\n        for (int i =  1; i < n; i++) {\n            f[i] = max(f[i - 1] + nums[i], nums[i]);\n            ret = max(f[i], ret);\n        }\n        return ret;\n    }\n};\n```\n\n时间复杂度O(n)，空间复杂度O(n)\n\n\n\n---\n\n\n\n### 改进：\n\n由于 `f[i]` 只是与 `f[i - 1]` 和 `nums[i]` 有关，且 `ret` 只与当前的 `f[i]` 有关，不需要存储整个数组\n\n```\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int nowMax = 0;\n        int ret = nums[0];\n        for (auto x : nums) {\n            nowMax = max(nowMax + x, x);\n            ret = max(nowMax, ret);\n        }\n        return ret;\n    }\n};\n```\n\n时间复杂度O(n)，空间复杂度O(1)\n\n\n\n---\n\n\n\n### 细节：\n\n1.只需求出最大值，不用求出最大的子数组\n\n","slug":"2021-07-17-【LeetCode.剑指Offer.42】连续子数组的最大和","published":1,"updated":"2021-07-23T07:07:51.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71he000r1ou08rqkhpfl","content":"<h3 id=\"题目：连续子数组的最大和\"><a href=\"#题目：连续子数组的最大和\" class=\"headerlink\" title=\"题目：连续子数组的最大和\"></a>题目：连续子数组的最大和</h3><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的<strong>最大值</strong>。</p>\n<p>要求时间复杂度为**O(n)**。</p>\n<p>示例1:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class=\"line\">输出: 6</span><br><span class=\"line\">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<p>提示：</p>\n<p><code>1 &lt;= arr.length &lt;= 10^5</code><br><code>-100 &lt;= arr[i] &lt;= 100</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>我们用<code> f(i)</code>代表以第<code>i</code>个数结尾的「连续子数组的最大和」</p>\n<p>只需要求出每个位置的<code> f(i)</code>，然后返回 <code>f </code>数组中的最大值即可。那么我们如何求<code>f(i)</code>呢？</p>\n<p>我们可以考虑 <code>nums[i] </code>单独成为一段还是加入<code>f(i-1)</code>对应的那一段，这取决于<code>nums[i]</code>和<code>f(i−1) + nums[i] </code>的大小，我们希望获得一个比较大的</p>\n<p>于是可以写出这样的动态规划转移方程：<br><code>f(i) = max&#123; f(i−1) + nums[i], nums[i] &#125;</code></p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        int n = nums.size();</span><br><span class=\"line\">        vector&lt;int&gt; f(n);</span><br><span class=\"line\">        f[0] = nums[0];</span><br><span class=\"line\">        int ret = nums[0];</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i =  1; i &lt; n; i++) &#123;</span><br><span class=\"line\">            f[i] = max(f[i - 1] + nums[i], nums[i]);</span><br><span class=\"line\">            ret = max(f[i], ret);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n)，空间复杂度O(n)</p>\n<hr>\n<h3 id=\"改进：\"><a href=\"#改进：\" class=\"headerlink\" title=\"改进：\"></a>改进：</h3><p>由于 <code>f[i]</code> 只是与 <code>f[i - 1]</code> 和 <code>nums[i]</code> 有关，且 <code>ret</code> 只与当前的 <code>f[i]</code> 有关，不需要存储整个数组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        int nowMax = 0;</span><br><span class=\"line\">        int ret = nums[0];</span><br><span class=\"line\">        for (auto x : nums) &#123;</span><br><span class=\"line\">            nowMax = max(nowMax + x, x);</span><br><span class=\"line\">            ret = max(nowMax, ret);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n)，空间复杂度O(1)</p>\n<hr>\n<h3 id=\"细节：\"><a href=\"#细节：\" class=\"headerlink\" title=\"细节：\"></a>细节：</h3><p>1.只需求出最大值，不用求出最大的子数组</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"题目：连续子数组的最大和\"><a href=\"#题目：连续子数组的最大和\" class=\"headerlink\" title=\"题目：连续子数组的最大和\"></a>题目：连续子数组的最大和</h3><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的<strong>最大值</strong>。</p>\n<p>要求时间复杂度为**O(n)**。</p>\n<p>示例1:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class=\"line\">输出: 6</span><br><span class=\"line\">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>","more":"<p>提示：</p>\n<p><code>1 &lt;= arr.length &lt;= 10^5</code><br><code>-100 &lt;= arr[i] &lt;= 100</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>我们用<code> f(i)</code>代表以第<code>i</code>个数结尾的「连续子数组的最大和」</p>\n<p>只需要求出每个位置的<code> f(i)</code>，然后返回 <code>f </code>数组中的最大值即可。那么我们如何求<code>f(i)</code>呢？</p>\n<p>我们可以考虑 <code>nums[i] </code>单独成为一段还是加入<code>f(i-1)</code>对应的那一段，这取决于<code>nums[i]</code>和<code>f(i−1) + nums[i] </code>的大小，我们希望获得一个比较大的</p>\n<p>于是可以写出这样的动态规划转移方程：<br><code>f(i) = max&#123; f(i−1) + nums[i], nums[i] &#125;</code></p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        int n = nums.size();</span><br><span class=\"line\">        vector&lt;int&gt; f(n);</span><br><span class=\"line\">        f[0] = nums[0];</span><br><span class=\"line\">        int ret = nums[0];</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i =  1; i &lt; n; i++) &#123;</span><br><span class=\"line\">            f[i] = max(f[i - 1] + nums[i], nums[i]);</span><br><span class=\"line\">            ret = max(f[i], ret);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n)，空间复杂度O(n)</p>\n<hr>\n<h3 id=\"改进：\"><a href=\"#改进：\" class=\"headerlink\" title=\"改进：\"></a>改进：</h3><p>由于 <code>f[i]</code> 只是与 <code>f[i - 1]</code> 和 <code>nums[i]</code> 有关，且 <code>ret</code> 只与当前的 <code>f[i]</code> 有关，不需要存储整个数组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        int nowMax = 0;</span><br><span class=\"line\">        int ret = nums[0];</span><br><span class=\"line\">        for (auto x : nums) &#123;</span><br><span class=\"line\">            nowMax = max(nowMax + x, x);</span><br><span class=\"line\">            ret = max(nowMax, ret);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n)，空间复杂度O(1)</p>\n<hr>\n<h3 id=\"细节：\"><a href=\"#细节：\" class=\"headerlink\" title=\"细节：\"></a>细节：</h3><p>1.只需求出最大值，不用求出最大的子数组</p>"},{"title":"《Robbie Swifthand》Unity2d独立游戏学习（一）","date":"2021-07-18T08:16:23.000Z","_content":"\n\n\n### \t始、前言\n\n继续跟M大学习unity2d开发，这次是《从独立游戏学习开发》系列，我们将从一款已经上架steam的独立游戏《Robbie Swifthand and the Orb of Mysteries》中学习\n\n\n\n版本：\n\nunity 2021.1.12f1c1\n\nvs 2019\n\nunityhub 2.1.14\n\n\n\n<!--more-->\n\n---\n\n\n\n### 一、导入资源\n\n1.资源地址：https://pan.baidu.com/s/1c0I1pO7Rr8w4s4SGcfscHA\n\n提取码:   a338\n\n2.新建2d unity项目，界面左上角工具栏中Assets - import package - custom assets ，导入刚刚下载的资源\n\n3.导入过程中提示更新API，选择“Yes”\n\n4.导入完成后发现脚本报错，原因是我的新版unity自带的脚本和资源里的有冲突，需要删除对应的新脚本\n\n\n\n---\n\n\n\n### 二、整理资源\n\n导入工作完成后Assets文件夹下出现了大量的文件夹，先看看他们都是些什么\n\n1._Extended：额外的扩展包，后期需要用到的资源\n\n2.Addons：插件，新版本unity有自带的，这里需要删掉\n\n3.Audio：音乐素材\n\n4.Fonts：字体\n\n5.Gizmos：小插件，这里包含2D摄像机跟踪\n\n6.Level：背景前景素材，用于制作透视效果\n\n7.Props：道具，里面是一些游戏元素的预制体\n\n8.Robbie：本游戏主角，包含主角的素材、动画等\n\n9.Scripts：脚本，包含几个简单代码，其他的自己写\n\n10.Tilemaps：用来存放游戏素材，即项目中正在用的素材（为啥得用他给我的文件夹，我就不）\n\n11.UI：用户界面用到的素材\n\n12.VFX：特效\n\n\n\n---\n\n\n\n### 三、绘制背景准备工作\n\n1.找到windows - 2D - Tile Palette调出调色板窗口\n\n2.新建调色板，起名Background，存放到Tilemap文件夹里新建的Palettes文件夹\n\n3.将Level中的素材BG walls 拖入调色板里，保存到Tilemap - Tile 新建的Background文件夹\n\n4.重复2~3步骤，制作Platform和Shadow的调色板，同样管理好切割的瓦片\n\n5.在调色板界面中点击Edit 就可以修改调色板的素材（界面中几个画画工具都玩一下）\n\n6.在Hierarchy中新建2D Object - Tilemap ，命名为Background\n\n7.在调色板Active Tilemap 中可以选择要绘制的对象\n\n8.同样地，在Grid 父物体下新建Tilemap 三个物体，分别命名Background Detailed、Shadow、Platform\n\n9.设置Sorting Layer，添加四种，分别为Background、Platform、Player、Foreground（Sorting Layer 中越往下排的层级在镜头中越靠前）\n\n10.分别设置Tilemap的Sorting Layer ，其中Order In Layer 又可以在同Layer 中再排序一次\n\n（设置都要套娃？）\n\n11.拖入主角Robbie，设置Sorting Layer 为Player\n\n\n\n---\n\n\n\n### 四、设置Rule Tile\n\nRule Tile 是超强的瓦片绘制工具，通过设定瓦片生成规则，实现利用一个瓦片就可以任意拖拽生成各种不规则图案。新版本的unity已经成为内置功能，可以直接创建使用\n\n1.在Tilemaps - Tile - Backgrounds中新建Rule Tile，命名为BG rule ，默认图片随便选个背景瓦片\n\n2.添加瓦片，并给每个瓦片设置规则，上面的规则比下面的规则优先。\n\n规则为：检测九宫格中是否存在其他同样在列表中的瓦片，绿色箭头表示那个方向**必**存在此类瓦片，红色叉叉表示**必**不存在此类瓦片，没有设置的方向就是没要求\n\n3.设置好每个瓦片后，将BG rule 拖入调色板Palette 中， 这样就可以用这个瓦片随意画图啦！\n\n4.多设置几个功能瓦片堆积在一起可以变成大瓦片，方便大面积作图\n\n5.同上，设置Shadows 瓦片的Rule Tile\n\n6.设置Platforms 瓦片的Rule Tile 时，我们希望平台瓦片随机生成，而不用某种特定规则。在Rule Tile 下添加一个瓦片，在Output中选择Random，Size设置为4，将要随机生成的四种瓦片拖入空格中\n\n\n\n---\n\n\n\n### 五、绘制地图\n\n可以随意绘制地图，但是有几个注意点：\n\n1.在调色板中选取瓦片时，要记得在Active Tilemap 中选择要绘制的对象\n\n2.瓦片要绘制两层以上，因为各种规则瓦片在只有一层时会非常难看\n\n3.Shadows 瓦片覆盖在在Platforms 瓦片上面，后面调灯光的时候就会有很美妙的效果\n\n4.地图记得留一个出口位置\n\n\n\n---\n\n\n\n### 终、睡觉\n\n画地图还挺过瘾的，先这样了，洗澡睡觉！\n","source":"_posts/2021-07-18-《Robbie Swifthand》Unity2d独立游戏学习（一）.md","raw":"---\ntitle: 《Robbie Swifthand》Unity2d独立游戏学习（一）\ndate: 2021-07-18 16:16:23\ncategories: unity\ntags:\n  - unity\n  - c#\n  - tilemap\n---\n\n\n\n### \t始、前言\n\n继续跟M大学习unity2d开发，这次是《从独立游戏学习开发》系列，我们将从一款已经上架steam的独立游戏《Robbie Swifthand and the Orb of Mysteries》中学习\n\n\n\n版本：\n\nunity 2021.1.12f1c1\n\nvs 2019\n\nunityhub 2.1.14\n\n\n\n<!--more-->\n\n---\n\n\n\n### 一、导入资源\n\n1.资源地址：https://pan.baidu.com/s/1c0I1pO7Rr8w4s4SGcfscHA\n\n提取码:   a338\n\n2.新建2d unity项目，界面左上角工具栏中Assets - import package - custom assets ，导入刚刚下载的资源\n\n3.导入过程中提示更新API，选择“Yes”\n\n4.导入完成后发现脚本报错，原因是我的新版unity自带的脚本和资源里的有冲突，需要删除对应的新脚本\n\n\n\n---\n\n\n\n### 二、整理资源\n\n导入工作完成后Assets文件夹下出现了大量的文件夹，先看看他们都是些什么\n\n1._Extended：额外的扩展包，后期需要用到的资源\n\n2.Addons：插件，新版本unity有自带的，这里需要删掉\n\n3.Audio：音乐素材\n\n4.Fonts：字体\n\n5.Gizmos：小插件，这里包含2D摄像机跟踪\n\n6.Level：背景前景素材，用于制作透视效果\n\n7.Props：道具，里面是一些游戏元素的预制体\n\n8.Robbie：本游戏主角，包含主角的素材、动画等\n\n9.Scripts：脚本，包含几个简单代码，其他的自己写\n\n10.Tilemaps：用来存放游戏素材，即项目中正在用的素材（为啥得用他给我的文件夹，我就不）\n\n11.UI：用户界面用到的素材\n\n12.VFX：特效\n\n\n\n---\n\n\n\n### 三、绘制背景准备工作\n\n1.找到windows - 2D - Tile Palette调出调色板窗口\n\n2.新建调色板，起名Background，存放到Tilemap文件夹里新建的Palettes文件夹\n\n3.将Level中的素材BG walls 拖入调色板里，保存到Tilemap - Tile 新建的Background文件夹\n\n4.重复2~3步骤，制作Platform和Shadow的调色板，同样管理好切割的瓦片\n\n5.在调色板界面中点击Edit 就可以修改调色板的素材（界面中几个画画工具都玩一下）\n\n6.在Hierarchy中新建2D Object - Tilemap ，命名为Background\n\n7.在调色板Active Tilemap 中可以选择要绘制的对象\n\n8.同样地，在Grid 父物体下新建Tilemap 三个物体，分别命名Background Detailed、Shadow、Platform\n\n9.设置Sorting Layer，添加四种，分别为Background、Platform、Player、Foreground（Sorting Layer 中越往下排的层级在镜头中越靠前）\n\n10.分别设置Tilemap的Sorting Layer ，其中Order In Layer 又可以在同Layer 中再排序一次\n\n（设置都要套娃？）\n\n11.拖入主角Robbie，设置Sorting Layer 为Player\n\n\n\n---\n\n\n\n### 四、设置Rule Tile\n\nRule Tile 是超强的瓦片绘制工具，通过设定瓦片生成规则，实现利用一个瓦片就可以任意拖拽生成各种不规则图案。新版本的unity已经成为内置功能，可以直接创建使用\n\n1.在Tilemaps - Tile - Backgrounds中新建Rule Tile，命名为BG rule ，默认图片随便选个背景瓦片\n\n2.添加瓦片，并给每个瓦片设置规则，上面的规则比下面的规则优先。\n\n规则为：检测九宫格中是否存在其他同样在列表中的瓦片，绿色箭头表示那个方向**必**存在此类瓦片，红色叉叉表示**必**不存在此类瓦片，没有设置的方向就是没要求\n\n3.设置好每个瓦片后，将BG rule 拖入调色板Palette 中， 这样就可以用这个瓦片随意画图啦！\n\n4.多设置几个功能瓦片堆积在一起可以变成大瓦片，方便大面积作图\n\n5.同上，设置Shadows 瓦片的Rule Tile\n\n6.设置Platforms 瓦片的Rule Tile 时，我们希望平台瓦片随机生成，而不用某种特定规则。在Rule Tile 下添加一个瓦片，在Output中选择Random，Size设置为4，将要随机生成的四种瓦片拖入空格中\n\n\n\n---\n\n\n\n### 五、绘制地图\n\n可以随意绘制地图，但是有几个注意点：\n\n1.在调色板中选取瓦片时，要记得在Active Tilemap 中选择要绘制的对象\n\n2.瓦片要绘制两层以上，因为各种规则瓦片在只有一层时会非常难看\n\n3.Shadows 瓦片覆盖在在Platforms 瓦片上面，后面调灯光的时候就会有很美妙的效果\n\n4.地图记得留一个出口位置\n\n\n\n---\n\n\n\n### 终、睡觉\n\n画地图还挺过瘾的，先这样了，洗澡睡觉！\n","slug":"2021-07-18-《Robbie Swifthand》Unity2d独立游戏学习（一）","published":1,"updated":"2021-08-14T10:57:02.779Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hf000t1ou08ruy0cv7","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>继续跟M大学习unity2d开发，这次是《从独立游戏学习开发》系列，我们将从一款已经上架steam的独立游戏《Robbie Swifthand and the Orb of Mysteries》中学习</p>\n<p>版本：</p>\n<p>unity 2021.1.12f1c1</p>\n<p>vs 2019</p>\n<p>unityhub 2.1.14</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、导入资源\"><a href=\"#一、导入资源\" class=\"headerlink\" title=\"一、导入资源\"></a>一、导入资源</h3><p>1.资源地址：<a href=\"https://pan.baidu.com/s/1c0I1pO7Rr8w4s4SGcfscHA\">https://pan.baidu.com/s/1c0I1pO7Rr8w4s4SGcfscHA</a></p>\n<p>提取码:   a338</p>\n<p>2.新建2d unity项目，界面左上角工具栏中Assets - import package - custom assets ，导入刚刚下载的资源</p>\n<p>3.导入过程中提示更新API，选择“Yes”</p>\n<p>4.导入完成后发现脚本报错，原因是我的新版unity自带的脚本和资源里的有冲突，需要删除对应的新脚本</p>\n<hr>\n<h3 id=\"二、整理资源\"><a href=\"#二、整理资源\" class=\"headerlink\" title=\"二、整理资源\"></a>二、整理资源</h3><p>导入工作完成后Assets文件夹下出现了大量的文件夹，先看看他们都是些什么</p>\n<p>1._Extended：额外的扩展包，后期需要用到的资源</p>\n<p>2.Addons：插件，新版本unity有自带的，这里需要删掉</p>\n<p>3.Audio：音乐素材</p>\n<p>4.Fonts：字体</p>\n<p>5.Gizmos：小插件，这里包含2D摄像机跟踪</p>\n<p>6.Level：背景前景素材，用于制作透视效果</p>\n<p>7.Props：道具，里面是一些游戏元素的预制体</p>\n<p>8.Robbie：本游戏主角，包含主角的素材、动画等</p>\n<p>9.Scripts：脚本，包含几个简单代码，其他的自己写</p>\n<p>10.Tilemaps：用来存放游戏素材，即项目中正在用的素材（为啥得用他给我的文件夹，我就不）</p>\n<p>11.UI：用户界面用到的素材</p>\n<p>12.VFX：特效</p>\n<hr>\n<h3 id=\"三、绘制背景准备工作\"><a href=\"#三、绘制背景准备工作\" class=\"headerlink\" title=\"三、绘制背景准备工作\"></a>三、绘制背景准备工作</h3><p>1.找到windows - 2D - Tile Palette调出调色板窗口</p>\n<p>2.新建调色板，起名Background，存放到Tilemap文件夹里新建的Palettes文件夹</p>\n<p>3.将Level中的素材BG walls 拖入调色板里，保存到Tilemap - Tile 新建的Background文件夹</p>\n<p>4.重复2~3步骤，制作Platform和Shadow的调色板，同样管理好切割的瓦片</p>\n<p>5.在调色板界面中点击Edit 就可以修改调色板的素材（界面中几个画画工具都玩一下）</p>\n<p>6.在Hierarchy中新建2D Object - Tilemap ，命名为Background</p>\n<p>7.在调色板Active Tilemap 中可以选择要绘制的对象</p>\n<p>8.同样地，在Grid 父物体下新建Tilemap 三个物体，分别命名Background Detailed、Shadow、Platform</p>\n<p>9.设置Sorting Layer，添加四种，分别为Background、Platform、Player、Foreground（Sorting Layer 中越往下排的层级在镜头中越靠前）</p>\n<p>10.分别设置Tilemap的Sorting Layer ，其中Order In Layer 又可以在同Layer 中再排序一次</p>\n<p>（设置都要套娃？）</p>\n<p>11.拖入主角Robbie，设置Sorting Layer 为Player</p>\n<hr>\n<h3 id=\"四、设置Rule-Tile\"><a href=\"#四、设置Rule-Tile\" class=\"headerlink\" title=\"四、设置Rule Tile\"></a>四、设置Rule Tile</h3><p>Rule Tile 是超强的瓦片绘制工具，通过设定瓦片生成规则，实现利用一个瓦片就可以任意拖拽生成各种不规则图案。新版本的unity已经成为内置功能，可以直接创建使用</p>\n<p>1.在Tilemaps - Tile - Backgrounds中新建Rule Tile，命名为BG rule ，默认图片随便选个背景瓦片</p>\n<p>2.添加瓦片，并给每个瓦片设置规则，上面的规则比下面的规则优先。</p>\n<p>规则为：检测九宫格中是否存在其他同样在列表中的瓦片，绿色箭头表示那个方向<strong>必</strong>存在此类瓦片，红色叉叉表示<strong>必</strong>不存在此类瓦片，没有设置的方向就是没要求</p>\n<p>3.设置好每个瓦片后，将BG rule 拖入调色板Palette 中， 这样就可以用这个瓦片随意画图啦！</p>\n<p>4.多设置几个功能瓦片堆积在一起可以变成大瓦片，方便大面积作图</p>\n<p>5.同上，设置Shadows 瓦片的Rule Tile</p>\n<p>6.设置Platforms 瓦片的Rule Tile 时，我们希望平台瓦片随机生成，而不用某种特定规则。在Rule Tile 下添加一个瓦片，在Output中选择Random，Size设置为4，将要随机生成的四种瓦片拖入空格中</p>\n<hr>\n<h3 id=\"五、绘制地图\"><a href=\"#五、绘制地图\" class=\"headerlink\" title=\"五、绘制地图\"></a>五、绘制地图</h3><p>可以随意绘制地图，但是有几个注意点：</p>\n<p>1.在调色板中选取瓦片时，要记得在Active Tilemap 中选择要绘制的对象</p>\n<p>2.瓦片要绘制两层以上，因为各种规则瓦片在只有一层时会非常难看</p>\n<p>3.Shadows 瓦片覆盖在在Platforms 瓦片上面，后面调灯光的时候就会有很美妙的效果</p>\n<p>4.地图记得留一个出口位置</p>\n<hr>\n<h3 id=\"终、睡觉\"><a href=\"#终、睡觉\" class=\"headerlink\" title=\"终、睡觉\"></a>终、睡觉</h3><p>画地图还挺过瘾的，先这样了，洗澡睡觉！</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>继续跟M大学习unity2d开发，这次是《从独立游戏学习开发》系列，我们将从一款已经上架steam的独立游戏《Robbie Swifthand and the Orb of Mysteries》中学习</p>\n<p>版本：</p>\n<p>unity 2021.1.12f1c1</p>\n<p>vs 2019</p>\n<p>unityhub 2.1.14</p>","more":"<hr>\n<h3 id=\"一、导入资源\"><a href=\"#一、导入资源\" class=\"headerlink\" title=\"一、导入资源\"></a>一、导入资源</h3><p>1.资源地址：<a href=\"https://pan.baidu.com/s/1c0I1pO7Rr8w4s4SGcfscHA\">https://pan.baidu.com/s/1c0I1pO7Rr8w4s4SGcfscHA</a></p>\n<p>提取码:   a338</p>\n<p>2.新建2d unity项目，界面左上角工具栏中Assets - import package - custom assets ，导入刚刚下载的资源</p>\n<p>3.导入过程中提示更新API，选择“Yes”</p>\n<p>4.导入完成后发现脚本报错，原因是我的新版unity自带的脚本和资源里的有冲突，需要删除对应的新脚本</p>\n<hr>\n<h3 id=\"二、整理资源\"><a href=\"#二、整理资源\" class=\"headerlink\" title=\"二、整理资源\"></a>二、整理资源</h3><p>导入工作完成后Assets文件夹下出现了大量的文件夹，先看看他们都是些什么</p>\n<p>1._Extended：额外的扩展包，后期需要用到的资源</p>\n<p>2.Addons：插件，新版本unity有自带的，这里需要删掉</p>\n<p>3.Audio：音乐素材</p>\n<p>4.Fonts：字体</p>\n<p>5.Gizmos：小插件，这里包含2D摄像机跟踪</p>\n<p>6.Level：背景前景素材，用于制作透视效果</p>\n<p>7.Props：道具，里面是一些游戏元素的预制体</p>\n<p>8.Robbie：本游戏主角，包含主角的素材、动画等</p>\n<p>9.Scripts：脚本，包含几个简单代码，其他的自己写</p>\n<p>10.Tilemaps：用来存放游戏素材，即项目中正在用的素材（为啥得用他给我的文件夹，我就不）</p>\n<p>11.UI：用户界面用到的素材</p>\n<p>12.VFX：特效</p>\n<hr>\n<h3 id=\"三、绘制背景准备工作\"><a href=\"#三、绘制背景准备工作\" class=\"headerlink\" title=\"三、绘制背景准备工作\"></a>三、绘制背景准备工作</h3><p>1.找到windows - 2D - Tile Palette调出调色板窗口</p>\n<p>2.新建调色板，起名Background，存放到Tilemap文件夹里新建的Palettes文件夹</p>\n<p>3.将Level中的素材BG walls 拖入调色板里，保存到Tilemap - Tile 新建的Background文件夹</p>\n<p>4.重复2~3步骤，制作Platform和Shadow的调色板，同样管理好切割的瓦片</p>\n<p>5.在调色板界面中点击Edit 就可以修改调色板的素材（界面中几个画画工具都玩一下）</p>\n<p>6.在Hierarchy中新建2D Object - Tilemap ，命名为Background</p>\n<p>7.在调色板Active Tilemap 中可以选择要绘制的对象</p>\n<p>8.同样地，在Grid 父物体下新建Tilemap 三个物体，分别命名Background Detailed、Shadow、Platform</p>\n<p>9.设置Sorting Layer，添加四种，分别为Background、Platform、Player、Foreground（Sorting Layer 中越往下排的层级在镜头中越靠前）</p>\n<p>10.分别设置Tilemap的Sorting Layer ，其中Order In Layer 又可以在同Layer 中再排序一次</p>\n<p>（设置都要套娃？）</p>\n<p>11.拖入主角Robbie，设置Sorting Layer 为Player</p>\n<hr>\n<h3 id=\"四、设置Rule-Tile\"><a href=\"#四、设置Rule-Tile\" class=\"headerlink\" title=\"四、设置Rule Tile\"></a>四、设置Rule Tile</h3><p>Rule Tile 是超强的瓦片绘制工具，通过设定瓦片生成规则，实现利用一个瓦片就可以任意拖拽生成各种不规则图案。新版本的unity已经成为内置功能，可以直接创建使用</p>\n<p>1.在Tilemaps - Tile - Backgrounds中新建Rule Tile，命名为BG rule ，默认图片随便选个背景瓦片</p>\n<p>2.添加瓦片，并给每个瓦片设置规则，上面的规则比下面的规则优先。</p>\n<p>规则为：检测九宫格中是否存在其他同样在列表中的瓦片，绿色箭头表示那个方向<strong>必</strong>存在此类瓦片，红色叉叉表示<strong>必</strong>不存在此类瓦片，没有设置的方向就是没要求</p>\n<p>3.设置好每个瓦片后，将BG rule 拖入调色板Palette 中， 这样就可以用这个瓦片随意画图啦！</p>\n<p>4.多设置几个功能瓦片堆积在一起可以变成大瓦片，方便大面积作图</p>\n<p>5.同上，设置Shadows 瓦片的Rule Tile</p>\n<p>6.设置Platforms 瓦片的Rule Tile 时，我们希望平台瓦片随机生成，而不用某种特定规则。在Rule Tile 下添加一个瓦片，在Output中选择Random，Size设置为4，将要随机生成的四种瓦片拖入空格中</p>\n<hr>\n<h3 id=\"五、绘制地图\"><a href=\"#五、绘制地图\" class=\"headerlink\" title=\"五、绘制地图\"></a>五、绘制地图</h3><p>可以随意绘制地图，但是有几个注意点：</p>\n<p>1.在调色板中选取瓦片时，要记得在Active Tilemap 中选择要绘制的对象</p>\n<p>2.瓦片要绘制两层以上，因为各种规则瓦片在只有一层时会非常难看</p>\n<p>3.Shadows 瓦片覆盖在在Platforms 瓦片上面，后面调灯光的时候就会有很美妙的效果</p>\n<p>4.地图记得留一个出口位置</p>\n<hr>\n<h3 id=\"终、睡觉\"><a href=\"#终、睡觉\" class=\"headerlink\" title=\"终、睡觉\"></a>终、睡觉</h3><p>画地图还挺过瘾的，先这样了，洗澡睡觉！</p>"},{"title":"《Robbie Swifthand》Unity2d独立游戏学习（三）","date":"2021-07-20T07:36:35.000Z","_content":"\n\n\n\n\n### \t始、前言\n\n简单的角色移动已经完成了，这次来学习用Raycast 射线检测的方法让角色的状态检测变得更细致\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、Physics2D.Raycast 脚本API\n\n```\npublic static RaycastHit2D Raycast (Vector2 origin, Vector2 direction, float distance= Mathf.Infinity, int layerMask= DefaultRaycastLayers, float minDepth= -Mathf.Infinity, float maxDepth= Mathf.Infinity);\n```\n\n参数\n\n| origin    | 射线在 2D 空间中的起点。                    |\n| --------- | ------------------------------------------- |\n| direction | 表示射线方向的矢量。                        |\n| distance  | 射线的最大投射距离。                        |\n| layerMask | 过滤器，用于仅在特定层上检测碰撞体。        |\n| minDepth  | 仅包括 Z 坐标（深度）大于或等于该值的对象。 |\n| maxDepth  | 仅包括 Z 坐标（深度）小于或等于该值的对象。 |\n\n返回**`RaycastHit2D`** 返回的投射数量。\n\n描述：\n\n向场景中的碰撞体投射射线。\n\n从概念上说，*射线投射* 类似于从空间中的某个点朝特定方向发射一条光束。在该过程中，可以检测并报告与光束接触的任何对象。\n\n函数返回一个 `RaycastHit` 对象，该对象引用了射线命中的碰撞体（如果未命中任何对象，则结果的碰撞体属性将为 NULL）。*`layerMask`* 可用于仅在特定层上有选择地检测对象（例如，这让您能够仅将检测应用于敌人角色）。\n\n使用 `contactFilter` 的此方法重载可以按 `ContactFilter2D` 中提供的选项筛选结果。\n\n对于确定视线、炮火击中的目标以及游戏中的许多其他目的来说，射线投射很有用。\n\n此外，这还将检测位于射线起点的碰撞体。在这种情况下，射线从碰撞体内部开始，并且不与碰撞体表面交叠。这意味着无法计算碰撞法线，在这种情况下，返回的碰撞法线设置为正在测试的射线向量的倒数。这可轻松检测到，因为此类结果始终是 `RaycastHit2D` 分数为零。\n\n\n\n---\n\n\n\n### 二、脚部、头顶碰撞\n\n1. 在`[Header(\"环境检测\")]`新建几个需要用到的变量\n\n```\n    [Header(\"环境检测\")]\n    public LayerMask groundLayer;\n    public float footOffset = 0.35f;\n    public float headClearance = 0.5f;\n    public float groundDistance = 0.2f;\n```\n\n\n\n2.重写一个射线检测的方法，包含射线可视化\n\n```\n    RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer)//自己封装的射线检测方法\n    {\n        Vector2 pos = transform.position;\n        RaycastHit2D hit = Physics2D.Raycast(pos + offset, rayDirection, length, layer);\n        Debug.DrawRay(pos + offset, rayDirection, hit ? Color.red : Color.green);\n        return hit;\n    }\n```\n\n\n\n3.更改地面检测函数`PhysicsCheck()`\n\n```\n    void PhysicsCheck()//检测是否在地面，并修改状态\n    {\n        RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);\n        RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);\n        isOnGround = leftCheck || rightCheck;\n\n    }\n```\n\n保存回到unity，运行\n\n角色碰撞体左右脚下方都出现了射线，并且会按照射线方向检测是否碰撞到地面，以此改变`isOnGround`，可以调整参数让检测距离更 “舒服”\n\n下面来增加头顶的检测\n\n\n\n4.在`[Header(\"角色状态\")]`中增加头顶状态 `public bool isHeadBlocked;`\n\n\n\n5.修改`PhysicsCheck()`：\n\n```\n    void PhysicsCheck()//检测是否在地面，并修改状态\n    {\n        RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);\n        RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);\n        isOnGround = leftCheck || rightCheck;\n\n        RaycastHit2D headCheck = Raycast(new Vector2(0f, cd.size.y), Vector2.up, headClearance, groundLayer);\n        isHeadBlocked = headCheck;\n    }\n```\n\n同样，修改`public`参数就可以调整检测距离（注意射线的长度不等于检测距离）\n\n\n\n---\n\n\n\n### 三、悬挂检测\n\n判断悬挂需要三条射线，分别是头顶射线，眼部射线，垂直射线。\n\n悬挂在边缘的条件：头顶射线**无**碰撞，眼部射线有碰撞，垂直射线**有**碰撞\n\n1.在`[Header(\"环境检测\")]`添加变量：\n\n```\n    [Header(\"环境检测\")]\n    //悬挂\n    public float playerHeight = 2f;\n    public float playerEyeHeight = 1.5f;\n    public float grabDistance = 0.2f;\n    public float reachOffset = 0.5f;\n```\n\n\n\n2.在`[Header(\"角色状态\")]`添加状态：\n\n```\n\t[Header(\"角色状态\")]\n    public bool isHanging;\n```\n\n\n\n3.在`PhysicsCheck()`中添加悬挂的各种射线生成以及悬挂状态判断：\n\n```\n    void PhysicsCheck()//物理检测，并修改状态\n    {\n        //悬挂系列射线\n        float direction = transform.localScale.x;\n        Vector2 grabDirection = new Vector2(direction, 0f);\n        RaycastHit2D blockedCheck = Raycast(new Vector2(direction * footOffset, playerHeight), grabDirection, grabDistance, groundLayer);\n        RaycastHit2D wallCheck = Raycast(new Vector2(direction * footOffset, playerEyeHeight), grabDirection, grabDistance, groundLayer);\n        RaycastHit2D ledgeCheck = Raycast(new Vector2(direction * reachOffset, playerHeight), Vector2.down, grabDistance, groundLayer);\n        if (!isOnGround && !blockedCheck && wallCheck && ledgeCheck && rb.velocity.y < 0f)\n        {\n            Vector3 pos = transform.position;\n            pos.x += (wallCheck.distance - 0.05f) * direction;\n            pos.y -= ledgeCheck.distance;\n            transform.position = pos; \n            rb.bodyType = RigidbodyType2D.Static;\n            isHanging = true;\n        }\n    }\n```\n\n其中`pos.x += (wallCheck.distance - 0.05f) * direction;`稍微调整一下悬挂的位置，可以按照图案的位置来调整\n\n\n\n4.悬挂状态已经设置好了，现在我们希望在悬挂时按跳跃键会有一个固定的跳跃高度，并且会取消刚体的锁定\n\n在`[Header(\"跳跃参数\")]`中添加：\n\n```\n\t[Header(\"跳跃参数\")]\n    public float hangingJumpForce = 15f;\n```\n\n\n\n5.在`MidAirMovement()`添加悬挂跳跃：\n\n```\n    void MidAirMovement()//空中移动\n    {\n        if (isHanging)//悬挂时两种选择\n        {\n            if (jumpPressed)\n            {\n                rb.bodyType = RigidbodyType2D.Dynamic;\n                rb.AddForce(new Vector2(0f, hangingJumpForce), ForceMode2D.Impulse);\n                //rb.velocity = new Vector2(rb.velocity.x, hangingJumpForce);\n                isHanging = false;\n            }\n            if (crouchPressed)\n            {\n                rb.bodyType = RigidbodyType2D.Dynamic;\n                crouchPressed = false;\n                isHanging = false;\n            } \n        }\n    }\n```\n\n其中`crouchPressed`要在`[Header(\"按键状态\")]`中设置好，并且在`Update()`中赋值，以此来和`crouchHeld`分开\n\n\n\n---\n\n\n\n### \t终、阶段总结\n\n到此为止，已经完成了各种基础运动的逻辑\n\n自我感觉有些状态的判断没有很好的归类，比如悬挂状态，应该和下蹲&站立一样新建一个悬挂的函数，在悬挂函数中完成悬挂的各种处理，最后使`isHanging = true`，这样代码应该会比较 ”整齐”\n","source":"_posts/2021-07-20-《Robbie Swifthand》Unity2d独立游戏学习（三）.md","raw":"---\ntitle: 《Robbie Swifthand》Unity2d独立游戏学习（三）\ndate: 2021-07-20 15:36:35\ncategories: unity\ntags:\n  - unity\n  - c#\n  - raycast\n---\n\n\n\n\n\n### \t始、前言\n\n简单的角色移动已经完成了，这次来学习用Raycast 射线检测的方法让角色的状态检测变得更细致\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、Physics2D.Raycast 脚本API\n\n```\npublic static RaycastHit2D Raycast (Vector2 origin, Vector2 direction, float distance= Mathf.Infinity, int layerMask= DefaultRaycastLayers, float minDepth= -Mathf.Infinity, float maxDepth= Mathf.Infinity);\n```\n\n参数\n\n| origin    | 射线在 2D 空间中的起点。                    |\n| --------- | ------------------------------------------- |\n| direction | 表示射线方向的矢量。                        |\n| distance  | 射线的最大投射距离。                        |\n| layerMask | 过滤器，用于仅在特定层上检测碰撞体。        |\n| minDepth  | 仅包括 Z 坐标（深度）大于或等于该值的对象。 |\n| maxDepth  | 仅包括 Z 坐标（深度）小于或等于该值的对象。 |\n\n返回**`RaycastHit2D`** 返回的投射数量。\n\n描述：\n\n向场景中的碰撞体投射射线。\n\n从概念上说，*射线投射* 类似于从空间中的某个点朝特定方向发射一条光束。在该过程中，可以检测并报告与光束接触的任何对象。\n\n函数返回一个 `RaycastHit` 对象，该对象引用了射线命中的碰撞体（如果未命中任何对象，则结果的碰撞体属性将为 NULL）。*`layerMask`* 可用于仅在特定层上有选择地检测对象（例如，这让您能够仅将检测应用于敌人角色）。\n\n使用 `contactFilter` 的此方法重载可以按 `ContactFilter2D` 中提供的选项筛选结果。\n\n对于确定视线、炮火击中的目标以及游戏中的许多其他目的来说，射线投射很有用。\n\n此外，这还将检测位于射线起点的碰撞体。在这种情况下，射线从碰撞体内部开始，并且不与碰撞体表面交叠。这意味着无法计算碰撞法线，在这种情况下，返回的碰撞法线设置为正在测试的射线向量的倒数。这可轻松检测到，因为此类结果始终是 `RaycastHit2D` 分数为零。\n\n\n\n---\n\n\n\n### 二、脚部、头顶碰撞\n\n1. 在`[Header(\"环境检测\")]`新建几个需要用到的变量\n\n```\n    [Header(\"环境检测\")]\n    public LayerMask groundLayer;\n    public float footOffset = 0.35f;\n    public float headClearance = 0.5f;\n    public float groundDistance = 0.2f;\n```\n\n\n\n2.重写一个射线检测的方法，包含射线可视化\n\n```\n    RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer)//自己封装的射线检测方法\n    {\n        Vector2 pos = transform.position;\n        RaycastHit2D hit = Physics2D.Raycast(pos + offset, rayDirection, length, layer);\n        Debug.DrawRay(pos + offset, rayDirection, hit ? Color.red : Color.green);\n        return hit;\n    }\n```\n\n\n\n3.更改地面检测函数`PhysicsCheck()`\n\n```\n    void PhysicsCheck()//检测是否在地面，并修改状态\n    {\n        RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);\n        RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);\n        isOnGround = leftCheck || rightCheck;\n\n    }\n```\n\n保存回到unity，运行\n\n角色碰撞体左右脚下方都出现了射线，并且会按照射线方向检测是否碰撞到地面，以此改变`isOnGround`，可以调整参数让检测距离更 “舒服”\n\n下面来增加头顶的检测\n\n\n\n4.在`[Header(\"角色状态\")]`中增加头顶状态 `public bool isHeadBlocked;`\n\n\n\n5.修改`PhysicsCheck()`：\n\n```\n    void PhysicsCheck()//检测是否在地面，并修改状态\n    {\n        RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);\n        RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);\n        isOnGround = leftCheck || rightCheck;\n\n        RaycastHit2D headCheck = Raycast(new Vector2(0f, cd.size.y), Vector2.up, headClearance, groundLayer);\n        isHeadBlocked = headCheck;\n    }\n```\n\n同样，修改`public`参数就可以调整检测距离（注意射线的长度不等于检测距离）\n\n\n\n---\n\n\n\n### 三、悬挂检测\n\n判断悬挂需要三条射线，分别是头顶射线，眼部射线，垂直射线。\n\n悬挂在边缘的条件：头顶射线**无**碰撞，眼部射线有碰撞，垂直射线**有**碰撞\n\n1.在`[Header(\"环境检测\")]`添加变量：\n\n```\n    [Header(\"环境检测\")]\n    //悬挂\n    public float playerHeight = 2f;\n    public float playerEyeHeight = 1.5f;\n    public float grabDistance = 0.2f;\n    public float reachOffset = 0.5f;\n```\n\n\n\n2.在`[Header(\"角色状态\")]`添加状态：\n\n```\n\t[Header(\"角色状态\")]\n    public bool isHanging;\n```\n\n\n\n3.在`PhysicsCheck()`中添加悬挂的各种射线生成以及悬挂状态判断：\n\n```\n    void PhysicsCheck()//物理检测，并修改状态\n    {\n        //悬挂系列射线\n        float direction = transform.localScale.x;\n        Vector2 grabDirection = new Vector2(direction, 0f);\n        RaycastHit2D blockedCheck = Raycast(new Vector2(direction * footOffset, playerHeight), grabDirection, grabDistance, groundLayer);\n        RaycastHit2D wallCheck = Raycast(new Vector2(direction * footOffset, playerEyeHeight), grabDirection, grabDistance, groundLayer);\n        RaycastHit2D ledgeCheck = Raycast(new Vector2(direction * reachOffset, playerHeight), Vector2.down, grabDistance, groundLayer);\n        if (!isOnGround && !blockedCheck && wallCheck && ledgeCheck && rb.velocity.y < 0f)\n        {\n            Vector3 pos = transform.position;\n            pos.x += (wallCheck.distance - 0.05f) * direction;\n            pos.y -= ledgeCheck.distance;\n            transform.position = pos; \n            rb.bodyType = RigidbodyType2D.Static;\n            isHanging = true;\n        }\n    }\n```\n\n其中`pos.x += (wallCheck.distance - 0.05f) * direction;`稍微调整一下悬挂的位置，可以按照图案的位置来调整\n\n\n\n4.悬挂状态已经设置好了，现在我们希望在悬挂时按跳跃键会有一个固定的跳跃高度，并且会取消刚体的锁定\n\n在`[Header(\"跳跃参数\")]`中添加：\n\n```\n\t[Header(\"跳跃参数\")]\n    public float hangingJumpForce = 15f;\n```\n\n\n\n5.在`MidAirMovement()`添加悬挂跳跃：\n\n```\n    void MidAirMovement()//空中移动\n    {\n        if (isHanging)//悬挂时两种选择\n        {\n            if (jumpPressed)\n            {\n                rb.bodyType = RigidbodyType2D.Dynamic;\n                rb.AddForce(new Vector2(0f, hangingJumpForce), ForceMode2D.Impulse);\n                //rb.velocity = new Vector2(rb.velocity.x, hangingJumpForce);\n                isHanging = false;\n            }\n            if (crouchPressed)\n            {\n                rb.bodyType = RigidbodyType2D.Dynamic;\n                crouchPressed = false;\n                isHanging = false;\n            } \n        }\n    }\n```\n\n其中`crouchPressed`要在`[Header(\"按键状态\")]`中设置好，并且在`Update()`中赋值，以此来和`crouchHeld`分开\n\n\n\n---\n\n\n\n### \t终、阶段总结\n\n到此为止，已经完成了各种基础运动的逻辑\n\n自我感觉有些状态的判断没有很好的归类，比如悬挂状态，应该和下蹲&站立一样新建一个悬挂的函数，在悬挂函数中完成悬挂的各种处理，最后使`isHanging = true`，这样代码应该会比较 ”整齐”\n","slug":"2021-07-20-《Robbie Swifthand》Unity2d独立游戏学习（三）","published":1,"updated":"2021-07-21T08:17:18.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hg000v1ou014tocspq","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>简单的角色移动已经完成了，这次来学习用Raycast 射线检测的方法让角色的状态检测变得更细致</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、Physics2D-Raycast-脚本API\"><a href=\"#一、Physics2D-Raycast-脚本API\" class=\"headerlink\" title=\"一、Physics2D.Raycast 脚本API\"></a>一、Physics2D.Raycast 脚本API</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static RaycastHit2D Raycast (Vector2 origin, Vector2 direction, float distance= Mathf.Infinity, int layerMask= DefaultRaycastLayers, float minDepth= -Mathf.Infinity, float maxDepth= Mathf.Infinity);</span><br></pre></td></tr></table></figure>\n\n<p>参数</p>\n<table>\n<thead>\n<tr>\n<th>origin</th>\n<th>射线在 2D 空间中的起点。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>direction</td>\n<td>表示射线方向的矢量。</td>\n</tr>\n<tr>\n<td>distance</td>\n<td>射线的最大投射距离。</td>\n</tr>\n<tr>\n<td>layerMask</td>\n<td>过滤器，用于仅在特定层上检测碰撞体。</td>\n</tr>\n<tr>\n<td>minDepth</td>\n<td>仅包括 Z 坐标（深度）大于或等于该值的对象。</td>\n</tr>\n<tr>\n<td>maxDepth</td>\n<td>仅包括 Z 坐标（深度）小于或等于该值的对象。</td>\n</tr>\n</tbody></table>\n<p>返回**<code>RaycastHit2D</code>** 返回的投射数量。</p>\n<p>描述：</p>\n<p>向场景中的碰撞体投射射线。</p>\n<p>从概念上说，<em>射线投射</em> 类似于从空间中的某个点朝特定方向发射一条光束。在该过程中，可以检测并报告与光束接触的任何对象。</p>\n<p>函数返回一个 <code>RaycastHit</code> 对象，该对象引用了射线命中的碰撞体（如果未命中任何对象，则结果的碰撞体属性将为 NULL）。*<code>layerMask</code>* 可用于仅在特定层上有选择地检测对象（例如，这让您能够仅将检测应用于敌人角色）。</p>\n<p>使用 <code>contactFilter</code> 的此方法重载可以按 <code>ContactFilter2D</code> 中提供的选项筛选结果。</p>\n<p>对于确定视线、炮火击中的目标以及游戏中的许多其他目的来说，射线投射很有用。</p>\n<p>此外，这还将检测位于射线起点的碰撞体。在这种情况下，射线从碰撞体内部开始，并且不与碰撞体表面交叠。这意味着无法计算碰撞法线，在这种情况下，返回的碰撞法线设置为正在测试的射线向量的倒数。这可轻松检测到，因为此类结果始终是 <code>RaycastHit2D</code> 分数为零。</p>\n<hr>\n<h3 id=\"二、脚部、头顶碰撞\"><a href=\"#二、脚部、头顶碰撞\" class=\"headerlink\" title=\"二、脚部、头顶碰撞\"></a>二、脚部、头顶碰撞</h3><ol>\n<li>在<code>[Header(&quot;环境检测&quot;)]</code>新建几个需要用到的变量</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;环境检测&quot;)]</span><br><span class=\"line\">public LayerMask groundLayer;</span><br><span class=\"line\">public float footOffset = 0.35f;</span><br><span class=\"line\">public float headClearance = 0.5f;</span><br><span class=\"line\">public float groundDistance = 0.2f;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.重写一个射线检测的方法，包含射线可视化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer)//自己封装的射线检测方法</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector2 pos = transform.position;</span><br><span class=\"line\">    RaycastHit2D hit = Physics2D.Raycast(pos + offset, rayDirection, length, layer);</span><br><span class=\"line\">    Debug.DrawRay(pos + offset, rayDirection, hit ? Color.red : Color.green);</span><br><span class=\"line\">    return hit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>3.更改地面检测函数<code>PhysicsCheck()</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class=\"line\">    RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class=\"line\">    isOnGround = leftCheck || rightCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>保存回到unity，运行</p>\n<p>角色碰撞体左右脚下方都出现了射线，并且会按照射线方向检测是否碰撞到地面，以此改变<code>isOnGround</code>，可以调整参数让检测距离更 “舒服”</p>\n<p>下面来增加头顶的检测</p>\n<p>4.在<code>[Header(&quot;角色状态&quot;)]</code>中增加头顶状态 <code>public bool isHeadBlocked;</code></p>\n<p>5.修改<code>PhysicsCheck()</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class=\"line\">    RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class=\"line\">    isOnGround = leftCheck || rightCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">    RaycastHit2D headCheck = Raycast(new Vector2(0f, cd.size.y), Vector2.up, headClearance, groundLayer);</span><br><span class=\"line\">    isHeadBlocked = headCheck;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样，修改<code>public</code>参数就可以调整检测距离（注意射线的长度不等于检测距离）</p>\n<hr>\n<h3 id=\"三、悬挂检测\"><a href=\"#三、悬挂检测\" class=\"headerlink\" title=\"三、悬挂检测\"></a>三、悬挂检测</h3><p>判断悬挂需要三条射线，分别是头顶射线，眼部射线，垂直射线。</p>\n<p>悬挂在边缘的条件：头顶射线<strong>无</strong>碰撞，眼部射线有碰撞，垂直射线<strong>有</strong>碰撞</p>\n<p>1.在<code>[Header(&quot;环境检测&quot;)]</code>添加变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;环境检测&quot;)]</span><br><span class=\"line\">//悬挂</span><br><span class=\"line\">public float playerHeight = 2f;</span><br><span class=\"line\">public float playerEyeHeight = 1.5f;</span><br><span class=\"line\">public float grabDistance = 0.2f;</span><br><span class=\"line\">public float reachOffset = 0.5f;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.在<code>[Header(&quot;角色状态&quot;)]</code>添加状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;角色状态&quot;)]</span><br><span class=\"line\">   public bool isHanging;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>3.在<code>PhysicsCheck()</code>中添加悬挂的各种射线生成以及悬挂状态判断：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void PhysicsCheck()//物理检测，并修改状态</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //悬挂系列射线</span><br><span class=\"line\">    float direction = transform.localScale.x;</span><br><span class=\"line\">    Vector2 grabDirection = new Vector2(direction, 0f);</span><br><span class=\"line\">    RaycastHit2D blockedCheck = Raycast(new Vector2(direction * footOffset, playerHeight), grabDirection, grabDistance, groundLayer);</span><br><span class=\"line\">    RaycastHit2D wallCheck = Raycast(new Vector2(direction * footOffset, playerEyeHeight), grabDirection, grabDistance, groundLayer);</span><br><span class=\"line\">    RaycastHit2D ledgeCheck = Raycast(new Vector2(direction * reachOffset, playerHeight), Vector2.down, grabDistance, groundLayer);</span><br><span class=\"line\">    if (!isOnGround &amp;&amp; !blockedCheck &amp;&amp; wallCheck &amp;&amp; ledgeCheck &amp;&amp; rb.velocity.y &lt; 0f)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Vector3 pos = transform.position;</span><br><span class=\"line\">        pos.x += (wallCheck.distance - 0.05f) * direction;</span><br><span class=\"line\">        pos.y -= ledgeCheck.distance;</span><br><span class=\"line\">        transform.position = pos; </span><br><span class=\"line\">        rb.bodyType = RigidbodyType2D.Static;</span><br><span class=\"line\">        isHanging = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>pos.x += (wallCheck.distance - 0.05f) * direction;</code>稍微调整一下悬挂的位置，可以按照图案的位置来调整</p>\n<p>4.悬挂状态已经设置好了，现在我们希望在悬挂时按跳跃键会有一个固定的跳跃高度，并且会取消刚体的锁定</p>\n<p>在<code>[Header(&quot;跳跃参数&quot;)]</code>中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;跳跃参数&quot;)]</span><br><span class=\"line\">   public float hangingJumpForce = 15f;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>5.在<code>MidAirMovement()</code>添加悬挂跳跃：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void MidAirMovement()//空中移动</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (isHanging)//悬挂时两种选择</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (jumpPressed)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rb.bodyType = RigidbodyType2D.Dynamic;</span><br><span class=\"line\">            rb.AddForce(new Vector2(0f, hangingJumpForce), ForceMode2D.Impulse);</span><br><span class=\"line\">            //rb.velocity = new Vector2(rb.velocity.x, hangingJumpForce);</span><br><span class=\"line\">            isHanging = false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (crouchPressed)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rb.bodyType = RigidbodyType2D.Dynamic;</span><br><span class=\"line\">            crouchPressed = false;</span><br><span class=\"line\">            isHanging = false;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>crouchPressed</code>要在<code>[Header(&quot;按键状态&quot;)]</code>中设置好，并且在<code>Update()</code>中赋值，以此来和<code>crouchHeld</code>分开</p>\n<hr>\n<h3 id=\"终、阶段总结\"><a href=\"#终、阶段总结\" class=\"headerlink\" title=\"终、阶段总结\"></a>终、阶段总结</h3><p>到此为止，已经完成了各种基础运动的逻辑</p>\n<p>自我感觉有些状态的判断没有很好的归类，比如悬挂状态，应该和下蹲&amp;站立一样新建一个悬挂的函数，在悬挂函数中完成悬挂的各种处理，最后使<code>isHanging = true</code>，这样代码应该会比较 ”整齐”</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>简单的角色移动已经完成了，这次来学习用Raycast 射线检测的方法让角色的状态检测变得更细致</p>","more":"<hr>\n<h3 id=\"一、Physics2D-Raycast-脚本API\"><a href=\"#一、Physics2D-Raycast-脚本API\" class=\"headerlink\" title=\"一、Physics2D.Raycast 脚本API\"></a>一、Physics2D.Raycast 脚本API</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static RaycastHit2D Raycast (Vector2 origin, Vector2 direction, float distance= Mathf.Infinity, int layerMask= DefaultRaycastLayers, float minDepth= -Mathf.Infinity, float maxDepth= Mathf.Infinity);</span><br></pre></td></tr></table></figure>\n\n<p>参数</p>\n<table>\n<thead>\n<tr>\n<th>origin</th>\n<th>射线在 2D 空间中的起点。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>direction</td>\n<td>表示射线方向的矢量。</td>\n</tr>\n<tr>\n<td>distance</td>\n<td>射线的最大投射距离。</td>\n</tr>\n<tr>\n<td>layerMask</td>\n<td>过滤器，用于仅在特定层上检测碰撞体。</td>\n</tr>\n<tr>\n<td>minDepth</td>\n<td>仅包括 Z 坐标（深度）大于或等于该值的对象。</td>\n</tr>\n<tr>\n<td>maxDepth</td>\n<td>仅包括 Z 坐标（深度）小于或等于该值的对象。</td>\n</tr>\n</tbody></table>\n<p>返回**<code>RaycastHit2D</code>** 返回的投射数量。</p>\n<p>描述：</p>\n<p>向场景中的碰撞体投射射线。</p>\n<p>从概念上说，<em>射线投射</em> 类似于从空间中的某个点朝特定方向发射一条光束。在该过程中，可以检测并报告与光束接触的任何对象。</p>\n<p>函数返回一个 <code>RaycastHit</code> 对象，该对象引用了射线命中的碰撞体（如果未命中任何对象，则结果的碰撞体属性将为 NULL）。*<code>layerMask</code>* 可用于仅在特定层上有选择地检测对象（例如，这让您能够仅将检测应用于敌人角色）。</p>\n<p>使用 <code>contactFilter</code> 的此方法重载可以按 <code>ContactFilter2D</code> 中提供的选项筛选结果。</p>\n<p>对于确定视线、炮火击中的目标以及游戏中的许多其他目的来说，射线投射很有用。</p>\n<p>此外，这还将检测位于射线起点的碰撞体。在这种情况下，射线从碰撞体内部开始，并且不与碰撞体表面交叠。这意味着无法计算碰撞法线，在这种情况下，返回的碰撞法线设置为正在测试的射线向量的倒数。这可轻松检测到，因为此类结果始终是 <code>RaycastHit2D</code> 分数为零。</p>\n<hr>\n<h3 id=\"二、脚部、头顶碰撞\"><a href=\"#二、脚部、头顶碰撞\" class=\"headerlink\" title=\"二、脚部、头顶碰撞\"></a>二、脚部、头顶碰撞</h3><ol>\n<li>在<code>[Header(&quot;环境检测&quot;)]</code>新建几个需要用到的变量</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;环境检测&quot;)]</span><br><span class=\"line\">public LayerMask groundLayer;</span><br><span class=\"line\">public float footOffset = 0.35f;</span><br><span class=\"line\">public float headClearance = 0.5f;</span><br><span class=\"line\">public float groundDistance = 0.2f;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.重写一个射线检测的方法，包含射线可视化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer)//自己封装的射线检测方法</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector2 pos = transform.position;</span><br><span class=\"line\">    RaycastHit2D hit = Physics2D.Raycast(pos + offset, rayDirection, length, layer);</span><br><span class=\"line\">    Debug.DrawRay(pos + offset, rayDirection, hit ? Color.red : Color.green);</span><br><span class=\"line\">    return hit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>3.更改地面检测函数<code>PhysicsCheck()</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class=\"line\">    RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class=\"line\">    isOnGround = leftCheck || rightCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>保存回到unity，运行</p>\n<p>角色碰撞体左右脚下方都出现了射线，并且会按照射线方向检测是否碰撞到地面，以此改变<code>isOnGround</code>，可以调整参数让检测距离更 “舒服”</p>\n<p>下面来增加头顶的检测</p>\n<p>4.在<code>[Header(&quot;角色状态&quot;)]</code>中增加头顶状态 <code>public bool isHeadBlocked;</code></p>\n<p>5.修改<code>PhysicsCheck()</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class=\"line\">    RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class=\"line\">    isOnGround = leftCheck || rightCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">    RaycastHit2D headCheck = Raycast(new Vector2(0f, cd.size.y), Vector2.up, headClearance, groundLayer);</span><br><span class=\"line\">    isHeadBlocked = headCheck;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样，修改<code>public</code>参数就可以调整检测距离（注意射线的长度不等于检测距离）</p>\n<hr>\n<h3 id=\"三、悬挂检测\"><a href=\"#三、悬挂检测\" class=\"headerlink\" title=\"三、悬挂检测\"></a>三、悬挂检测</h3><p>判断悬挂需要三条射线，分别是头顶射线，眼部射线，垂直射线。</p>\n<p>悬挂在边缘的条件：头顶射线<strong>无</strong>碰撞，眼部射线有碰撞，垂直射线<strong>有</strong>碰撞</p>\n<p>1.在<code>[Header(&quot;环境检测&quot;)]</code>添加变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;环境检测&quot;)]</span><br><span class=\"line\">//悬挂</span><br><span class=\"line\">public float playerHeight = 2f;</span><br><span class=\"line\">public float playerEyeHeight = 1.5f;</span><br><span class=\"line\">public float grabDistance = 0.2f;</span><br><span class=\"line\">public float reachOffset = 0.5f;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.在<code>[Header(&quot;角色状态&quot;)]</code>添加状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;角色状态&quot;)]</span><br><span class=\"line\">   public bool isHanging;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>3.在<code>PhysicsCheck()</code>中添加悬挂的各种射线生成以及悬挂状态判断：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void PhysicsCheck()//物理检测，并修改状态</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //悬挂系列射线</span><br><span class=\"line\">    float direction = transform.localScale.x;</span><br><span class=\"line\">    Vector2 grabDirection = new Vector2(direction, 0f);</span><br><span class=\"line\">    RaycastHit2D blockedCheck = Raycast(new Vector2(direction * footOffset, playerHeight), grabDirection, grabDistance, groundLayer);</span><br><span class=\"line\">    RaycastHit2D wallCheck = Raycast(new Vector2(direction * footOffset, playerEyeHeight), grabDirection, grabDistance, groundLayer);</span><br><span class=\"line\">    RaycastHit2D ledgeCheck = Raycast(new Vector2(direction * reachOffset, playerHeight), Vector2.down, grabDistance, groundLayer);</span><br><span class=\"line\">    if (!isOnGround &amp;&amp; !blockedCheck &amp;&amp; wallCheck &amp;&amp; ledgeCheck &amp;&amp; rb.velocity.y &lt; 0f)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Vector3 pos = transform.position;</span><br><span class=\"line\">        pos.x += (wallCheck.distance - 0.05f) * direction;</span><br><span class=\"line\">        pos.y -= ledgeCheck.distance;</span><br><span class=\"line\">        transform.position = pos; </span><br><span class=\"line\">        rb.bodyType = RigidbodyType2D.Static;</span><br><span class=\"line\">        isHanging = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>pos.x += (wallCheck.distance - 0.05f) * direction;</code>稍微调整一下悬挂的位置，可以按照图案的位置来调整</p>\n<p>4.悬挂状态已经设置好了，现在我们希望在悬挂时按跳跃键会有一个固定的跳跃高度，并且会取消刚体的锁定</p>\n<p>在<code>[Header(&quot;跳跃参数&quot;)]</code>中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;跳跃参数&quot;)]</span><br><span class=\"line\">   public float hangingJumpForce = 15f;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>5.在<code>MidAirMovement()</code>添加悬挂跳跃：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void MidAirMovement()//空中移动</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (isHanging)//悬挂时两种选择</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (jumpPressed)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rb.bodyType = RigidbodyType2D.Dynamic;</span><br><span class=\"line\">            rb.AddForce(new Vector2(0f, hangingJumpForce), ForceMode2D.Impulse);</span><br><span class=\"line\">            //rb.velocity = new Vector2(rb.velocity.x, hangingJumpForce);</span><br><span class=\"line\">            isHanging = false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (crouchPressed)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rb.bodyType = RigidbodyType2D.Dynamic;</span><br><span class=\"line\">            crouchPressed = false;</span><br><span class=\"line\">            isHanging = false;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>crouchPressed</code>要在<code>[Header(&quot;按键状态&quot;)]</code>中设置好，并且在<code>Update()</code>中赋值，以此来和<code>crouchHeld</code>分开</p>\n<hr>\n<h3 id=\"终、阶段总结\"><a href=\"#终、阶段总结\" class=\"headerlink\" title=\"终、阶段总结\"></a>终、阶段总结</h3><p>到此为止，已经完成了各种基础运动的逻辑</p>\n<p>自我感觉有些状态的判断没有很好的归类，比如悬挂状态，应该和下蹲&amp;站立一样新建一个悬挂的函数，在悬挂函数中完成悬挂的各种处理，最后使<code>isHanging = true</code>，这样代码应该会比较 ”整齐”</p>"},{"title":"《Robbie Swifthand》Unity2d独立游戏学习（二）","date":"2021-07-19T07:23:30.000Z","_content":"\n\n\n### \t一、添加物理组件\n\n1.给Platforms 添加Tilemap Collider 2D，勾选Used By Composite，添加Composite Collider 2D\n\n2.将Platforms自动添加的Rigidbody 2D 选择成Static 模式\n\n3.给主角添加Rigidbody 2D，把Collision Detection选择成Continuous连续不断地检测碰撞，把Interpolate 设置成Interpolate产生碰撞时会有一个缓冲的效果\n\n4.添加Box Collider 2D，调整主角碰撞器大小，size - y 最好设置在 2 以下，这样就可以通过两格高的空间\n\n5.运行，发现在角落处下落会导致角色翻转，需要在主角Rigidbody 2D 中锁定 z 轴\n\n6.为了避免角色碰到墙壁时会卡进墙体里，给主角Box Collider 2D添加Material 物理材质Teflon（资源包里的，摩擦力和弹力都是0）\n\n7.新增Layer ，主角设置成Player，Platforms 设置成Ground，以供后面进行碰撞检测\n\n\n\n<!--more-->\n\n\n\n---\n\n\n\n### 二、角色移动\n\n1.在Scripts文件夹新建PlayerMovement脚本，编写代码：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerMovement : MonoBehaviour\n{\n    private Rigidbody2D rb;\n\n    [Header(\"移动参数\")]\n    public float speed = 10f;\n    public float crouchSpeedDivisor = 5f;\n    private float xVelocity;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n    }\n\n    void Update()//每帧调用\n    {\n        \n    }\n\n    private void FixedUpdate()//每一段时间调用，默认0.02s\n    {\n        GroundMovement();\n    }\n\n    void GroundMovement()\n    {\n        xVelocity = Input.GetAxis(\"Horizontal\");//-1f ~ 1f\n        //在FixedUpdate()中调用无需Time.deltatime\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n        flipDirection();\n    }\n\n\n    void flipDirection()\n    {\n        if (xVelocity > 0) transform.localScale = new Vector2 (1, 1);\n        else if (xVelocity < 0) transform.localScale = new Vector2(-1, 1);\n    }\n}\n```\n\n键盘左右键可以让主角左右移动，并且会改变图案方向\n\n\n\n---\n\n\n\n### 三、下蹲\n\n1.打开Edit - Project Settings - Input ，复制Jump 命名为Crouch，Positive Button 改为down，Alt Positive Button 改为 s\n\n2.修改角色移动代码：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerMovement : MonoBehaviour\n{\n    private Rigidbody2D rb;\n    private BoxCollider2D cd;\n\n    [Header(\"移动参数\")]\n    public float speed = 10f;\n    public float crouchSpeedFactor = 0.5f;\n    private float xVelocity;\n\n    [Header(\"角色状态\")]\n    public bool isCrouch;\n\n    //碰撞体尺寸\n    private Vector2 crouchOffset;\n    private Vector2 crouchSize;\n    private Vector2 standOffset;\n    private Vector2 standSize;\n\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        cd = GetComponent<BoxCollider2D>();\n\n        standOffset = cd.offset;\n        standSize = cd.size;\n        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);\n        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);\n    }\n\n\n    void Update()//每帧调用\n    {\n        \n    }\n\n\n    private void FixedUpdate()//每一段时间调用，默认0.02s\n    {\n        GroundMovement();\n    }\n    void GroundMovement()//移动的各种数值\n    {\n        xVelocity = Input.GetAxis(\"Horizontal\");//-1f ~ 1f\n        if (Input.GetButton(\"Crouch\")) Crouch();\n        else if (isCrouch) StandUp();\n\n        //在FixedUpdate()中调用无需Time.deltatime\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n        flipDirection();\n    }\n    void flipDirection()//改变角色图案方向\n    {\n        if (xVelocity > 0) transform.localScale = new Vector2 (1, 1);\n        else if (xVelocity < 0) transform.localScale = new Vector2(-1, 1);\n    }\n\n    void Crouch()//下蹲时的各种改变\n    {\n        isCrouch = true;\n        xVelocity *= crouchSpeedFactor;\n        cd.size = crouchSize;\n        cd.offset = crouchOffset;\n    }\n    void StandUp()//从下蹲转变为站立时各种变化\n    {\n        isCrouch = false;\n        xVelocity /= crouchSpeedFactor;\n        cd.size = standSize;\n        cd.offset = standOffset;\n    }\n}\n```\n\n顺便给每个函数添加了注释\n\n现在，按下s键或者方向下键就会让角色的碰撞体 “蹲下\" （移动速度变慢并且碰撞体高度减半）\n\n\n\n测试一下确实可以通过高度为1的障碍了，但是在经过障碍的途中如果松开下蹲键，就会穿模卡在墙里，因为缺少了在通过障碍时需要持续下蹲的判断，这一部分放到后面再处理\n\n\n\n---\n\n\n\n### 四、跳跃\n\n1.打开Edit - Project Setting - Physics 2D，将 y 轴重力改大一点，这里改为-50\n\n2.先添加与跳跃有关的参数：\n\n```\n    [Header(\"跳跃参数\")]\n    public float jumpForce = 5f;\n    public float jumpHoldForce = 3f;\n    public float jumpHoldDuration = 0.1f;\n    public float crouchJumpBoost = 3f;\n    float jumpTime;\n```\n\n其中jumpTime 是允许长按跳跃加高的时间\n\n\n\n3.添加判断各种状态的参数：\n\n```\n    [Header(\"按键状态\")]\n    public bool jumpPressed;\n    public bool jumpHeld;\n    public bool crouchHeld;\n\n    [Header(\"角色状态\")]\n    public bool isCrouch;\n    public bool isOnGround;\n    public bool isJump;\n\n    [Header(\"环境检测\")]\n    public LayerMask groundLayer;\n```\n\n同时可以更新一下之前的下蹲判断，用刚刚定义的状态参数\n\n\n\n4.在Update（）中获取按键信息：\n\n```\n    void Update()//每帧调用\n    {\n        //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化\n        if (Input.GetButtonDown(\"Jump\")) jumpPressed = true;\n\n        jumpHeld = Input.GetButton(\"Jump\");\n        crouchHeld = Input.GetButton(\"Crouch\");\n    }\n```\n\n\n\n5.添加判断是否在地面上：\n\n```\n\tvoid PhysicsCheck()//检测是否在地面，并修改状态\n    {\n        isOnGround = cd.IsTouchingLayers(groundLayer);\n\n    }\n```\n\n记得在FixedUpdate（）中调用，物理性质都推荐放在FixedUpdate中\n\n\n\n6.添加跳跃函数：\n\n```\n    void MidAirMovement()//跳跃移动\n    {\n        if(jumpPressed && isOnGround && !isJump)//起跳\n        {\n            if(crouchHeld)//判断是否要蹲跳\n            {\n                rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);\n            }\n            jumpTime = Time.time + jumpHoldDuration;\n            rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);\n            jumpPressed = false;\n            isJump = true;\n        }\n\n        else if(isJump)\n        {\n            if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);\n            if (jumpTime < Time.time) isJump = false;\n        }\n\n    }\n```\n\n精髓就是`jumpTime = Time.time + jumpHoldDuration;`，`if (jumpTime < Time.time) isJump = false;` \n\n这两句代码可以很好地对能否在空中持续加速进行判断\n\n\n\n---\n\n\n\n### 终、总结\n\n这次的跳跃代码真的收获不少，Update和FixedUpdate可以理解成完全独立的两个函数\n\n这一波折腾下来角色控制脚本 PlayerMovement 有点长了，这里先全部放上来记录一下，以便日后回顾\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerMovement : MonoBehaviour\n{\n    //组件\n    private Rigidbody2D rb;\n    private BoxCollider2D cd;\n\n    [Header(\"移动参数\")]\n    public float speed = 10f;\n    public float crouchSpeedFactor = 0.5f;\n    float xVelocity;\n\n    [Header(\"跳跃参数\")]\n    public float jumpForce = 5f;\n    public float jumpHoldForce = 3f;\n    public float jumpHoldDuration = 0.1f;\n    public float crouchJumpBoost = 3f;\n    float jumpTime;\n\n    [Header(\"按键状态\")]\n    public bool jumpPressed;\n    public bool jumpHeld;\n    public bool crouchHeld;\n\n    [Header(\"角色状态\")]\n    public bool isCrouch;\n    public bool isOnGround;\n    public bool isJump;\n\n    [Header(\"环境检测\")]\n    public LayerMask groundLayer;\n\n    //碰撞体尺寸\n    private Vector2 crouchOffset;\n    private Vector2 crouchSize;\n    private Vector2 standOffset;\n    private Vector2 standSize;\n\n    void Start()\n    {\n        //获取组件\n        rb = GetComponent<Rigidbody2D>();\n        cd = GetComponent<BoxCollider2D>();\n\n        //初始化\n        standOffset = cd.offset;\n        standSize = cd.size;\n        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);\n        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);\n    }\n\n\n    void Update()//每帧调用\n    {\n        //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化\n        if (Input.GetButtonDown(\"Jump\")) jumpPressed = true;\n\n        jumpHeld = Input.GetButton(\"Jump\");\n        crouchHeld = Input.GetButton(\"Crouch\");\n    }\n\n\n    private void FixedUpdate()//每一段时间调用，unity默认0.02s\n    {\n        PhysicsCheck();\n        GroundMovement();\n        MidAirMovement();\n    }\n\n    void PhysicsCheck()//检测是否在地面，并修改状态\n    {\n        isOnGround = cd.IsTouchingLayers(groundLayer);\n\n    }\n\n\n    void GroundMovement()//移动的各种数值\n    {\n        xVelocity = Input.GetAxis(\"Horizontal\");//-1f ~ 1f\n        if (crouchHeld && !isCrouch && isOnGround) Crouch();\n        else if ((isCrouch && !crouchHeld) || isJump) StandUp();\n\n\n        //在FixedUpdate()中调用无需Time.deltatime\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n        flipDirection();\n    }\n\n    void MidAirMovement()//跳跃移动\n    {\n        if(jumpPressed && isOnGround && !isJump)//起跳\n        {\n            if(crouchHeld)//判断是否要蹲跳\n            {\n                rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);\n            }\n            jumpTime = Time.time + jumpHoldDuration;\n            rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);\n            jumpPressed = false;\n            isJump = true;\n        }\n\n        else if(isJump)\n        {\n            if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);\n            if (jumpTime < Time.time) isJump = false;\n        }\n\n    }\n\n    void flipDirection()//改变角色图案方向\n    {\n        if (xVelocity > 0) transform.localScale = new Vector2 (1, 1);\n        else if (xVelocity < 0) transform.localScale = new Vector2(-1, 1);\n    }\n\n    void Crouch()//下蹲时的各种改变\n    {\n        isCrouch = true;\n        xVelocity *= crouchSpeedFactor;\n        cd.size = crouchSize;\n        cd.offset = crouchOffset;\n    }\n\n    void StandUp()//从下蹲转变为站立时各种变化\n    {\n        isCrouch = false;\n        xVelocity /= crouchSpeedFactor;\n        cd.size = standSize;\n        cd.offset = standOffset;\n    }\n}\n```\n\n","source":"_posts/2021-07-19-《Robbie Swifthand》Unity2d独立游戏学习（二）.md","raw":"---\ntitle: 《Robbie Swifthand》Unity2d独立游戏学习（二）\ndate: 2021-07-19 15:23:30\ncategories: unity\ntags:\n  - unity\n  - c#\n  - update\n---\n\n\n\n### \t一、添加物理组件\n\n1.给Platforms 添加Tilemap Collider 2D，勾选Used By Composite，添加Composite Collider 2D\n\n2.将Platforms自动添加的Rigidbody 2D 选择成Static 模式\n\n3.给主角添加Rigidbody 2D，把Collision Detection选择成Continuous连续不断地检测碰撞，把Interpolate 设置成Interpolate产生碰撞时会有一个缓冲的效果\n\n4.添加Box Collider 2D，调整主角碰撞器大小，size - y 最好设置在 2 以下，这样就可以通过两格高的空间\n\n5.运行，发现在角落处下落会导致角色翻转，需要在主角Rigidbody 2D 中锁定 z 轴\n\n6.为了避免角色碰到墙壁时会卡进墙体里，给主角Box Collider 2D添加Material 物理材质Teflon（资源包里的，摩擦力和弹力都是0）\n\n7.新增Layer ，主角设置成Player，Platforms 设置成Ground，以供后面进行碰撞检测\n\n\n\n<!--more-->\n\n\n\n---\n\n\n\n### 二、角色移动\n\n1.在Scripts文件夹新建PlayerMovement脚本，编写代码：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerMovement : MonoBehaviour\n{\n    private Rigidbody2D rb;\n\n    [Header(\"移动参数\")]\n    public float speed = 10f;\n    public float crouchSpeedDivisor = 5f;\n    private float xVelocity;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n    }\n\n    void Update()//每帧调用\n    {\n        \n    }\n\n    private void FixedUpdate()//每一段时间调用，默认0.02s\n    {\n        GroundMovement();\n    }\n\n    void GroundMovement()\n    {\n        xVelocity = Input.GetAxis(\"Horizontal\");//-1f ~ 1f\n        //在FixedUpdate()中调用无需Time.deltatime\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n        flipDirection();\n    }\n\n\n    void flipDirection()\n    {\n        if (xVelocity > 0) transform.localScale = new Vector2 (1, 1);\n        else if (xVelocity < 0) transform.localScale = new Vector2(-1, 1);\n    }\n}\n```\n\n键盘左右键可以让主角左右移动，并且会改变图案方向\n\n\n\n---\n\n\n\n### 三、下蹲\n\n1.打开Edit - Project Settings - Input ，复制Jump 命名为Crouch，Positive Button 改为down，Alt Positive Button 改为 s\n\n2.修改角色移动代码：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerMovement : MonoBehaviour\n{\n    private Rigidbody2D rb;\n    private BoxCollider2D cd;\n\n    [Header(\"移动参数\")]\n    public float speed = 10f;\n    public float crouchSpeedFactor = 0.5f;\n    private float xVelocity;\n\n    [Header(\"角色状态\")]\n    public bool isCrouch;\n\n    //碰撞体尺寸\n    private Vector2 crouchOffset;\n    private Vector2 crouchSize;\n    private Vector2 standOffset;\n    private Vector2 standSize;\n\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        cd = GetComponent<BoxCollider2D>();\n\n        standOffset = cd.offset;\n        standSize = cd.size;\n        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);\n        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);\n    }\n\n\n    void Update()//每帧调用\n    {\n        \n    }\n\n\n    private void FixedUpdate()//每一段时间调用，默认0.02s\n    {\n        GroundMovement();\n    }\n    void GroundMovement()//移动的各种数值\n    {\n        xVelocity = Input.GetAxis(\"Horizontal\");//-1f ~ 1f\n        if (Input.GetButton(\"Crouch\")) Crouch();\n        else if (isCrouch) StandUp();\n\n        //在FixedUpdate()中调用无需Time.deltatime\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n        flipDirection();\n    }\n    void flipDirection()//改变角色图案方向\n    {\n        if (xVelocity > 0) transform.localScale = new Vector2 (1, 1);\n        else if (xVelocity < 0) transform.localScale = new Vector2(-1, 1);\n    }\n\n    void Crouch()//下蹲时的各种改变\n    {\n        isCrouch = true;\n        xVelocity *= crouchSpeedFactor;\n        cd.size = crouchSize;\n        cd.offset = crouchOffset;\n    }\n    void StandUp()//从下蹲转变为站立时各种变化\n    {\n        isCrouch = false;\n        xVelocity /= crouchSpeedFactor;\n        cd.size = standSize;\n        cd.offset = standOffset;\n    }\n}\n```\n\n顺便给每个函数添加了注释\n\n现在，按下s键或者方向下键就会让角色的碰撞体 “蹲下\" （移动速度变慢并且碰撞体高度减半）\n\n\n\n测试一下确实可以通过高度为1的障碍了，但是在经过障碍的途中如果松开下蹲键，就会穿模卡在墙里，因为缺少了在通过障碍时需要持续下蹲的判断，这一部分放到后面再处理\n\n\n\n---\n\n\n\n### 四、跳跃\n\n1.打开Edit - Project Setting - Physics 2D，将 y 轴重力改大一点，这里改为-50\n\n2.先添加与跳跃有关的参数：\n\n```\n    [Header(\"跳跃参数\")]\n    public float jumpForce = 5f;\n    public float jumpHoldForce = 3f;\n    public float jumpHoldDuration = 0.1f;\n    public float crouchJumpBoost = 3f;\n    float jumpTime;\n```\n\n其中jumpTime 是允许长按跳跃加高的时间\n\n\n\n3.添加判断各种状态的参数：\n\n```\n    [Header(\"按键状态\")]\n    public bool jumpPressed;\n    public bool jumpHeld;\n    public bool crouchHeld;\n\n    [Header(\"角色状态\")]\n    public bool isCrouch;\n    public bool isOnGround;\n    public bool isJump;\n\n    [Header(\"环境检测\")]\n    public LayerMask groundLayer;\n```\n\n同时可以更新一下之前的下蹲判断，用刚刚定义的状态参数\n\n\n\n4.在Update（）中获取按键信息：\n\n```\n    void Update()//每帧调用\n    {\n        //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化\n        if (Input.GetButtonDown(\"Jump\")) jumpPressed = true;\n\n        jumpHeld = Input.GetButton(\"Jump\");\n        crouchHeld = Input.GetButton(\"Crouch\");\n    }\n```\n\n\n\n5.添加判断是否在地面上：\n\n```\n\tvoid PhysicsCheck()//检测是否在地面，并修改状态\n    {\n        isOnGround = cd.IsTouchingLayers(groundLayer);\n\n    }\n```\n\n记得在FixedUpdate（）中调用，物理性质都推荐放在FixedUpdate中\n\n\n\n6.添加跳跃函数：\n\n```\n    void MidAirMovement()//跳跃移动\n    {\n        if(jumpPressed && isOnGround && !isJump)//起跳\n        {\n            if(crouchHeld)//判断是否要蹲跳\n            {\n                rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);\n            }\n            jumpTime = Time.time + jumpHoldDuration;\n            rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);\n            jumpPressed = false;\n            isJump = true;\n        }\n\n        else if(isJump)\n        {\n            if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);\n            if (jumpTime < Time.time) isJump = false;\n        }\n\n    }\n```\n\n精髓就是`jumpTime = Time.time + jumpHoldDuration;`，`if (jumpTime < Time.time) isJump = false;` \n\n这两句代码可以很好地对能否在空中持续加速进行判断\n\n\n\n---\n\n\n\n### 终、总结\n\n这次的跳跃代码真的收获不少，Update和FixedUpdate可以理解成完全独立的两个函数\n\n这一波折腾下来角色控制脚本 PlayerMovement 有点长了，这里先全部放上来记录一下，以便日后回顾\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerMovement : MonoBehaviour\n{\n    //组件\n    private Rigidbody2D rb;\n    private BoxCollider2D cd;\n\n    [Header(\"移动参数\")]\n    public float speed = 10f;\n    public float crouchSpeedFactor = 0.5f;\n    float xVelocity;\n\n    [Header(\"跳跃参数\")]\n    public float jumpForce = 5f;\n    public float jumpHoldForce = 3f;\n    public float jumpHoldDuration = 0.1f;\n    public float crouchJumpBoost = 3f;\n    float jumpTime;\n\n    [Header(\"按键状态\")]\n    public bool jumpPressed;\n    public bool jumpHeld;\n    public bool crouchHeld;\n\n    [Header(\"角色状态\")]\n    public bool isCrouch;\n    public bool isOnGround;\n    public bool isJump;\n\n    [Header(\"环境检测\")]\n    public LayerMask groundLayer;\n\n    //碰撞体尺寸\n    private Vector2 crouchOffset;\n    private Vector2 crouchSize;\n    private Vector2 standOffset;\n    private Vector2 standSize;\n\n    void Start()\n    {\n        //获取组件\n        rb = GetComponent<Rigidbody2D>();\n        cd = GetComponent<BoxCollider2D>();\n\n        //初始化\n        standOffset = cd.offset;\n        standSize = cd.size;\n        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);\n        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);\n    }\n\n\n    void Update()//每帧调用\n    {\n        //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化\n        if (Input.GetButtonDown(\"Jump\")) jumpPressed = true;\n\n        jumpHeld = Input.GetButton(\"Jump\");\n        crouchHeld = Input.GetButton(\"Crouch\");\n    }\n\n\n    private void FixedUpdate()//每一段时间调用，unity默认0.02s\n    {\n        PhysicsCheck();\n        GroundMovement();\n        MidAirMovement();\n    }\n\n    void PhysicsCheck()//检测是否在地面，并修改状态\n    {\n        isOnGround = cd.IsTouchingLayers(groundLayer);\n\n    }\n\n\n    void GroundMovement()//移动的各种数值\n    {\n        xVelocity = Input.GetAxis(\"Horizontal\");//-1f ~ 1f\n        if (crouchHeld && !isCrouch && isOnGround) Crouch();\n        else if ((isCrouch && !crouchHeld) || isJump) StandUp();\n\n\n        //在FixedUpdate()中调用无需Time.deltatime\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n        flipDirection();\n    }\n\n    void MidAirMovement()//跳跃移动\n    {\n        if(jumpPressed && isOnGround && !isJump)//起跳\n        {\n            if(crouchHeld)//判断是否要蹲跳\n            {\n                rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);\n            }\n            jumpTime = Time.time + jumpHoldDuration;\n            rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);\n            jumpPressed = false;\n            isJump = true;\n        }\n\n        else if(isJump)\n        {\n            if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);\n            if (jumpTime < Time.time) isJump = false;\n        }\n\n    }\n\n    void flipDirection()//改变角色图案方向\n    {\n        if (xVelocity > 0) transform.localScale = new Vector2 (1, 1);\n        else if (xVelocity < 0) transform.localScale = new Vector2(-1, 1);\n    }\n\n    void Crouch()//下蹲时的各种改变\n    {\n        isCrouch = true;\n        xVelocity *= crouchSpeedFactor;\n        cd.size = crouchSize;\n        cd.offset = crouchOffset;\n    }\n\n    void StandUp()//从下蹲转变为站立时各种变化\n    {\n        isCrouch = false;\n        xVelocity /= crouchSpeedFactor;\n        cd.size = standSize;\n        cd.offset = standOffset;\n    }\n}\n```\n\n","slug":"2021-07-19-《Robbie Swifthand》Unity2d独立游戏学习（二）","published":1,"updated":"2021-08-14T10:56:52.982Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hh000z1ou0hzoa7yvt","content":"<h3 id=\"一、添加物理组件\"><a href=\"#一、添加物理组件\" class=\"headerlink\" title=\"一、添加物理组件\"></a>一、添加物理组件</h3><p>1.给Platforms 添加Tilemap Collider 2D，勾选Used By Composite，添加Composite Collider 2D</p>\n<p>2.将Platforms自动添加的Rigidbody 2D 选择成Static 模式</p>\n<p>3.给主角添加Rigidbody 2D，把Collision Detection选择成Continuous连续不断地检测碰撞，把Interpolate 设置成Interpolate产生碰撞时会有一个缓冲的效果</p>\n<p>4.添加Box Collider 2D，调整主角碰撞器大小，size - y 最好设置在 2 以下，这样就可以通过两格高的空间</p>\n<p>5.运行，发现在角落处下落会导致角色翻转，需要在主角Rigidbody 2D 中锁定 z 轴</p>\n<p>6.为了避免角色碰到墙壁时会卡进墙体里，给主角Box Collider 2D添加Material 物理材质Teflon（资源包里的，摩擦力和弹力都是0）</p>\n<p>7.新增Layer ，主角设置成Player，Platforms 设置成Ground，以供后面进行碰撞检测</p>\n<span id=\"more\"></span>\n\n\n\n<hr>\n<h3 id=\"二、角色移动\"><a href=\"#二、角色移动\" class=\"headerlink\" title=\"二、角色移动\"></a>二、角色移动</h3><p>1.在Scripts文件夹新建PlayerMovement脚本，编写代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerMovement : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private Rigidbody2D rb;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;移动参数&quot;)]</span><br><span class=\"line\">    public float speed = 10f;</span><br><span class=\"line\">    public float crouchSpeedDivisor = 5f;</span><br><span class=\"line\">    private float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()//每帧调用</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void FixedUpdate()//每一段时间调用，默认0.02s</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        GroundMovement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void GroundMovement()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxis(&quot;Horizontal&quot;);//-1f ~ 1f</span><br><span class=\"line\">        //在FixedUpdate()中调用无需Time.deltatime</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\">        flipDirection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void flipDirection()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (xVelocity &gt; 0) transform.localScale = new Vector2 (1, 1);</span><br><span class=\"line\">        else if (xVelocity &lt; 0) transform.localScale = new Vector2(-1, 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>键盘左右键可以让主角左右移动，并且会改变图案方向</p>\n<hr>\n<h3 id=\"三、下蹲\"><a href=\"#三、下蹲\" class=\"headerlink\" title=\"三、下蹲\"></a>三、下蹲</h3><p>1.打开Edit - Project Settings - Input ，复制Jump 命名为Crouch，Positive Button 改为down，Alt Positive Button 改为 s</p>\n<p>2.修改角色移动代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerMovement : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private Rigidbody2D rb;</span><br><span class=\"line\">    private BoxCollider2D cd;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;移动参数&quot;)]</span><br><span class=\"line\">    public float speed = 10f;</span><br><span class=\"line\">    public float crouchSpeedFactor = 0.5f;</span><br><span class=\"line\">    private float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;角色状态&quot;)]</span><br><span class=\"line\">    public bool isCrouch;</span><br><span class=\"line\"></span><br><span class=\"line\">    //碰撞体尺寸</span><br><span class=\"line\">    private Vector2 crouchOffset;</span><br><span class=\"line\">    private Vector2 crouchSize;</span><br><span class=\"line\">    private Vector2 standOffset;</span><br><span class=\"line\">    private Vector2 standSize;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">        cd = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        standOffset = cd.offset;</span><br><span class=\"line\">        standSize = cd.size;</span><br><span class=\"line\">        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);</span><br><span class=\"line\">        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()//每帧调用</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private void FixedUpdate()//每一段时间调用，默认0.02s</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        GroundMovement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void GroundMovement()//移动的各种数值</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxis(&quot;Horizontal&quot;);//-1f ~ 1f</span><br><span class=\"line\">        if (Input.GetButton(&quot;Crouch&quot;)) Crouch();</span><br><span class=\"line\">        else if (isCrouch) StandUp();</span><br><span class=\"line\"></span><br><span class=\"line\">        //在FixedUpdate()中调用无需Time.deltatime</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\">        flipDirection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void flipDirection()//改变角色图案方向</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (xVelocity &gt; 0) transform.localScale = new Vector2 (1, 1);</span><br><span class=\"line\">        else if (xVelocity &lt; 0) transform.localScale = new Vector2(-1, 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Crouch()//下蹲时的各种改变</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isCrouch = true;</span><br><span class=\"line\">        xVelocity *= crouchSpeedFactor;</span><br><span class=\"line\">        cd.size = crouchSize;</span><br><span class=\"line\">        cd.offset = crouchOffset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void StandUp()//从下蹲转变为站立时各种变化</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isCrouch = false;</span><br><span class=\"line\">        xVelocity /= crouchSpeedFactor;</span><br><span class=\"line\">        cd.size = standSize;</span><br><span class=\"line\">        cd.offset = standOffset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>顺便给每个函数添加了注释</p>\n<p>现在，按下s键或者方向下键就会让角色的碰撞体 “蹲下” （移动速度变慢并且碰撞体高度减半）</p>\n<p>测试一下确实可以通过高度为1的障碍了，但是在经过障碍的途中如果松开下蹲键，就会穿模卡在墙里，因为缺少了在通过障碍时需要持续下蹲的判断，这一部分放到后面再处理</p>\n<hr>\n<h3 id=\"四、跳跃\"><a href=\"#四、跳跃\" class=\"headerlink\" title=\"四、跳跃\"></a>四、跳跃</h3><p>1.打开Edit - Project Setting - Physics 2D，将 y 轴重力改大一点，这里改为-50</p>\n<p>2.先添加与跳跃有关的参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;跳跃参数&quot;)]</span><br><span class=\"line\">public float jumpForce = 5f;</span><br><span class=\"line\">public float jumpHoldForce = 3f;</span><br><span class=\"line\">public float jumpHoldDuration = 0.1f;</span><br><span class=\"line\">public float crouchJumpBoost = 3f;</span><br><span class=\"line\">float jumpTime;</span><br></pre></td></tr></table></figure>\n\n<p>其中jumpTime 是允许长按跳跃加高的时间</p>\n<p>3.添加判断各种状态的参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;按键状态&quot;)]</span><br><span class=\"line\">public bool jumpPressed;</span><br><span class=\"line\">public bool jumpHeld;</span><br><span class=\"line\">public bool crouchHeld;</span><br><span class=\"line\"></span><br><span class=\"line\">[Header(&quot;角色状态&quot;)]</span><br><span class=\"line\">public bool isCrouch;</span><br><span class=\"line\">public bool isOnGround;</span><br><span class=\"line\">public bool isJump;</span><br><span class=\"line\"></span><br><span class=\"line\">[Header(&quot;环境检测&quot;)]</span><br><span class=\"line\">public LayerMask groundLayer;</span><br></pre></td></tr></table></figure>\n\n<p>同时可以更新一下之前的下蹲判断，用刚刚定义的状态参数</p>\n<p>4.在Update（）中获取按键信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Update()//每帧调用</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化</span><br><span class=\"line\">    if (Input.GetButtonDown(&quot;Jump&quot;)) jumpPressed = true;</span><br><span class=\"line\"></span><br><span class=\"line\">    jumpHeld = Input.GetButton(&quot;Jump&quot;);</span><br><span class=\"line\">    crouchHeld = Input.GetButton(&quot;Crouch&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>5.添加判断是否在地面上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       isOnGround = cd.IsTouchingLayers(groundLayer);</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>记得在FixedUpdate（）中调用，物理性质都推荐放在FixedUpdate中</p>\n<p>6.添加跳跃函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void MidAirMovement()//跳跃移动</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump)//起跳</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(crouchHeld)//判断是否要蹲跳</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        jumpTime = Time.time + jumpHoldDuration;</span><br><span class=\"line\">        rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);</span><br><span class=\"line\">        jumpPressed = false;</span><br><span class=\"line\">        isJump = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    else if(isJump)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);</span><br><span class=\"line\">        if (jumpTime &lt; Time.time) isJump = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>精髓就是<code>jumpTime = Time.time + jumpHoldDuration;</code>，<code>if (jumpTime &lt; Time.time) isJump = false;</code> </p>\n<p>这两句代码可以很好地对能否在空中持续加速进行判断</p>\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>这次的跳跃代码真的收获不少，Update和FixedUpdate可以理解成完全独立的两个函数</p>\n<p>这一波折腾下来角色控制脚本 PlayerMovement 有点长了，这里先全部放上来记录一下，以便日后回顾</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerMovement : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //组件</span><br><span class=\"line\">    private Rigidbody2D rb;</span><br><span class=\"line\">    private BoxCollider2D cd;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;移动参数&quot;)]</span><br><span class=\"line\">    public float speed = 10f;</span><br><span class=\"line\">    public float crouchSpeedFactor = 0.5f;</span><br><span class=\"line\">    float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;跳跃参数&quot;)]</span><br><span class=\"line\">    public float jumpForce = 5f;</span><br><span class=\"line\">    public float jumpHoldForce = 3f;</span><br><span class=\"line\">    public float jumpHoldDuration = 0.1f;</span><br><span class=\"line\">    public float crouchJumpBoost = 3f;</span><br><span class=\"line\">    float jumpTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;按键状态&quot;)]</span><br><span class=\"line\">    public bool jumpPressed;</span><br><span class=\"line\">    public bool jumpHeld;</span><br><span class=\"line\">    public bool crouchHeld;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;角色状态&quot;)]</span><br><span class=\"line\">    public bool isCrouch;</span><br><span class=\"line\">    public bool isOnGround;</span><br><span class=\"line\">    public bool isJump;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;环境检测&quot;)]</span><br><span class=\"line\">    public LayerMask groundLayer;</span><br><span class=\"line\"></span><br><span class=\"line\">    //碰撞体尺寸</span><br><span class=\"line\">    private Vector2 crouchOffset;</span><br><span class=\"line\">    private Vector2 crouchSize;</span><br><span class=\"line\">    private Vector2 standOffset;</span><br><span class=\"line\">    private Vector2 standSize;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //获取组件</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">        cd = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        //初始化</span><br><span class=\"line\">        standOffset = cd.offset;</span><br><span class=\"line\">        standSize = cd.size;</span><br><span class=\"line\">        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);</span><br><span class=\"line\">        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()//每帧调用</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化</span><br><span class=\"line\">        if (Input.GetButtonDown(&quot;Jump&quot;)) jumpPressed = true;</span><br><span class=\"line\"></span><br><span class=\"line\">        jumpHeld = Input.GetButton(&quot;Jump&quot;);</span><br><span class=\"line\">        crouchHeld = Input.GetButton(&quot;Crouch&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private void FixedUpdate()//每一段时间调用，unity默认0.02s</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        PhysicsCheck();</span><br><span class=\"line\">        GroundMovement();</span><br><span class=\"line\">        MidAirMovement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isOnGround = cd.IsTouchingLayers(groundLayer);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void GroundMovement()//移动的各种数值</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxis(&quot;Horizontal&quot;);//-1f ~ 1f</span><br><span class=\"line\">        if (crouchHeld &amp;&amp; !isCrouch &amp;&amp; isOnGround) Crouch();</span><br><span class=\"line\">        else if ((isCrouch &amp;&amp; !crouchHeld) || isJump) StandUp();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        //在FixedUpdate()中调用无需Time.deltatime</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\">        flipDirection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void MidAirMovement()//跳跃移动</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump)//起跳</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if(crouchHeld)//判断是否要蹲跳</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            jumpTime = Time.time + jumpHoldDuration;</span><br><span class=\"line\">            rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);</span><br><span class=\"line\">            jumpPressed = false;</span><br><span class=\"line\">            isJump = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        else if(isJump)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);</span><br><span class=\"line\">            if (jumpTime &lt; Time.time) isJump = false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void flipDirection()//改变角色图案方向</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (xVelocity &gt; 0) transform.localScale = new Vector2 (1, 1);</span><br><span class=\"line\">        else if (xVelocity &lt; 0) transform.localScale = new Vector2(-1, 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Crouch()//下蹲时的各种改变</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isCrouch = true;</span><br><span class=\"line\">        xVelocity *= crouchSpeedFactor;</span><br><span class=\"line\">        cd.size = crouchSize;</span><br><span class=\"line\">        cd.offset = crouchOffset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void StandUp()//从下蹲转变为站立时各种变化</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isCrouch = false;</span><br><span class=\"line\">        xVelocity /= crouchSpeedFactor;</span><br><span class=\"line\">        cd.size = standSize;</span><br><span class=\"line\">        cd.offset = standOffset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"一、添加物理组件\"><a href=\"#一、添加物理组件\" class=\"headerlink\" title=\"一、添加物理组件\"></a>一、添加物理组件</h3><p>1.给Platforms 添加Tilemap Collider 2D，勾选Used By Composite，添加Composite Collider 2D</p>\n<p>2.将Platforms自动添加的Rigidbody 2D 选择成Static 模式</p>\n<p>3.给主角添加Rigidbody 2D，把Collision Detection选择成Continuous连续不断地检测碰撞，把Interpolate 设置成Interpolate产生碰撞时会有一个缓冲的效果</p>\n<p>4.添加Box Collider 2D，调整主角碰撞器大小，size - y 最好设置在 2 以下，这样就可以通过两格高的空间</p>\n<p>5.运行，发现在角落处下落会导致角色翻转，需要在主角Rigidbody 2D 中锁定 z 轴</p>\n<p>6.为了避免角色碰到墙壁时会卡进墙体里，给主角Box Collider 2D添加Material 物理材质Teflon（资源包里的，摩擦力和弹力都是0）</p>\n<p>7.新增Layer ，主角设置成Player，Platforms 设置成Ground，以供后面进行碰撞检测</p>","more":"<hr>\n<h3 id=\"二、角色移动\"><a href=\"#二、角色移动\" class=\"headerlink\" title=\"二、角色移动\"></a>二、角色移动</h3><p>1.在Scripts文件夹新建PlayerMovement脚本，编写代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerMovement : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private Rigidbody2D rb;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;移动参数&quot;)]</span><br><span class=\"line\">    public float speed = 10f;</span><br><span class=\"line\">    public float crouchSpeedDivisor = 5f;</span><br><span class=\"line\">    private float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()//每帧调用</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void FixedUpdate()//每一段时间调用，默认0.02s</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        GroundMovement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void GroundMovement()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxis(&quot;Horizontal&quot;);//-1f ~ 1f</span><br><span class=\"line\">        //在FixedUpdate()中调用无需Time.deltatime</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\">        flipDirection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void flipDirection()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (xVelocity &gt; 0) transform.localScale = new Vector2 (1, 1);</span><br><span class=\"line\">        else if (xVelocity &lt; 0) transform.localScale = new Vector2(-1, 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>键盘左右键可以让主角左右移动，并且会改变图案方向</p>\n<hr>\n<h3 id=\"三、下蹲\"><a href=\"#三、下蹲\" class=\"headerlink\" title=\"三、下蹲\"></a>三、下蹲</h3><p>1.打开Edit - Project Settings - Input ，复制Jump 命名为Crouch，Positive Button 改为down，Alt Positive Button 改为 s</p>\n<p>2.修改角色移动代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerMovement : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private Rigidbody2D rb;</span><br><span class=\"line\">    private BoxCollider2D cd;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;移动参数&quot;)]</span><br><span class=\"line\">    public float speed = 10f;</span><br><span class=\"line\">    public float crouchSpeedFactor = 0.5f;</span><br><span class=\"line\">    private float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;角色状态&quot;)]</span><br><span class=\"line\">    public bool isCrouch;</span><br><span class=\"line\"></span><br><span class=\"line\">    //碰撞体尺寸</span><br><span class=\"line\">    private Vector2 crouchOffset;</span><br><span class=\"line\">    private Vector2 crouchSize;</span><br><span class=\"line\">    private Vector2 standOffset;</span><br><span class=\"line\">    private Vector2 standSize;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">        cd = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        standOffset = cd.offset;</span><br><span class=\"line\">        standSize = cd.size;</span><br><span class=\"line\">        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);</span><br><span class=\"line\">        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()//每帧调用</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private void FixedUpdate()//每一段时间调用，默认0.02s</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        GroundMovement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void GroundMovement()//移动的各种数值</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxis(&quot;Horizontal&quot;);//-1f ~ 1f</span><br><span class=\"line\">        if (Input.GetButton(&quot;Crouch&quot;)) Crouch();</span><br><span class=\"line\">        else if (isCrouch) StandUp();</span><br><span class=\"line\"></span><br><span class=\"line\">        //在FixedUpdate()中调用无需Time.deltatime</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\">        flipDirection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void flipDirection()//改变角色图案方向</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (xVelocity &gt; 0) transform.localScale = new Vector2 (1, 1);</span><br><span class=\"line\">        else if (xVelocity &lt; 0) transform.localScale = new Vector2(-1, 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Crouch()//下蹲时的各种改变</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isCrouch = true;</span><br><span class=\"line\">        xVelocity *= crouchSpeedFactor;</span><br><span class=\"line\">        cd.size = crouchSize;</span><br><span class=\"line\">        cd.offset = crouchOffset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void StandUp()//从下蹲转变为站立时各种变化</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isCrouch = false;</span><br><span class=\"line\">        xVelocity /= crouchSpeedFactor;</span><br><span class=\"line\">        cd.size = standSize;</span><br><span class=\"line\">        cd.offset = standOffset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>顺便给每个函数添加了注释</p>\n<p>现在，按下s键或者方向下键就会让角色的碰撞体 “蹲下” （移动速度变慢并且碰撞体高度减半）</p>\n<p>测试一下确实可以通过高度为1的障碍了，但是在经过障碍的途中如果松开下蹲键，就会穿模卡在墙里，因为缺少了在通过障碍时需要持续下蹲的判断，这一部分放到后面再处理</p>\n<hr>\n<h3 id=\"四、跳跃\"><a href=\"#四、跳跃\" class=\"headerlink\" title=\"四、跳跃\"></a>四、跳跃</h3><p>1.打开Edit - Project Setting - Physics 2D，将 y 轴重力改大一点，这里改为-50</p>\n<p>2.先添加与跳跃有关的参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;跳跃参数&quot;)]</span><br><span class=\"line\">public float jumpForce = 5f;</span><br><span class=\"line\">public float jumpHoldForce = 3f;</span><br><span class=\"line\">public float jumpHoldDuration = 0.1f;</span><br><span class=\"line\">public float crouchJumpBoost = 3f;</span><br><span class=\"line\">float jumpTime;</span><br></pre></td></tr></table></figure>\n\n<p>其中jumpTime 是允许长按跳跃加高的时间</p>\n<p>3.添加判断各种状态的参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;按键状态&quot;)]</span><br><span class=\"line\">public bool jumpPressed;</span><br><span class=\"line\">public bool jumpHeld;</span><br><span class=\"line\">public bool crouchHeld;</span><br><span class=\"line\"></span><br><span class=\"line\">[Header(&quot;角色状态&quot;)]</span><br><span class=\"line\">public bool isCrouch;</span><br><span class=\"line\">public bool isOnGround;</span><br><span class=\"line\">public bool isJump;</span><br><span class=\"line\"></span><br><span class=\"line\">[Header(&quot;环境检测&quot;)]</span><br><span class=\"line\">public LayerMask groundLayer;</span><br></pre></td></tr></table></figure>\n\n<p>同时可以更新一下之前的下蹲判断，用刚刚定义的状态参数</p>\n<p>4.在Update（）中获取按键信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Update()//每帧调用</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化</span><br><span class=\"line\">    if (Input.GetButtonDown(&quot;Jump&quot;)) jumpPressed = true;</span><br><span class=\"line\"></span><br><span class=\"line\">    jumpHeld = Input.GetButton(&quot;Jump&quot;);</span><br><span class=\"line\">    crouchHeld = Input.GetButton(&quot;Crouch&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>5.添加判断是否在地面上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       isOnGround = cd.IsTouchingLayers(groundLayer);</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>记得在FixedUpdate（）中调用，物理性质都推荐放在FixedUpdate中</p>\n<p>6.添加跳跃函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void MidAirMovement()//跳跃移动</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump)//起跳</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(crouchHeld)//判断是否要蹲跳</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        jumpTime = Time.time + jumpHoldDuration;</span><br><span class=\"line\">        rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);</span><br><span class=\"line\">        jumpPressed = false;</span><br><span class=\"line\">        isJump = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    else if(isJump)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);</span><br><span class=\"line\">        if (jumpTime &lt; Time.time) isJump = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>精髓就是<code>jumpTime = Time.time + jumpHoldDuration;</code>，<code>if (jumpTime &lt; Time.time) isJump = false;</code> </p>\n<p>这两句代码可以很好地对能否在空中持续加速进行判断</p>\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>这次的跳跃代码真的收获不少，Update和FixedUpdate可以理解成完全独立的两个函数</p>\n<p>这一波折腾下来角色控制脚本 PlayerMovement 有点长了，这里先全部放上来记录一下，以便日后回顾</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerMovement : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //组件</span><br><span class=\"line\">    private Rigidbody2D rb;</span><br><span class=\"line\">    private BoxCollider2D cd;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;移动参数&quot;)]</span><br><span class=\"line\">    public float speed = 10f;</span><br><span class=\"line\">    public float crouchSpeedFactor = 0.5f;</span><br><span class=\"line\">    float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;跳跃参数&quot;)]</span><br><span class=\"line\">    public float jumpForce = 5f;</span><br><span class=\"line\">    public float jumpHoldForce = 3f;</span><br><span class=\"line\">    public float jumpHoldDuration = 0.1f;</span><br><span class=\"line\">    public float crouchJumpBoost = 3f;</span><br><span class=\"line\">    float jumpTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;按键状态&quot;)]</span><br><span class=\"line\">    public bool jumpPressed;</span><br><span class=\"line\">    public bool jumpHeld;</span><br><span class=\"line\">    public bool crouchHeld;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;角色状态&quot;)]</span><br><span class=\"line\">    public bool isCrouch;</span><br><span class=\"line\">    public bool isOnGround;</span><br><span class=\"line\">    public bool isJump;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;环境检测&quot;)]</span><br><span class=\"line\">    public LayerMask groundLayer;</span><br><span class=\"line\"></span><br><span class=\"line\">    //碰撞体尺寸</span><br><span class=\"line\">    private Vector2 crouchOffset;</span><br><span class=\"line\">    private Vector2 crouchSize;</span><br><span class=\"line\">    private Vector2 standOffset;</span><br><span class=\"line\">    private Vector2 standSize;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //获取组件</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">        cd = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        //初始化</span><br><span class=\"line\">        standOffset = cd.offset;</span><br><span class=\"line\">        standSize = cd.size;</span><br><span class=\"line\">        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);</span><br><span class=\"line\">        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()//每帧调用</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化</span><br><span class=\"line\">        if (Input.GetButtonDown(&quot;Jump&quot;)) jumpPressed = true;</span><br><span class=\"line\"></span><br><span class=\"line\">        jumpHeld = Input.GetButton(&quot;Jump&quot;);</span><br><span class=\"line\">        crouchHeld = Input.GetButton(&quot;Crouch&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private void FixedUpdate()//每一段时间调用，unity默认0.02s</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        PhysicsCheck();</span><br><span class=\"line\">        GroundMovement();</span><br><span class=\"line\">        MidAirMovement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isOnGround = cd.IsTouchingLayers(groundLayer);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void GroundMovement()//移动的各种数值</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxis(&quot;Horizontal&quot;);//-1f ~ 1f</span><br><span class=\"line\">        if (crouchHeld &amp;&amp; !isCrouch &amp;&amp; isOnGround) Crouch();</span><br><span class=\"line\">        else if ((isCrouch &amp;&amp; !crouchHeld) || isJump) StandUp();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        //在FixedUpdate()中调用无需Time.deltatime</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\">        flipDirection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void MidAirMovement()//跳跃移动</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump)//起跳</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if(crouchHeld)//判断是否要蹲跳</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            jumpTime = Time.time + jumpHoldDuration;</span><br><span class=\"line\">            rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);</span><br><span class=\"line\">            jumpPressed = false;</span><br><span class=\"line\">            isJump = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        else if(isJump)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);</span><br><span class=\"line\">            if (jumpTime &lt; Time.time) isJump = false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void flipDirection()//改变角色图案方向</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (xVelocity &gt; 0) transform.localScale = new Vector2 (1, 1);</span><br><span class=\"line\">        else if (xVelocity &lt; 0) transform.localScale = new Vector2(-1, 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Crouch()//下蹲时的各种改变</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isCrouch = true;</span><br><span class=\"line\">        xVelocity *= crouchSpeedFactor;</span><br><span class=\"line\">        cd.size = crouchSize;</span><br><span class=\"line\">        cd.offset = crouchOffset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void StandUp()//从下蹲转变为站立时各种变化</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isCrouch = false;</span><br><span class=\"line\">        xVelocity /= crouchSpeedFactor;</span><br><span class=\"line\">        cd.size = standSize;</span><br><span class=\"line\">        cd.offset = standOffset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"《Robbie Swifthand》Unity2d独立游戏学习（四）","date":"2021-07-23T07:22:41.000Z","_content":"\n\n\n### \t始、前言\n\n接下来做一些视觉上的东西，首先是让镜头跟随主角移动，还有场景的灯光效果\n\n\n\n<!--more-->\n\n---\n\n### \t一、摄像机\n\n1.可以选择Camera 修改背景颜色\n\n2.将摄像机的Projection 修改为Perspective，这样就设置成了透视模式，可以通过修改图层深度来产生景深效果\n\n3.为了产生景深效果，将Grid 中的Background 的Transform → Position → z 设置为 1， 同样地，将Background Details 设置为0.99，Platforms 不变， Shadow 为 - 0.1\n\n4.在unity界面Window → Package Manager 中添加 Cinemachine\n\n5.创建2D Camera物体，将主角拖拽到相机的Follow中，摄像机会跟随角色移动\n\n6.可以设置Camera Distance 到一个合适的位置，这个选项会影响游戏画面的远近\n\n7.选择2D Camera → Extensions → Add Extension 添加一个CinemachineConfiner\n\n8.新建空项目，添加多边形碰撞体，设置成触发器，拖拽到2D摄像机的Confiner中。这样就可以通过调整多边形的形状来限制摄像机的移动范围啦\n\n完成，调试\n\n发现阴影没有遮挡角色，要把Shadow 的Sorting Layer 修改成Foreground\n\n\n\n---\n\n\n\n### 二、2D灯光效果\n\n1.在Props 中找到墙灯，打开预制体修改父物体和子物体的Sorting Layer为Background（粒子效果又是一个大坑）\n\n2.拖入场景之前添加点光源，设置光源的z 轴为 -0.2 ，这样就可以在所有背景的前面照亮它们（更靠近摄像机），还可以修改颜色的照明距离等\n\n拖入火炬后为什么场景没有被照亮呢？因为场景中的物体都还没添加法线贴图\n\n3.打开Level 文件夹，将Platform 和Background 的材质球拖入对应的场景物体中（材质会自动对应瓦片）\n\n4.打开Props 添加另外一种灯：悬挂蓝灯，蓝灯会左右摇摆，因为它有一个动画效果修改z 轴旋转\n\n5.调整场景的整体灯光，打开Window → Rendering → Lighting，在Environment Lighting 中可以调整颜色和亮度\n\n","source":"_posts/2021-07-23-《Robbie Swifthand》Unity2d独立游戏学习（四）.md","raw":"---\ntitle: 《Robbie Swifthand》Unity2d独立游戏学习（四）\ndate: 2021-07-23 15:22:41\ncategories: unity\ntags:\n  - unity\n  - c#\n  - camera\n---\n\n\n\n### \t始、前言\n\n接下来做一些视觉上的东西，首先是让镜头跟随主角移动，还有场景的灯光效果\n\n\n\n<!--more-->\n\n---\n\n### \t一、摄像机\n\n1.可以选择Camera 修改背景颜色\n\n2.将摄像机的Projection 修改为Perspective，这样就设置成了透视模式，可以通过修改图层深度来产生景深效果\n\n3.为了产生景深效果，将Grid 中的Background 的Transform → Position → z 设置为 1， 同样地，将Background Details 设置为0.99，Platforms 不变， Shadow 为 - 0.1\n\n4.在unity界面Window → Package Manager 中添加 Cinemachine\n\n5.创建2D Camera物体，将主角拖拽到相机的Follow中，摄像机会跟随角色移动\n\n6.可以设置Camera Distance 到一个合适的位置，这个选项会影响游戏画面的远近\n\n7.选择2D Camera → Extensions → Add Extension 添加一个CinemachineConfiner\n\n8.新建空项目，添加多边形碰撞体，设置成触发器，拖拽到2D摄像机的Confiner中。这样就可以通过调整多边形的形状来限制摄像机的移动范围啦\n\n完成，调试\n\n发现阴影没有遮挡角色，要把Shadow 的Sorting Layer 修改成Foreground\n\n\n\n---\n\n\n\n### 二、2D灯光效果\n\n1.在Props 中找到墙灯，打开预制体修改父物体和子物体的Sorting Layer为Background（粒子效果又是一个大坑）\n\n2.拖入场景之前添加点光源，设置光源的z 轴为 -0.2 ，这样就可以在所有背景的前面照亮它们（更靠近摄像机），还可以修改颜色的照明距离等\n\n拖入火炬后为什么场景没有被照亮呢？因为场景中的物体都还没添加法线贴图\n\n3.打开Level 文件夹，将Platform 和Background 的材质球拖入对应的场景物体中（材质会自动对应瓦片）\n\n4.打开Props 添加另外一种灯：悬挂蓝灯，蓝灯会左右摇摆，因为它有一个动画效果修改z 轴旋转\n\n5.调整场景的整体灯光，打开Window → Rendering → Lighting，在Environment Lighting 中可以调整颜色和亮度\n\n","slug":"2021-07-23-《Robbie Swifthand》Unity2d独立游戏学习（四）","published":1,"updated":"2021-07-30T07:53:21.103Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hi00121ou0bth1emna","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>接下来做一些视觉上的东西，首先是让镜头跟随主角移动，还有场景的灯光效果</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、摄像机\"><a href=\"#一、摄像机\" class=\"headerlink\" title=\"一、摄像机\"></a>一、摄像机</h3><p>1.可以选择Camera 修改背景颜色</p>\n<p>2.将摄像机的Projection 修改为Perspective，这样就设置成了透视模式，可以通过修改图层深度来产生景深效果</p>\n<p>3.为了产生景深效果，将Grid 中的Background 的Transform → Position → z 设置为 1， 同样地，将Background Details 设置为0.99，Platforms 不变， Shadow 为 - 0.1</p>\n<p>4.在unity界面Window → Package Manager 中添加 Cinemachine</p>\n<p>5.创建2D Camera物体，将主角拖拽到相机的Follow中，摄像机会跟随角色移动</p>\n<p>6.可以设置Camera Distance 到一个合适的位置，这个选项会影响游戏画面的远近</p>\n<p>7.选择2D Camera → Extensions → Add Extension 添加一个CinemachineConfiner</p>\n<p>8.新建空项目，添加多边形碰撞体，设置成触发器，拖拽到2D摄像机的Confiner中。这样就可以通过调整多边形的形状来限制摄像机的移动范围啦</p>\n<p>完成，调试</p>\n<p>发现阴影没有遮挡角色，要把Shadow 的Sorting Layer 修改成Foreground</p>\n<hr>\n<h3 id=\"二、2D灯光效果\"><a href=\"#二、2D灯光效果\" class=\"headerlink\" title=\"二、2D灯光效果\"></a>二、2D灯光效果</h3><p>1.在Props 中找到墙灯，打开预制体修改父物体和子物体的Sorting Layer为Background（粒子效果又是一个大坑）</p>\n<p>2.拖入场景之前添加点光源，设置光源的z 轴为 -0.2 ，这样就可以在所有背景的前面照亮它们（更靠近摄像机），还可以修改颜色的照明距离等</p>\n<p>拖入火炬后为什么场景没有被照亮呢？因为场景中的物体都还没添加法线贴图</p>\n<p>3.打开Level 文件夹，将Platform 和Background 的材质球拖入对应的场景物体中（材质会自动对应瓦片）</p>\n<p>4.打开Props 添加另外一种灯：悬挂蓝灯，蓝灯会左右摇摆，因为它有一个动画效果修改z 轴旋转</p>\n<p>5.调整场景的整体灯光，打开Window → Rendering → Lighting，在Environment Lighting 中可以调整颜色和亮度</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>接下来做一些视觉上的东西，首先是让镜头跟随主角移动，还有场景的灯光效果</p>","more":"<hr>\n<h3 id=\"一、摄像机\"><a href=\"#一、摄像机\" class=\"headerlink\" title=\"一、摄像机\"></a>一、摄像机</h3><p>1.可以选择Camera 修改背景颜色</p>\n<p>2.将摄像机的Projection 修改为Perspective，这样就设置成了透视模式，可以通过修改图层深度来产生景深效果</p>\n<p>3.为了产生景深效果，将Grid 中的Background 的Transform → Position → z 设置为 1， 同样地，将Background Details 设置为0.99，Platforms 不变， Shadow 为 - 0.1</p>\n<p>4.在unity界面Window → Package Manager 中添加 Cinemachine</p>\n<p>5.创建2D Camera物体，将主角拖拽到相机的Follow中，摄像机会跟随角色移动</p>\n<p>6.可以设置Camera Distance 到一个合适的位置，这个选项会影响游戏画面的远近</p>\n<p>7.选择2D Camera → Extensions → Add Extension 添加一个CinemachineConfiner</p>\n<p>8.新建空项目，添加多边形碰撞体，设置成触发器，拖拽到2D摄像机的Confiner中。这样就可以通过调整多边形的形状来限制摄像机的移动范围啦</p>\n<p>完成，调试</p>\n<p>发现阴影没有遮挡角色，要把Shadow 的Sorting Layer 修改成Foreground</p>\n<hr>\n<h3 id=\"二、2D灯光效果\"><a href=\"#二、2D灯光效果\" class=\"headerlink\" title=\"二、2D灯光效果\"></a>二、2D灯光效果</h3><p>1.在Props 中找到墙灯，打开预制体修改父物体和子物体的Sorting Layer为Background（粒子效果又是一个大坑）</p>\n<p>2.拖入场景之前添加点光源，设置光源的z 轴为 -0.2 ，这样就可以在所有背景的前面照亮它们（更靠近摄像机），还可以修改颜色的照明距离等</p>\n<p>拖入火炬后为什么场景没有被照亮呢？因为场景中的物体都还没添加法线贴图</p>\n<p>3.打开Level 文件夹，将Platform 和Background 的材质球拖入对应的场景物体中（材质会自动对应瓦片）</p>\n<p>4.打开Props 添加另外一种灯：悬挂蓝灯，蓝灯会左右摇摆，因为它有一个动画效果修改z 轴旋转</p>\n<p>5.调整场景的整体灯光，打开Window → Rendering → Lighting，在Environment Lighting 中可以调整颜色和亮度</p>"},{"title":"【LeetCode.138】 复制带随机指针的链表","date":"2021-07-22T06:59:35.000Z","_content":"\n\n\n### \t题目：复制带随机指针的链表\n\n​\t给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。\n\n​\t构造这个链表的 **深拷贝**。 深拷贝应该正好由 `n` 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。\n\n​\t例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 x 和 `y` ，同样有 `x.random --> y` 。\n\n​\t返回复制链表的头节点。\n\n​\t用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：\n\n**val**：一个表示 `Node.val` 的整数。\n**random_index**：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为  `null` 。\n\t你的代码 只 接受原链表的头节点 `head` 作为传入参数。\n\n <!--more-->\n\n示例 1：\n\n```\n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n```\n\n示例 2：\n\n```\n输入：head = [[1,1],[2,1]]\n输出：[[1,1],[2,1]]\n```\n\n示例 3：\n\n```\n输入：head = [[3,null],[3,0],[3,null]]\n输出：[[3,null],[3,0],[3,null]]\n```\n\n示例 4：\n\n```\n输入：head = []\n输出：[]\n解释：给定的链表为空（空指针），因此返回 null。\n```\n\n\n提示：\n\n`0 <= n <= 1000`\n`-10000 <= Node.val <= 10000`\n`Node.random 为空（null）或指向链表中的节点。`\n\n\n\n---\n\n\n\n### \t分析：\n\n​\t首先将该链表中每一个节点拆分为两个相连的节点，例如对于链表 `A→B→C`，我们可以将其拆分为 `A→A ′ →B→B ′ →C→C ′` 。对于任意一个原节点 `S`，其拷贝节点 `S ′` 即为其后继节点。\n\n​\t这样，我们可以直接找到每一个拷贝节点 `S ′` 的随机指针应当指向的节点，即为其原节点 `S` 的随机指针指向的节点 `T` 的后继节点 `T ′` 。需要注意原节点的随机指针可能为空，我们需要特别判断这种情况。\n\n当我们完成了拷贝节点的随机指针的赋值，我们只需要将这个链表按照原节点与拷贝节点的种类进行拆分即可，只需要遍历一次。同样需要注意最后一个拷贝节点的后继节点为空，我们需要特别判断这种情况。\n\n\n\n---\n\n\n\n### \t题解：\n\n```\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        if(!head) return NULL;\n        Node * ret = head;\n        \n        // 将A→B→C，拆分为 A→A ′ →B→B ′ →C→C ′\n        while(ret){\n            Node *q = new Node(ret->val);\n            q->next = ret->next;   \n            ret->next = q;      \n            ret = q->next;\n        }\n        ret = head;\n        \n        // S ′ 指向其原节点 S 的随机指针指向的节点 T 的后继节点 T ′\n        while(ret){\n            Node* pre = ret;\n            ret = ret->next;\n            if(pre->random) ret->random = pre->random->next;\n            else ret->random = NULL;            \n            ret = ret->next;\n        }\n        ret = head->next;\n        Node* p = head;\n        Node * q = ret;\n        Node * now = ret;\n        \n        //拆分原数组和拷贝数组\n        while(p->next){\n            now = now->next;\n            q = p->next;\n            p->next = now;          \n            p = q;\n        }\n        return ret;\n    }\n};\n```\n\n","source":"_posts/2021-07-22-【LeetCode.138】 复制带随机指针的链表.md","raw":"---\ntitle: 【LeetCode.138】 复制带随机指针的链表\ndate: 2021-07-22 14:59:35\ncategories:\t算法\ntags:\n  - c++\n  - 原地算法\n  - 链表\n---\n\n\n\n### \t题目：复制带随机指针的链表\n\n​\t给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。\n\n​\t构造这个链表的 **深拷贝**。 深拷贝应该正好由 `n` 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。\n\n​\t例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 x 和 `y` ，同样有 `x.random --> y` 。\n\n​\t返回复制链表的头节点。\n\n​\t用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：\n\n**val**：一个表示 `Node.val` 的整数。\n**random_index**：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为  `null` 。\n\t你的代码 只 接受原链表的头节点 `head` 作为传入参数。\n\n <!--more-->\n\n示例 1：\n\n```\n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n```\n\n示例 2：\n\n```\n输入：head = [[1,1],[2,1]]\n输出：[[1,1],[2,1]]\n```\n\n示例 3：\n\n```\n输入：head = [[3,null],[3,0],[3,null]]\n输出：[[3,null],[3,0],[3,null]]\n```\n\n示例 4：\n\n```\n输入：head = []\n输出：[]\n解释：给定的链表为空（空指针），因此返回 null。\n```\n\n\n提示：\n\n`0 <= n <= 1000`\n`-10000 <= Node.val <= 10000`\n`Node.random 为空（null）或指向链表中的节点。`\n\n\n\n---\n\n\n\n### \t分析：\n\n​\t首先将该链表中每一个节点拆分为两个相连的节点，例如对于链表 `A→B→C`，我们可以将其拆分为 `A→A ′ →B→B ′ →C→C ′` 。对于任意一个原节点 `S`，其拷贝节点 `S ′` 即为其后继节点。\n\n​\t这样，我们可以直接找到每一个拷贝节点 `S ′` 的随机指针应当指向的节点，即为其原节点 `S` 的随机指针指向的节点 `T` 的后继节点 `T ′` 。需要注意原节点的随机指针可能为空，我们需要特别判断这种情况。\n\n当我们完成了拷贝节点的随机指针的赋值，我们只需要将这个链表按照原节点与拷贝节点的种类进行拆分即可，只需要遍历一次。同样需要注意最后一个拷贝节点的后继节点为空，我们需要特别判断这种情况。\n\n\n\n---\n\n\n\n### \t题解：\n\n```\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        if(!head) return NULL;\n        Node * ret = head;\n        \n        // 将A→B→C，拆分为 A→A ′ →B→B ′ →C→C ′\n        while(ret){\n            Node *q = new Node(ret->val);\n            q->next = ret->next;   \n            ret->next = q;      \n            ret = q->next;\n        }\n        ret = head;\n        \n        // S ′ 指向其原节点 S 的随机指针指向的节点 T 的后继节点 T ′\n        while(ret){\n            Node* pre = ret;\n            ret = ret->next;\n            if(pre->random) ret->random = pre->random->next;\n            else ret->random = NULL;            \n            ret = ret->next;\n        }\n        ret = head->next;\n        Node* p = head;\n        Node * q = ret;\n        Node * now = ret;\n        \n        //拆分原数组和拷贝数组\n        while(p->next){\n            now = now->next;\n            q = p->next;\n            p->next = now;          \n            p = q;\n        }\n        return ret;\n    }\n};\n```\n\n","slug":"2021-07-22-【LeetCode.138】 复制带随机指针的链表","published":1,"updated":"2021-07-23T07:17:49.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hj00161ou0c8ivfaze","content":"<h3 id=\"题目：复制带随机指针的链表\"><a href=\"#题目：复制带随机指针的链表\" class=\"headerlink\" title=\"题目：复制带随机指针的链表\"></a>题目：复制带随机指针的链表</h3><p>​    给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>\n<p>​    构造这个链表的 <strong>深拷贝</strong>。 深拷贝应该正好由 <code>n</code> 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p>\n<p>​    例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 x 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p>\n<p>​    返回复制链表的头节点。</p>\n<p>​    用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p>\n<p><strong>val</strong>：一个表示 <code>Node.val</code> 的整数。<br><strong>random_index</strong>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为  <code>null</code> 。<br>    你的代码 只 接受原链表的头节点 <code>head</code> 作为传入参数。</p>\n <span id=\"more\"></span>\n\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class=\"line\">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [[1,1],[2,1]]</span><br><span class=\"line\">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure>\n\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class=\"line\">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure>\n\n<p>示例 4：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = []</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure>\n\n\n<p>提示：</p>\n<p><code>0 &lt;= n &lt;= 1000</code><br><code>-10000 &lt;= Node.val &lt;= 10000</code><br><code>Node.random 为空（null）或指向链表中的节点。</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>​    首先将该链表中每一个节点拆分为两个相连的节点，例如对于链表 <code>A→B→C</code>，我们可以将其拆分为 <code>A→A ′ →B→B ′ →C→C ′</code> 。对于任意一个原节点 <code>S</code>，其拷贝节点 <code>S ′</code> 即为其后继节点。</p>\n<p>​    这样，我们可以直接找到每一个拷贝节点 <code>S ′</code> 的随机指针应当指向的节点，即为其原节点 <code>S</code> 的随机指针指向的节点 <code>T</code> 的后继节点 <code>T ′</code> 。需要注意原节点的随机指针可能为空，我们需要特别判断这种情况。</p>\n<p>当我们完成了拷贝节点的随机指针的赋值，我们只需要将这个链表按照原节点与拷贝节点的种类进行拆分即可，只需要遍历一次。同样需要注意最后一个拷贝节点的后继节点为空，我们需要特别判断这种情况。</p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Node* copyRandomList(Node* head) &#123;</span><br><span class=\"line\">        if(!head) return NULL;</span><br><span class=\"line\">        Node * ret = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 将A→B→C，拆分为 A→A ′ →B→B ′ →C→C ′</span><br><span class=\"line\">        while(ret)&#123;</span><br><span class=\"line\">            Node *q = new Node(ret-&gt;val);</span><br><span class=\"line\">            q-&gt;next = ret-&gt;next;   </span><br><span class=\"line\">            ret-&gt;next = q;      </span><br><span class=\"line\">            ret = q-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // S ′ 指向其原节点 S 的随机指针指向的节点 T 的后继节点 T ′</span><br><span class=\"line\">        while(ret)&#123;</span><br><span class=\"line\">            Node* pre = ret;</span><br><span class=\"line\">            ret = ret-&gt;next;</span><br><span class=\"line\">            if(pre-&gt;random) ret-&gt;random = pre-&gt;random-&gt;next;</span><br><span class=\"line\">            else ret-&gt;random = NULL;            </span><br><span class=\"line\">            ret = ret-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret = head-&gt;next;</span><br><span class=\"line\">        Node* p = head;</span><br><span class=\"line\">        Node * q = ret;</span><br><span class=\"line\">        Node * now = ret;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //拆分原数组和拷贝数组</span><br><span class=\"line\">        while(p-&gt;next)&#123;</span><br><span class=\"line\">            now = now-&gt;next;</span><br><span class=\"line\">            q = p-&gt;next;</span><br><span class=\"line\">            p-&gt;next = now;          </span><br><span class=\"line\">            p = q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"题目：复制带随机指针的链表\"><a href=\"#题目：复制带随机指针的链表\" class=\"headerlink\" title=\"题目：复制带随机指针的链表\"></a>题目：复制带随机指针的链表</h3><p>​    给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>\n<p>​    构造这个链表的 <strong>深拷贝</strong>。 深拷贝应该正好由 <code>n</code> 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p>\n<p>​    例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 x 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p>\n<p>​    返回复制链表的头节点。</p>\n<p>​    用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p>\n<p><strong>val</strong>：一个表示 <code>Node.val</code> 的整数。<br><strong>random_index</strong>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为  <code>null</code> 。<br>    你的代码 只 接受原链表的头节点 <code>head</code> 作为传入参数。</p>","more":"<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class=\"line\">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [[1,1],[2,1]]</span><br><span class=\"line\">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure>\n\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class=\"line\">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure>\n\n<p>示例 4：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = []</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure>\n\n\n<p>提示：</p>\n<p><code>0 &lt;= n &lt;= 1000</code><br><code>-10000 &lt;= Node.val &lt;= 10000</code><br><code>Node.random 为空（null）或指向链表中的节点。</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>​    首先将该链表中每一个节点拆分为两个相连的节点，例如对于链表 <code>A→B→C</code>，我们可以将其拆分为 <code>A→A ′ →B→B ′ →C→C ′</code> 。对于任意一个原节点 <code>S</code>，其拷贝节点 <code>S ′</code> 即为其后继节点。</p>\n<p>​    这样，我们可以直接找到每一个拷贝节点 <code>S ′</code> 的随机指针应当指向的节点，即为其原节点 <code>S</code> 的随机指针指向的节点 <code>T</code> 的后继节点 <code>T ′</code> 。需要注意原节点的随机指针可能为空，我们需要特别判断这种情况。</p>\n<p>当我们完成了拷贝节点的随机指针的赋值，我们只需要将这个链表按照原节点与拷贝节点的种类进行拆分即可，只需要遍历一次。同样需要注意最后一个拷贝节点的后继节点为空，我们需要特别判断这种情况。</p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Node* copyRandomList(Node* head) &#123;</span><br><span class=\"line\">        if(!head) return NULL;</span><br><span class=\"line\">        Node * ret = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 将A→B→C，拆分为 A→A ′ →B→B ′ →C→C ′</span><br><span class=\"line\">        while(ret)&#123;</span><br><span class=\"line\">            Node *q = new Node(ret-&gt;val);</span><br><span class=\"line\">            q-&gt;next = ret-&gt;next;   </span><br><span class=\"line\">            ret-&gt;next = q;      </span><br><span class=\"line\">            ret = q-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // S ′ 指向其原节点 S 的随机指针指向的节点 T 的后继节点 T ′</span><br><span class=\"line\">        while(ret)&#123;</span><br><span class=\"line\">            Node* pre = ret;</span><br><span class=\"line\">            ret = ret-&gt;next;</span><br><span class=\"line\">            if(pre-&gt;random) ret-&gt;random = pre-&gt;random-&gt;next;</span><br><span class=\"line\">            else ret-&gt;random = NULL;            </span><br><span class=\"line\">            ret = ret-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret = head-&gt;next;</span><br><span class=\"line\">        Node* p = head;</span><br><span class=\"line\">        Node * q = ret;</span><br><span class=\"line\">        Node * now = ret;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //拆分原数组和拷贝数组</span><br><span class=\"line\">        while(p-&gt;next)&#123;</span><br><span class=\"line\">            now = now-&gt;next;</span><br><span class=\"line\">            q = p-&gt;next;</span><br><span class=\"line\">            p-&gt;next = now;          </span><br><span class=\"line\">            p = q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"【LeetCode.1143】最长公共子序列","date":"2021-07-26T15:32:25.000Z","_content":"\n\n\n### \t题目： 最长公共子序列\n\n​\t给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 公共子序列 ，返回 `0` 。\n\n​\t一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n\n​\t例如，`\"ace\"` 是 `\"abcde\"` 的子序列，但 `\"aec\"` 不是 `\"abcde\"` 的子序列。\n​\t两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。\n\n \n\n<!--more-->\n\n示例 1：\n\n```\n输入：text1 = \"abcde\", text2 = \"ace\" \n输出：3  \n解释：最长公共子序列是 \"ace\" ，它的长度为 3 。\n```\n\n示例 2：\n\n```\n输入：text1 = \"abc\", text2 = \"abc\"\n输出：3\n解释：最长公共子序列是 \"abc\" ，它的长度为 3 。\n```\n\n示例 3：\n\n```\n输入：text1 = \"abc\", text2 = \"def\"\n输出：0\n解释：两个字符串没有公共子序列，返回 0 。\n```\n\n\n\n提示：\n\n`1 <= text1.length, text2.length <= 1000`\n`text1 和 text2 仅由小写英文字符组成。`\n\n\n\n---\n\n\n\n### 分析：\n\n定义 `dp[i][j]` 表示 `text1[0:i]` 和 `text2[0:j]` 的最长公共子序列，其中 `text1[0:i]` 表示数组中从`0`到`i`长度为 `i + 1`的子数组\n\n当 `text1[i - 1] == text2[j - 1]` 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 `1`，所以 `dp[i][j] = dp[i - 1][j - 1] + 1`；举个例子，比如对于 `ac` 和 `bc` 而言，他们的最长公共子序列的长度等于 `a` 和 `b` 的最长公共子序列长度 `0 + 1 = 1`。\n当 `text1[i - 1] != text2[j - 1]` 时，说明两个子字符串的最后一位不相等，那么此时的状态 `dp[i][j]` 应该是 `dp[i - 1][j]` 和 `dp[i][j - 1]` 的最大值。举个例子，比如对于 `ace` 和 `bc` 而言，他们的最长公共子序列的长度等于 ① `ace` 和 `b` 的最长公共子序列长度`0` 与 ② `ac` 和 `bc` 的最长公共子序列长度`1` 的最大值，即 `1`。\n\n综上状态转移方程为：\n\n`dp[i][j] = dp[i - 1][j - 1] + 1, 当 text1[i - 1] == text2[j - 1];text1[i−1]==text2[j−1];`\n`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]), 当 text1[i - 1] != text2[j - 1]text1[i−1]!=text2[j−1]`\n\n\n\n----\n\n\n\n### 题解：\n\n```\nclass Solution {\npublic:\n\t//动态规划\n    int longestCommonSubsequence(string text1, string text2) {\n        int n = text1.size(), m = text2.size();\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\n        //逐渐将text1[i - 1]和text2[j - 1]纳入考虑，更新dp数组\n        for(int i = 1; i <= n; i++){\n            char c1 = text1[i - 1];\n            for(int j = 1; j <= m; j++){\n                char c2 = text2[j - 1];\n                if(c1 == c2) dp[i][j] = dp[i - 1][j - 1] + 1;\n                else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);\n            }\n        }\n        return dp[n][m];\n    }\n};\n```\n\n\n\n---\n\n\n\n### 总结：\n\n遇到考查动态规划的题也算有点头绪了，我的感悟是这是一种从无到有的思想：一步一步将单个信息纳入考虑范围，然后按照条件更新已知的情报。其中的难点在于`dp`数组的定义，怎么样的定义才能有效快捷地达成目的呢？\n","source":"_posts/2021-07-26-【LeetCode.1143】最长公共子序列.md","raw":"---\ntitle: 【LeetCode.1143】最长公共子序列\ndate: 2021-07-26 23:32:25\ncategories:\t算法\ntags:\n  - c++\n  - 动态规划\n  - 数组\n  - vector\n---\n\n\n\n### \t题目： 最长公共子序列\n\n​\t给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 公共子序列 ，返回 `0` 。\n\n​\t一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n\n​\t例如，`\"ace\"` 是 `\"abcde\"` 的子序列，但 `\"aec\"` 不是 `\"abcde\"` 的子序列。\n​\t两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。\n\n \n\n<!--more-->\n\n示例 1：\n\n```\n输入：text1 = \"abcde\", text2 = \"ace\" \n输出：3  \n解释：最长公共子序列是 \"ace\" ，它的长度为 3 。\n```\n\n示例 2：\n\n```\n输入：text1 = \"abc\", text2 = \"abc\"\n输出：3\n解释：最长公共子序列是 \"abc\" ，它的长度为 3 。\n```\n\n示例 3：\n\n```\n输入：text1 = \"abc\", text2 = \"def\"\n输出：0\n解释：两个字符串没有公共子序列，返回 0 。\n```\n\n\n\n提示：\n\n`1 <= text1.length, text2.length <= 1000`\n`text1 和 text2 仅由小写英文字符组成。`\n\n\n\n---\n\n\n\n### 分析：\n\n定义 `dp[i][j]` 表示 `text1[0:i]` 和 `text2[0:j]` 的最长公共子序列，其中 `text1[0:i]` 表示数组中从`0`到`i`长度为 `i + 1`的子数组\n\n当 `text1[i - 1] == text2[j - 1]` 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 `1`，所以 `dp[i][j] = dp[i - 1][j - 1] + 1`；举个例子，比如对于 `ac` 和 `bc` 而言，他们的最长公共子序列的长度等于 `a` 和 `b` 的最长公共子序列长度 `0 + 1 = 1`。\n当 `text1[i - 1] != text2[j - 1]` 时，说明两个子字符串的最后一位不相等，那么此时的状态 `dp[i][j]` 应该是 `dp[i - 1][j]` 和 `dp[i][j - 1]` 的最大值。举个例子，比如对于 `ace` 和 `bc` 而言，他们的最长公共子序列的长度等于 ① `ace` 和 `b` 的最长公共子序列长度`0` 与 ② `ac` 和 `bc` 的最长公共子序列长度`1` 的最大值，即 `1`。\n\n综上状态转移方程为：\n\n`dp[i][j] = dp[i - 1][j - 1] + 1, 当 text1[i - 1] == text2[j - 1];text1[i−1]==text2[j−1];`\n`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]), 当 text1[i - 1] != text2[j - 1]text1[i−1]!=text2[j−1]`\n\n\n\n----\n\n\n\n### 题解：\n\n```\nclass Solution {\npublic:\n\t//动态规划\n    int longestCommonSubsequence(string text1, string text2) {\n        int n = text1.size(), m = text2.size();\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\n        //逐渐将text1[i - 1]和text2[j - 1]纳入考虑，更新dp数组\n        for(int i = 1; i <= n; i++){\n            char c1 = text1[i - 1];\n            for(int j = 1; j <= m; j++){\n                char c2 = text2[j - 1];\n                if(c1 == c2) dp[i][j] = dp[i - 1][j - 1] + 1;\n                else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);\n            }\n        }\n        return dp[n][m];\n    }\n};\n```\n\n\n\n---\n\n\n\n### 总结：\n\n遇到考查动态规划的题也算有点头绪了，我的感悟是这是一种从无到有的思想：一步一步将单个信息纳入考虑范围，然后按照条件更新已知的情报。其中的难点在于`dp`数组的定义，怎么样的定义才能有效快捷地达成目的呢？\n","slug":"2021-07-26-【LeetCode.1143】最长公共子序列","published":1,"updated":"2021-07-26T16:01:08.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hk00191ou0cmax4vnj","content":"<h3 id=\"题目：-最长公共子序列\"><a href=\"#题目：-最长公共子序列\" class=\"headerlink\" title=\"题目： 最长公共子序列\"></a>题目： 最长公共子序列</h3><p>​    给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 公共子序列 ，返回 <code>0</code> 。</p>\n<p>​    一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>\n<p>​    例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。<br>​    两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>\n<span id=\"more\"></span>\n\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class=\"line\">输出：3  </span><br><span class=\"line\">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>\n\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>提示：</p>\n<p><code>1 &lt;= text1.length, text2.length &lt;= 1000</code><br><code>text1 和 text2 仅由小写英文字符组成。</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>定义 <code>dp[i][j]</code> 表示 <code>text1[0:i]</code> 和 <code>text2[0:j]</code> 的最长公共子序列，其中 <code>text1[0:i]</code> 表示数组中从<code>0</code>到<code>i</code>长度为 <code>i + 1</code>的子数组</p>\n<p>当 <code>text1[i - 1] == text2[j - 1]</code> 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 <code>1</code>，所以 <code>dp[i][j] = dp[i - 1][j - 1] + 1</code>；举个例子，比如对于 <code>ac</code> 和 <code>bc</code> 而言，他们的最长公共子序列的长度等于 <code>a</code> 和 <code>b</code> 的最长公共子序列长度 <code>0 + 1 = 1</code>。<br>当 <code>text1[i - 1] != text2[j - 1]</code> 时，说明两个子字符串的最后一位不相等，那么此时的状态 <code>dp[i][j]</code> 应该是 <code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code> 的最大值。举个例子，比如对于 <code>ace</code> 和 <code>bc</code> 而言，他们的最长公共子序列的长度等于 ① <code>ace</code> 和 <code>b</code> 的最长公共子序列长度<code>0</code> 与 ② <code>ac</code> 和 <code>bc</code> 的最长公共子序列长度<code>1</code> 的最大值，即 <code>1</code>。</p>\n<p>综上状态转移方程为：</p>\n<p><code>dp[i][j] = dp[i - 1][j - 1] + 1, 当 text1[i - 1] == text2[j - 1];text1[i−1]==text2[j−1];</code><br><code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]), 当 text1[i - 1] != text2[j - 1]text1[i−1]!=text2[j−1]</code></p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\t//动态规划</span><br><span class=\"line\">    int longestCommonSubsequence(string text1, string text2) &#123;</span><br><span class=\"line\">        int n = text1.size(), m = text2.size();</span><br><span class=\"line\">        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1));</span><br><span class=\"line\">        //逐渐将text1[i - 1]和text2[j - 1]纳入考虑，更新dp数组</span><br><span class=\"line\">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            char c1 = text1[i - 1];</span><br><span class=\"line\">            for(int j = 1; j &lt;= m; j++)&#123;</span><br><span class=\"line\">                char c2 = text2[j - 1];</span><br><span class=\"line\">                if(c1 == c2) dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class=\"line\">                else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[n][m];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>遇到考查动态规划的题也算有点头绪了，我的感悟是这是一种从无到有的思想：一步一步将单个信息纳入考虑范围，然后按照条件更新已知的情报。其中的难点在于<code>dp</code>数组的定义，怎么样的定义才能有效快捷地达成目的呢？</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"题目：-最长公共子序列\"><a href=\"#题目：-最长公共子序列\" class=\"headerlink\" title=\"题目： 最长公共子序列\"></a>题目： 最长公共子序列</h3><p>​    给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 公共子序列 ，返回 <code>0</code> 。</p>\n<p>​    一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>\n<p>​    例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。<br>​    两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>","more":"<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class=\"line\">输出：3  </span><br><span class=\"line\">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>\n\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>提示：</p>\n<p><code>1 &lt;= text1.length, text2.length &lt;= 1000</code><br><code>text1 和 text2 仅由小写英文字符组成。</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>定义 <code>dp[i][j]</code> 表示 <code>text1[0:i]</code> 和 <code>text2[0:j]</code> 的最长公共子序列，其中 <code>text1[0:i]</code> 表示数组中从<code>0</code>到<code>i</code>长度为 <code>i + 1</code>的子数组</p>\n<p>当 <code>text1[i - 1] == text2[j - 1]</code> 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 <code>1</code>，所以 <code>dp[i][j] = dp[i - 1][j - 1] + 1</code>；举个例子，比如对于 <code>ac</code> 和 <code>bc</code> 而言，他们的最长公共子序列的长度等于 <code>a</code> 和 <code>b</code> 的最长公共子序列长度 <code>0 + 1 = 1</code>。<br>当 <code>text1[i - 1] != text2[j - 1]</code> 时，说明两个子字符串的最后一位不相等，那么此时的状态 <code>dp[i][j]</code> 应该是 <code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code> 的最大值。举个例子，比如对于 <code>ace</code> 和 <code>bc</code> 而言，他们的最长公共子序列的长度等于 ① <code>ace</code> 和 <code>b</code> 的最长公共子序列长度<code>0</code> 与 ② <code>ac</code> 和 <code>bc</code> 的最长公共子序列长度<code>1</code> 的最大值，即 <code>1</code>。</p>\n<p>综上状态转移方程为：</p>\n<p><code>dp[i][j] = dp[i - 1][j - 1] + 1, 当 text1[i - 1] == text2[j - 1];text1[i−1]==text2[j−1];</code><br><code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]), 当 text1[i - 1] != text2[j - 1]text1[i−1]!=text2[j−1]</code></p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\t//动态规划</span><br><span class=\"line\">    int longestCommonSubsequence(string text1, string text2) &#123;</span><br><span class=\"line\">        int n = text1.size(), m = text2.size();</span><br><span class=\"line\">        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1));</span><br><span class=\"line\">        //逐渐将text1[i - 1]和text2[j - 1]纳入考虑，更新dp数组</span><br><span class=\"line\">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            char c1 = text1[i - 1];</span><br><span class=\"line\">            for(int j = 1; j &lt;= m; j++)&#123;</span><br><span class=\"line\">                char c2 = text2[j - 1];</span><br><span class=\"line\">                if(c1 == c2) dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class=\"line\">                else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[n][m];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>遇到考查动态规划的题也算有点头绪了，我的感悟是这是一种从无到有的思想：一步一步将单个信息纳入考虑范围，然后按照条件更新已知的情报。其中的难点在于<code>dp</code>数组的定义，怎么样的定义才能有效快捷地达成目的呢？</p>"},{"title":"《Robbie Swifthand》Unity2d独立游戏学习（五）","date":"2021-07-30T12:37:14.000Z","_content":"\n\n\n### \t始、前言\n\n一个小知识，预制体放入场景中后，如果在场景中的物体修改完想同步到预制体，需要选择场景中物体的 Inspector → Prefab → Overrides → Apply All\n\n<!--more-->\n\n---\n\n\n\n### \t一、角色动画\n\n1.打开Robbie 文件夹将资源里的材质拖拽到场景中主角的子物体中，并关闭原父物体的Render\n\n2.发现新加的body 里骨骼的Sorting Layer 全是Default ，直接修改Sorting Layer 的顺序好了，把Default 移动到背景的下方，这样就会显示在背景的前面\n\n3.打开body的Animator 看看，已经有几个变量和连接好的状态机\n\n4.新建脚本PlayerAnimation 挂到body上 ，先获取组件和变量：\n\n```\n\tAnimator anim;\n    PlayerMovement movement;\n    Rigidbody2D rb;\n    \n    void Start()\n    {\n        anim = GetComponent<Animator>();\n        movement = GetComponentInParent<PlayerMovement>();\n        rb = GetComponentInParent<Rigidbody2D>();\n    }\n```\n\nGetComponentInParent可以获取父级的组件\n\n状态机中已经添加了很多动画效果，但是跳跃的还没有，那现在就来自己添加跳跃的动画效果\n\n\n\n5.打开混合树Mid Air，同时打开资源中动画资源的MId Air文件夹，给混合树添加7个MId Air的动画资源，设置参考变量为verticalVelocity，然后按照动作设置好各自的值（值的大小就参照跳跃时Rigidbody的Velocity.y 的值）\n\n\n\n6..获取角色移动代码PlayerMovement中的变量，记得先改成Public类型。然后用编号法给动画变量赋值：\n\n```\n    //动画状态编号\n    int groundID;\n    int speedID;\n    int crouchID;\n    int hangingID;\n    int fallID;\n    \n    void Start()\n    {\n        groundID = Animator.StringToHash(\"isOnGround\");\n        speedID = Animator.StringToHash(\"speed\");\n        hangingID = Animator.StringToHash(\"isHanging\");\n        crouchID = Animator.StringToHash(\"isCrouching\");\n        fallID = Animator.StringToHash(\"verticalVelocity\");\n    }\n    \n    void Update()\n    {\n        anim.SetFloat(speedID, Mathf.Abs(movement.xVelocity));//撞墙也会继续跑\n        /*anim.SetFloat(speedID, Mathf.Abs(rb.velocity.x));*/ //撞墙停下\n        anim.SetBool(groundID, movement.isOnGround);\n        anim.SetBool(crouchID, movement.isCrouch);\n        anim.SetBool(hangingID, movement.isHanging);\n        anim.SetFloat(fallID, rb.velocity.y);\n    }\n```\n\nAnimator.StringToHash() 可以获取变量在变量列表中的编号\n\n为什么官方推荐用编号来赋值呢？给出的解释是这样可以避免移动端可能产生的一些错误\n\n\n\n---\n\n\n\n### 二、音效控制\n\n在角色的走路和下蹲走路的动画中都插入了一些音效，模拟脚步的声音，现在就来补上这些音效\n\n1.在PlayerAnimation 脚本中添加对应的发声函数：\n\n```\n    public void StepAudio()\n    {\n        AudioManager.PlayFootstepAudio();\n    }\n\n    public void CrouchStepAudio()\n    {\n        AudioManager.PlayCrouchFootstepAudio();\n    }\n```\n\n名字不同的话记得修改动画中调用的函数\n\n\n\n2.将Audios文件夹中的预制体Audio Manager加入场景中\n\n3.新建AudioManager脚本挂在Audio Manager物体中（绕口令？），先新建一些变量来存放音效资源：\n\n```\n    static AudioManager current;\n\n    [Header(\"环境声音\")]\n    public AudioClip ambientClip;\n    public AudioClip musicClip;\n\n    [Header(\"主角音效\")]\n    public AudioClip[] walkStepClips;\n    public AudioClip[] crouchStepClips;\n    public AudioClip jumpClip;\n    public AudioClip jumpVoiceClip;\n```\n\n然后将资源里的音效资源拖拽到相应的变量位置，这样就可以在代码中控制音效播放\n\n\n\n4.我们需要在游戏一开始就处理好音效的事情，所以用Awake函数来进行各种设置：\n\n```\n    private void Awake()\n    {\n        current = this;\n\n        //切换场景也不会销毁这个物体\n        DontDestroyOnLoad(gameObject);\n    }\n```\n\n\n\n5.为了避免在属性界面中处理太多的组件，选择在代码中添加组件，这样有助于同一管理并且减少失误的发生：\n\n```\n    //声音播放组件\n    AudioSource ambientSource;\n    AudioSource musicSource;\n    AudioSource fxSource;\n    AudioSource playerSource;\n    AudioSource voiceSource;\n    \n    private void Awake()\n    {\n        ambientSource = gameObject.AddComponent<AudioSource>();\n        musicSource = gameObject.AddComponent<AudioSource>();\n        fxSource = gameObject.AddComponent<AudioSource>();\n        playerSource = gameObject.AddComponent<AudioSource>();\n        voiceSource = gameObject.AddComponent<AudioSource>();\n    }\n```\n\n\n\n6.编写背景声音的发声函数：\n\n```\n    void StartLevelAudio()\n    {\n        current.ambientSource.clip = current.ambientClip;\n        current.ambientSource.loop = true;\n        current.ambientSource.Play();\n\n        current.musicSource.clip = current.musicClip;\n        current.musicSource.loop = true;\n        current.musicSource.Play();\n    }\n```\n\n在本脚本Awake()调用，一开始运行游戏就有背景声音\n\n\n\n7.编写脚步声音的两种发声函数：\n\n```\n    public static void PlayFootstepAudio()\n    {\n        int index = Random.Range(0, current.walkStepClips.Length);\n\n        current.playerSource.clip = current.walkStepClips[index];\n        current.playerSource.Play();\n    }    \n    \n    public static void PlayCrouchFootstepAudio()\n    {\n        int index = Random.Range(0, current.crouchStepClips.Length);\n\n        current.playerSource.clip = current.crouchStepClips[index];\n        current.playerSource.Play();\n    }\n```\n\n在PlayerAnimation脚本中调用，因为这是在动画中调用的函数：\n\n```\n    public void StepAudio()\n    {\n        AudioManager.PlayFootstepAudio();\n    }\n\n    public void CrouchStepAudio()\n    {\n        AudioManager.PlayCrouchFootstepAudio();\n    }\n```\n\n\n\n8.编写跳跃声音的发声函数：\n\n```\n    public static void PlayJumpAudio()\n    {\n        current.playerSource.clip = current.jumpClip;\n        current.playerSource.Play();\n\n        current.voiceSource.clip = current.jumpVoiceClip;\n        current.voiceSource.Play();\n    }\n```\n\n其中包括了起跳的脚步声和人物声，在PlayerMovement脚本中的跳跃函数中的起跳部分调用：\n\n```\n    void MidAirMovement()//空中移动\n    {\n        if(jumpPressed && isOnGround && !isJump && !isHeadBlocked)//起跳\n        {\n            AudioManager.PlayJumpAudio();\n\t\t}\n\t}\n```\n\n\n\n---\n\n\n\n### 终、本节总结\n\n测试游戏，移动时发现主角的反光情况有些不对劲，原因是角色移动时图案的翻转代码中用的是二维的向量，这样就会使得z 轴大小变为0 ，即厚度没了人物瘪了光也反不了了，要改成三维向量：\n\n```\n    void flipDirection()//改变角色图案方向\n    {\n        if (xVelocity > 0) transform.localScale = new Vector3 (1, 1, 1);\n        else if (xVelocity < 0) transform.localScale = new Vector3(-1, 1, 1);\n    }\n```\n\n\n\n下面记录一下这次新增的两个脚本内容：\n\nPlayerAnimation脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerAnimation : MonoBehaviour\n{\n\n    Animator anim;\n    PlayerMovement movement;\n    Rigidbody2D rb;\n\n    //动画状态编号\n    int groundID;\n    int speedID;\n    int crouchID;\n    int hangingID;\n    int fallID;\n\n    void Start()\n    {\n        anim = GetComponent<Animator>();\n        movement = GetComponentInParent<PlayerMovement>();\n        rb = GetComponentInParent<Rigidbody2D>();\n\n        groundID = Animator.StringToHash(\"isOnGround\");\n        speedID = Animator.StringToHash(\"speed\");\n        hangingID = Animator.StringToHash(\"isHanging\");\n        crouchID = Animator.StringToHash(\"isCrouching\");\n        fallID = Animator.StringToHash(\"verticalVelocity\");\n    }\n\n    void Update()\n    {\n        anim.SetFloat(speedID, Mathf.Abs(movement.xVelocity));//撞墙也会继续跑\n        /*anim.SetFloat(speedID, rb.velocity.x);*/ //撞墙停下\n        anim.SetBool(groundID, movement.isOnGround);\n        anim.SetBool(crouchID, movement.isCrouch);\n        anim.SetBool(hangingID, movement.isHanging);\n        anim.SetFloat(fallID, rb.velocity.y);\n    }\n\n    public void StepAudio()\n    {\n        AudioManager.PlayFootstepAudio();\n    }\n\n    public void CrouchStepAudio()\n    {\n        AudioManager.PlayCrouchFootstepAudio();\n    }\n}\n\n```\n\n\n\nAudioManager脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\nusing UnityEngine.Audio;\n\npublic class AudioManager : MonoBehaviour\n{\n    static AudioManager current;\n\n    [Header(\"环境声音\")]\n    public AudioClip ambientClip;\n    public AudioClip musicClip;\n\n    [Header(\"主角音效\")]\n    public AudioClip[] walkStepClips;\n    public AudioClip[] crouchStepClips;\n    public AudioClip jumpClip;\n    public AudioClip jumpVoiceClip;\n\n    //声音播放组件\n    AudioSource ambientSource;\n    AudioSource musicSource;\n    AudioSource fxSource;\n    AudioSource playerSource;\n    AudioSource voiceSource;\n\n    private void Awake()\n    {\n        current = this;\n\n        //切换场景也不会销毁这个物体\n        DontDestroyOnLoad(gameObject);\n\n        ambientSource = gameObject.AddComponent<AudioSource>();\n        musicSource = gameObject.AddComponent<AudioSource>();\n        fxSource = gameObject.AddComponent<AudioSource>();\n        playerSource = gameObject.AddComponent<AudioSource>();\n        voiceSource = gameObject.AddComponent<AudioSource>();\n\n        StartLevelAudio();\n    }\n\n    void StartLevelAudio()\n    {\n        current.ambientSource.clip = current.ambientClip;\n        current.ambientSource.loop = true;\n        current.ambientSource.Play();\n\n        current.musicSource.clip = current.musicClip;\n        current.musicSource.loop = true;\n        current.musicSource.Play();\n    }\n\n    public static void PlayFootstepAudio()\n    {\n        int index = Random.Range(0, current.walkStepClips.Length);\n\n        current.playerSource.clip = current.walkStepClips[index];\n        current.playerSource.Play();\n    }    \n    \n    public static void PlayCrouchFootstepAudio()\n    {\n        int index = Random.Range(0, current.crouchStepClips.Length);\n\n        current.playerSource.clip = current.crouchStepClips[index];\n        current.playerSource.Play();\n    }\n\n    public static void PlayJumpAudio()\n    {\n        current.playerSource.clip = current.jumpClip;\n        current.playerSource.Play();\n\n        current.voiceSource.clip = current.jumpVoiceClip;\n        current.voiceSource.Play();\n    }\n}\n```\n\n","source":"_posts/2021-07-30-《Robbie Swifthand》Unity2d独立游戏学习（五）.md","raw":"---\ntitle: 《Robbie Swifthand》Unity2d独立游戏学习（五）\ndate: 2021-07-30 20:37:14\ncategories:\tunity\ntags:\n  - unity\n  - c#\n  - animator\n  - audio\n---\n\n\n\n### \t始、前言\n\n一个小知识，预制体放入场景中后，如果在场景中的物体修改完想同步到预制体，需要选择场景中物体的 Inspector → Prefab → Overrides → Apply All\n\n<!--more-->\n\n---\n\n\n\n### \t一、角色动画\n\n1.打开Robbie 文件夹将资源里的材质拖拽到场景中主角的子物体中，并关闭原父物体的Render\n\n2.发现新加的body 里骨骼的Sorting Layer 全是Default ，直接修改Sorting Layer 的顺序好了，把Default 移动到背景的下方，这样就会显示在背景的前面\n\n3.打开body的Animator 看看，已经有几个变量和连接好的状态机\n\n4.新建脚本PlayerAnimation 挂到body上 ，先获取组件和变量：\n\n```\n\tAnimator anim;\n    PlayerMovement movement;\n    Rigidbody2D rb;\n    \n    void Start()\n    {\n        anim = GetComponent<Animator>();\n        movement = GetComponentInParent<PlayerMovement>();\n        rb = GetComponentInParent<Rigidbody2D>();\n    }\n```\n\nGetComponentInParent可以获取父级的组件\n\n状态机中已经添加了很多动画效果，但是跳跃的还没有，那现在就来自己添加跳跃的动画效果\n\n\n\n5.打开混合树Mid Air，同时打开资源中动画资源的MId Air文件夹，给混合树添加7个MId Air的动画资源，设置参考变量为verticalVelocity，然后按照动作设置好各自的值（值的大小就参照跳跃时Rigidbody的Velocity.y 的值）\n\n\n\n6..获取角色移动代码PlayerMovement中的变量，记得先改成Public类型。然后用编号法给动画变量赋值：\n\n```\n    //动画状态编号\n    int groundID;\n    int speedID;\n    int crouchID;\n    int hangingID;\n    int fallID;\n    \n    void Start()\n    {\n        groundID = Animator.StringToHash(\"isOnGround\");\n        speedID = Animator.StringToHash(\"speed\");\n        hangingID = Animator.StringToHash(\"isHanging\");\n        crouchID = Animator.StringToHash(\"isCrouching\");\n        fallID = Animator.StringToHash(\"verticalVelocity\");\n    }\n    \n    void Update()\n    {\n        anim.SetFloat(speedID, Mathf.Abs(movement.xVelocity));//撞墙也会继续跑\n        /*anim.SetFloat(speedID, Mathf.Abs(rb.velocity.x));*/ //撞墙停下\n        anim.SetBool(groundID, movement.isOnGround);\n        anim.SetBool(crouchID, movement.isCrouch);\n        anim.SetBool(hangingID, movement.isHanging);\n        anim.SetFloat(fallID, rb.velocity.y);\n    }\n```\n\nAnimator.StringToHash() 可以获取变量在变量列表中的编号\n\n为什么官方推荐用编号来赋值呢？给出的解释是这样可以避免移动端可能产生的一些错误\n\n\n\n---\n\n\n\n### 二、音效控制\n\n在角色的走路和下蹲走路的动画中都插入了一些音效，模拟脚步的声音，现在就来补上这些音效\n\n1.在PlayerAnimation 脚本中添加对应的发声函数：\n\n```\n    public void StepAudio()\n    {\n        AudioManager.PlayFootstepAudio();\n    }\n\n    public void CrouchStepAudio()\n    {\n        AudioManager.PlayCrouchFootstepAudio();\n    }\n```\n\n名字不同的话记得修改动画中调用的函数\n\n\n\n2.将Audios文件夹中的预制体Audio Manager加入场景中\n\n3.新建AudioManager脚本挂在Audio Manager物体中（绕口令？），先新建一些变量来存放音效资源：\n\n```\n    static AudioManager current;\n\n    [Header(\"环境声音\")]\n    public AudioClip ambientClip;\n    public AudioClip musicClip;\n\n    [Header(\"主角音效\")]\n    public AudioClip[] walkStepClips;\n    public AudioClip[] crouchStepClips;\n    public AudioClip jumpClip;\n    public AudioClip jumpVoiceClip;\n```\n\n然后将资源里的音效资源拖拽到相应的变量位置，这样就可以在代码中控制音效播放\n\n\n\n4.我们需要在游戏一开始就处理好音效的事情，所以用Awake函数来进行各种设置：\n\n```\n    private void Awake()\n    {\n        current = this;\n\n        //切换场景也不会销毁这个物体\n        DontDestroyOnLoad(gameObject);\n    }\n```\n\n\n\n5.为了避免在属性界面中处理太多的组件，选择在代码中添加组件，这样有助于同一管理并且减少失误的发生：\n\n```\n    //声音播放组件\n    AudioSource ambientSource;\n    AudioSource musicSource;\n    AudioSource fxSource;\n    AudioSource playerSource;\n    AudioSource voiceSource;\n    \n    private void Awake()\n    {\n        ambientSource = gameObject.AddComponent<AudioSource>();\n        musicSource = gameObject.AddComponent<AudioSource>();\n        fxSource = gameObject.AddComponent<AudioSource>();\n        playerSource = gameObject.AddComponent<AudioSource>();\n        voiceSource = gameObject.AddComponent<AudioSource>();\n    }\n```\n\n\n\n6.编写背景声音的发声函数：\n\n```\n    void StartLevelAudio()\n    {\n        current.ambientSource.clip = current.ambientClip;\n        current.ambientSource.loop = true;\n        current.ambientSource.Play();\n\n        current.musicSource.clip = current.musicClip;\n        current.musicSource.loop = true;\n        current.musicSource.Play();\n    }\n```\n\n在本脚本Awake()调用，一开始运行游戏就有背景声音\n\n\n\n7.编写脚步声音的两种发声函数：\n\n```\n    public static void PlayFootstepAudio()\n    {\n        int index = Random.Range(0, current.walkStepClips.Length);\n\n        current.playerSource.clip = current.walkStepClips[index];\n        current.playerSource.Play();\n    }    \n    \n    public static void PlayCrouchFootstepAudio()\n    {\n        int index = Random.Range(0, current.crouchStepClips.Length);\n\n        current.playerSource.clip = current.crouchStepClips[index];\n        current.playerSource.Play();\n    }\n```\n\n在PlayerAnimation脚本中调用，因为这是在动画中调用的函数：\n\n```\n    public void StepAudio()\n    {\n        AudioManager.PlayFootstepAudio();\n    }\n\n    public void CrouchStepAudio()\n    {\n        AudioManager.PlayCrouchFootstepAudio();\n    }\n```\n\n\n\n8.编写跳跃声音的发声函数：\n\n```\n    public static void PlayJumpAudio()\n    {\n        current.playerSource.clip = current.jumpClip;\n        current.playerSource.Play();\n\n        current.voiceSource.clip = current.jumpVoiceClip;\n        current.voiceSource.Play();\n    }\n```\n\n其中包括了起跳的脚步声和人物声，在PlayerMovement脚本中的跳跃函数中的起跳部分调用：\n\n```\n    void MidAirMovement()//空中移动\n    {\n        if(jumpPressed && isOnGround && !isJump && !isHeadBlocked)//起跳\n        {\n            AudioManager.PlayJumpAudio();\n\t\t}\n\t}\n```\n\n\n\n---\n\n\n\n### 终、本节总结\n\n测试游戏，移动时发现主角的反光情况有些不对劲，原因是角色移动时图案的翻转代码中用的是二维的向量，这样就会使得z 轴大小变为0 ，即厚度没了人物瘪了光也反不了了，要改成三维向量：\n\n```\n    void flipDirection()//改变角色图案方向\n    {\n        if (xVelocity > 0) transform.localScale = new Vector3 (1, 1, 1);\n        else if (xVelocity < 0) transform.localScale = new Vector3(-1, 1, 1);\n    }\n```\n\n\n\n下面记录一下这次新增的两个脚本内容：\n\nPlayerAnimation脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerAnimation : MonoBehaviour\n{\n\n    Animator anim;\n    PlayerMovement movement;\n    Rigidbody2D rb;\n\n    //动画状态编号\n    int groundID;\n    int speedID;\n    int crouchID;\n    int hangingID;\n    int fallID;\n\n    void Start()\n    {\n        anim = GetComponent<Animator>();\n        movement = GetComponentInParent<PlayerMovement>();\n        rb = GetComponentInParent<Rigidbody2D>();\n\n        groundID = Animator.StringToHash(\"isOnGround\");\n        speedID = Animator.StringToHash(\"speed\");\n        hangingID = Animator.StringToHash(\"isHanging\");\n        crouchID = Animator.StringToHash(\"isCrouching\");\n        fallID = Animator.StringToHash(\"verticalVelocity\");\n    }\n\n    void Update()\n    {\n        anim.SetFloat(speedID, Mathf.Abs(movement.xVelocity));//撞墙也会继续跑\n        /*anim.SetFloat(speedID, rb.velocity.x);*/ //撞墙停下\n        anim.SetBool(groundID, movement.isOnGround);\n        anim.SetBool(crouchID, movement.isCrouch);\n        anim.SetBool(hangingID, movement.isHanging);\n        anim.SetFloat(fallID, rb.velocity.y);\n    }\n\n    public void StepAudio()\n    {\n        AudioManager.PlayFootstepAudio();\n    }\n\n    public void CrouchStepAudio()\n    {\n        AudioManager.PlayCrouchFootstepAudio();\n    }\n}\n\n```\n\n\n\nAudioManager脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\nusing UnityEngine.Audio;\n\npublic class AudioManager : MonoBehaviour\n{\n    static AudioManager current;\n\n    [Header(\"环境声音\")]\n    public AudioClip ambientClip;\n    public AudioClip musicClip;\n\n    [Header(\"主角音效\")]\n    public AudioClip[] walkStepClips;\n    public AudioClip[] crouchStepClips;\n    public AudioClip jumpClip;\n    public AudioClip jumpVoiceClip;\n\n    //声音播放组件\n    AudioSource ambientSource;\n    AudioSource musicSource;\n    AudioSource fxSource;\n    AudioSource playerSource;\n    AudioSource voiceSource;\n\n    private void Awake()\n    {\n        current = this;\n\n        //切换场景也不会销毁这个物体\n        DontDestroyOnLoad(gameObject);\n\n        ambientSource = gameObject.AddComponent<AudioSource>();\n        musicSource = gameObject.AddComponent<AudioSource>();\n        fxSource = gameObject.AddComponent<AudioSource>();\n        playerSource = gameObject.AddComponent<AudioSource>();\n        voiceSource = gameObject.AddComponent<AudioSource>();\n\n        StartLevelAudio();\n    }\n\n    void StartLevelAudio()\n    {\n        current.ambientSource.clip = current.ambientClip;\n        current.ambientSource.loop = true;\n        current.ambientSource.Play();\n\n        current.musicSource.clip = current.musicClip;\n        current.musicSource.loop = true;\n        current.musicSource.Play();\n    }\n\n    public static void PlayFootstepAudio()\n    {\n        int index = Random.Range(0, current.walkStepClips.Length);\n\n        current.playerSource.clip = current.walkStepClips[index];\n        current.playerSource.Play();\n    }    \n    \n    public static void PlayCrouchFootstepAudio()\n    {\n        int index = Random.Range(0, current.crouchStepClips.Length);\n\n        current.playerSource.clip = current.crouchStepClips[index];\n        current.playerSource.Play();\n    }\n\n    public static void PlayJumpAudio()\n    {\n        current.playerSource.clip = current.jumpClip;\n        current.playerSource.Play();\n\n        current.voiceSource.clip = current.jumpVoiceClip;\n        current.voiceSource.Play();\n    }\n}\n```\n\n","slug":"2021-07-30-《Robbie Swifthand》Unity2d独立游戏学习（五）","published":1,"updated":"2021-08-08T10:45:54.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hl001d1ou0catvh30l","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>一个小知识，预制体放入场景中后，如果在场景中的物体修改完想同步到预制体，需要选择场景中物体的 Inspector → Prefab → Overrides → Apply All</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、角色动画\"><a href=\"#一、角色动画\" class=\"headerlink\" title=\"一、角色动画\"></a>一、角色动画</h3><p>1.打开Robbie 文件夹将资源里的材质拖拽到场景中主角的子物体中，并关闭原父物体的Render</p>\n<p>2.发现新加的body 里骨骼的Sorting Layer 全是Default ，直接修改Sorting Layer 的顺序好了，把Default 移动到背景的下方，这样就会显示在背景的前面</p>\n<p>3.打开body的Animator 看看，已经有几个变量和连接好的状态机</p>\n<p>4.新建脚本PlayerAnimation 挂到body上 ，先获取组件和变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animator anim;</span><br><span class=\"line\">   PlayerMovement movement;</span><br><span class=\"line\">   Rigidbody2D rb;</span><br><span class=\"line\">   </span><br><span class=\"line\">   void Start()</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       anim = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">       movement = GetComponentInParent&lt;PlayerMovement&gt;();</span><br><span class=\"line\">       rb = GetComponentInParent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>GetComponentInParent可以获取父级的组件</p>\n<p>状态机中已经添加了很多动画效果，但是跳跃的还没有，那现在就来自己添加跳跃的动画效果</p>\n<p>5.打开混合树Mid Air，同时打开资源中动画资源的MId Air文件夹，给混合树添加7个MId Air的动画资源，设置参考变量为verticalVelocity，然后按照动作设置好各自的值（值的大小就参照跳跃时Rigidbody的Velocity.y 的值）</p>\n<p>6..获取角色移动代码PlayerMovement中的变量，记得先改成Public类型。然后用编号法给动画变量赋值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//动画状态编号</span><br><span class=\"line\">int groundID;</span><br><span class=\"line\">int speedID;</span><br><span class=\"line\">int crouchID;</span><br><span class=\"line\">int hangingID;</span><br><span class=\"line\">int fallID;</span><br><span class=\"line\"></span><br><span class=\"line\">void Start()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    groundID = Animator.StringToHash(&quot;isOnGround&quot;);</span><br><span class=\"line\">    speedID = Animator.StringToHash(&quot;speed&quot;);</span><br><span class=\"line\">    hangingID = Animator.StringToHash(&quot;isHanging&quot;);</span><br><span class=\"line\">    crouchID = Animator.StringToHash(&quot;isCrouching&quot;);</span><br><span class=\"line\">    fallID = Animator.StringToHash(&quot;verticalVelocity&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Update()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    anim.SetFloat(speedID, Mathf.Abs(movement.xVelocity));//撞墙也会继续跑</span><br><span class=\"line\">    /*anim.SetFloat(speedID, Mathf.Abs(rb.velocity.x));*/ //撞墙停下</span><br><span class=\"line\">    anim.SetBool(groundID, movement.isOnGround);</span><br><span class=\"line\">    anim.SetBool(crouchID, movement.isCrouch);</span><br><span class=\"line\">    anim.SetBool(hangingID, movement.isHanging);</span><br><span class=\"line\">    anim.SetFloat(fallID, rb.velocity.y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Animator.StringToHash() 可以获取变量在变量列表中的编号</p>\n<p>为什么官方推荐用编号来赋值呢？给出的解释是这样可以避免移动端可能产生的一些错误</p>\n<hr>\n<h3 id=\"二、音效控制\"><a href=\"#二、音效控制\" class=\"headerlink\" title=\"二、音效控制\"></a>二、音效控制</h3><p>在角色的走路和下蹲走路的动画中都插入了一些音效，模拟脚步的声音，现在就来补上这些音效</p>\n<p>1.在PlayerAnimation 脚本中添加对应的发声函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void StepAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AudioManager.PlayFootstepAudio();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void CrouchStepAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AudioManager.PlayCrouchFootstepAudio();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>名字不同的话记得修改动画中调用的函数</p>\n<p>2.将Audios文件夹中的预制体Audio Manager加入场景中</p>\n<p>3.新建AudioManager脚本挂在Audio Manager物体中（绕口令？），先新建一些变量来存放音效资源：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static AudioManager current;</span><br><span class=\"line\"></span><br><span class=\"line\">[Header(&quot;环境声音&quot;)]</span><br><span class=\"line\">public AudioClip ambientClip;</span><br><span class=\"line\">public AudioClip musicClip;</span><br><span class=\"line\"></span><br><span class=\"line\">[Header(&quot;主角音效&quot;)]</span><br><span class=\"line\">public AudioClip[] walkStepClips;</span><br><span class=\"line\">public AudioClip[] crouchStepClips;</span><br><span class=\"line\">public AudioClip jumpClip;</span><br><span class=\"line\">public AudioClip jumpVoiceClip;</span><br></pre></td></tr></table></figure>\n\n<p>然后将资源里的音效资源拖拽到相应的变量位置，这样就可以在代码中控制音效播放</p>\n<p>4.我们需要在游戏一开始就处理好音效的事情，所以用Awake函数来进行各种设置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void Awake()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    current = this;</span><br><span class=\"line\"></span><br><span class=\"line\">    //切换场景也不会销毁这个物体</span><br><span class=\"line\">    DontDestroyOnLoad(gameObject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>5.为了避免在属性界面中处理太多的组件，选择在代码中添加组件，这样有助于同一管理并且减少失误的发生：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//声音播放组件</span><br><span class=\"line\">AudioSource ambientSource;</span><br><span class=\"line\">AudioSource musicSource;</span><br><span class=\"line\">AudioSource fxSource;</span><br><span class=\"line\">AudioSource playerSource;</span><br><span class=\"line\">AudioSource voiceSource;</span><br><span class=\"line\"></span><br><span class=\"line\">private void Awake()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ambientSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">    musicSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">    fxSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">    playerSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">    voiceSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>6.编写背景声音的发声函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void StartLevelAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    current.ambientSource.clip = current.ambientClip;</span><br><span class=\"line\">    current.ambientSource.loop = true;</span><br><span class=\"line\">    current.ambientSource.Play();</span><br><span class=\"line\"></span><br><span class=\"line\">    current.musicSource.clip = current.musicClip;</span><br><span class=\"line\">    current.musicSource.loop = true;</span><br><span class=\"line\">    current.musicSource.Play();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在本脚本Awake()调用，一开始运行游戏就有背景声音</p>\n<p>7.编写脚步声音的两种发声函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void PlayFootstepAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int index = Random.Range(0, current.walkStepClips.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">    current.playerSource.clip = current.walkStepClips[index];</span><br><span class=\"line\">    current.playerSource.Play();</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">public static void PlayCrouchFootstepAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int index = Random.Range(0, current.crouchStepClips.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">    current.playerSource.clip = current.crouchStepClips[index];</span><br><span class=\"line\">    current.playerSource.Play();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在PlayerAnimation脚本中调用，因为这是在动画中调用的函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void StepAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AudioManager.PlayFootstepAudio();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void CrouchStepAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AudioManager.PlayCrouchFootstepAudio();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>8.编写跳跃声音的发声函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void PlayJumpAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    current.playerSource.clip = current.jumpClip;</span><br><span class=\"line\">    current.playerSource.Play();</span><br><span class=\"line\"></span><br><span class=\"line\">    current.voiceSource.clip = current.jumpVoiceClip;</span><br><span class=\"line\">    current.voiceSource.Play();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中包括了起跳的脚步声和人物声，在PlayerMovement脚本中的跳跃函数中的起跳部分调用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   void MidAirMovement()//空中移动</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump &amp;&amp; !isHeadBlocked)//起跳</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           AudioManager.PlayJumpAudio();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"终、本节总结\"><a href=\"#终、本节总结\" class=\"headerlink\" title=\"终、本节总结\"></a>终、本节总结</h3><p>测试游戏，移动时发现主角的反光情况有些不对劲，原因是角色移动时图案的翻转代码中用的是二维的向量，这样就会使得z 轴大小变为0 ，即厚度没了人物瘪了光也反不了了，要改成三维向量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void flipDirection()//改变角色图案方向</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (xVelocity &gt; 0) transform.localScale = new Vector3 (1, 1, 1);</span><br><span class=\"line\">    else if (xVelocity &lt; 0) transform.localScale = new Vector3(-1, 1, 1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>下面记录一下这次新增的两个脚本内容：</p>\n<p>PlayerAnimation脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerAnimation : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Animator anim;</span><br><span class=\"line\">    PlayerMovement movement;</span><br><span class=\"line\">    Rigidbody2D rb;</span><br><span class=\"line\"></span><br><span class=\"line\">    //动画状态编号</span><br><span class=\"line\">    int groundID;</span><br><span class=\"line\">    int speedID;</span><br><span class=\"line\">    int crouchID;</span><br><span class=\"line\">    int hangingID;</span><br><span class=\"line\">    int fallID;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        anim = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">        movement = GetComponentInParent&lt;PlayerMovement&gt;();</span><br><span class=\"line\">        rb = GetComponentInParent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        groundID = Animator.StringToHash(&quot;isOnGround&quot;);</span><br><span class=\"line\">        speedID = Animator.StringToHash(&quot;speed&quot;);</span><br><span class=\"line\">        hangingID = Animator.StringToHash(&quot;isHanging&quot;);</span><br><span class=\"line\">        crouchID = Animator.StringToHash(&quot;isCrouching&quot;);</span><br><span class=\"line\">        fallID = Animator.StringToHash(&quot;verticalVelocity&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        anim.SetFloat(speedID, Mathf.Abs(movement.xVelocity));//撞墙也会继续跑</span><br><span class=\"line\">        /*anim.SetFloat(speedID, rb.velocity.x);*/ //撞墙停下</span><br><span class=\"line\">        anim.SetBool(groundID, movement.isOnGround);</span><br><span class=\"line\">        anim.SetBool(crouchID, movement.isCrouch);</span><br><span class=\"line\">        anim.SetBool(hangingID, movement.isHanging);</span><br><span class=\"line\">        anim.SetFloat(fallID, rb.velocity.y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void StepAudio()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AudioManager.PlayFootstepAudio();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void CrouchStepAudio()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AudioManager.PlayCrouchFootstepAudio();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>AudioManager脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">using UnityEngine.Audio;</span><br><span class=\"line\"></span><br><span class=\"line\">public class AudioManager : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static AudioManager current;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;环境声音&quot;)]</span><br><span class=\"line\">    public AudioClip ambientClip;</span><br><span class=\"line\">    public AudioClip musicClip;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;主角音效&quot;)]</span><br><span class=\"line\">    public AudioClip[] walkStepClips;</span><br><span class=\"line\">    public AudioClip[] crouchStepClips;</span><br><span class=\"line\">    public AudioClip jumpClip;</span><br><span class=\"line\">    public AudioClip jumpVoiceClip;</span><br><span class=\"line\"></span><br><span class=\"line\">    //声音播放组件</span><br><span class=\"line\">    AudioSource ambientSource;</span><br><span class=\"line\">    AudioSource musicSource;</span><br><span class=\"line\">    AudioSource fxSource;</span><br><span class=\"line\">    AudioSource playerSource;</span><br><span class=\"line\">    AudioSource voiceSource;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void Awake()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        current = this;</span><br><span class=\"line\"></span><br><span class=\"line\">        //切换场景也不会销毁这个物体</span><br><span class=\"line\">        DontDestroyOnLoad(gameObject);</span><br><span class=\"line\"></span><br><span class=\"line\">        ambientSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">        musicSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">        fxSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">        playerSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">        voiceSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        StartLevelAudio();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void StartLevelAudio()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        current.ambientSource.clip = current.ambientClip;</span><br><span class=\"line\">        current.ambientSource.loop = true;</span><br><span class=\"line\">        current.ambientSource.Play();</span><br><span class=\"line\"></span><br><span class=\"line\">        current.musicSource.clip = current.musicClip;</span><br><span class=\"line\">        current.musicSource.loop = true;</span><br><span class=\"line\">        current.musicSource.Play();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void PlayFootstepAudio()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int index = Random.Range(0, current.walkStepClips.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">        current.playerSource.clip = current.walkStepClips[index];</span><br><span class=\"line\">        current.playerSource.Play();</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    </span><br><span class=\"line\">    public static void PlayCrouchFootstepAudio()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int index = Random.Range(0, current.crouchStepClips.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">        current.playerSource.clip = current.crouchStepClips[index];</span><br><span class=\"line\">        current.playerSource.Play();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void PlayJumpAudio()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        current.playerSource.clip = current.jumpClip;</span><br><span class=\"line\">        current.playerSource.Play();</span><br><span class=\"line\"></span><br><span class=\"line\">        current.voiceSource.clip = current.jumpVoiceClip;</span><br><span class=\"line\">        current.voiceSource.Play();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>一个小知识，预制体放入场景中后，如果在场景中的物体修改完想同步到预制体，需要选择场景中物体的 Inspector → Prefab → Overrides → Apply All</p>","more":"<hr>\n<h3 id=\"一、角色动画\"><a href=\"#一、角色动画\" class=\"headerlink\" title=\"一、角色动画\"></a>一、角色动画</h3><p>1.打开Robbie 文件夹将资源里的材质拖拽到场景中主角的子物体中，并关闭原父物体的Render</p>\n<p>2.发现新加的body 里骨骼的Sorting Layer 全是Default ，直接修改Sorting Layer 的顺序好了，把Default 移动到背景的下方，这样就会显示在背景的前面</p>\n<p>3.打开body的Animator 看看，已经有几个变量和连接好的状态机</p>\n<p>4.新建脚本PlayerAnimation 挂到body上 ，先获取组件和变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animator anim;</span><br><span class=\"line\">   PlayerMovement movement;</span><br><span class=\"line\">   Rigidbody2D rb;</span><br><span class=\"line\">   </span><br><span class=\"line\">   void Start()</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       anim = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">       movement = GetComponentInParent&lt;PlayerMovement&gt;();</span><br><span class=\"line\">       rb = GetComponentInParent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>GetComponentInParent可以获取父级的组件</p>\n<p>状态机中已经添加了很多动画效果，但是跳跃的还没有，那现在就来自己添加跳跃的动画效果</p>\n<p>5.打开混合树Mid Air，同时打开资源中动画资源的MId Air文件夹，给混合树添加7个MId Air的动画资源，设置参考变量为verticalVelocity，然后按照动作设置好各自的值（值的大小就参照跳跃时Rigidbody的Velocity.y 的值）</p>\n<p>6..获取角色移动代码PlayerMovement中的变量，记得先改成Public类型。然后用编号法给动画变量赋值：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//动画状态编号</span><br><span class=\"line\">int groundID;</span><br><span class=\"line\">int speedID;</span><br><span class=\"line\">int crouchID;</span><br><span class=\"line\">int hangingID;</span><br><span class=\"line\">int fallID;</span><br><span class=\"line\"></span><br><span class=\"line\">void Start()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    groundID = Animator.StringToHash(&quot;isOnGround&quot;);</span><br><span class=\"line\">    speedID = Animator.StringToHash(&quot;speed&quot;);</span><br><span class=\"line\">    hangingID = Animator.StringToHash(&quot;isHanging&quot;);</span><br><span class=\"line\">    crouchID = Animator.StringToHash(&quot;isCrouching&quot;);</span><br><span class=\"line\">    fallID = Animator.StringToHash(&quot;verticalVelocity&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void Update()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    anim.SetFloat(speedID, Mathf.Abs(movement.xVelocity));//撞墙也会继续跑</span><br><span class=\"line\">    /*anim.SetFloat(speedID, Mathf.Abs(rb.velocity.x));*/ //撞墙停下</span><br><span class=\"line\">    anim.SetBool(groundID, movement.isOnGround);</span><br><span class=\"line\">    anim.SetBool(crouchID, movement.isCrouch);</span><br><span class=\"line\">    anim.SetBool(hangingID, movement.isHanging);</span><br><span class=\"line\">    anim.SetFloat(fallID, rb.velocity.y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Animator.StringToHash() 可以获取变量在变量列表中的编号</p>\n<p>为什么官方推荐用编号来赋值呢？给出的解释是这样可以避免移动端可能产生的一些错误</p>\n<hr>\n<h3 id=\"二、音效控制\"><a href=\"#二、音效控制\" class=\"headerlink\" title=\"二、音效控制\"></a>二、音效控制</h3><p>在角色的走路和下蹲走路的动画中都插入了一些音效，模拟脚步的声音，现在就来补上这些音效</p>\n<p>1.在PlayerAnimation 脚本中添加对应的发声函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void StepAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AudioManager.PlayFootstepAudio();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void CrouchStepAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AudioManager.PlayCrouchFootstepAudio();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>名字不同的话记得修改动画中调用的函数</p>\n<p>2.将Audios文件夹中的预制体Audio Manager加入场景中</p>\n<p>3.新建AudioManager脚本挂在Audio Manager物体中（绕口令？），先新建一些变量来存放音效资源：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static AudioManager current;</span><br><span class=\"line\"></span><br><span class=\"line\">[Header(&quot;环境声音&quot;)]</span><br><span class=\"line\">public AudioClip ambientClip;</span><br><span class=\"line\">public AudioClip musicClip;</span><br><span class=\"line\"></span><br><span class=\"line\">[Header(&quot;主角音效&quot;)]</span><br><span class=\"line\">public AudioClip[] walkStepClips;</span><br><span class=\"line\">public AudioClip[] crouchStepClips;</span><br><span class=\"line\">public AudioClip jumpClip;</span><br><span class=\"line\">public AudioClip jumpVoiceClip;</span><br></pre></td></tr></table></figure>\n\n<p>然后将资源里的音效资源拖拽到相应的变量位置，这样就可以在代码中控制音效播放</p>\n<p>4.我们需要在游戏一开始就处理好音效的事情，所以用Awake函数来进行各种设置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void Awake()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    current = this;</span><br><span class=\"line\"></span><br><span class=\"line\">    //切换场景也不会销毁这个物体</span><br><span class=\"line\">    DontDestroyOnLoad(gameObject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>5.为了避免在属性界面中处理太多的组件，选择在代码中添加组件，这样有助于同一管理并且减少失误的发生：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//声音播放组件</span><br><span class=\"line\">AudioSource ambientSource;</span><br><span class=\"line\">AudioSource musicSource;</span><br><span class=\"line\">AudioSource fxSource;</span><br><span class=\"line\">AudioSource playerSource;</span><br><span class=\"line\">AudioSource voiceSource;</span><br><span class=\"line\"></span><br><span class=\"line\">private void Awake()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ambientSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">    musicSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">    fxSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">    playerSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">    voiceSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>6.编写背景声音的发声函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void StartLevelAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    current.ambientSource.clip = current.ambientClip;</span><br><span class=\"line\">    current.ambientSource.loop = true;</span><br><span class=\"line\">    current.ambientSource.Play();</span><br><span class=\"line\"></span><br><span class=\"line\">    current.musicSource.clip = current.musicClip;</span><br><span class=\"line\">    current.musicSource.loop = true;</span><br><span class=\"line\">    current.musicSource.Play();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在本脚本Awake()调用，一开始运行游戏就有背景声音</p>\n<p>7.编写脚步声音的两种发声函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void PlayFootstepAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int index = Random.Range(0, current.walkStepClips.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">    current.playerSource.clip = current.walkStepClips[index];</span><br><span class=\"line\">    current.playerSource.Play();</span><br><span class=\"line\">&#125;    </span><br><span class=\"line\"></span><br><span class=\"line\">public static void PlayCrouchFootstepAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int index = Random.Range(0, current.crouchStepClips.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">    current.playerSource.clip = current.crouchStepClips[index];</span><br><span class=\"line\">    current.playerSource.Play();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在PlayerAnimation脚本中调用，因为这是在动画中调用的函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void StepAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AudioManager.PlayFootstepAudio();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public void CrouchStepAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    AudioManager.PlayCrouchFootstepAudio();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>8.编写跳跃声音的发声函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void PlayJumpAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    current.playerSource.clip = current.jumpClip;</span><br><span class=\"line\">    current.playerSource.Play();</span><br><span class=\"line\"></span><br><span class=\"line\">    current.voiceSource.clip = current.jumpVoiceClip;</span><br><span class=\"line\">    current.voiceSource.Play();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中包括了起跳的脚步声和人物声，在PlayerMovement脚本中的跳跃函数中的起跳部分调用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   void MidAirMovement()//空中移动</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump &amp;&amp; !isHeadBlocked)//起跳</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           AudioManager.PlayJumpAudio();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"终、本节总结\"><a href=\"#终、本节总结\" class=\"headerlink\" title=\"终、本节总结\"></a>终、本节总结</h3><p>测试游戏，移动时发现主角的反光情况有些不对劲，原因是角色移动时图案的翻转代码中用的是二维的向量，这样就会使得z 轴大小变为0 ，即厚度没了人物瘪了光也反不了了，要改成三维向量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void flipDirection()//改变角色图案方向</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (xVelocity &gt; 0) transform.localScale = new Vector3 (1, 1, 1);</span><br><span class=\"line\">    else if (xVelocity &lt; 0) transform.localScale = new Vector3(-1, 1, 1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>下面记录一下这次新增的两个脚本内容：</p>\n<p>PlayerAnimation脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerAnimation : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Animator anim;</span><br><span class=\"line\">    PlayerMovement movement;</span><br><span class=\"line\">    Rigidbody2D rb;</span><br><span class=\"line\"></span><br><span class=\"line\">    //动画状态编号</span><br><span class=\"line\">    int groundID;</span><br><span class=\"line\">    int speedID;</span><br><span class=\"line\">    int crouchID;</span><br><span class=\"line\">    int hangingID;</span><br><span class=\"line\">    int fallID;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        anim = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">        movement = GetComponentInParent&lt;PlayerMovement&gt;();</span><br><span class=\"line\">        rb = GetComponentInParent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        groundID = Animator.StringToHash(&quot;isOnGround&quot;);</span><br><span class=\"line\">        speedID = Animator.StringToHash(&quot;speed&quot;);</span><br><span class=\"line\">        hangingID = Animator.StringToHash(&quot;isHanging&quot;);</span><br><span class=\"line\">        crouchID = Animator.StringToHash(&quot;isCrouching&quot;);</span><br><span class=\"line\">        fallID = Animator.StringToHash(&quot;verticalVelocity&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        anim.SetFloat(speedID, Mathf.Abs(movement.xVelocity));//撞墙也会继续跑</span><br><span class=\"line\">        /*anim.SetFloat(speedID, rb.velocity.x);*/ //撞墙停下</span><br><span class=\"line\">        anim.SetBool(groundID, movement.isOnGround);</span><br><span class=\"line\">        anim.SetBool(crouchID, movement.isCrouch);</span><br><span class=\"line\">        anim.SetBool(hangingID, movement.isHanging);</span><br><span class=\"line\">        anim.SetFloat(fallID, rb.velocity.y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void StepAudio()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AudioManager.PlayFootstepAudio();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void CrouchStepAudio()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AudioManager.PlayCrouchFootstepAudio();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>AudioManager脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">using UnityEngine.Audio;</span><br><span class=\"line\"></span><br><span class=\"line\">public class AudioManager : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static AudioManager current;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;环境声音&quot;)]</span><br><span class=\"line\">    public AudioClip ambientClip;</span><br><span class=\"line\">    public AudioClip musicClip;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;主角音效&quot;)]</span><br><span class=\"line\">    public AudioClip[] walkStepClips;</span><br><span class=\"line\">    public AudioClip[] crouchStepClips;</span><br><span class=\"line\">    public AudioClip jumpClip;</span><br><span class=\"line\">    public AudioClip jumpVoiceClip;</span><br><span class=\"line\"></span><br><span class=\"line\">    //声音播放组件</span><br><span class=\"line\">    AudioSource ambientSource;</span><br><span class=\"line\">    AudioSource musicSource;</span><br><span class=\"line\">    AudioSource fxSource;</span><br><span class=\"line\">    AudioSource playerSource;</span><br><span class=\"line\">    AudioSource voiceSource;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void Awake()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        current = this;</span><br><span class=\"line\"></span><br><span class=\"line\">        //切换场景也不会销毁这个物体</span><br><span class=\"line\">        DontDestroyOnLoad(gameObject);</span><br><span class=\"line\"></span><br><span class=\"line\">        ambientSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">        musicSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">        fxSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">        playerSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\">        voiceSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        StartLevelAudio();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void StartLevelAudio()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        current.ambientSource.clip = current.ambientClip;</span><br><span class=\"line\">        current.ambientSource.loop = true;</span><br><span class=\"line\">        current.ambientSource.Play();</span><br><span class=\"line\"></span><br><span class=\"line\">        current.musicSource.clip = current.musicClip;</span><br><span class=\"line\">        current.musicSource.loop = true;</span><br><span class=\"line\">        current.musicSource.Play();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void PlayFootstepAudio()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int index = Random.Range(0, current.walkStepClips.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">        current.playerSource.clip = current.walkStepClips[index];</span><br><span class=\"line\">        current.playerSource.Play();</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    </span><br><span class=\"line\">    public static void PlayCrouchFootstepAudio()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int index = Random.Range(0, current.crouchStepClips.Length);</span><br><span class=\"line\"></span><br><span class=\"line\">        current.playerSource.clip = current.crouchStepClips[index];</span><br><span class=\"line\">        current.playerSource.Play();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void PlayJumpAudio()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        current.playerSource.clip = current.jumpClip;</span><br><span class=\"line\">        current.playerSource.Play();</span><br><span class=\"line\"></span><br><span class=\"line\">        current.voiceSource.clip = current.jumpVoiceClip;</span><br><span class=\"line\">        current.voiceSource.Play();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"【LeetCode.611】有效三角形的个数","date":"2021-08-04T07:53:39.000Z","_content":"\n\n\n### \t题目：有效三角形的个数\n\n给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。\n\n示例 1:\n\n```\n输入: [2,2,3,4]\n输出: 3\n解释:\n有效的组合是: \n2,3,4 (使用第一个 2)\n2,3,4 (使用第二个 2)\n2,2,3\n```\n\n\n\n<!--more-->\n\n注意:\n\n`数组长度不超过1000。`\n`数组里整数的范围为 [0, 1000]。`\n\n\n\n---\n\n\n\n### 分析：\n\n首先，能够组成三角形三条边的条件是 `a + b > c` ，其中a和b为较小边，那就可以先将数组升序排序。\n\n暴力解法是三重循环枚举数组，找出符合条件的组合并计数，时间复杂度`O(n^3)`\n\n对于需要循环遍历的算法，有个常用的优化时间方法就是二分法，本题中前两个数字用循环遍历，最后一个数字使用二分法，时间复杂度`O(n^2 * logn)`\n\n还可以进一步优化，就是双指针法，可以发现，如果我们固定 i，那么随着 j 的递增，不等式 `nums[i]+ nums[j]` 也是递增的，因此 k 也是递增的，这样一来，我们就可以将 j 和 k 看成两个同向（递增）移动的指针\n\n在第一个数字的循环中，就定义最后一个数字，即第二个数字和最后一个数字都有各自的递增路线，只要找到各自符合的位置即可，时间复杂度`O(n * (n + n) = O(n^2)`\n\n\n\n---\n\n\n\n### 题解：\n\n```\nclass Solution {\npublic:\n    //排序 + 双指针法\n    int triangleNumber(vector<int>& nums) {\n        if(nums.size() < 3) return 0;\n        sort(nums.begin(), nums.end());\n        int ret = 0;\n        for(int i = 0; i <= nums.size() - 3; ++i){\n            int k = i + 2;\n            for(int j = i + 1; j <= nums.size() - 2; ++j){\n                while(k < nums.size() && nums[i] + nums[j] > nums[k]) k++;\n                ret += max(--k - j, 0);\n            }\n        }\n        return ret;\n    }\n\n    //排序 + 二分法\n    // int triangleNumber(vector<int>& nums) {\n    //     if(nums.size() < 3) return 0;\n    //     sort(nums.begin(), nums.end());\n    //     int ret = 0;\n    //     for(int i = 0; i <= nums.size() - 3; ++i){\n    //         for(int j = i + 1; j <= nums.size() - 2; ++j){\n    //             int k = j;\n    //             int left = j + 1, right = nums.size() - 1;\n    //             while(left <= right){\n    //                 int mid = (right - left) / 2 + left;\n    //                 if(nums[i] + nums[j] > nums[mid]) {\n    //                     left = mid + 1;\n    //                     k =  mid;\n    //                 }\n    //                 else right = mid - 1;\n    //             }\n    //             ret += k - j;\n    //         }\n    //     }\n    //     return ret;\n    // }\n};\n\n```\n\n\n\n---\n\n\n\n### 收获：\n\n1.优化循环遍历可以用二分法\n\n2.根据公式如何找出潜在的规律，逃出多重循环\n","source":"_posts/2021-08-04-【LeetCode.611】有效三角形的个数.md","raw":"---\ntitle: 【LeetCode.611】有效三角形的个数\ndate: 2021-08-04 15:53:39\ncategories: 算法\ntags:\n  - c++\n  - 双指针法\n---\n\n\n\n### \t题目：有效三角形的个数\n\n给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。\n\n示例 1:\n\n```\n输入: [2,2,3,4]\n输出: 3\n解释:\n有效的组合是: \n2,3,4 (使用第一个 2)\n2,3,4 (使用第二个 2)\n2,2,3\n```\n\n\n\n<!--more-->\n\n注意:\n\n`数组长度不超过1000。`\n`数组里整数的范围为 [0, 1000]。`\n\n\n\n---\n\n\n\n### 分析：\n\n首先，能够组成三角形三条边的条件是 `a + b > c` ，其中a和b为较小边，那就可以先将数组升序排序。\n\n暴力解法是三重循环枚举数组，找出符合条件的组合并计数，时间复杂度`O(n^3)`\n\n对于需要循环遍历的算法，有个常用的优化时间方法就是二分法，本题中前两个数字用循环遍历，最后一个数字使用二分法，时间复杂度`O(n^2 * logn)`\n\n还可以进一步优化，就是双指针法，可以发现，如果我们固定 i，那么随着 j 的递增，不等式 `nums[i]+ nums[j]` 也是递增的，因此 k 也是递增的，这样一来，我们就可以将 j 和 k 看成两个同向（递增）移动的指针\n\n在第一个数字的循环中，就定义最后一个数字，即第二个数字和最后一个数字都有各自的递增路线，只要找到各自符合的位置即可，时间复杂度`O(n * (n + n) = O(n^2)`\n\n\n\n---\n\n\n\n### 题解：\n\n```\nclass Solution {\npublic:\n    //排序 + 双指针法\n    int triangleNumber(vector<int>& nums) {\n        if(nums.size() < 3) return 0;\n        sort(nums.begin(), nums.end());\n        int ret = 0;\n        for(int i = 0; i <= nums.size() - 3; ++i){\n            int k = i + 2;\n            for(int j = i + 1; j <= nums.size() - 2; ++j){\n                while(k < nums.size() && nums[i] + nums[j] > nums[k]) k++;\n                ret += max(--k - j, 0);\n            }\n        }\n        return ret;\n    }\n\n    //排序 + 二分法\n    // int triangleNumber(vector<int>& nums) {\n    //     if(nums.size() < 3) return 0;\n    //     sort(nums.begin(), nums.end());\n    //     int ret = 0;\n    //     for(int i = 0; i <= nums.size() - 3; ++i){\n    //         for(int j = i + 1; j <= nums.size() - 2; ++j){\n    //             int k = j;\n    //             int left = j + 1, right = nums.size() - 1;\n    //             while(left <= right){\n    //                 int mid = (right - left) / 2 + left;\n    //                 if(nums[i] + nums[j] > nums[mid]) {\n    //                     left = mid + 1;\n    //                     k =  mid;\n    //                 }\n    //                 else right = mid - 1;\n    //             }\n    //             ret += k - j;\n    //         }\n    //     }\n    //     return ret;\n    // }\n};\n\n```\n\n\n\n---\n\n\n\n### 收获：\n\n1.优化循环遍历可以用二分法\n\n2.根据公式如何找出潜在的规律，逃出多重循环\n","slug":"2021-08-04-【LeetCode.611】有效三角形的个数","published":1,"updated":"2021-08-04T08:26:06.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hm001f1ou08tn3b8xz","content":"<h3 id=\"题目：有效三角形的个数\"><a href=\"#题目：有效三角形的个数\" class=\"headerlink\" title=\"题目：有效三角形的个数\"></a>题目：有效三角形的个数</h3><p>给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [2,2,3,4]</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释:</span><br><span class=\"line\">有效的组合是: </span><br><span class=\"line\">2,3,4 (使用第一个 2)</span><br><span class=\"line\">2,3,4 (使用第二个 2)</span><br><span class=\"line\">2,2,3</span><br></pre></td></tr></table></figure>\n\n\n\n<span id=\"more\"></span>\n\n<p>注意:</p>\n<p><code>数组长度不超过1000。</code><br><code>数组里整数的范围为 [0, 1000]。</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>首先，能够组成三角形三条边的条件是 <code>a + b &gt; c</code> ，其中a和b为较小边，那就可以先将数组升序排序。</p>\n<p>暴力解法是三重循环枚举数组，找出符合条件的组合并计数，时间复杂度<code>O(n^3)</code></p>\n<p>对于需要循环遍历的算法，有个常用的优化时间方法就是二分法，本题中前两个数字用循环遍历，最后一个数字使用二分法，时间复杂度<code>O(n^2 * logn)</code></p>\n<p>还可以进一步优化，就是双指针法，可以发现，如果我们固定 i，那么随着 j 的递增，不等式 <code>nums[i]+ nums[j]</code> 也是递增的，因此 k 也是递增的，这样一来，我们就可以将 j 和 k 看成两个同向（递增）移动的指针</p>\n<p>在第一个数字的循环中，就定义最后一个数字，即第二个数字和最后一个数字都有各自的递增路线，只要找到各自符合的位置即可，时间复杂度<code>O(n * (n + n) = O(n^2)</code></p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    //排序 + 双指针法</span><br><span class=\"line\">    int triangleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        if(nums.size() &lt; 3) return 0;</span><br><span class=\"line\">        sort(nums.begin(), nums.end());</span><br><span class=\"line\">        int ret = 0;</span><br><span class=\"line\">        for(int i = 0; i &lt;= nums.size() - 3; ++i)&#123;</span><br><span class=\"line\">            int k = i + 2;</span><br><span class=\"line\">            for(int j = i + 1; j &lt;= nums.size() - 2; ++j)&#123;</span><br><span class=\"line\">                while(k &lt; nums.size() &amp;&amp; nums[i] + nums[j] &gt; nums[k]) k++;</span><br><span class=\"line\">                ret += max(--k - j, 0);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //排序 + 二分法</span><br><span class=\"line\">    // int triangleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">    //     if(nums.size() &lt; 3) return 0;</span><br><span class=\"line\">    //     sort(nums.begin(), nums.end());</span><br><span class=\"line\">    //     int ret = 0;</span><br><span class=\"line\">    //     for(int i = 0; i &lt;= nums.size() - 3; ++i)&#123;</span><br><span class=\"line\">    //         for(int j = i + 1; j &lt;= nums.size() - 2; ++j)&#123;</span><br><span class=\"line\">    //             int k = j;</span><br><span class=\"line\">    //             int left = j + 1, right = nums.size() - 1;</span><br><span class=\"line\">    //             while(left &lt;= right)&#123;</span><br><span class=\"line\">    //                 int mid = (right - left) / 2 + left;</span><br><span class=\"line\">    //                 if(nums[i] + nums[j] &gt; nums[mid]) &#123;</span><br><span class=\"line\">    //                     left = mid + 1;</span><br><span class=\"line\">    //                     k =  mid;</span><br><span class=\"line\">    //                 &#125;</span><br><span class=\"line\">    //                 else right = mid - 1;</span><br><span class=\"line\">    //             &#125;</span><br><span class=\"line\">    //             ret += k - j;</span><br><span class=\"line\">    //         &#125;</span><br><span class=\"line\">    //     &#125;</span><br><span class=\"line\">    //     return ret;</span><br><span class=\"line\">    // &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"收获：\"><a href=\"#收获：\" class=\"headerlink\" title=\"收获：\"></a>收获：</h3><p>1.优化循环遍历可以用二分法</p>\n<p>2.根据公式如何找出潜在的规律，逃出多重循环</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"题目：有效三角形的个数\"><a href=\"#题目：有效三角形的个数\" class=\"headerlink\" title=\"题目：有效三角形的个数\"></a>题目：有效三角形的个数</h3><p>给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。</p>\n<p>示例 1:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: [2,2,3,4]</span><br><span class=\"line\">输出: 3</span><br><span class=\"line\">解释:</span><br><span class=\"line\">有效的组合是: </span><br><span class=\"line\">2,3,4 (使用第一个 2)</span><br><span class=\"line\">2,3,4 (使用第二个 2)</span><br><span class=\"line\">2,2,3</span><br></pre></td></tr></table></figure>","more":"<p>注意:</p>\n<p><code>数组长度不超过1000。</code><br><code>数组里整数的范围为 [0, 1000]。</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>首先，能够组成三角形三条边的条件是 <code>a + b &gt; c</code> ，其中a和b为较小边，那就可以先将数组升序排序。</p>\n<p>暴力解法是三重循环枚举数组，找出符合条件的组合并计数，时间复杂度<code>O(n^3)</code></p>\n<p>对于需要循环遍历的算法，有个常用的优化时间方法就是二分法，本题中前两个数字用循环遍历，最后一个数字使用二分法，时间复杂度<code>O(n^2 * logn)</code></p>\n<p>还可以进一步优化，就是双指针法，可以发现，如果我们固定 i，那么随着 j 的递增，不等式 <code>nums[i]+ nums[j]</code> 也是递增的，因此 k 也是递增的，这样一来，我们就可以将 j 和 k 看成两个同向（递增）移动的指针</p>\n<p>在第一个数字的循环中，就定义最后一个数字，即第二个数字和最后一个数字都有各自的递增路线，只要找到各自符合的位置即可，时间复杂度<code>O(n * (n + n) = O(n^2)</code></p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    //排序 + 双指针法</span><br><span class=\"line\">    int triangleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        if(nums.size() &lt; 3) return 0;</span><br><span class=\"line\">        sort(nums.begin(), nums.end());</span><br><span class=\"line\">        int ret = 0;</span><br><span class=\"line\">        for(int i = 0; i &lt;= nums.size() - 3; ++i)&#123;</span><br><span class=\"line\">            int k = i + 2;</span><br><span class=\"line\">            for(int j = i + 1; j &lt;= nums.size() - 2; ++j)&#123;</span><br><span class=\"line\">                while(k &lt; nums.size() &amp;&amp; nums[i] + nums[j] &gt; nums[k]) k++;</span><br><span class=\"line\">                ret += max(--k - j, 0);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //排序 + 二分法</span><br><span class=\"line\">    // int triangleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">    //     if(nums.size() &lt; 3) return 0;</span><br><span class=\"line\">    //     sort(nums.begin(), nums.end());</span><br><span class=\"line\">    //     int ret = 0;</span><br><span class=\"line\">    //     for(int i = 0; i &lt;= nums.size() - 3; ++i)&#123;</span><br><span class=\"line\">    //         for(int j = i + 1; j &lt;= nums.size() - 2; ++j)&#123;</span><br><span class=\"line\">    //             int k = j;</span><br><span class=\"line\">    //             int left = j + 1, right = nums.size() - 1;</span><br><span class=\"line\">    //             while(left &lt;= right)&#123;</span><br><span class=\"line\">    //                 int mid = (right - left) / 2 + left;</span><br><span class=\"line\">    //                 if(nums[i] + nums[j] &gt; nums[mid]) &#123;</span><br><span class=\"line\">    //                     left = mid + 1;</span><br><span class=\"line\">    //                     k =  mid;</span><br><span class=\"line\">    //                 &#125;</span><br><span class=\"line\">    //                 else right = mid - 1;</span><br><span class=\"line\">    //             &#125;</span><br><span class=\"line\">    //             ret += k - j;</span><br><span class=\"line\">    //         &#125;</span><br><span class=\"line\">    //     &#125;</span><br><span class=\"line\">    //     return ret;</span><br><span class=\"line\">    // &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"收获：\"><a href=\"#收获：\" class=\"headerlink\" title=\"收获：\"></a>收获：</h3><p>1.优化循环遍历可以用二分法</p>\n<p>2.根据公式如何找出潜在的规律，逃出多重循环</p>"},{"title":"【LeetCode.457】环形数组是否存在循环","date":"2021-08-08T10:30:52.000Z","_content":"\n\n\n### \t题目：环形数组是否存在循环\n\n存在一个不含 0 的 环形 数组 `nums` ，每个 `nums[i]` 都表示位于下标 i 的角色应该向前或向后移动的下标个数：\n\n如果 `nums[i]` 是**正数**，向前 移动 `nums[i]` 步\n如果 `nums[i]` 是**负数**，向后 移动 `nums[i]` 步\n因为数组是 环形 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。\n\n数组中的 循环 由长度为 k 的下标序列 `seq` ：\n\n遵循上述移动规则将导致重复下标序列 `seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...`\n所有 `nums[seq[j]]` 应当不是 **全正** 就是 **全负**\nk > 1\n如果 `nums` 中存在循环，返回 `true` ；否则，返回 `false` 。\n\n \n\n<!--more-->\n\n示例 1：\n\n```\n输入：nums = [2,-1,1,2,2]\n输出：true\n解释：存在循环，按下标 0 -> 2 -> 3 -> 0 。循环长度为 3 。\n```\n\n\n\n示例 2：\n\n```\n输入：nums = [-1,2]\n输出：false\n解释：按下标 1 -> 1 -> 1 ... 的运动无法构成循环，因为循环的长度为 1 。根据定义，循环的长度必须大于 1 。\n```\n\n\n\n示例 3:\n\n```\n输入：nums = [-2,1,-1,-2,-2]\n输出：false\n解释：按下标 1 -> 2 -> 1 -> ... 的运动无法构成循环，因为 nums[1] 是正数，而 nums[2] 是负数。\n所有 nums[seq[j]] 应当不是全正就是全负。\n```\n\n\n\n提示：\n\n`1 <= nums.length <= 5000`\n`-1000 <= nums[i] <= 1000`\n`nums[i] != 0`\n\n\n\n---\n\n\n\n### 分析：\n\n我们可以将环形数组理解为图中的 n 个点，`nums[i]` 表示 i 号点向 `(i+nums[i]) mod n` 号点连有一条单向边。\n\n注意到这张图中的每个点有且仅有一条出边，这样我们从某一个点出发，沿着单向边不断移动，最终必然会进入一个环中。\n\n我们检查每一个节点，令快慢指针从当前点出发，快指针每次移动两步，慢指针每次移动一步，期间每移动一次，我们都需要检查当前单向边的方向是否与初始方向是否一致，如果不一致，我们即可停止遍历，因为当前路径必然不满足条件。为了降低时间复杂度，我们可以标记每一个点是否访问过，过程中如果我们的下一个节点为已经访问过的节点，则可以停止遍历。\n\n\n\n---\n\n\n\n### \t题解：\n\n```\nclass Solution {\npublic:\n    //快慢指针\n    bool circularArrayLoop(vector<int>& nums) {\n        int n = nums.size();\n        auto next = [&](int cur) {\n            return ((cur + nums[cur]) % n + n) % n; // 保证返回值在 [0,n) 中\n        };\n\n        for (int i = 0; i < n; i++) {\n            //遍历过的自然验证了此处出发是否存在回路\n            if (!nums[i]) {\n                continue;\n            }\n            int slow = i, fast = next(i);\n            // 判断非零且方向相同\n            while (nums[slow] * nums[fast] > 0 && nums[slow] * nums[next(fast)] > 0) {\n                if (slow == fast) {\n                    if (slow != next(slow)) {\n                        return true;\n                    } else {\n                        break;\n                    }\n                }\n                slow = next(slow);\n                fast = next(next(fast));\n            }\n            //将本轮遍历过的结点置零\n            int add = i;\n            while (nums[add] * nums[next(add)] > 0) {\n                int tmp = add;\n                add = next(add);\n                nums[tmp] = 0;\n            }\n        }\n        return false;\n    }\n};\n```\n\n\n\n---\n\n\n\n### 难点：\n\n1.数据结构的知识如何应用在具体问题中\n","source":"_posts/2021-08-08-【LeetCode.457】环形数组是否存在循环.md","raw":"---\ntitle: 【LeetCode.457】环形数组是否存在循环\ndate: 2021-08-08 18:30:52\ncategories:\t算法\ntags:\n  - c++\n  - 快慢指针\n---\n\n\n\n### \t题目：环形数组是否存在循环\n\n存在一个不含 0 的 环形 数组 `nums` ，每个 `nums[i]` 都表示位于下标 i 的角色应该向前或向后移动的下标个数：\n\n如果 `nums[i]` 是**正数**，向前 移动 `nums[i]` 步\n如果 `nums[i]` 是**负数**，向后 移动 `nums[i]` 步\n因为数组是 环形 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。\n\n数组中的 循环 由长度为 k 的下标序列 `seq` ：\n\n遵循上述移动规则将导致重复下标序列 `seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...`\n所有 `nums[seq[j]]` 应当不是 **全正** 就是 **全负**\nk > 1\n如果 `nums` 中存在循环，返回 `true` ；否则，返回 `false` 。\n\n \n\n<!--more-->\n\n示例 1：\n\n```\n输入：nums = [2,-1,1,2,2]\n输出：true\n解释：存在循环，按下标 0 -> 2 -> 3 -> 0 。循环长度为 3 。\n```\n\n\n\n示例 2：\n\n```\n输入：nums = [-1,2]\n输出：false\n解释：按下标 1 -> 1 -> 1 ... 的运动无法构成循环，因为循环的长度为 1 。根据定义，循环的长度必须大于 1 。\n```\n\n\n\n示例 3:\n\n```\n输入：nums = [-2,1,-1,-2,-2]\n输出：false\n解释：按下标 1 -> 2 -> 1 -> ... 的运动无法构成循环，因为 nums[1] 是正数，而 nums[2] 是负数。\n所有 nums[seq[j]] 应当不是全正就是全负。\n```\n\n\n\n提示：\n\n`1 <= nums.length <= 5000`\n`-1000 <= nums[i] <= 1000`\n`nums[i] != 0`\n\n\n\n---\n\n\n\n### 分析：\n\n我们可以将环形数组理解为图中的 n 个点，`nums[i]` 表示 i 号点向 `(i+nums[i]) mod n` 号点连有一条单向边。\n\n注意到这张图中的每个点有且仅有一条出边，这样我们从某一个点出发，沿着单向边不断移动，最终必然会进入一个环中。\n\n我们检查每一个节点，令快慢指针从当前点出发，快指针每次移动两步，慢指针每次移动一步，期间每移动一次，我们都需要检查当前单向边的方向是否与初始方向是否一致，如果不一致，我们即可停止遍历，因为当前路径必然不满足条件。为了降低时间复杂度，我们可以标记每一个点是否访问过，过程中如果我们的下一个节点为已经访问过的节点，则可以停止遍历。\n\n\n\n---\n\n\n\n### \t题解：\n\n```\nclass Solution {\npublic:\n    //快慢指针\n    bool circularArrayLoop(vector<int>& nums) {\n        int n = nums.size();\n        auto next = [&](int cur) {\n            return ((cur + nums[cur]) % n + n) % n; // 保证返回值在 [0,n) 中\n        };\n\n        for (int i = 0; i < n; i++) {\n            //遍历过的自然验证了此处出发是否存在回路\n            if (!nums[i]) {\n                continue;\n            }\n            int slow = i, fast = next(i);\n            // 判断非零且方向相同\n            while (nums[slow] * nums[fast] > 0 && nums[slow] * nums[next(fast)] > 0) {\n                if (slow == fast) {\n                    if (slow != next(slow)) {\n                        return true;\n                    } else {\n                        break;\n                    }\n                }\n                slow = next(slow);\n                fast = next(next(fast));\n            }\n            //将本轮遍历过的结点置零\n            int add = i;\n            while (nums[add] * nums[next(add)] > 0) {\n                int tmp = add;\n                add = next(add);\n                nums[tmp] = 0;\n            }\n        }\n        return false;\n    }\n};\n```\n\n\n\n---\n\n\n\n### 难点：\n\n1.数据结构的知识如何应用在具体问题中\n","slug":"2021-08-08-【LeetCode.457】环形数组是否存在循环","published":1,"updated":"2021-08-08T10:39:03.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hp001i1ou0btvw0eob","content":"<h3 id=\"题目：环形数组是否存在循环\"><a href=\"#题目：环形数组是否存在循环\" class=\"headerlink\" title=\"题目：环形数组是否存在循环\"></a>题目：环形数组是否存在循环</h3><p>存在一个不含 0 的 环形 数组 <code>nums</code> ，每个 <code>nums[i]</code> 都表示位于下标 i 的角色应该向前或向后移动的下标个数：</p>\n<p>如果 <code>nums[i]</code> 是<strong>正数</strong>，向前 移动 <code>nums[i]</code> 步<br>如果 <code>nums[i]</code> 是<strong>负数</strong>，向后 移动 <code>nums[i]</code> 步<br>因为数组是 环形 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。</p>\n<p>数组中的 循环 由长度为 k 的下标序列 <code>seq</code> ：</p>\n<p>遵循上述移动规则将导致重复下标序列 <code>seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...</code><br>所有 <code>nums[seq[j]]</code> 应当不是 <strong>全正</strong> 就是 <strong>全负</strong><br>k &gt; 1<br>如果 <code>nums</code> 中存在循环，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n<span id=\"more\"></span>\n\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,-1,1,2,2]</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：存在循环，按下标 0 -&gt; 2 -&gt; 3 -&gt; 0 。循环长度为 3 。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [-1,2]</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：按下标 1 -&gt; 1 -&gt; 1 ... 的运动无法构成循环，因为循环的长度为 1 。根据定义，循环的长度必须大于 1 。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 3:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [-2,1,-1,-2,-2]</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：按下标 1 -&gt; 2 -&gt; 1 -&gt; ... 的运动无法构成循环，因为 nums[1] 是正数，而 nums[2] 是负数。</span><br><span class=\"line\">所有 nums[seq[j]] 应当不是全正就是全负。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>提示：</p>\n<p><code>1 &lt;= nums.length &lt;= 5000</code><br><code>-1000 &lt;= nums[i] &lt;= 1000</code><br><code>nums[i] != 0</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>我们可以将环形数组理解为图中的 n 个点，<code>nums[i]</code> 表示 i 号点向 <code>(i+nums[i]) mod n</code> 号点连有一条单向边。</p>\n<p>注意到这张图中的每个点有且仅有一条出边，这样我们从某一个点出发，沿着单向边不断移动，最终必然会进入一个环中。</p>\n<p>我们检查每一个节点，令快慢指针从当前点出发，快指针每次移动两步，慢指针每次移动一步，期间每移动一次，我们都需要检查当前单向边的方向是否与初始方向是否一致，如果不一致，我们即可停止遍历，因为当前路径必然不满足条件。为了降低时间复杂度，我们可以标记每一个点是否访问过，过程中如果我们的下一个节点为已经访问过的节点，则可以停止遍历。</p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    //快慢指针</span><br><span class=\"line\">    bool circularArrayLoop(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        int n = nums.size();</span><br><span class=\"line\">        auto next = [&amp;](int cur) &#123;</span><br><span class=\"line\">            return ((cur + nums[cur]) % n + n) % n; // 保证返回值在 [0,n) 中</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">            //遍历过的自然验证了此处出发是否存在回路</span><br><span class=\"line\">            if (!nums[i]) &#123;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            int slow = i, fast = next(i);</span><br><span class=\"line\">            // 判断非零且方向相同</span><br><span class=\"line\">            while (nums[slow] * nums[fast] &gt; 0 &amp;&amp; nums[slow] * nums[next(fast)] &gt; 0) &#123;</span><br><span class=\"line\">                if (slow == fast) &#123;</span><br><span class=\"line\">                    if (slow != next(slow)) &#123;</span><br><span class=\"line\">                        return true;</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                slow = next(slow);</span><br><span class=\"line\">                fast = next(next(fast));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //将本轮遍历过的结点置零</span><br><span class=\"line\">            int add = i;</span><br><span class=\"line\">            while (nums[add] * nums[next(add)] &gt; 0) &#123;</span><br><span class=\"line\">                int tmp = add;</span><br><span class=\"line\">                add = next(add);</span><br><span class=\"line\">                nums[tmp] = 0;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"难点：\"><a href=\"#难点：\" class=\"headerlink\" title=\"难点：\"></a>难点：</h3><p>1.数据结构的知识如何应用在具体问题中</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"题目：环形数组是否存在循环\"><a href=\"#题目：环形数组是否存在循环\" class=\"headerlink\" title=\"题目：环形数组是否存在循环\"></a>题目：环形数组是否存在循环</h3><p>存在一个不含 0 的 环形 数组 <code>nums</code> ，每个 <code>nums[i]</code> 都表示位于下标 i 的角色应该向前或向后移动的下标个数：</p>\n<p>如果 <code>nums[i]</code> 是<strong>正数</strong>，向前 移动 <code>nums[i]</code> 步<br>如果 <code>nums[i]</code> 是<strong>负数</strong>，向后 移动 <code>nums[i]</code> 步<br>因为数组是 环形 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。</p>\n<p>数组中的 循环 由长度为 k 的下标序列 <code>seq</code> ：</p>\n<p>遵循上述移动规则将导致重复下标序列 <code>seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...</code><br>所有 <code>nums[seq[j]]</code> 应当不是 <strong>全正</strong> 就是 <strong>全负</strong><br>k &gt; 1<br>如果 <code>nums</code> 中存在循环，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>","more":"<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,-1,1,2,2]</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：存在循环，按下标 0 -&gt; 2 -&gt; 3 -&gt; 0 。循环长度为 3 。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [-1,2]</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：按下标 1 -&gt; 1 -&gt; 1 ... 的运动无法构成循环，因为循环的长度为 1 。根据定义，循环的长度必须大于 1 。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 3:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [-2,1,-1,-2,-2]</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：按下标 1 -&gt; 2 -&gt; 1 -&gt; ... 的运动无法构成循环，因为 nums[1] 是正数，而 nums[2] 是负数。</span><br><span class=\"line\">所有 nums[seq[j]] 应当不是全正就是全负。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>提示：</p>\n<p><code>1 &lt;= nums.length &lt;= 5000</code><br><code>-1000 &lt;= nums[i] &lt;= 1000</code><br><code>nums[i] != 0</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>我们可以将环形数组理解为图中的 n 个点，<code>nums[i]</code> 表示 i 号点向 <code>(i+nums[i]) mod n</code> 号点连有一条单向边。</p>\n<p>注意到这张图中的每个点有且仅有一条出边，这样我们从某一个点出发，沿着单向边不断移动，最终必然会进入一个环中。</p>\n<p>我们检查每一个节点，令快慢指针从当前点出发，快指针每次移动两步，慢指针每次移动一步，期间每移动一次，我们都需要检查当前单向边的方向是否与初始方向是否一致，如果不一致，我们即可停止遍历，因为当前路径必然不满足条件。为了降低时间复杂度，我们可以标记每一个点是否访问过，过程中如果我们的下一个节点为已经访问过的节点，则可以停止遍历。</p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    //快慢指针</span><br><span class=\"line\">    bool circularArrayLoop(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        int n = nums.size();</span><br><span class=\"line\">        auto next = [&amp;](int cur) &#123;</span><br><span class=\"line\">            return ((cur + nums[cur]) % n + n) % n; // 保证返回值在 [0,n) 中</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">            //遍历过的自然验证了此处出发是否存在回路</span><br><span class=\"line\">            if (!nums[i]) &#123;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            int slow = i, fast = next(i);</span><br><span class=\"line\">            // 判断非零且方向相同</span><br><span class=\"line\">            while (nums[slow] * nums[fast] &gt; 0 &amp;&amp; nums[slow] * nums[next(fast)] &gt; 0) &#123;</span><br><span class=\"line\">                if (slow == fast) &#123;</span><br><span class=\"line\">                    if (slow != next(slow)) &#123;</span><br><span class=\"line\">                        return true;</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        break;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                slow = next(slow);</span><br><span class=\"line\">                fast = next(next(fast));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //将本轮遍历过的结点置零</span><br><span class=\"line\">            int add = i;</span><br><span class=\"line\">            while (nums[add] * nums[next(add)] &gt; 0) &#123;</span><br><span class=\"line\">                int tmp = add;</span><br><span class=\"line\">                add = next(add);</span><br><span class=\"line\">                nums[tmp] = 0;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"难点：\"><a href=\"#难点：\" class=\"headerlink\" title=\"难点：\"></a>难点：</h3><p>1.数据结构的知识如何应用在具体问题中</p>"},{"title":"【LeetCode.446】等差数列划分 II - 子序列","date":"2021-08-11T15:43:29.000Z","_content":"\n\n\n### \t题目：等差数列划分 II - 子序列\n\n给你一个整数数组 `nums` ，返回 nums 中所有 等差子序列 的数目。\n\n如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。\n\n例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。\n再例如，[1, 1, 2, 5, 7] 不是等差序列。\n数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。\n\n例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。\n题目数据保证答案是一个 32-bit 整数。\n\n<!--more-->\n\n示例 1：\n\n```\n输入：nums = [2,4,6,8,10]\n输出：7\n解释：所有的等差子序列为：\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]\n```\n\n\n\n示例 2：\n\n```\n输入：nums = [7,7,7,7,7]\n输出：16\n解释：数组中的任意子序列都是等差子序列。\n```\n\n\n\n提示：\n\n`1  <= nums.length <= 1000`\n`-231 <= nums[i] <= 231 - 1`\n\n\n\n---\n\n\n\n### 分析：\n\n给定数组为[1,2,3,4,5]，求等差子数组，我们使用动态规划的过程，一次遍历：\n\n遍历到3，发现它跟[1,2]可以组成子数组[1,2,3]，满足等差子数组要求，记`dp[3]=1`。\n\n遍历到4，发现它跟[2,3]可以组成子数组[2,3,4]，满足等差子数组要求，而它的前一位即3本来就有一个等差子数组，我们在它的基础上可以延续出来一个新的等差子数组[1,2,3,4]，所以，`dp[4]=dp[3]+1=2`，`dp[3]`表示原来3的基础上延续出来的[1,2,3,4]，+1表示全新的[2,3,4]。\n\n遍历到5，发现它跟[3,4]可以组成子数组[3,4,5]，满足等差子数组要求，而它的前一位即4本来是有两个等差子数组，我们在它的基础上可以延续出来两个新的等差子数组分别为[1,2,3,4,5]和[2,3,4,5]，所以，dp[5]=dp[4]+1=3，解释同上。\n这样，我们把`dp[3]+dp[4]+dp[5]=1+2+3=6`就是答案。\n\n方法一、动态规划\n好了，本题还是以[1,2,3,4,5]为例，[1,3,5]也是一个合格的答案，所以，我们可以转换成昨天的题目，我们求出每一个以`nums[i]`结尾的公差d的元素个数，再按照上述求等差子数组的思路很容易求出以`nums[i]`结尾等着为d的等差子数组的数量，把所有这些等差d加一起就是以`nums[i]`结尾的等差子序列的数量，列举所有的i即可求得结果，所以，我们定义如下：\n\n状态定义：`dp[i][d]`表示以`nums[i]`结尾，公差为d的等差子数组的数量。\n\n状态转移：`dp[i][d]=dp[j][d]+1`，其中j表示以`nums[i]`结尾等着为d的前面那个数`nums[j]`的下标。\n\n这样定义看似没有问题，实际运行的过程其实是有问题的：\n\n问题一：以[1,2,3,4,5]为例，遍历到2（下标为1）的时候，它与下标0的元素1的差值为1，按照公式应该得到：`dp[1][1]=dp[0][1]+1=1`,但是这个结果并不符合题目的要求，题目要求长度至少为3，那么，我们怎么才能知道下标j前面还有没有元素呢？如果只有`[nums[j], nums[i]]`是无法满足长度3的要求的。\n问题二：以[7,7,7,7,7]为例，遍历到第4个7（下标为3）的时候，它的等差子序列有4个，分别为[7(0),7(1),7(3)]、[7(0),7(2),7(3)]、[7(1),7(2),7(3)]、[7(0),7(1),7(2),7(3)]，按照`dp[i][d]=dp[j][d]+1`的规则去计算也是不对的。\n似乎没有思路了。再仔细想一下，既然三个长度的子序列是由两个长度的子序列升级来的，那么，我们能不能在统计结果的时候从两个长度的子序列开始计算呢，这样，三个长度的子序列就不用计算了。比如，以[1,2,3,4,5]为例：\n\n遍历到2时，以2结尾的子序列只有一个，即[1,2]，我们记为`dp2=1`。\n遍历到3时，以3结尾的子序列有三个，分别为[1,2,3]、[1,3]、[2,3]，我们分别记为`dp[3][1]=dp[2][1]+1=2`和`dp[3][2]=dp[1][2]+1=1`，可以看到，只有`dp[2][1]`升级上来的那个子序列才可以作为结果，所以，我们在这里`ans += dp[2][1]`。\n遍历到4时，以4结尾的子序列有多少个呢？它与前面元素的公差分别有1、2、3，我们按照公式可得`dp[4][1]=dp[3][1]+1=3`、`dp[4][2]=dp[2][2]+1=1`、`dp[4][3]=dp[1][3]+1=1`，一共五个，分别是[1,4]、[2,4]、[3,4]、[2,3,4]、[1,2,3,4]，可以看到，只有`dp[3][1]`升级上来的那两个子序列才满足条件，所以，ans += `dp[3][1]`。\n再来看看[7,7,7,7,7]这种特殊用例，遍历到第4个7的时候，它与前面任意元素的差值都是0，按照前面的公式`dp[i][0]=dp[j][0]+1`就不行了，这时候我们可以换成累加就可以轻松解决了，`dp[i][0]+=dp[j][0]+1`。\n\n最后，题目限定`nums[i]`的范围为`-2^31 <= nums[i] <= 2^31 - 1`，有可能溢出，而且，我们也不知道等差d有多少个，所以，使用`HashMap`来存储key为公差的等差子数组数量。\n\n\n\n---\n\n\n\n### 题解：\n\n```\nclass Solution {\npublic:\n    //动态规划，vector<map<int, int>> dp(n)\n    //dp[j][diff]表示以 nums[j] 为结尾、 diff 为等差数的等差序列个数\n    int numberOfArithmeticSlices(vector<int> &nums) {\n        const int n = nums.size();\n        int ans = 0;\n        vector<unordered_map<long long, int>> dp(n);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                long long diff = 1ll * nums[i] - nums[j]; //差值\n                auto it = dp[j].find(diff);  //查找这个地方是否有差值满足条件\n                int cnt = it == dp[j].end() ? 0 : it->second; //没有记录0，有则取出\n                ans += cnt;  //放入答案\n                dp[i][diff] += cnt + 1; //此位置为原位置 + 1，下次取出时会直接放入答案\n            }\n        }\n        return ans;\n    }\n};\n```\n\n\n\n---\n\n\n\n### 感想：\n\n第一眼就是动态规划，可是`dp`数组的含义没有确定好，也找不准状态转移方程，导致写了一大片冗余且错误的代码。\n\n看了官方题解才恍然大悟，评论区有一个观点也让我受益良多：动态规划就是逆向反推，又最后需要求得的答案反推到前面的转移方程。看似自底向上从无到有，实则逆向反推寻找来路\n","source":"_posts/2021-08-11-【LeetCode.446】等差数列划分 II - 子序列.md","raw":"---\ntitle: 【LeetCode.446】等差数列划分 II - 子序列\ndate: 2021-08-11 23:43:29\ncategories:\t算法\ntags:\n  - c++\n  - 动态规划\n---\n\n\n\n### \t题目：等差数列划分 II - 子序列\n\n给你一个整数数组 `nums` ，返回 nums 中所有 等差子序列 的数目。\n\n如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。\n\n例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。\n再例如，[1, 1, 2, 5, 7] 不是等差序列。\n数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。\n\n例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。\n题目数据保证答案是一个 32-bit 整数。\n\n<!--more-->\n\n示例 1：\n\n```\n输入：nums = [2,4,6,8,10]\n输出：7\n解释：所有的等差子序列为：\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]\n```\n\n\n\n示例 2：\n\n```\n输入：nums = [7,7,7,7,7]\n输出：16\n解释：数组中的任意子序列都是等差子序列。\n```\n\n\n\n提示：\n\n`1  <= nums.length <= 1000`\n`-231 <= nums[i] <= 231 - 1`\n\n\n\n---\n\n\n\n### 分析：\n\n给定数组为[1,2,3,4,5]，求等差子数组，我们使用动态规划的过程，一次遍历：\n\n遍历到3，发现它跟[1,2]可以组成子数组[1,2,3]，满足等差子数组要求，记`dp[3]=1`。\n\n遍历到4，发现它跟[2,3]可以组成子数组[2,3,4]，满足等差子数组要求，而它的前一位即3本来就有一个等差子数组，我们在它的基础上可以延续出来一个新的等差子数组[1,2,3,4]，所以，`dp[4]=dp[3]+1=2`，`dp[3]`表示原来3的基础上延续出来的[1,2,3,4]，+1表示全新的[2,3,4]。\n\n遍历到5，发现它跟[3,4]可以组成子数组[3,4,5]，满足等差子数组要求，而它的前一位即4本来是有两个等差子数组，我们在它的基础上可以延续出来两个新的等差子数组分别为[1,2,3,4,5]和[2,3,4,5]，所以，dp[5]=dp[4]+1=3，解释同上。\n这样，我们把`dp[3]+dp[4]+dp[5]=1+2+3=6`就是答案。\n\n方法一、动态规划\n好了，本题还是以[1,2,3,4,5]为例，[1,3,5]也是一个合格的答案，所以，我们可以转换成昨天的题目，我们求出每一个以`nums[i]`结尾的公差d的元素个数，再按照上述求等差子数组的思路很容易求出以`nums[i]`结尾等着为d的等差子数组的数量，把所有这些等差d加一起就是以`nums[i]`结尾的等差子序列的数量，列举所有的i即可求得结果，所以，我们定义如下：\n\n状态定义：`dp[i][d]`表示以`nums[i]`结尾，公差为d的等差子数组的数量。\n\n状态转移：`dp[i][d]=dp[j][d]+1`，其中j表示以`nums[i]`结尾等着为d的前面那个数`nums[j]`的下标。\n\n这样定义看似没有问题，实际运行的过程其实是有问题的：\n\n问题一：以[1,2,3,4,5]为例，遍历到2（下标为1）的时候，它与下标0的元素1的差值为1，按照公式应该得到：`dp[1][1]=dp[0][1]+1=1`,但是这个结果并不符合题目的要求，题目要求长度至少为3，那么，我们怎么才能知道下标j前面还有没有元素呢？如果只有`[nums[j], nums[i]]`是无法满足长度3的要求的。\n问题二：以[7,7,7,7,7]为例，遍历到第4个7（下标为3）的时候，它的等差子序列有4个，分别为[7(0),7(1),7(3)]、[7(0),7(2),7(3)]、[7(1),7(2),7(3)]、[7(0),7(1),7(2),7(3)]，按照`dp[i][d]=dp[j][d]+1`的规则去计算也是不对的。\n似乎没有思路了。再仔细想一下，既然三个长度的子序列是由两个长度的子序列升级来的，那么，我们能不能在统计结果的时候从两个长度的子序列开始计算呢，这样，三个长度的子序列就不用计算了。比如，以[1,2,3,4,5]为例：\n\n遍历到2时，以2结尾的子序列只有一个，即[1,2]，我们记为`dp2=1`。\n遍历到3时，以3结尾的子序列有三个，分别为[1,2,3]、[1,3]、[2,3]，我们分别记为`dp[3][1]=dp[2][1]+1=2`和`dp[3][2]=dp[1][2]+1=1`，可以看到，只有`dp[2][1]`升级上来的那个子序列才可以作为结果，所以，我们在这里`ans += dp[2][1]`。\n遍历到4时，以4结尾的子序列有多少个呢？它与前面元素的公差分别有1、2、3，我们按照公式可得`dp[4][1]=dp[3][1]+1=3`、`dp[4][2]=dp[2][2]+1=1`、`dp[4][3]=dp[1][3]+1=1`，一共五个，分别是[1,4]、[2,4]、[3,4]、[2,3,4]、[1,2,3,4]，可以看到，只有`dp[3][1]`升级上来的那两个子序列才满足条件，所以，ans += `dp[3][1]`。\n再来看看[7,7,7,7,7]这种特殊用例，遍历到第4个7的时候，它与前面任意元素的差值都是0，按照前面的公式`dp[i][0]=dp[j][0]+1`就不行了，这时候我们可以换成累加就可以轻松解决了，`dp[i][0]+=dp[j][0]+1`。\n\n最后，题目限定`nums[i]`的范围为`-2^31 <= nums[i] <= 2^31 - 1`，有可能溢出，而且，我们也不知道等差d有多少个，所以，使用`HashMap`来存储key为公差的等差子数组数量。\n\n\n\n---\n\n\n\n### 题解：\n\n```\nclass Solution {\npublic:\n    //动态规划，vector<map<int, int>> dp(n)\n    //dp[j][diff]表示以 nums[j] 为结尾、 diff 为等差数的等差序列个数\n    int numberOfArithmeticSlices(vector<int> &nums) {\n        const int n = nums.size();\n        int ans = 0;\n        vector<unordered_map<long long, int>> dp(n);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                long long diff = 1ll * nums[i] - nums[j]; //差值\n                auto it = dp[j].find(diff);  //查找这个地方是否有差值满足条件\n                int cnt = it == dp[j].end() ? 0 : it->second; //没有记录0，有则取出\n                ans += cnt;  //放入答案\n                dp[i][diff] += cnt + 1; //此位置为原位置 + 1，下次取出时会直接放入答案\n            }\n        }\n        return ans;\n    }\n};\n```\n\n\n\n---\n\n\n\n### 感想：\n\n第一眼就是动态规划，可是`dp`数组的含义没有确定好，也找不准状态转移方程，导致写了一大片冗余且错误的代码。\n\n看了官方题解才恍然大悟，评论区有一个观点也让我受益良多：动态规划就是逆向反推，又最后需要求得的答案反推到前面的转移方程。看似自底向上从无到有，实则逆向反推寻找来路\n","slug":"2021-08-11-【LeetCode.446】等差数列划分 II - 子序列","published":1,"updated":"2021-08-11T18:09:44.399Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hp001k1ou0efvc37ye","content":"<h3 id=\"题目：等差数列划分-II-子序列\"><a href=\"#题目：等差数列划分-II-子序列\" class=\"headerlink\" title=\"题目：等差数列划分 II - 子序列\"></a>题目：等差数列划分 II - 子序列</h3><p>给你一个整数数组 <code>nums</code> ，返回 nums 中所有 等差子序列 的数目。</p>\n<p>如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。</p>\n<p>例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。<br>再例如，[1, 1, 2, 5, 7] 不是等差序列。<br>数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。</p>\n<p>例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。<br>题目数据保证答案是一个 32-bit 整数。</p>\n<span id=\"more\"></span>\n\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,4,6,8,10]</span><br><span class=\"line\">输出：7</span><br><span class=\"line\">解释：所有的等差子序列为：</span><br><span class=\"line\">[2,4,6]</span><br><span class=\"line\">[4,6,8]</span><br><span class=\"line\">[6,8,10]</span><br><span class=\"line\">[2,4,6,8]</span><br><span class=\"line\">[4,6,8,10]</span><br><span class=\"line\">[2,4,6,8,10]</span><br><span class=\"line\">[2,6,10]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [7,7,7,7,7]</span><br><span class=\"line\">输出：16</span><br><span class=\"line\">解释：数组中的任意子序列都是等差子序列。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>提示：</p>\n<p><code>1  &lt;= nums.length &lt;= 1000</code><br><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>给定数组为[1,2,3,4,5]，求等差子数组，我们使用动态规划的过程，一次遍历：</p>\n<p>遍历到3，发现它跟[1,2]可以组成子数组[1,2,3]，满足等差子数组要求，记<code>dp[3]=1</code>。</p>\n<p>遍历到4，发现它跟[2,3]可以组成子数组[2,3,4]，满足等差子数组要求，而它的前一位即3本来就有一个等差子数组，我们在它的基础上可以延续出来一个新的等差子数组[1,2,3,4]，所以，<code>dp[4]=dp[3]+1=2</code>，<code>dp[3]</code>表示原来3的基础上延续出来的[1,2,3,4]，+1表示全新的[2,3,4]。</p>\n<p>遍历到5，发现它跟[3,4]可以组成子数组[3,4,5]，满足等差子数组要求，而它的前一位即4本来是有两个等差子数组，我们在它的基础上可以延续出来两个新的等差子数组分别为[1,2,3,4,5]和[2,3,4,5]，所以，dp[5]=dp[4]+1=3，解释同上。<br>这样，我们把<code>dp[3]+dp[4]+dp[5]=1+2+3=6</code>就是答案。</p>\n<p>方法一、动态规划<br>好了，本题还是以[1,2,3,4,5]为例，[1,3,5]也是一个合格的答案，所以，我们可以转换成昨天的题目，我们求出每一个以<code>nums[i]</code>结尾的公差d的元素个数，再按照上述求等差子数组的思路很容易求出以<code>nums[i]</code>结尾等着为d的等差子数组的数量，把所有这些等差d加一起就是以<code>nums[i]</code>结尾的等差子序列的数量，列举所有的i即可求得结果，所以，我们定义如下：</p>\n<p>状态定义：<code>dp[i][d]</code>表示以<code>nums[i]</code>结尾，公差为d的等差子数组的数量。</p>\n<p>状态转移：<code>dp[i][d]=dp[j][d]+1</code>，其中j表示以<code>nums[i]</code>结尾等着为d的前面那个数<code>nums[j]</code>的下标。</p>\n<p>这样定义看似没有问题，实际运行的过程其实是有问题的：</p>\n<p>问题一：以[1,2,3,4,5]为例，遍历到2（下标为1）的时候，它与下标0的元素1的差值为1，按照公式应该得到：<code>dp[1][1]=dp[0][1]+1=1</code>,但是这个结果并不符合题目的要求，题目要求长度至少为3，那么，我们怎么才能知道下标j前面还有没有元素呢？如果只有<code>[nums[j], nums[i]]</code>是无法满足长度3的要求的。<br>问题二：以[7,7,7,7,7]为例，遍历到第4个7（下标为3）的时候，它的等差子序列有4个，分别为[7(0),7(1),7(3)]、[7(0),7(2),7(3)]、[7(1),7(2),7(3)]、[7(0),7(1),7(2),7(3)]，按照<code>dp[i][d]=dp[j][d]+1</code>的规则去计算也是不对的。<br>似乎没有思路了。再仔细想一下，既然三个长度的子序列是由两个长度的子序列升级来的，那么，我们能不能在统计结果的时候从两个长度的子序列开始计算呢，这样，三个长度的子序列就不用计算了。比如，以[1,2,3,4,5]为例：</p>\n<p>遍历到2时，以2结尾的子序列只有一个，即[1,2]，我们记为<code>dp2=1</code>。<br>遍历到3时，以3结尾的子序列有三个，分别为[1,2,3]、[1,3]、[2,3]，我们分别记为<code>dp[3][1]=dp[2][1]+1=2</code>和<code>dp[3][2]=dp[1][2]+1=1</code>，可以看到，只有<code>dp[2][1]</code>升级上来的那个子序列才可以作为结果，所以，我们在这里<code>ans += dp[2][1]</code>。<br>遍历到4时，以4结尾的子序列有多少个呢？它与前面元素的公差分别有1、2、3，我们按照公式可得<code>dp[4][1]=dp[3][1]+1=3</code>、<code>dp[4][2]=dp[2][2]+1=1</code>、<code>dp[4][3]=dp[1][3]+1=1</code>，一共五个，分别是[1,4]、[2,4]、[3,4]、[2,3,4]、[1,2,3,4]，可以看到，只有<code>dp[3][1]</code>升级上来的那两个子序列才满足条件，所以，ans += <code>dp[3][1]</code>。<br>再来看看[7,7,7,7,7]这种特殊用例，遍历到第4个7的时候，它与前面任意元素的差值都是0，按照前面的公式<code>dp[i][0]=dp[j][0]+1</code>就不行了，这时候我们可以换成累加就可以轻松解决了，<code>dp[i][0]+=dp[j][0]+1</code>。</p>\n<p>最后，题目限定<code>nums[i]</code>的范围为<code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code>，有可能溢出，而且，我们也不知道等差d有多少个，所以，使用<code>HashMap</code>来存储key为公差的等差子数组数量。</p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    //动态规划，vector&lt;map&lt;int, int&gt;&gt; dp(n)</span><br><span class=\"line\">    //dp[j][diff]表示以 nums[j] 为结尾、 diff 为等差数的等差序列个数</span><br><span class=\"line\">    int numberOfArithmeticSlices(vector&lt;int&gt; &amp;nums) &#123;</span><br><span class=\"line\">        const int n = nums.size();</span><br><span class=\"line\">        int ans = 0;</span><br><span class=\"line\">        vector&lt;unordered_map&lt;long long, int&gt;&gt; dp(n);</span><br><span class=\"line\">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class=\"line\">                long long diff = 1ll * nums[i] - nums[j]; //差值</span><br><span class=\"line\">                auto it = dp[j].find(diff);  //查找这个地方是否有差值满足条件</span><br><span class=\"line\">                int cnt = it == dp[j].end() ? 0 : it-&gt;second; //没有记录0，有则取出</span><br><span class=\"line\">                ans += cnt;  //放入答案</span><br><span class=\"line\">                dp[i][diff] += cnt + 1; //此位置为原位置 + 1，下次取出时会直接放入答案</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"感想：\"><a href=\"#感想：\" class=\"headerlink\" title=\"感想：\"></a>感想：</h3><p>第一眼就是动态规划，可是<code>dp</code>数组的含义没有确定好，也找不准状态转移方程，导致写了一大片冗余且错误的代码。</p>\n<p>看了官方题解才恍然大悟，评论区有一个观点也让我受益良多：动态规划就是逆向反推，又最后需要求得的答案反推到前面的转移方程。看似自底向上从无到有，实则逆向反推寻找来路</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"题目：等差数列划分-II-子序列\"><a href=\"#题目：等差数列划分-II-子序列\" class=\"headerlink\" title=\"题目：等差数列划分 II - 子序列\"></a>题目：等差数列划分 II - 子序列</h3><p>给你一个整数数组 <code>nums</code> ，返回 nums 中所有 等差子序列 的数目。</p>\n<p>如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。</p>\n<p>例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。<br>再例如，[1, 1, 2, 5, 7] 不是等差序列。<br>数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。</p>\n<p>例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。<br>题目数据保证答案是一个 32-bit 整数。</p>","more":"<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,4,6,8,10]</span><br><span class=\"line\">输出：7</span><br><span class=\"line\">解释：所有的等差子序列为：</span><br><span class=\"line\">[2,4,6]</span><br><span class=\"line\">[4,6,8]</span><br><span class=\"line\">[6,8,10]</span><br><span class=\"line\">[2,4,6,8]</span><br><span class=\"line\">[4,6,8,10]</span><br><span class=\"line\">[2,4,6,8,10]</span><br><span class=\"line\">[2,6,10]</span><br></pre></td></tr></table></figure>\n\n\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [7,7,7,7,7]</span><br><span class=\"line\">输出：16</span><br><span class=\"line\">解释：数组中的任意子序列都是等差子序列。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>提示：</p>\n<p><code>1  &lt;= nums.length &lt;= 1000</code><br><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>给定数组为[1,2,3,4,5]，求等差子数组，我们使用动态规划的过程，一次遍历：</p>\n<p>遍历到3，发现它跟[1,2]可以组成子数组[1,2,3]，满足等差子数组要求，记<code>dp[3]=1</code>。</p>\n<p>遍历到4，发现它跟[2,3]可以组成子数组[2,3,4]，满足等差子数组要求，而它的前一位即3本来就有一个等差子数组，我们在它的基础上可以延续出来一个新的等差子数组[1,2,3,4]，所以，<code>dp[4]=dp[3]+1=2</code>，<code>dp[3]</code>表示原来3的基础上延续出来的[1,2,3,4]，+1表示全新的[2,3,4]。</p>\n<p>遍历到5，发现它跟[3,4]可以组成子数组[3,4,5]，满足等差子数组要求，而它的前一位即4本来是有两个等差子数组，我们在它的基础上可以延续出来两个新的等差子数组分别为[1,2,3,4,5]和[2,3,4,5]，所以，dp[5]=dp[4]+1=3，解释同上。<br>这样，我们把<code>dp[3]+dp[4]+dp[5]=1+2+3=6</code>就是答案。</p>\n<p>方法一、动态规划<br>好了，本题还是以[1,2,3,4,5]为例，[1,3,5]也是一个合格的答案，所以，我们可以转换成昨天的题目，我们求出每一个以<code>nums[i]</code>结尾的公差d的元素个数，再按照上述求等差子数组的思路很容易求出以<code>nums[i]</code>结尾等着为d的等差子数组的数量，把所有这些等差d加一起就是以<code>nums[i]</code>结尾的等差子序列的数量，列举所有的i即可求得结果，所以，我们定义如下：</p>\n<p>状态定义：<code>dp[i][d]</code>表示以<code>nums[i]</code>结尾，公差为d的等差子数组的数量。</p>\n<p>状态转移：<code>dp[i][d]=dp[j][d]+1</code>，其中j表示以<code>nums[i]</code>结尾等着为d的前面那个数<code>nums[j]</code>的下标。</p>\n<p>这样定义看似没有问题，实际运行的过程其实是有问题的：</p>\n<p>问题一：以[1,2,3,4,5]为例，遍历到2（下标为1）的时候，它与下标0的元素1的差值为1，按照公式应该得到：<code>dp[1][1]=dp[0][1]+1=1</code>,但是这个结果并不符合题目的要求，题目要求长度至少为3，那么，我们怎么才能知道下标j前面还有没有元素呢？如果只有<code>[nums[j], nums[i]]</code>是无法满足长度3的要求的。<br>问题二：以[7,7,7,7,7]为例，遍历到第4个7（下标为3）的时候，它的等差子序列有4个，分别为[7(0),7(1),7(3)]、[7(0),7(2),7(3)]、[7(1),7(2),7(3)]、[7(0),7(1),7(2),7(3)]，按照<code>dp[i][d]=dp[j][d]+1</code>的规则去计算也是不对的。<br>似乎没有思路了。再仔细想一下，既然三个长度的子序列是由两个长度的子序列升级来的，那么，我们能不能在统计结果的时候从两个长度的子序列开始计算呢，这样，三个长度的子序列就不用计算了。比如，以[1,2,3,4,5]为例：</p>\n<p>遍历到2时，以2结尾的子序列只有一个，即[1,2]，我们记为<code>dp2=1</code>。<br>遍历到3时，以3结尾的子序列有三个，分别为[1,2,3]、[1,3]、[2,3]，我们分别记为<code>dp[3][1]=dp[2][1]+1=2</code>和<code>dp[3][2]=dp[1][2]+1=1</code>，可以看到，只有<code>dp[2][1]</code>升级上来的那个子序列才可以作为结果，所以，我们在这里<code>ans += dp[2][1]</code>。<br>遍历到4时，以4结尾的子序列有多少个呢？它与前面元素的公差分别有1、2、3，我们按照公式可得<code>dp[4][1]=dp[3][1]+1=3</code>、<code>dp[4][2]=dp[2][2]+1=1</code>、<code>dp[4][3]=dp[1][3]+1=1</code>，一共五个，分别是[1,4]、[2,4]、[3,4]、[2,3,4]、[1,2,3,4]，可以看到，只有<code>dp[3][1]</code>升级上来的那两个子序列才满足条件，所以，ans += <code>dp[3][1]</code>。<br>再来看看[7,7,7,7,7]这种特殊用例，遍历到第4个7的时候，它与前面任意元素的差值都是0，按照前面的公式<code>dp[i][0]=dp[j][0]+1</code>就不行了，这时候我们可以换成累加就可以轻松解决了，<code>dp[i][0]+=dp[j][0]+1</code>。</p>\n<p>最后，题目限定<code>nums[i]</code>的范围为<code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code>，有可能溢出，而且，我们也不知道等差d有多少个，所以，使用<code>HashMap</code>来存储key为公差的等差子数组数量。</p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    //动态规划，vector&lt;map&lt;int, int&gt;&gt; dp(n)</span><br><span class=\"line\">    //dp[j][diff]表示以 nums[j] 为结尾、 diff 为等差数的等差序列个数</span><br><span class=\"line\">    int numberOfArithmeticSlices(vector&lt;int&gt; &amp;nums) &#123;</span><br><span class=\"line\">        const int n = nums.size();</span><br><span class=\"line\">        int ans = 0;</span><br><span class=\"line\">        vector&lt;unordered_map&lt;long long, int&gt;&gt; dp(n);</span><br><span class=\"line\">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class=\"line\">                long long diff = 1ll * nums[i] - nums[j]; //差值</span><br><span class=\"line\">                auto it = dp[j].find(diff);  //查找这个地方是否有差值满足条件</span><br><span class=\"line\">                int cnt = it == dp[j].end() ? 0 : it-&gt;second; //没有记录0，有则取出</span><br><span class=\"line\">                ans += cnt;  //放入答案</span><br><span class=\"line\">                dp[i][diff] += cnt + 1; //此位置为原位置 + 1，下次取出时会直接放入答案</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"感想：\"><a href=\"#感想：\" class=\"headerlink\" title=\"感想：\"></a>感想：</h3><p>第一眼就是动态规划，可是<code>dp</code>数组的含义没有确定好，也找不准状态转移方程，导致写了一大片冗余且错误的代码。</p>\n<p>看了官方题解才恍然大悟，评论区有一个观点也让我受益良多：动态规划就是逆向反推，又最后需要求得的答案反推到前面的转移方程。看似自底向上从无到有，实则逆向反推寻找来路</p>"},{"title":"C++中map和unordered_map的区别和使用","date":"2021-08-11T15:43:58.000Z","_content":"\n\n\n### \t始、前言\n\n在平时刷题需要使用map时，官方题解用的unordered_map，而我用的是map执行时间相对较慢，这就来看看两者有啥区别\n\n<!--more-->\n\n---\n\n\n\n### 一、需要引入的头文件不同\n\n**map**: \n\n`#include < map >`\n\n\n\n**unordered_map**:\n\n `#include < unordered_map >`\n\n\n\n---\n\n\n\n### 二、内部实现机理不同\n\n**map**： \n\nmap内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。\n\n\n\n**unordered_map**: \n\nunordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。\n\n\n\n---\n\n\n\n### 三、优缺点以及适用处\n\n**map**：\n\n优点：\n\n有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作\n红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高\n\n缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间\n\n适用处：对于那些有顺序要求的问题，用map会更高效一些\n\n \n\n**unordered_map**：\n\n优点： 因为内部实现了哈希表，因此其查找速度非常的快\n\n缺点： 哈希表的建立比较耗费时间\n\n适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map\n\n\n\n**总结**：\n\n内存占有率的问题就转化成红黑树 VS hash表 , 还是unordered_map占用的内存要高。\n但是unordered_map执行效率要比map高很多\n对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的\n\n\n\n---\n\n\n\n### 四、map和unordered_map的使用\n\nunordered_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，上方已经解释了，但是就外部使用来说却是一致的。\n\n\n\n**常用操作汇总举例**：\n\n```\n\n#include <iostream>  \n#include <unordered_map>  \n#include <map>\n#include <string>  \nusing namespace std;  \nint main()  \n{  \n\t//注意：C++11才开始支持括号初始化\n    unordered_map<int, string> myMap={{ 5, \"张大\" },{ 6, \"李五\" }};//使用{}赋值\n    myMap[2] = \"李四\";  //使用[ ]进行单个插入，若已存在键值2，则赋值修改，若无则插入。\n    myMap.insert(pair<int, string>(3, \"陈二\"));//使用insert和pair插入\n  \n\t//遍历输出+迭代器的使用\n    auto iter = myMap.begin();\n    //auto自动识别为迭代器类型unordered_map<int,string>::iterator\n    \n    while (iter!= myMap.end())\n    {  \n        cout << iter->first << \",\" << iter->second << endl;  \n        ++iter;  \n    }  \n\t\n\t//查找元素并输出+迭代器的使用\n    auto iterator = myMap.find(2);//find()返回一个指向2的迭代器\n    if (iterator != myMap.end())\n\t    cout << endl<< iterator->first << \",\" << iterator->second << endl;  \n    system(\"pause\");  \n    return 0;  \n}  \n```\n\n\n\n此时用的是unordered_map，输出的结果为：\n\n3,陈二\n\n2,李四\n\n6,李五\n\n5,张大\n\n2,李四\n\n\n\n若把unordered_map换成map，输出的结果为：\n\n2,李四\n\n3,陈二\n\n5,张大\n\n6,李五\n\n2,李四\n\n\n\n---\n\n\n\n### 终、补充\n\nunordered_map插入顺序不固定，按编译器的规定，这里的是头插\n","source":"_posts/2021-08-11-C++中map和unordered_map的区别和使用.md","raw":"---\ntitle: C++中map和unordered_map的区别和使用\ndate: 2021-08-11 23:43:58\ncategories:\tc++\ntags:\n  - map\n  - c++\n---\n\n\n\n### \t始、前言\n\n在平时刷题需要使用map时，官方题解用的unordered_map，而我用的是map执行时间相对较慢，这就来看看两者有啥区别\n\n<!--more-->\n\n---\n\n\n\n### 一、需要引入的头文件不同\n\n**map**: \n\n`#include < map >`\n\n\n\n**unordered_map**:\n\n `#include < unordered_map >`\n\n\n\n---\n\n\n\n### 二、内部实现机理不同\n\n**map**： \n\nmap内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。\n\n\n\n**unordered_map**: \n\nunordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。\n\n\n\n---\n\n\n\n### 三、优缺点以及适用处\n\n**map**：\n\n优点：\n\n有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作\n红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高\n\n缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间\n\n适用处：对于那些有顺序要求的问题，用map会更高效一些\n\n \n\n**unordered_map**：\n\n优点： 因为内部实现了哈希表，因此其查找速度非常的快\n\n缺点： 哈希表的建立比较耗费时间\n\n适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map\n\n\n\n**总结**：\n\n内存占有率的问题就转化成红黑树 VS hash表 , 还是unordered_map占用的内存要高。\n但是unordered_map执行效率要比map高很多\n对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的\n\n\n\n---\n\n\n\n### 四、map和unordered_map的使用\n\nunordered_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，上方已经解释了，但是就外部使用来说却是一致的。\n\n\n\n**常用操作汇总举例**：\n\n```\n\n#include <iostream>  \n#include <unordered_map>  \n#include <map>\n#include <string>  \nusing namespace std;  \nint main()  \n{  \n\t//注意：C++11才开始支持括号初始化\n    unordered_map<int, string> myMap={{ 5, \"张大\" },{ 6, \"李五\" }};//使用{}赋值\n    myMap[2] = \"李四\";  //使用[ ]进行单个插入，若已存在键值2，则赋值修改，若无则插入。\n    myMap.insert(pair<int, string>(3, \"陈二\"));//使用insert和pair插入\n  \n\t//遍历输出+迭代器的使用\n    auto iter = myMap.begin();\n    //auto自动识别为迭代器类型unordered_map<int,string>::iterator\n    \n    while (iter!= myMap.end())\n    {  \n        cout << iter->first << \",\" << iter->second << endl;  \n        ++iter;  \n    }  \n\t\n\t//查找元素并输出+迭代器的使用\n    auto iterator = myMap.find(2);//find()返回一个指向2的迭代器\n    if (iterator != myMap.end())\n\t    cout << endl<< iterator->first << \",\" << iterator->second << endl;  \n    system(\"pause\");  \n    return 0;  \n}  \n```\n\n\n\n此时用的是unordered_map，输出的结果为：\n\n3,陈二\n\n2,李四\n\n6,李五\n\n5,张大\n\n2,李四\n\n\n\n若把unordered_map换成map，输出的结果为：\n\n2,李四\n\n3,陈二\n\n5,张大\n\n6,李五\n\n2,李四\n\n\n\n---\n\n\n\n### 终、补充\n\nunordered_map插入顺序不固定，按编译器的规定，这里的是头插\n","slug":"2021-08-11-C++中map和unordered_map的区别和使用","published":1,"updated":"2021-08-12T07:37:53.001Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hq001m1ou05u855pcs","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>在平时刷题需要使用map时，官方题解用的unordered_map，而我用的是map执行时间相对较慢，这就来看看两者有啥区别</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、需要引入的头文件不同\"><a href=\"#一、需要引入的头文件不同\" class=\"headerlink\" title=\"一、需要引入的头文件不同\"></a>一、需要引入的头文件不同</h3><p><strong>map</strong>: </p>\n<p><code>#include &lt; map &gt;</code></p>\n<p><strong>unordered_map</strong>:</p>\n<p> <code>#include &lt; unordered_map &gt;</code></p>\n<hr>\n<h3 id=\"二、内部实现机理不同\"><a href=\"#二、内部实现机理不同\" class=\"headerlink\" title=\"二、内部实现机理不同\"></a>二、内部实现机理不同</h3><p><strong>map</strong>： </p>\n<p>map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。</p>\n<p><strong>unordered_map</strong>: </p>\n<p>unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。</p>\n<hr>\n<h3 id=\"三、优缺点以及适用处\"><a href=\"#三、优缺点以及适用处\" class=\"headerlink\" title=\"三、优缺点以及适用处\"></a>三、优缺点以及适用处</h3><p><strong>map</strong>：</p>\n<p>优点：</p>\n<p>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作<br>红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高</p>\n<p>缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间</p>\n<p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p>\n<p><strong>unordered_map</strong>：</p>\n<p>优点： 因为内部实现了哈希表，因此其查找速度非常的快</p>\n<p>缺点： 哈希表的建立比较耗费时间</p>\n<p>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>\n<p><strong>总结</strong>：</p>\n<p>内存占有率的问题就转化成红黑树 VS hash表 , 还是unordered_map占用的内存要高。<br>但是unordered_map执行效率要比map高很多<br>对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的</p>\n<hr>\n<h3 id=\"四、map和unordered-map的使用\"><a href=\"#四、map和unordered-map的使用\" class=\"headerlink\" title=\"四、map和unordered_map的使用\"></a>四、map和unordered_map的使用</h3><p>unordered_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，上方已经解释了，但是就外部使用来说却是一致的。</p>\n<p><strong>常用操作汇总举例</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#include &lt;iostream&gt;  </span><br><span class=\"line\">#include &lt;unordered_map&gt;  </span><br><span class=\"line\">#include &lt;map&gt;</span><br><span class=\"line\">#include &lt;string&gt;  </span><br><span class=\"line\">using namespace std;  </span><br><span class=\"line\">int main()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\t//注意：C++11才开始支持括号初始化</span><br><span class=\"line\">    unordered_map&lt;int, string&gt; myMap=&#123;&#123; 5, &quot;张大&quot; &#125;,&#123; 6, &quot;李五&quot; &#125;&#125;;//使用&#123;&#125;赋值</span><br><span class=\"line\">    myMap[2] = &quot;李四&quot;;  //使用[ ]进行单个插入，若已存在键值2，则赋值修改，若无则插入。</span><br><span class=\"line\">    myMap.insert(pair&lt;int, string&gt;(3, &quot;陈二&quot;));//使用insert和pair插入</span><br><span class=\"line\">  </span><br><span class=\"line\">\t//遍历输出+迭代器的使用</span><br><span class=\"line\">    auto iter = myMap.begin();</span><br><span class=\"line\">    //auto自动识别为迭代器类型unordered_map&lt;int,string&gt;::iterator</span><br><span class=\"line\">    </span><br><span class=\"line\">    while (iter!= myMap.end())</span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        cout &lt;&lt; iter-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;  </span><br><span class=\"line\">        ++iter;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//查找元素并输出+迭代器的使用</span><br><span class=\"line\">    auto iterator = myMap.find(2);//find()返回一个指向2的迭代器</span><br><span class=\"line\">    if (iterator != myMap.end())</span><br><span class=\"line\">\t    cout &lt;&lt; endl&lt;&lt; iterator-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; iterator-&gt;second &lt;&lt; endl;  </span><br><span class=\"line\">    system(&quot;pause&quot;);  </span><br><span class=\"line\">    return 0;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n\n\n<p>此时用的是unordered_map，输出的结果为：</p>\n<p>3,陈二</p>\n<p>2,李四</p>\n<p>6,李五</p>\n<p>5,张大</p>\n<p>2,李四</p>\n<p>若把unordered_map换成map，输出的结果为：</p>\n<p>2,李四</p>\n<p>3,陈二</p>\n<p>5,张大</p>\n<p>6,李五</p>\n<p>2,李四</p>\n<hr>\n<h3 id=\"终、补充\"><a href=\"#终、补充\" class=\"headerlink\" title=\"终、补充\"></a>终、补充</h3><p>unordered_map插入顺序不固定，按编译器的规定，这里的是头插</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>在平时刷题需要使用map时，官方题解用的unordered_map，而我用的是map执行时间相对较慢，这就来看看两者有啥区别</p>","more":"<hr>\n<h3 id=\"一、需要引入的头文件不同\"><a href=\"#一、需要引入的头文件不同\" class=\"headerlink\" title=\"一、需要引入的头文件不同\"></a>一、需要引入的头文件不同</h3><p><strong>map</strong>: </p>\n<p><code>#include &lt; map &gt;</code></p>\n<p><strong>unordered_map</strong>:</p>\n<p> <code>#include &lt; unordered_map &gt;</code></p>\n<hr>\n<h3 id=\"二、内部实现机理不同\"><a href=\"#二、内部实现机理不同\" class=\"headerlink\" title=\"二、内部实现机理不同\"></a>二、内部实现机理不同</h3><p><strong>map</strong>： </p>\n<p>map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。</p>\n<p><strong>unordered_map</strong>: </p>\n<p>unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。</p>\n<hr>\n<h3 id=\"三、优缺点以及适用处\"><a href=\"#三、优缺点以及适用处\" class=\"headerlink\" title=\"三、优缺点以及适用处\"></a>三、优缺点以及适用处</h3><p><strong>map</strong>：</p>\n<p>优点：</p>\n<p>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作<br>红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高</p>\n<p>缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间</p>\n<p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p>\n<p><strong>unordered_map</strong>：</p>\n<p>优点： 因为内部实现了哈希表，因此其查找速度非常的快</p>\n<p>缺点： 哈希表的建立比较耗费时间</p>\n<p>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>\n<p><strong>总结</strong>：</p>\n<p>内存占有率的问题就转化成红黑树 VS hash表 , 还是unordered_map占用的内存要高。<br>但是unordered_map执行效率要比map高很多<br>对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的</p>\n<hr>\n<h3 id=\"四、map和unordered-map的使用\"><a href=\"#四、map和unordered-map的使用\" class=\"headerlink\" title=\"四、map和unordered_map的使用\"></a>四、map和unordered_map的使用</h3><p>unordered_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，上方已经解释了，但是就外部使用来说却是一致的。</p>\n<p><strong>常用操作汇总举例</strong>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#include &lt;iostream&gt;  </span><br><span class=\"line\">#include &lt;unordered_map&gt;  </span><br><span class=\"line\">#include &lt;map&gt;</span><br><span class=\"line\">#include &lt;string&gt;  </span><br><span class=\"line\">using namespace std;  </span><br><span class=\"line\">int main()  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">\t//注意：C++11才开始支持括号初始化</span><br><span class=\"line\">    unordered_map&lt;int, string&gt; myMap=&#123;&#123; 5, &quot;张大&quot; &#125;,&#123; 6, &quot;李五&quot; &#125;&#125;;//使用&#123;&#125;赋值</span><br><span class=\"line\">    myMap[2] = &quot;李四&quot;;  //使用[ ]进行单个插入，若已存在键值2，则赋值修改，若无则插入。</span><br><span class=\"line\">    myMap.insert(pair&lt;int, string&gt;(3, &quot;陈二&quot;));//使用insert和pair插入</span><br><span class=\"line\">  </span><br><span class=\"line\">\t//遍历输出+迭代器的使用</span><br><span class=\"line\">    auto iter = myMap.begin();</span><br><span class=\"line\">    //auto自动识别为迭代器类型unordered_map&lt;int,string&gt;::iterator</span><br><span class=\"line\">    </span><br><span class=\"line\">    while (iter!= myMap.end())</span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        cout &lt;&lt; iter-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;  </span><br><span class=\"line\">        ++iter;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">\t</span><br><span class=\"line\">\t//查找元素并输出+迭代器的使用</span><br><span class=\"line\">    auto iterator = myMap.find(2);//find()返回一个指向2的迭代器</span><br><span class=\"line\">    if (iterator != myMap.end())</span><br><span class=\"line\">\t    cout &lt;&lt; endl&lt;&lt; iterator-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; iterator-&gt;second &lt;&lt; endl;  </span><br><span class=\"line\">    system(&quot;pause&quot;);  </span><br><span class=\"line\">    return 0;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n\n\n\n<p>此时用的是unordered_map，输出的结果为：</p>\n<p>3,陈二</p>\n<p>2,李四</p>\n<p>6,李五</p>\n<p>5,张大</p>\n<p>2,李四</p>\n<p>若把unordered_map换成map，输出的结果为：</p>\n<p>2,李四</p>\n<p>3,陈二</p>\n<p>5,张大</p>\n<p>6,李五</p>\n<p>2,李四</p>\n<hr>\n<h3 id=\"终、补充\"><a href=\"#终、补充\" class=\"headerlink\" title=\"终、补充\"></a>终、补充</h3><p>unordered_map插入顺序不固定，按编译器的规定，这里的是头插</p>"},{"title":"《Robbie Swifthand》Unity2d独立游戏学习（七）","date":"2021-09-12T07:30:04.000Z","_content":"\n\n\n### \t始、回顾\n\n（忙完开学的琐事）\n\n先回顾上一回完成的内容，我们制作了会让角色死亡的尖刺，还加上了死亡效果配套的特效和声音。场景中添加了游戏的主要任务——收集宝珠，同样也有配套的特效和声音\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、更炫酷的视觉效果\n\n1.检查插件Post Processing是否已安装，Window → Package Manage\n\n2.为主摄像机添加组件Post Processing Layer\n\n3.新建空项目Global Post Processing，将Layer 改成 Post Processing（新建）\n\n4.将主摄像机中Post Processing Layer的Layer设置成Post Processing，这样主摄像机就会观察新项目的特效\n\n5.为Global Post Processing添加组件Post Processing Volume，勾选is Global\n\n6.为Global Post Processing新建一个Profile（new）用来承载即将要设置的特效，Add effect 可以添加各种视觉效果：\n\nBloom：泛光效果\n\nColor Grading：镜头调色\n\nChromatic Aberration：场景畸变效果\n\nLens Distortion：镜头畸变效果9\n\nVignette：边缘阴影效果\n\n\n\n7.调好特效了吗，调好了偏不用，就是玩儿。在Assets → VFX → Profiles 中找到Global Reference预制体，拖入Global Post Processing → Post Processing Volume → Profile（如果场景过亮可以在Lightning → Environment Lighting调整场景亮度）\n\n\n\n---\n\n\n\n### \t二、摄像头震动效果\n\n1.在跟随人物的2D摄像机中的Extension添加新的组件Cinemachine Impulse Listener\n\n2.在宝珠Shrine → Orb预制体中添加新组件Cinemachine Collision Impulse Sourse（就像音效系统一样，有一个接收器接收声音并且播放，有一个物体设定条件发出声音）\n\n3.将Assets → VFX → Profiles中的Explosion Shake 拖入Cinemachine Collision Impulse Sourse → Raw Signal\n\n4.设置触发此特效的Layer ，将Cinemachine Collision Impulse Sourse → Layer Mask 设置成Player，我们希望当Layer为Player的物体触碰到Orb时就会触发摄像头震动效果\n\n5.还可以在Cinemachine Collision Impulse Sourse → Frequency Gain 设置成100，这个数值越高，震动的频率越高，更快完成\n\n\n\n---\n\n\n\n### \t终、休整\n\n到此为止，我们已经实现了游戏大部分刚需内容，接下来把目光转移到游戏整体管理，还有一些细节的修补\n\n","source":"_posts/2021-09-12-《Robbie Swifthand》Unity2d独立游戏学习（七）.md","raw":"---\ntitle: 《Robbie Swifthand》Unity2d独立游戏学习（七）\ndate: 2021-09-12 15:30:04\ncategories:\tunity\ntags:\n  - c#\n  - unity\n---\n\n\n\n### \t始、回顾\n\n（忙完开学的琐事）\n\n先回顾上一回完成的内容，我们制作了会让角色死亡的尖刺，还加上了死亡效果配套的特效和声音。场景中添加了游戏的主要任务——收集宝珠，同样也有配套的特效和声音\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、更炫酷的视觉效果\n\n1.检查插件Post Processing是否已安装，Window → Package Manage\n\n2.为主摄像机添加组件Post Processing Layer\n\n3.新建空项目Global Post Processing，将Layer 改成 Post Processing（新建）\n\n4.将主摄像机中Post Processing Layer的Layer设置成Post Processing，这样主摄像机就会观察新项目的特效\n\n5.为Global Post Processing添加组件Post Processing Volume，勾选is Global\n\n6.为Global Post Processing新建一个Profile（new）用来承载即将要设置的特效，Add effect 可以添加各种视觉效果：\n\nBloom：泛光效果\n\nColor Grading：镜头调色\n\nChromatic Aberration：场景畸变效果\n\nLens Distortion：镜头畸变效果9\n\nVignette：边缘阴影效果\n\n\n\n7.调好特效了吗，调好了偏不用，就是玩儿。在Assets → VFX → Profiles 中找到Global Reference预制体，拖入Global Post Processing → Post Processing Volume → Profile（如果场景过亮可以在Lightning → Environment Lighting调整场景亮度）\n\n\n\n---\n\n\n\n### \t二、摄像头震动效果\n\n1.在跟随人物的2D摄像机中的Extension添加新的组件Cinemachine Impulse Listener\n\n2.在宝珠Shrine → Orb预制体中添加新组件Cinemachine Collision Impulse Sourse（就像音效系统一样，有一个接收器接收声音并且播放，有一个物体设定条件发出声音）\n\n3.将Assets → VFX → Profiles中的Explosion Shake 拖入Cinemachine Collision Impulse Sourse → Raw Signal\n\n4.设置触发此特效的Layer ，将Cinemachine Collision Impulse Sourse → Layer Mask 设置成Player，我们希望当Layer为Player的物体触碰到Orb时就会触发摄像头震动效果\n\n5.还可以在Cinemachine Collision Impulse Sourse → Frequency Gain 设置成100，这个数值越高，震动的频率越高，更快完成\n\n\n\n---\n\n\n\n### \t终、休整\n\n到此为止，我们已经实现了游戏大部分刚需内容，接下来把目光转移到游戏整体管理，还有一些细节的修补\n\n","slug":"2021-09-12-《Robbie Swifthand》Unity2d独立游戏学习（七）","published":1,"updated":"2022-02-09T12:32:54.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hr001q1ou081aa6625","content":"<h3 id=\"始、回顾\"><a href=\"#始、回顾\" class=\"headerlink\" title=\"始、回顾\"></a>始、回顾</h3><p>（忙完开学的琐事）</p>\n<p>先回顾上一回完成的内容，我们制作了会让角色死亡的尖刺，还加上了死亡效果配套的特效和声音。场景中添加了游戏的主要任务——收集宝珠，同样也有配套的特效和声音</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、更炫酷的视觉效果\"><a href=\"#一、更炫酷的视觉效果\" class=\"headerlink\" title=\"一、更炫酷的视觉效果\"></a>一、更炫酷的视觉效果</h3><p>1.检查插件Post Processing是否已安装，Window → Package Manage</p>\n<p>2.为主摄像机添加组件Post Processing Layer</p>\n<p>3.新建空项目Global Post Processing，将Layer 改成 Post Processing（新建）</p>\n<p>4.将主摄像机中Post Processing Layer的Layer设置成Post Processing，这样主摄像机就会观察新项目的特效</p>\n<p>5.为Global Post Processing添加组件Post Processing Volume，勾选is Global</p>\n<p>6.为Global Post Processing新建一个Profile（new）用来承载即将要设置的特效，Add effect 可以添加各种视觉效果：</p>\n<p>Bloom：泛光效果</p>\n<p>Color Grading：镜头调色</p>\n<p>Chromatic Aberration：场景畸变效果</p>\n<p>Lens Distortion：镜头畸变效果9</p>\n<p>Vignette：边缘阴影效果</p>\n<p>7.调好特效了吗，调好了偏不用，就是玩儿。在Assets → VFX → Profiles 中找到Global Reference预制体，拖入Global Post Processing → Post Processing Volume → Profile（如果场景过亮可以在Lightning → Environment Lighting调整场景亮度）</p>\n<hr>\n<h3 id=\"二、摄像头震动效果\"><a href=\"#二、摄像头震动效果\" class=\"headerlink\" title=\"二、摄像头震动效果\"></a>二、摄像头震动效果</h3><p>1.在跟随人物的2D摄像机中的Extension添加新的组件Cinemachine Impulse Listener</p>\n<p>2.在宝珠Shrine → Orb预制体中添加新组件Cinemachine Collision Impulse Sourse（就像音效系统一样，有一个接收器接收声音并且播放，有一个物体设定条件发出声音）</p>\n<p>3.将Assets → VFX → Profiles中的Explosion Shake 拖入Cinemachine Collision Impulse Sourse → Raw Signal</p>\n<p>4.设置触发此特效的Layer ，将Cinemachine Collision Impulse Sourse → Layer Mask 设置成Player，我们希望当Layer为Player的物体触碰到Orb时就会触发摄像头震动效果</p>\n<p>5.还可以在Cinemachine Collision Impulse Sourse → Frequency Gain 设置成100，这个数值越高，震动的频率越高，更快完成</p>\n<hr>\n<h3 id=\"终、休整\"><a href=\"#终、休整\" class=\"headerlink\" title=\"终、休整\"></a>终、休整</h3><p>到此为止，我们已经实现了游戏大部分刚需内容，接下来把目光转移到游戏整体管理，还有一些细节的修补</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、回顾\"><a href=\"#始、回顾\" class=\"headerlink\" title=\"始、回顾\"></a>始、回顾</h3><p>（忙完开学的琐事）</p>\n<p>先回顾上一回完成的内容，我们制作了会让角色死亡的尖刺，还加上了死亡效果配套的特效和声音。场景中添加了游戏的主要任务——收集宝珠，同样也有配套的特效和声音</p>","more":"<hr>\n<h3 id=\"一、更炫酷的视觉效果\"><a href=\"#一、更炫酷的视觉效果\" class=\"headerlink\" title=\"一、更炫酷的视觉效果\"></a>一、更炫酷的视觉效果</h3><p>1.检查插件Post Processing是否已安装，Window → Package Manage</p>\n<p>2.为主摄像机添加组件Post Processing Layer</p>\n<p>3.新建空项目Global Post Processing，将Layer 改成 Post Processing（新建）</p>\n<p>4.将主摄像机中Post Processing Layer的Layer设置成Post Processing，这样主摄像机就会观察新项目的特效</p>\n<p>5.为Global Post Processing添加组件Post Processing Volume，勾选is Global</p>\n<p>6.为Global Post Processing新建一个Profile（new）用来承载即将要设置的特效，Add effect 可以添加各种视觉效果：</p>\n<p>Bloom：泛光效果</p>\n<p>Color Grading：镜头调色</p>\n<p>Chromatic Aberration：场景畸变效果</p>\n<p>Lens Distortion：镜头畸变效果9</p>\n<p>Vignette：边缘阴影效果</p>\n<p>7.调好特效了吗，调好了偏不用，就是玩儿。在Assets → VFX → Profiles 中找到Global Reference预制体，拖入Global Post Processing → Post Processing Volume → Profile（如果场景过亮可以在Lightning → Environment Lighting调整场景亮度）</p>\n<hr>\n<h3 id=\"二、摄像头震动效果\"><a href=\"#二、摄像头震动效果\" class=\"headerlink\" title=\"二、摄像头震动效果\"></a>二、摄像头震动效果</h3><p>1.在跟随人物的2D摄像机中的Extension添加新的组件Cinemachine Impulse Listener</p>\n<p>2.在宝珠Shrine → Orb预制体中添加新组件Cinemachine Collision Impulse Sourse（就像音效系统一样，有一个接收器接收声音并且播放，有一个物体设定条件发出声音）</p>\n<p>3.将Assets → VFX → Profiles中的Explosion Shake 拖入Cinemachine Collision Impulse Sourse → Raw Signal</p>\n<p>4.设置触发此特效的Layer ，将Cinemachine Collision Impulse Sourse → Layer Mask 设置成Player，我们希望当Layer为Player的物体触碰到Orb时就会触发摄像头震动效果</p>\n<p>5.还可以在Cinemachine Collision Impulse Sourse → Frequency Gain 设置成100，这个数值越高，震动的频率越高，更快完成</p>\n<hr>\n<h3 id=\"终、休整\"><a href=\"#终、休整\" class=\"headerlink\" title=\"终、休整\"></a>终、休整</h3><p>到此为止，我们已经实现了游戏大部分刚需内容，接下来把目光转移到游戏整体管理，还有一些细节的修补</p>"},{"title":"《Robbie Swifthand》Unity2d独立游戏学习（六）","date":"2021-08-14T06:27:04.000Z","_content":"\n\n\n### \t始、前言\n\n距离上次琢磨unity已经半个月了，希望没有生疏（打开unity已经有点懵逼了）\n\n<!--more-->\n\n`^(*￣(oo)￣)^`\n\n\n\n---\n\n\n\n### \t一、死亡机制\n\n1.找到Props文件夹中的尖刺Spikes，可以逐个添加并且对齐，但没必要\n\n2.打开Tile Palette，在左下角有个选择笔刷的选项，选择GameObject Brush并且在Cells中添加尖刺的预制体Spikes\n\n3.Active Tilemap选择Platforms，就可以在场景中快乐涂鸦啦，生成的尖刺会成为Platforms物体的子物体\n\n4.新建Traps的Layer，给尖刺更换Layer，利用预制体Apply All\n\n5.新建脚本PlayerHealth，挂到Robbie上，编写代码：\n\n```\npublic class PalyerHealth : MonoBehaviour\n{\n    int trapsLayer;\n    void Start()\n    {\n        trapsLayer = LayerMask.NameToLayer(\"Traps\");\n    }\n\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if(collision.gameObject.layer == trapsLayer)\n        {\n            gameObject.SetActive(false);\n        }\n    }\n}\n```\n\n这里当角色触碰到尖刺时就会被摧毁消失\n\n\n\n7.添加死亡烟雾效果：\n\n```\npublic class PalyerHealth : MonoBehaviour\n{\n    public GameObject deathVFXPrefab;\n    \n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if(collision.gameObject.layer == trapsLayer)\n        {\n            Instantiate(deathVFXPrefab, transform.position, transform.rotation);\n        }\n    }\n}\n```\n\n找到烟雾特效并添加进来，在角色死亡时顺便用Instantiate(）播放烟雾特效\n\n\n\n8.在Audio Manage脚本中添加代码：\n\n```\n    [Header(\"主角音效\")]\n    //动作声\n    public AudioClip deathClip;\n    //说话声\n    public AudioClip deathVoiceClip;\n\n    [Header(\"特效音效\")]\n    public AudioClip deathVFXClip;\n```\n\n找到对应声音素材并添加到变量中\n\n\n\n9.继续修改Audio Manage脚本：\n\n```\n    public static void PlayDeathAudio()\n    {\n        current.playerSource.clip = current.deathClip;\n        current.playerSource.Play();\n\n        current.voiceSource.clip = current.deathVoiceClip;\n        current.voiceSource.Play();\n\n        current.fxSource.clip = current.deathVFXClip;\n        current.fxSource.Play();\n    }\n```\n\n和之前的声音播放方法一样，添加音效并且播放音效\n\n\n\n10.在PlayerHealth中调用死亡声音：\n\n```\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if(collision.gameObject.layer == trapsLayer)\n        {\n            AudioManager.PlayDeathAudio();\n        }\n    }\n```\n\n\n\n11.死亡后重置场景：\n\n```\nusing UnityEngine.SceneManagement;\n\n\tprivate void OnTriggerEnter2D(Collider2D collision)\n    {\n        if(collision.gameObject.layer == trapsLayer)\n        {\n            SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);\n        }\n    }\n```\n\n并且在Unity中找到File → Build Setting 并且点击Add Open Scenes，这样就会在角色死亡时重置当前场景\n\n\n\n测试了几次发现虽然实现了重置场景时不会摧毁声音管理，但是这个声音管理又会无限重复生成，暂时不知道怎么解决，先把`DontDestroyOnLoad(gameObject);`注释掉，嘿嘿\n\n\n\n---\n\n\n\n### 二、收集物体\n\n1.在Props中找到宝珠预制体Shrine，同上的方法添加到Brush中并且随意画到场景中\n\n2.更改Shrine的Layer成为Ground，并且应用到预制体中\n\n3.新建脚本Orb挂到orb物体中：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Orb : MonoBehaviour\n{\n    int player;\n    void Start()\n    {\n        player = LayerMask.NameToLayer(\"Player\");\n    }\n\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if (collision.gameObject.layer == player)\n        {\n            gameObject.SetActive(false);\n        }\n    }\n}\n```\n\n就像角色触碰尖刺就消失一样，这里当角色接触宝珠就会让宝珠消失（记得检查一下角色的Layer是不是Player）\n\n\n\n4.添加爆炸特效：\n\n```\n\npublic class Orb : MonoBehaviour\n{\n    public GameObject exposionVFXPrefab;\n    void Start()\n    {\n        player = LayerMask.NameToLayer(\"Player\");\n    }\n\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if (collision.gameObject.layer == player)\n        {\n            Instantiate(exposionVFXPrefab, transform.position, transform.rotation);\n        }\n    }\n}\n\n```\n\n在VFX文件夹中找到Explosion添加到变量中\n\n\n\n5.添加音效，在AudioManage脚本中添加：\n\n```\n    [Header(\"主角音效\")]\n    //说话声\n    public AudioClip orbVoiceClip;\n\n    [Header(\"特效音效\")]\n    public AudioClip orbFXClip;\n    \n        public static void PlayOrbAudio()\n    {\n        current.voiceSource.clip = current.orbVoiceClip;\n        current.voiceSource.Play();\n\n        current.fxSource.clip = current.orbFXClip;\n        current.fxSource.Play();\n    }\n```\n\n将音效素材添加到变量中，并且记得在Orb脚本中调用：\n\n```\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if (collision.gameObject.layer == player)\n        {\n            AudioManager.PlayOrbAudio();\n        }\n    }\n```\n\n\n\n---\n\n\n\n### 终、总结\n\n本次主要添加了场景中主要的角色互动物体，分别是让游戏结束的**尖刺**和游戏目标需要收集的**宝珠**，总体来说两个物体的添加、与角色之间的互动制作都比较相似\n","source":"_posts/2021-08-14-《Robbie Swifthand》Unity2d独立游戏学习（六）.md","raw":"---\ntitle: 《Robbie Swifthand》Unity2d独立游戏学习（六）\ndate: 2021-08-14 14:27:04\ncategories:\tunity\ntags:\n  - c#\n  - unity\n  - tilemap\n  - audio\n---\n\n\n\n### \t始、前言\n\n距离上次琢磨unity已经半个月了，希望没有生疏（打开unity已经有点懵逼了）\n\n<!--more-->\n\n`^(*￣(oo)￣)^`\n\n\n\n---\n\n\n\n### \t一、死亡机制\n\n1.找到Props文件夹中的尖刺Spikes，可以逐个添加并且对齐，但没必要\n\n2.打开Tile Palette，在左下角有个选择笔刷的选项，选择GameObject Brush并且在Cells中添加尖刺的预制体Spikes\n\n3.Active Tilemap选择Platforms，就可以在场景中快乐涂鸦啦，生成的尖刺会成为Platforms物体的子物体\n\n4.新建Traps的Layer，给尖刺更换Layer，利用预制体Apply All\n\n5.新建脚本PlayerHealth，挂到Robbie上，编写代码：\n\n```\npublic class PalyerHealth : MonoBehaviour\n{\n    int trapsLayer;\n    void Start()\n    {\n        trapsLayer = LayerMask.NameToLayer(\"Traps\");\n    }\n\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if(collision.gameObject.layer == trapsLayer)\n        {\n            gameObject.SetActive(false);\n        }\n    }\n}\n```\n\n这里当角色触碰到尖刺时就会被摧毁消失\n\n\n\n7.添加死亡烟雾效果：\n\n```\npublic class PalyerHealth : MonoBehaviour\n{\n    public GameObject deathVFXPrefab;\n    \n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if(collision.gameObject.layer == trapsLayer)\n        {\n            Instantiate(deathVFXPrefab, transform.position, transform.rotation);\n        }\n    }\n}\n```\n\n找到烟雾特效并添加进来，在角色死亡时顺便用Instantiate(）播放烟雾特效\n\n\n\n8.在Audio Manage脚本中添加代码：\n\n```\n    [Header(\"主角音效\")]\n    //动作声\n    public AudioClip deathClip;\n    //说话声\n    public AudioClip deathVoiceClip;\n\n    [Header(\"特效音效\")]\n    public AudioClip deathVFXClip;\n```\n\n找到对应声音素材并添加到变量中\n\n\n\n9.继续修改Audio Manage脚本：\n\n```\n    public static void PlayDeathAudio()\n    {\n        current.playerSource.clip = current.deathClip;\n        current.playerSource.Play();\n\n        current.voiceSource.clip = current.deathVoiceClip;\n        current.voiceSource.Play();\n\n        current.fxSource.clip = current.deathVFXClip;\n        current.fxSource.Play();\n    }\n```\n\n和之前的声音播放方法一样，添加音效并且播放音效\n\n\n\n10.在PlayerHealth中调用死亡声音：\n\n```\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if(collision.gameObject.layer == trapsLayer)\n        {\n            AudioManager.PlayDeathAudio();\n        }\n    }\n```\n\n\n\n11.死亡后重置场景：\n\n```\nusing UnityEngine.SceneManagement;\n\n\tprivate void OnTriggerEnter2D(Collider2D collision)\n    {\n        if(collision.gameObject.layer == trapsLayer)\n        {\n            SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);\n        }\n    }\n```\n\n并且在Unity中找到File → Build Setting 并且点击Add Open Scenes，这样就会在角色死亡时重置当前场景\n\n\n\n测试了几次发现虽然实现了重置场景时不会摧毁声音管理，但是这个声音管理又会无限重复生成，暂时不知道怎么解决，先把`DontDestroyOnLoad(gameObject);`注释掉，嘿嘿\n\n\n\n---\n\n\n\n### 二、收集物体\n\n1.在Props中找到宝珠预制体Shrine，同上的方法添加到Brush中并且随意画到场景中\n\n2.更改Shrine的Layer成为Ground，并且应用到预制体中\n\n3.新建脚本Orb挂到orb物体中：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Orb : MonoBehaviour\n{\n    int player;\n    void Start()\n    {\n        player = LayerMask.NameToLayer(\"Player\");\n    }\n\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if (collision.gameObject.layer == player)\n        {\n            gameObject.SetActive(false);\n        }\n    }\n}\n```\n\n就像角色触碰尖刺就消失一样，这里当角色接触宝珠就会让宝珠消失（记得检查一下角色的Layer是不是Player）\n\n\n\n4.添加爆炸特效：\n\n```\n\npublic class Orb : MonoBehaviour\n{\n    public GameObject exposionVFXPrefab;\n    void Start()\n    {\n        player = LayerMask.NameToLayer(\"Player\");\n    }\n\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if (collision.gameObject.layer == player)\n        {\n            Instantiate(exposionVFXPrefab, transform.position, transform.rotation);\n        }\n    }\n}\n\n```\n\n在VFX文件夹中找到Explosion添加到变量中\n\n\n\n5.添加音效，在AudioManage脚本中添加：\n\n```\n    [Header(\"主角音效\")]\n    //说话声\n    public AudioClip orbVoiceClip;\n\n    [Header(\"特效音效\")]\n    public AudioClip orbFXClip;\n    \n        public static void PlayOrbAudio()\n    {\n        current.voiceSource.clip = current.orbVoiceClip;\n        current.voiceSource.Play();\n\n        current.fxSource.clip = current.orbFXClip;\n        current.fxSource.Play();\n    }\n```\n\n将音效素材添加到变量中，并且记得在Orb脚本中调用：\n\n```\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if (collision.gameObject.layer == player)\n        {\n            AudioManager.PlayOrbAudio();\n        }\n    }\n```\n\n\n\n---\n\n\n\n### 终、总结\n\n本次主要添加了场景中主要的角色互动物体，分别是让游戏结束的**尖刺**和游戏目标需要收集的**宝珠**，总体来说两个物体的添加、与角色之间的互动制作都比较相似\n","slug":"2021-08-14-《Robbie Swifthand》Unity2d独立游戏学习（六）","published":1,"updated":"2021-08-14T11:37:23.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hs001u1ou04w9r47qo","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>距离上次琢磨unity已经半个月了，希望没有生疏（打开unity已经有点懵逼了）</p>\n<span id=\"more\"></span>\n\n<p><code>^(*￣(oo)￣)^</code></p>\n<hr>\n<h3 id=\"一、死亡机制\"><a href=\"#一、死亡机制\" class=\"headerlink\" title=\"一、死亡机制\"></a>一、死亡机制</h3><p>1.找到Props文件夹中的尖刺Spikes，可以逐个添加并且对齐，但没必要</p>\n<p>2.打开Tile Palette，在左下角有个选择笔刷的选项，选择GameObject Brush并且在Cells中添加尖刺的预制体Spikes</p>\n<p>3.Active Tilemap选择Platforms，就可以在场景中快乐涂鸦啦，生成的尖刺会成为Platforms物体的子物体</p>\n<p>4.新建Traps的Layer，给尖刺更换Layer，利用预制体Apply All</p>\n<p>5.新建脚本PlayerHealth，挂到Robbie上，编写代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PalyerHealth : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int trapsLayer;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        trapsLayer = LayerMask.NameToLayer(&quot;Traps&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(collision.gameObject.layer == trapsLayer)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            gameObject.SetActive(false);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里当角色触碰到尖刺时就会被摧毁消失</p>\n<p>7.添加死亡烟雾效果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PalyerHealth : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public GameObject deathVFXPrefab;</span><br><span class=\"line\">    </span><br><span class=\"line\">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(collision.gameObject.layer == trapsLayer)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Instantiate(deathVFXPrefab, transform.position, transform.rotation);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>找到烟雾特效并添加进来，在角色死亡时顺便用Instantiate(）播放烟雾特效</p>\n<p>8.在Audio Manage脚本中添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;主角音效&quot;)]</span><br><span class=\"line\">//动作声</span><br><span class=\"line\">public AudioClip deathClip;</span><br><span class=\"line\">//说话声</span><br><span class=\"line\">public AudioClip deathVoiceClip;</span><br><span class=\"line\"></span><br><span class=\"line\">[Header(&quot;特效音效&quot;)]</span><br><span class=\"line\">public AudioClip deathVFXClip;</span><br></pre></td></tr></table></figure>\n\n<p>找到对应声音素材并添加到变量中</p>\n<p>9.继续修改Audio Manage脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void PlayDeathAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    current.playerSource.clip = current.deathClip;</span><br><span class=\"line\">    current.playerSource.Play();</span><br><span class=\"line\"></span><br><span class=\"line\">    current.voiceSource.clip = current.deathVoiceClip;</span><br><span class=\"line\">    current.voiceSource.Play();</span><br><span class=\"line\"></span><br><span class=\"line\">    current.fxSource.clip = current.deathVFXClip;</span><br><span class=\"line\">    current.fxSource.Play();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和之前的声音播放方法一样，添加音效并且播放音效</p>\n<p>10.在PlayerHealth中调用死亡声音：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(collision.gameObject.layer == trapsLayer)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AudioManager.PlayDeathAudio();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>11.死亡后重置场景：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using UnityEngine.SceneManagement;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(collision.gameObject.layer == trapsLayer)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且在Unity中找到File → Build Setting 并且点击Add Open Scenes，这样就会在角色死亡时重置当前场景</p>\n<p>测试了几次发现虽然实现了重置场景时不会摧毁声音管理，但是这个声音管理又会无限重复生成，暂时不知道怎么解决，先把<code>DontDestroyOnLoad(gameObject);</code>注释掉，嘿嘿</p>\n<hr>\n<h3 id=\"二、收集物体\"><a href=\"#二、收集物体\" class=\"headerlink\" title=\"二、收集物体\"></a>二、收集物体</h3><p>1.在Props中找到宝珠预制体Shrine，同上的方法添加到Brush中并且随意画到场景中</p>\n<p>2.更改Shrine的Layer成为Ground，并且应用到预制体中</p>\n<p>3.新建脚本Orb挂到orb物体中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Orb : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int player;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        player = LayerMask.NameToLayer(&quot;Player&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.gameObject.layer == player)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            gameObject.SetActive(false);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>就像角色触碰尖刺就消失一样，这里当角色接触宝珠就会让宝珠消失（记得检查一下角色的Layer是不是Player）</p>\n<p>4.添加爆炸特效：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class Orb : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public GameObject exposionVFXPrefab;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        player = LayerMask.NameToLayer(&quot;Player&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.gameObject.layer == player)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Instantiate(exposionVFXPrefab, transform.position, transform.rotation);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在VFX文件夹中找到Explosion添加到变量中</p>\n<p>5.添加音效，在AudioManage脚本中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;主角音效&quot;)]</span><br><span class=\"line\">//说话声</span><br><span class=\"line\">public AudioClip orbVoiceClip;</span><br><span class=\"line\"></span><br><span class=\"line\">[Header(&quot;特效音效&quot;)]</span><br><span class=\"line\">public AudioClip orbFXClip;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void PlayOrbAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    current.voiceSource.clip = current.orbVoiceClip;</span><br><span class=\"line\">    current.voiceSource.Play();</span><br><span class=\"line\"></span><br><span class=\"line\">    current.fxSource.clip = current.orbFXClip;</span><br><span class=\"line\">    current.fxSource.Play();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将音效素材添加到变量中，并且记得在Orb脚本中调用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (collision.gameObject.layer == player)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AudioManager.PlayOrbAudio();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>本次主要添加了场景中主要的角色互动物体，分别是让游戏结束的<strong>尖刺</strong>和游戏目标需要收集的<strong>宝珠</strong>，总体来说两个物体的添加、与角色之间的互动制作都比较相似</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>距离上次琢磨unity已经半个月了，希望没有生疏（打开unity已经有点懵逼了）</p>","more":"<p><code>^(*￣(oo)￣)^</code></p>\n<hr>\n<h3 id=\"一、死亡机制\"><a href=\"#一、死亡机制\" class=\"headerlink\" title=\"一、死亡机制\"></a>一、死亡机制</h3><p>1.找到Props文件夹中的尖刺Spikes，可以逐个添加并且对齐，但没必要</p>\n<p>2.打开Tile Palette，在左下角有个选择笔刷的选项，选择GameObject Brush并且在Cells中添加尖刺的预制体Spikes</p>\n<p>3.Active Tilemap选择Platforms，就可以在场景中快乐涂鸦啦，生成的尖刺会成为Platforms物体的子物体</p>\n<p>4.新建Traps的Layer，给尖刺更换Layer，利用预制体Apply All</p>\n<p>5.新建脚本PlayerHealth，挂到Robbie上，编写代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PalyerHealth : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int trapsLayer;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        trapsLayer = LayerMask.NameToLayer(&quot;Traps&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(collision.gameObject.layer == trapsLayer)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            gameObject.SetActive(false);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里当角色触碰到尖刺时就会被摧毁消失</p>\n<p>7.添加死亡烟雾效果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class PalyerHealth : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public GameObject deathVFXPrefab;</span><br><span class=\"line\">    </span><br><span class=\"line\">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(collision.gameObject.layer == trapsLayer)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Instantiate(deathVFXPrefab, transform.position, transform.rotation);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>找到烟雾特效并添加进来，在角色死亡时顺便用Instantiate(）播放烟雾特效</p>\n<p>8.在Audio Manage脚本中添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;主角音效&quot;)]</span><br><span class=\"line\">//动作声</span><br><span class=\"line\">public AudioClip deathClip;</span><br><span class=\"line\">//说话声</span><br><span class=\"line\">public AudioClip deathVoiceClip;</span><br><span class=\"line\"></span><br><span class=\"line\">[Header(&quot;特效音效&quot;)]</span><br><span class=\"line\">public AudioClip deathVFXClip;</span><br></pre></td></tr></table></figure>\n\n<p>找到对应声音素材并添加到变量中</p>\n<p>9.继续修改Audio Manage脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void PlayDeathAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    current.playerSource.clip = current.deathClip;</span><br><span class=\"line\">    current.playerSource.Play();</span><br><span class=\"line\"></span><br><span class=\"line\">    current.voiceSource.clip = current.deathVoiceClip;</span><br><span class=\"line\">    current.voiceSource.Play();</span><br><span class=\"line\"></span><br><span class=\"line\">    current.fxSource.clip = current.deathVFXClip;</span><br><span class=\"line\">    current.fxSource.Play();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和之前的声音播放方法一样，添加音效并且播放音效</p>\n<p>10.在PlayerHealth中调用死亡声音：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(collision.gameObject.layer == trapsLayer)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AudioManager.PlayDeathAudio();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>11.死亡后重置场景：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using UnityEngine.SceneManagement;</span><br><span class=\"line\"></span><br><span class=\"line\">\tprivate void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(collision.gameObject.layer == trapsLayer)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且在Unity中找到File → Build Setting 并且点击Add Open Scenes，这样就会在角色死亡时重置当前场景</p>\n<p>测试了几次发现虽然实现了重置场景时不会摧毁声音管理，但是这个声音管理又会无限重复生成，暂时不知道怎么解决，先把<code>DontDestroyOnLoad(gameObject);</code>注释掉，嘿嘿</p>\n<hr>\n<h3 id=\"二、收集物体\"><a href=\"#二、收集物体\" class=\"headerlink\" title=\"二、收集物体\"></a>二、收集物体</h3><p>1.在Props中找到宝珠预制体Shrine，同上的方法添加到Brush中并且随意画到场景中</p>\n<p>2.更改Shrine的Layer成为Ground，并且应用到预制体中</p>\n<p>3.新建脚本Orb挂到orb物体中：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Orb : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int player;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        player = LayerMask.NameToLayer(&quot;Player&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.gameObject.layer == player)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            gameObject.SetActive(false);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>就像角色触碰尖刺就消失一样，这里当角色接触宝珠就会让宝珠消失（记得检查一下角色的Layer是不是Player）</p>\n<p>4.添加爆炸特效：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">public class Orb : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public GameObject exposionVFXPrefab;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        player = LayerMask.NameToLayer(&quot;Player&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.gameObject.layer == player)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Instantiate(exposionVFXPrefab, transform.position, transform.rotation);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在VFX文件夹中找到Explosion添加到变量中</p>\n<p>5.添加音效，在AudioManage脚本中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;主角音效&quot;)]</span><br><span class=\"line\">//说话声</span><br><span class=\"line\">public AudioClip orbVoiceClip;</span><br><span class=\"line\"></span><br><span class=\"line\">[Header(&quot;特效音效&quot;)]</span><br><span class=\"line\">public AudioClip orbFXClip;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void PlayOrbAudio()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    current.voiceSource.clip = current.orbVoiceClip;</span><br><span class=\"line\">    current.voiceSource.Play();</span><br><span class=\"line\"></span><br><span class=\"line\">    current.fxSource.clip = current.orbFXClip;</span><br><span class=\"line\">    current.fxSource.Play();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将音效素材添加到变量中，并且记得在Orb脚本中调用：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (collision.gameObject.layer == player)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        AudioManager.PlayOrbAudio();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>本次主要添加了场景中主要的角色互动物体，分别是让游戏结束的<strong>尖刺</strong>和游戏目标需要收集的<strong>宝珠</strong>，总体来说两个物体的添加、与角色之间的互动制作都比较相似</p>"},{"title":"【LeetCode.552】学生出勤记录 II","date":"2021-08-18T12:31:41.000Z","_content":"\n\n\n### \t题目：学生出勤记录 II\n\n可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：\n'A'：Absent，缺勤\n'L'：Late，迟到\n'P'：Present，到场\n如果学生能够 **同时** 满足下面两个条件，则可以获得出勤奖励：\n\n按 **总出勤** 计，学生缺勤（'A'）**严格** 少于两天。\n学生 **不会** 存在 **连续** 3 天或 **连续** 3 天以上的迟到（'L'）记录。\n给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 **数量** 。答案可能很大，所以返回对 109 + 7 **取余** 的结果。\n\n <!--more-->\n\n\n\n示例 1：\n\n```\n输入：n = 2\n输出：8\n解释：\n有 8 种长度为 2 的记录将被视为可奖励：\n\"PP\" , \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\" \n只有\"AA\"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。\n```\n\n示例 2：\n\n```\n输入：n = 1\n输出：3\n```\n\n示例 3：\n\n```\n输入：n = 10101\n输出：183236316\n```\n\n\n\n提示：\n\n`1 <= n <= 105`\n\n\n\n---\n\n\n\n### 分析：\n\n动态规划做多了，一来就想到动态规划，都忘了还能模拟遍历（不过以我击败5%的结果用暴力法必定超时）\n\n考虑最简单的`dp`数组`dp[i]`表示有i天时可获得奖励的天数，`0 <= i <= n`。但是还需要记录有i天时的缺勤天数和结尾连续迟到天数，为什么是结尾连续迟到天数呢，因为一旦连续迟到天数达到3天，就将`dp`置0。所以要将`dp`数组升维再升维变成`dp[i][j][k]`\n\n`dp[i][j][k]`表示 “有i天、缺勤j天、结尾连续迟到k天” 的可获得奖励天数\n\n边界：`dp[0][0][0] = 1`即还没开始上课，这时可以获得出勤奖励\n\n状态转移分为三种情况：到场、迟到、缺勤\n\n到场：今天上课到场，于是迟到天数清零，缺勤保持不变，将前一天不同j和不同k的`dp`加起来\n\n迟到：今天上课迟到，前一天的迟到天数只能在0和1之间，因为一旦前一天的结尾迟到天数到达2，今天再迟到就没有奖励了，`dp`置零（置零不用特别计算，新建的未初始化数组就是0，不影响后续计算调用），于是迟到天数加一，缺勤保持不变，将前一天不同j和k - 1的`dp`加起来\n\n缺勤：今天上课缺勤，前一天的缺勤天数只能是0，理由同上，于是迟到天数清零，缺勤天数加一，将前一天j = 0和不同k的`dp`加起来\n\n\n\n---\n\n\n\n### 题解：\n\n```\nclass Solution {\npublic:\n    int checkRecord(int n) {\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(2, vector<int>(3)));\n        dp[0][0][0] = 1;\n        int mod = pow(10, 9) + 7;\n        int ans = 0;\n        for(int i = 1; i <= n; i++){\n            //P\n            for(int j = 0; j <= 1; j++){\n                for(int k = 0; k <= 2; k++){\n                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % mod;\n                }\n            }\n            //L\n            for(int j = 0; j <= 1; j++){\n                for(int k = 1; k <= 2; k++){\n                    dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % mod;\n                }\n            }\n            //A\n            for(int k = 0; k <= 2; k++){\n                dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % mod;\n            }\n        }\n\n        for(int j = 0; j <= 1; j++){\n            for(int k = 0; k <= 2; k++){\n                ans = (ans + dp[n][j][k]) % mod;\n            }\n        }\n        return ans;\n    }\n};\n\n```\n\n\n\n---\n\n\n\n### 结语：\n\n动态规划解题思路的一次更新，对于`dp`数组升维这件事一直都把握不住，这道题目的条件让人容易找到升维切入点，真是受益良多\n\n","source":"_posts/2021-08-18-【LeetCode.552】学生出勤记录 II.md","raw":"---\ntitle: 【LeetCode.552】学生出勤记录 II\ndate: 2021-08-18 20:31:41\ncategories:\t算法\ntags:\n  - c++\n  - 动态规划\n---\n\n\n\n### \t题目：学生出勤记录 II\n\n可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：\n'A'：Absent，缺勤\n'L'：Late，迟到\n'P'：Present，到场\n如果学生能够 **同时** 满足下面两个条件，则可以获得出勤奖励：\n\n按 **总出勤** 计，学生缺勤（'A'）**严格** 少于两天。\n学生 **不会** 存在 **连续** 3 天或 **连续** 3 天以上的迟到（'L'）记录。\n给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 **数量** 。答案可能很大，所以返回对 109 + 7 **取余** 的结果。\n\n <!--more-->\n\n\n\n示例 1：\n\n```\n输入：n = 2\n输出：8\n解释：\n有 8 种长度为 2 的记录将被视为可奖励：\n\"PP\" , \"AP\", \"PA\", \"LP\", \"PL\", \"AL\", \"LA\", \"LL\" \n只有\"AA\"不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。\n```\n\n示例 2：\n\n```\n输入：n = 1\n输出：3\n```\n\n示例 3：\n\n```\n输入：n = 10101\n输出：183236316\n```\n\n\n\n提示：\n\n`1 <= n <= 105`\n\n\n\n---\n\n\n\n### 分析：\n\n动态规划做多了，一来就想到动态规划，都忘了还能模拟遍历（不过以我击败5%的结果用暴力法必定超时）\n\n考虑最简单的`dp`数组`dp[i]`表示有i天时可获得奖励的天数，`0 <= i <= n`。但是还需要记录有i天时的缺勤天数和结尾连续迟到天数，为什么是结尾连续迟到天数呢，因为一旦连续迟到天数达到3天，就将`dp`置0。所以要将`dp`数组升维再升维变成`dp[i][j][k]`\n\n`dp[i][j][k]`表示 “有i天、缺勤j天、结尾连续迟到k天” 的可获得奖励天数\n\n边界：`dp[0][0][0] = 1`即还没开始上课，这时可以获得出勤奖励\n\n状态转移分为三种情况：到场、迟到、缺勤\n\n到场：今天上课到场，于是迟到天数清零，缺勤保持不变，将前一天不同j和不同k的`dp`加起来\n\n迟到：今天上课迟到，前一天的迟到天数只能在0和1之间，因为一旦前一天的结尾迟到天数到达2，今天再迟到就没有奖励了，`dp`置零（置零不用特别计算，新建的未初始化数组就是0，不影响后续计算调用），于是迟到天数加一，缺勤保持不变，将前一天不同j和k - 1的`dp`加起来\n\n缺勤：今天上课缺勤，前一天的缺勤天数只能是0，理由同上，于是迟到天数清零，缺勤天数加一，将前一天j = 0和不同k的`dp`加起来\n\n\n\n---\n\n\n\n### 题解：\n\n```\nclass Solution {\npublic:\n    int checkRecord(int n) {\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(2, vector<int>(3)));\n        dp[0][0][0] = 1;\n        int mod = pow(10, 9) + 7;\n        int ans = 0;\n        for(int i = 1; i <= n; i++){\n            //P\n            for(int j = 0; j <= 1; j++){\n                for(int k = 0; k <= 2; k++){\n                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % mod;\n                }\n            }\n            //L\n            for(int j = 0; j <= 1; j++){\n                for(int k = 1; k <= 2; k++){\n                    dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % mod;\n                }\n            }\n            //A\n            for(int k = 0; k <= 2; k++){\n                dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % mod;\n            }\n        }\n\n        for(int j = 0; j <= 1; j++){\n            for(int k = 0; k <= 2; k++){\n                ans = (ans + dp[n][j][k]) % mod;\n            }\n        }\n        return ans;\n    }\n};\n\n```\n\n\n\n---\n\n\n\n### 结语：\n\n动态规划解题思路的一次更新，对于`dp`数组升维这件事一直都把握不住，这道题目的条件让人容易找到升维切入点，真是受益良多\n\n","slug":"2021-08-18-【LeetCode.552】学生出勤记录 II","published":1,"updated":"2021-08-18T13:12:34.063Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71ht001y1ou0gtzfg822","content":"<h3 id=\"题目：学生出勤记录-II\"><a href=\"#题目：学生出勤记录-II\" class=\"headerlink\" title=\"题目：学生出勤记录 II\"></a>题目：学生出勤记录 II</h3><p>可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：<br>‘A’：Absent，缺勤<br>‘L’：Late，迟到<br>‘P’：Present，到场<br>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>\n<p>按 <strong>总出勤</strong> 计，学生缺勤（’A’）<strong>严格</strong> 少于两天。<br>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（’L’）记录。<br>给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 <strong>数量</strong> 。答案可能很大，所以返回对 109 + 7 <strong>取余</strong> 的结果。</p>\n <span id=\"more\"></span>\n\n\n\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 2</span><br><span class=\"line\">输出：8</span><br><span class=\"line\">解释：</span><br><span class=\"line\">有 8 种长度为 2 的记录将被视为可奖励：</span><br><span class=\"line\">&quot;PP&quot; , &quot;AP&quot;, &quot;PA&quot;, &quot;LP&quot;, &quot;PL&quot;, &quot;AL&quot;, &quot;LA&quot;, &quot;LL&quot; </span><br><span class=\"line\">只有&quot;AA&quot;不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 1</span><br><span class=\"line\">输出：3</span><br></pre></td></tr></table></figure>\n\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 10101</span><br><span class=\"line\">输出：183236316</span><br></pre></td></tr></table></figure>\n\n\n\n<p>提示：</p>\n<p><code>1 &lt;= n &lt;= 105</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>动态规划做多了，一来就想到动态规划，都忘了还能模拟遍历（不过以我击败5%的结果用暴力法必定超时）</p>\n<p>考虑最简单的<code>dp</code>数组<code>dp[i]</code>表示有i天时可获得奖励的天数，<code>0 &lt;= i &lt;= n</code>。但是还需要记录有i天时的缺勤天数和结尾连续迟到天数，为什么是结尾连续迟到天数呢，因为一旦连续迟到天数达到3天，就将<code>dp</code>置0。所以要将<code>dp</code>数组升维再升维变成<code>dp[i][j][k]</code></p>\n<p><code>dp[i][j][k]</code>表示 “有i天、缺勤j天、结尾连续迟到k天” 的可获得奖励天数</p>\n<p>边界：<code>dp[0][0][0] = 1</code>即还没开始上课，这时可以获得出勤奖励</p>\n<p>状态转移分为三种情况：到场、迟到、缺勤</p>\n<p>到场：今天上课到场，于是迟到天数清零，缺勤保持不变，将前一天不同j和不同k的<code>dp</code>加起来</p>\n<p>迟到：今天上课迟到，前一天的迟到天数只能在0和1之间，因为一旦前一天的结尾迟到天数到达2，今天再迟到就没有奖励了，<code>dp</code>置零（置零不用特别计算，新建的未初始化数组就是0，不影响后续计算调用），于是迟到天数加一，缺勤保持不变，将前一天不同j和k - 1的<code>dp</code>加起来</p>\n<p>缺勤：今天上课缺勤，前一天的缺勤天数只能是0，理由同上，于是迟到天数清零，缺勤天数加一，将前一天j = 0和不同k的<code>dp</code>加起来</p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int checkRecord(int n) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n + 1, vector&lt;vector&lt;int&gt;&gt;(2, vector&lt;int&gt;(3)));</span><br><span class=\"line\">        dp[0][0][0] = 1;</span><br><span class=\"line\">        int mod = pow(10, 9) + 7;</span><br><span class=\"line\">        int ans = 0;</span><br><span class=\"line\">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            //P</span><br><span class=\"line\">            for(int j = 0; j &lt;= 1; j++)&#123;</span><br><span class=\"line\">                for(int k = 0; k &lt;= 2; k++)&#123;</span><br><span class=\"line\">                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % mod;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //L</span><br><span class=\"line\">            for(int j = 0; j &lt;= 1; j++)&#123;</span><br><span class=\"line\">                for(int k = 1; k &lt;= 2; k++)&#123;</span><br><span class=\"line\">                    dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % mod;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //A</span><br><span class=\"line\">            for(int k = 0; k &lt;= 2; k++)&#123;</span><br><span class=\"line\">                dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % mod;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for(int j = 0; j &lt;= 1; j++)&#123;</span><br><span class=\"line\">            for(int k = 0; k &lt;= 2; k++)&#123;</span><br><span class=\"line\">                ans = (ans + dp[n][j][k]) % mod;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"结语：\"><a href=\"#结语：\" class=\"headerlink\" title=\"结语：\"></a>结语：</h3><p>动态规划解题思路的一次更新，对于<code>dp</code>数组升维这件事一直都把握不住，这道题目的条件让人容易找到升维切入点，真是受益良多</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"题目：学生出勤记录-II\"><a href=\"#题目：学生出勤记录-II\" class=\"headerlink\" title=\"题目：学生出勤记录 II\"></a>题目：学生出勤记录 II</h3><p>可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：<br>‘A’：Absent，缺勤<br>‘L’：Late，迟到<br>‘P’：Present，到场<br>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>\n<p>按 <strong>总出勤</strong> 计，学生缺勤（’A’）<strong>严格</strong> 少于两天。<br>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（’L’）记录。<br>给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 <strong>数量</strong> 。答案可能很大，所以返回对 109 + 7 <strong>取余</strong> 的结果。</p>","more":"<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 2</span><br><span class=\"line\">输出：8</span><br><span class=\"line\">解释：</span><br><span class=\"line\">有 8 种长度为 2 的记录将被视为可奖励：</span><br><span class=\"line\">&quot;PP&quot; , &quot;AP&quot;, &quot;PA&quot;, &quot;LP&quot;, &quot;PL&quot;, &quot;AL&quot;, &quot;LA&quot;, &quot;LL&quot; </span><br><span class=\"line\">只有&quot;AA&quot;不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 1</span><br><span class=\"line\">输出：3</span><br></pre></td></tr></table></figure>\n\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 10101</span><br><span class=\"line\">输出：183236316</span><br></pre></td></tr></table></figure>\n\n\n\n<p>提示：</p>\n<p><code>1 &lt;= n &lt;= 105</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>动态规划做多了，一来就想到动态规划，都忘了还能模拟遍历（不过以我击败5%的结果用暴力法必定超时）</p>\n<p>考虑最简单的<code>dp</code>数组<code>dp[i]</code>表示有i天时可获得奖励的天数，<code>0 &lt;= i &lt;= n</code>。但是还需要记录有i天时的缺勤天数和结尾连续迟到天数，为什么是结尾连续迟到天数呢，因为一旦连续迟到天数达到3天，就将<code>dp</code>置0。所以要将<code>dp</code>数组升维再升维变成<code>dp[i][j][k]</code></p>\n<p><code>dp[i][j][k]</code>表示 “有i天、缺勤j天、结尾连续迟到k天” 的可获得奖励天数</p>\n<p>边界：<code>dp[0][0][0] = 1</code>即还没开始上课，这时可以获得出勤奖励</p>\n<p>状态转移分为三种情况：到场、迟到、缺勤</p>\n<p>到场：今天上课到场，于是迟到天数清零，缺勤保持不变，将前一天不同j和不同k的<code>dp</code>加起来</p>\n<p>迟到：今天上课迟到，前一天的迟到天数只能在0和1之间，因为一旦前一天的结尾迟到天数到达2，今天再迟到就没有奖励了，<code>dp</code>置零（置零不用特别计算，新建的未初始化数组就是0，不影响后续计算调用），于是迟到天数加一，缺勤保持不变，将前一天不同j和k - 1的<code>dp</code>加起来</p>\n<p>缺勤：今天上课缺勤，前一天的缺勤天数只能是0，理由同上，于是迟到天数清零，缺勤天数加一，将前一天j = 0和不同k的<code>dp</code>加起来</p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int checkRecord(int n) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n + 1, vector&lt;vector&lt;int&gt;&gt;(2, vector&lt;int&gt;(3)));</span><br><span class=\"line\">        dp[0][0][0] = 1;</span><br><span class=\"line\">        int mod = pow(10, 9) + 7;</span><br><span class=\"line\">        int ans = 0;</span><br><span class=\"line\">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            //P</span><br><span class=\"line\">            for(int j = 0; j &lt;= 1; j++)&#123;</span><br><span class=\"line\">                for(int k = 0; k &lt;= 2; k++)&#123;</span><br><span class=\"line\">                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % mod;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //L</span><br><span class=\"line\">            for(int j = 0; j &lt;= 1; j++)&#123;</span><br><span class=\"line\">                for(int k = 1; k &lt;= 2; k++)&#123;</span><br><span class=\"line\">                    dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % mod;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            //A</span><br><span class=\"line\">            for(int k = 0; k &lt;= 2; k++)&#123;</span><br><span class=\"line\">                dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % mod;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for(int j = 0; j &lt;= 1; j++)&#123;</span><br><span class=\"line\">            for(int k = 0; k &lt;= 2; k++)&#123;</span><br><span class=\"line\">                ans = (ans + dp[n][j][k]) % mod;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"结语：\"><a href=\"#结语：\" class=\"headerlink\" title=\"结语：\"></a>结语：</h3><p>动态规划解题思路的一次更新，对于<code>dp</code>数组升维这件事一直都把握不住，这道题目的条件让人容易找到升维切入点，真是受益良多</p>"},{"title":"《多视角深度相机的猪体三维点云重构及体尺测量》阅读笔记","date":"2021-09-12T11:40:41.000Z","_content":"\n\n\n### \t一、信息\n\n尹 令，蔡更元，田绪红，孙爱东，石 帅，钟浩杰，梁世豪.多视角深度相机的猪体三维点云重构及体尺测量[J]. 农业工程学报，2019，35(23)：201－208. \n\nYin Ling, Cai Gengyuan, Tian Xuhong, Sun Aidong, Shi Shuai, Zhong Haojie, Liang Shihao. Three dimensional point cloud  reconstruction and body size measurement of pigs based on multi-view depth camera[J]. Transactions of the Chinese Society of  Agricultural Engineering (Transactions of the CSAE), 2019, 35(23): 201－208. (in Chinese with English abstract) \n\ndoi： 10.11975/j.issn.1002-6819.2019.23.025 \n\nhttp://www.tcsae.org \n\n\n\n<!--more-->\n\n---\n\n\n\n### 二、对比\n\n1.测量方法：\n\n人工皮尺测量：容易造成牲畜驱赶应激、人工测量准确性差、测定效率低、复杂性状难以度量等问题\n\n**人工智能无应激识别系统和体况自动评价系统**：有效解决传统测量方法的效率、精度和动物福利问题\n\n\n\n2.参数采集：\n\n热成像技术：能较清晰捕获动物表面轮廓信息，但热成像设备昂贵，且需从视频流中手动分离相应数据帧，无法实现完全自动化\n\n图像处理技术：参数大多以像素为单位，当相机参数或物距发生改变时，模型可能不再适用，因此通用性差。另外获取图像时天气、拍摄角度、光照条件影响比较大\n\n单视角：采集简单不需要融合配准，但只能获取体长、体宽、体高等体尺数据，腹围等体尺无法估测。\n\n**多视角**：获取牲畜各部分深度图像进行各部分点云配准融合、非刚体三维模型点云匹配、体表轮廓描述、家畜体测量交互式软件设计等关键技术都有研究报道。\n\n\n\n---\n\n\n\n### 三、难点\n\n当扫描较大面积物体时数据精度丢失严重，同时扫描活体动物时如时间较长容易出现非刚性形变。牲畜全局三维点云重构时，处理数据量大对存储和计算能力要求很高，实时处理是难点。\n\n\n\n**解决方案**：\n\n在测量通道上固定 3 个 KinectV2 相机，通道只能有一头猪单独通过，猪进入相机最佳拍摄位置时，3个深度相机瞬间同步抓取局部点云。采用基于轮廓连贯性点云配准融合全局点云，提取猪体长、体高、体宽、腹围等体尺特征实现对猪的非接触式体尺自动测量。该方法对通道预先设定最佳拍摄位置减少扫描范围，提高数据精度；多视角深度相机同步瞬间抓取减少活体动物运动时非刚性形变；提出各种体尺测量方法，尤其测量腹围时极坐标转换法一方面可以弥补由栏杆遮挡和相机视角未覆盖缺失的点云，另一方面对局部点云相交处轮廓精细配准；并且 KinectV2 为消费级深度设备成本低廉，易于实现产业化。\n\n\n\n---\n\n\n\n### 四、方法\n\n1.同时获取瞬间局部点云\n\n2.采用基于距离查询区域增长方法滤除掉远离群点\n\n3.对近离群点的消除采用 SVLOF 算法\n\n4.粗配准：多个深度摄像设备标定中得到相邻子区域的空间变换矩阵和平移向量变换到同一坐标系下\n\n5.精细配准：配准融合问题就变成一个多目标优化问题，使得顶点融合度和邻层轮廓覆盖率都最小化\n\n6.最小二乘法拟合中轴平面，确定起始和终止点，微分求体长\n\n\n\n\n\n---\n\n\n\n### 五、总结\n\n1.采用 3 个方 向深度相机完成猪体三维重构，与猪体长、体高、胸宽、腹围自动测算试验，其测量数据与实测数据相对误差分析表明本文提出的猪体三维重构和多体尺检测算法稳定、效果较好。\n\n2.一方面是猪动态行走时姿态不固定，有扭转、拱背、低头等多种形态动作，影响测量准确性，另外人工在猪动态环境下测量准确率也降低。\n\n3.腹围等 3 围度的测量需要依赖三维点云拼接融合效果，今后需要进一步研究三维点云拼接融合和空缺部分的填补算法。 \n\n\n\n---\n\n\n\n### 六、参考文献\n\n1.Halachmi I, Klopčič M, Polak P, et al. Automatic assessment  of dairy cattle body condition score using thermal imaging[J].  Computers & Electronics in Agriculture, 2013, 99(6): 35－ 40. \n\n2.Azzaro G, Caccamo M, Ferguson J D, et al. Objective  estimation of body condition score by modeling cow body  shape from digital images[J]. Journal of Dairy Science, 2011,  94(4): 2126－2137.\n\n3.Tedin R , Becerra J A , Duro R J , et al. Computational  intelligence based construction of a body condition  assessment system for cattle[C]// Computational Intelligence  and Virtual Environments for Measurement Systems and  Applications (CIVEMSA), 2013 IEEE International  Conference on. IEEE, 2013.\n\n4.Bercovich A, Edan Y, Alchanatis V, et al. Development of an  automatic cow body condition scoring using body shape  signature and Fourier descriptors.[J]. Journal of Dairy  Science, 2013, 96(12): 8047－8059. \n\n5.Kashiha M A, Bahr C, Ott S, et al. Automatic monitoring of  pig locomotion using image analysis[J]. Livestock Science,  2014, 159(1): 141－148.\n\n6.Vieira A, Brand, O S, Monteiro A, et al. Development and  validation of a visual body condition scoring system for dairy  goats with picture-based training[J]. Journal of Dairy Science,  2015, 98(9): 6597－608.\n\n7.陈菁菁，彭彦昆. 基于机器视觉技术的生猪活体监测系统[J].  食品安全质量检测学报，2012，3(6)：600－602. \n\n8.刘建飞. 图像识别技术在奶牛体况评分中的应用研究[D].  济南：山东大学，2012. \n\n9.吴复争，姜威，张美杰. 核-主成分分析在奶牛体况自动评 分中的应用[J]. 光学技术，2013，39(3)：222－227. \n\n10.刘同海，滕光辉，付为森，等. 基于机器视觉的猪体体尺 测点提取算法与应用[J]. 农业工程学报，2013，29(2)： 161－168. \n\n11.Menesatti P, Costa C, Antonucci F, et al. A low-cost  stereovision system to estimate size and weight of live  sheep[J]. Computers & Electronics in Agriculture, 2014,  103(2): 33－38.\n\n12.Salau J, Haas J H, Junge W, et al. Feasibility of automated  body trait determination using the SR4K time-of-flight  camera in cow barns[J]. Springer Plus, 2014, 3(1): 225. \n\n13.Weber A, Salau J, Haas J H, et al. Estimation of backfat  thickness using extracted traits from an automatic 3D optical  system in lactating Holstein-Friesian cows[J]. Livestock  Science, 2014, 165(1): 129－137.\n\n14.Kuzuhara Y, Kawamura K, Yoshitoshi R, et al. A  preliminarily study for predicting body weight and milk  properties in lactating Holstein cows using a three\u0002dimensional camera system[J]. Computers & Electronics in  Agriculture, 2015, 111: 186－193.\n\n15.Fischer A, Luginbühl T, Delattre L, et al. Rear shape in 3  dimensions summarized by principal component analysis is a  good predictor of body condition score in Holstein dairy  cows[J]. Journal of Dairy Science, 2015, 98(7): 4465－4476. \n\n16.Pezzuolo A, Guarino M, Sartori L, et al. On-barn pig weight  estimation based on body measurements by a Kinect v1 depth  camera[J]. Computers & Electronics in Agriculture, 2018,  148: 29－36. \n\n17.付为森，滕光辉. 基于双目视觉技术的猪生长监测系统标 定模式[J]. 农业机械学报，2009，40(S1)：223－227. \n\n18.李卓，毛涛涛，刘同海，等. 基于机器视觉的猪体质量估 测模型比较与优化[J]. 农业工程学报，2015，31(2)：155－ 161. \n\n19.Salau J, Haas J H, Junge W, et al. Extrinsic calibration of a  multi-Kinect camera scanning passage for measuring  functional traits in dairy cows[J]. Biosystems Engineering,  2016, 151: 409－424. \n\n20.王龙. 机器视觉在奶牛体况评定中的应用[D]. 上海：东华 大学，2014. \n\n21.张温. 基于机器视觉的牲畜体征测量系统的研究[D]. 包 头：内蒙古科技大学，2014. \n\n22.郭浩. 动物体表三维数据获取与处理算法研究[D]. 北京： 中国农业大学，2015. \n\n23.李卓，毛涛涛，刘同海，等. 基于机器视觉的猪体质量估 测模型比较与优化[J]. 农业工程学报，2015，31(2)：155－ 161. \n\n24.司永胜，安露露，刘刚，等. 基于 Kinect 相机的猪体理想 姿态检测与体尺测量[J]. 农业机械学报，2019，50(1)：58－ 65. \n\n25.王可，郭浩，刘威林，等. 基于点云旋转归一化的猪体体 尺测点提取方法[J]. 农业工程学报，2017，33(增刊 1)： 253－259.\n\n26.Guo H, Ma X, Ma Q, et al. LSSA_CAU:An interactive 3d  point clouds analysis software for body measurement of  livestock with similar forms of cows or pigs[J]. Computers &  Electronics in Agriculture, 2017, 138: 60－68.\n\n27.聂建辉，胡英，马孜. 散乱点云离群点的分类识别算法[J].  计算机辅助设计与图形学学报，2011，23(9)：1526－1532.\n","source":"_posts/2021-09-12-《多视角深度相机的猪体三维点云重构及体尺测量》阅读笔记.md","raw":"---\ntitle: 《多视角深度相机的猪体三维点云重构及体尺测量》阅读笔记\ndate: 2021-09-12 19:40:41\ncategories:\t阅读笔记\ntags:\n  - 三维重构\n  - 图像处理\n  - 三维点云\n  - 体尺测量\n---\n\n\n\n### \t一、信息\n\n尹 令，蔡更元，田绪红，孙爱东，石 帅，钟浩杰，梁世豪.多视角深度相机的猪体三维点云重构及体尺测量[J]. 农业工程学报，2019，35(23)：201－208. \n\nYin Ling, Cai Gengyuan, Tian Xuhong, Sun Aidong, Shi Shuai, Zhong Haojie, Liang Shihao. Three dimensional point cloud  reconstruction and body size measurement of pigs based on multi-view depth camera[J]. Transactions of the Chinese Society of  Agricultural Engineering (Transactions of the CSAE), 2019, 35(23): 201－208. (in Chinese with English abstract) \n\ndoi： 10.11975/j.issn.1002-6819.2019.23.025 \n\nhttp://www.tcsae.org \n\n\n\n<!--more-->\n\n---\n\n\n\n### 二、对比\n\n1.测量方法：\n\n人工皮尺测量：容易造成牲畜驱赶应激、人工测量准确性差、测定效率低、复杂性状难以度量等问题\n\n**人工智能无应激识别系统和体况自动评价系统**：有效解决传统测量方法的效率、精度和动物福利问题\n\n\n\n2.参数采集：\n\n热成像技术：能较清晰捕获动物表面轮廓信息，但热成像设备昂贵，且需从视频流中手动分离相应数据帧，无法实现完全自动化\n\n图像处理技术：参数大多以像素为单位，当相机参数或物距发生改变时，模型可能不再适用，因此通用性差。另外获取图像时天气、拍摄角度、光照条件影响比较大\n\n单视角：采集简单不需要融合配准，但只能获取体长、体宽、体高等体尺数据，腹围等体尺无法估测。\n\n**多视角**：获取牲畜各部分深度图像进行各部分点云配准融合、非刚体三维模型点云匹配、体表轮廓描述、家畜体测量交互式软件设计等关键技术都有研究报道。\n\n\n\n---\n\n\n\n### 三、难点\n\n当扫描较大面积物体时数据精度丢失严重，同时扫描活体动物时如时间较长容易出现非刚性形变。牲畜全局三维点云重构时，处理数据量大对存储和计算能力要求很高，实时处理是难点。\n\n\n\n**解决方案**：\n\n在测量通道上固定 3 个 KinectV2 相机，通道只能有一头猪单独通过，猪进入相机最佳拍摄位置时，3个深度相机瞬间同步抓取局部点云。采用基于轮廓连贯性点云配准融合全局点云，提取猪体长、体高、体宽、腹围等体尺特征实现对猪的非接触式体尺自动测量。该方法对通道预先设定最佳拍摄位置减少扫描范围，提高数据精度；多视角深度相机同步瞬间抓取减少活体动物运动时非刚性形变；提出各种体尺测量方法，尤其测量腹围时极坐标转换法一方面可以弥补由栏杆遮挡和相机视角未覆盖缺失的点云，另一方面对局部点云相交处轮廓精细配准；并且 KinectV2 为消费级深度设备成本低廉，易于实现产业化。\n\n\n\n---\n\n\n\n### 四、方法\n\n1.同时获取瞬间局部点云\n\n2.采用基于距离查询区域增长方法滤除掉远离群点\n\n3.对近离群点的消除采用 SVLOF 算法\n\n4.粗配准：多个深度摄像设备标定中得到相邻子区域的空间变换矩阵和平移向量变换到同一坐标系下\n\n5.精细配准：配准融合问题就变成一个多目标优化问题，使得顶点融合度和邻层轮廓覆盖率都最小化\n\n6.最小二乘法拟合中轴平面，确定起始和终止点，微分求体长\n\n\n\n\n\n---\n\n\n\n### 五、总结\n\n1.采用 3 个方 向深度相机完成猪体三维重构，与猪体长、体高、胸宽、腹围自动测算试验，其测量数据与实测数据相对误差分析表明本文提出的猪体三维重构和多体尺检测算法稳定、效果较好。\n\n2.一方面是猪动态行走时姿态不固定，有扭转、拱背、低头等多种形态动作，影响测量准确性，另外人工在猪动态环境下测量准确率也降低。\n\n3.腹围等 3 围度的测量需要依赖三维点云拼接融合效果，今后需要进一步研究三维点云拼接融合和空缺部分的填补算法。 \n\n\n\n---\n\n\n\n### 六、参考文献\n\n1.Halachmi I, Klopčič M, Polak P, et al. Automatic assessment  of dairy cattle body condition score using thermal imaging[J].  Computers & Electronics in Agriculture, 2013, 99(6): 35－ 40. \n\n2.Azzaro G, Caccamo M, Ferguson J D, et al. Objective  estimation of body condition score by modeling cow body  shape from digital images[J]. Journal of Dairy Science, 2011,  94(4): 2126－2137.\n\n3.Tedin R , Becerra J A , Duro R J , et al. Computational  intelligence based construction of a body condition  assessment system for cattle[C]// Computational Intelligence  and Virtual Environments for Measurement Systems and  Applications (CIVEMSA), 2013 IEEE International  Conference on. IEEE, 2013.\n\n4.Bercovich A, Edan Y, Alchanatis V, et al. Development of an  automatic cow body condition scoring using body shape  signature and Fourier descriptors.[J]. Journal of Dairy  Science, 2013, 96(12): 8047－8059. \n\n5.Kashiha M A, Bahr C, Ott S, et al. Automatic monitoring of  pig locomotion using image analysis[J]. Livestock Science,  2014, 159(1): 141－148.\n\n6.Vieira A, Brand, O S, Monteiro A, et al. Development and  validation of a visual body condition scoring system for dairy  goats with picture-based training[J]. Journal of Dairy Science,  2015, 98(9): 6597－608.\n\n7.陈菁菁，彭彦昆. 基于机器视觉技术的生猪活体监测系统[J].  食品安全质量检测学报，2012，3(6)：600－602. \n\n8.刘建飞. 图像识别技术在奶牛体况评分中的应用研究[D].  济南：山东大学，2012. \n\n9.吴复争，姜威，张美杰. 核-主成分分析在奶牛体况自动评 分中的应用[J]. 光学技术，2013，39(3)：222－227. \n\n10.刘同海，滕光辉，付为森，等. 基于机器视觉的猪体体尺 测点提取算法与应用[J]. 农业工程学报，2013，29(2)： 161－168. \n\n11.Menesatti P, Costa C, Antonucci F, et al. A low-cost  stereovision system to estimate size and weight of live  sheep[J]. Computers & Electronics in Agriculture, 2014,  103(2): 33－38.\n\n12.Salau J, Haas J H, Junge W, et al. Feasibility of automated  body trait determination using the SR4K time-of-flight  camera in cow barns[J]. Springer Plus, 2014, 3(1): 225. \n\n13.Weber A, Salau J, Haas J H, et al. Estimation of backfat  thickness using extracted traits from an automatic 3D optical  system in lactating Holstein-Friesian cows[J]. Livestock  Science, 2014, 165(1): 129－137.\n\n14.Kuzuhara Y, Kawamura K, Yoshitoshi R, et al. A  preliminarily study for predicting body weight and milk  properties in lactating Holstein cows using a three\u0002dimensional camera system[J]. Computers & Electronics in  Agriculture, 2015, 111: 186－193.\n\n15.Fischer A, Luginbühl T, Delattre L, et al. Rear shape in 3  dimensions summarized by principal component analysis is a  good predictor of body condition score in Holstein dairy  cows[J]. Journal of Dairy Science, 2015, 98(7): 4465－4476. \n\n16.Pezzuolo A, Guarino M, Sartori L, et al. On-barn pig weight  estimation based on body measurements by a Kinect v1 depth  camera[J]. Computers & Electronics in Agriculture, 2018,  148: 29－36. \n\n17.付为森，滕光辉. 基于双目视觉技术的猪生长监测系统标 定模式[J]. 农业机械学报，2009，40(S1)：223－227. \n\n18.李卓，毛涛涛，刘同海，等. 基于机器视觉的猪体质量估 测模型比较与优化[J]. 农业工程学报，2015，31(2)：155－ 161. \n\n19.Salau J, Haas J H, Junge W, et al. Extrinsic calibration of a  multi-Kinect camera scanning passage for measuring  functional traits in dairy cows[J]. Biosystems Engineering,  2016, 151: 409－424. \n\n20.王龙. 机器视觉在奶牛体况评定中的应用[D]. 上海：东华 大学，2014. \n\n21.张温. 基于机器视觉的牲畜体征测量系统的研究[D]. 包 头：内蒙古科技大学，2014. \n\n22.郭浩. 动物体表三维数据获取与处理算法研究[D]. 北京： 中国农业大学，2015. \n\n23.李卓，毛涛涛，刘同海，等. 基于机器视觉的猪体质量估 测模型比较与优化[J]. 农业工程学报，2015，31(2)：155－ 161. \n\n24.司永胜，安露露，刘刚，等. 基于 Kinect 相机的猪体理想 姿态检测与体尺测量[J]. 农业机械学报，2019，50(1)：58－ 65. \n\n25.王可，郭浩，刘威林，等. 基于点云旋转归一化的猪体体 尺测点提取方法[J]. 农业工程学报，2017，33(增刊 1)： 253－259.\n\n26.Guo H, Ma X, Ma Q, et al. LSSA_CAU:An interactive 3d  point clouds analysis software for body measurement of  livestock with similar forms of cows or pigs[J]. Computers &  Electronics in Agriculture, 2017, 138: 60－68.\n\n27.聂建辉，胡英，马孜. 散乱点云离群点的分类识别算法[J].  计算机辅助设计与图形学学报，2011，23(9)：1526－1532.\n","slug":"2021-09-12-《多视角深度相机的猪体三维点云重构及体尺测量》阅读笔记","published":1,"updated":"2021-10-27T11:01:30.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hu00211ou0d5zyfhtb","content":"<h3 id=\"一、信息\"><a href=\"#一、信息\" class=\"headerlink\" title=\"一、信息\"></a>一、信息</h3><p>尹 令，蔡更元，田绪红，孙爱东，石 帅，钟浩杰，梁世豪.多视角深度相机的猪体三维点云重构及体尺测量[J]. 农业工程学报，2019，35(23)：201－208. </p>\n<p>Yin Ling, Cai Gengyuan, Tian Xuhong, Sun Aidong, Shi Shuai, Zhong Haojie, Liang Shihao. Three dimensional point cloud  reconstruction and body size measurement of pigs based on multi-view depth camera[J]. Transactions of the Chinese Society of  Agricultural Engineering (Transactions of the CSAE), 2019, 35(23): 201－208. (in Chinese with English abstract) </p>\n<p>doi： 10.11975/j.issn.1002-6819.2019.23.025 </p>\n<p><a href=\"http://www.tcsae.org/\">http://www.tcsae.org</a> </p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"二、对比\"><a href=\"#二、对比\" class=\"headerlink\" title=\"二、对比\"></a>二、对比</h3><p>1.测量方法：</p>\n<p>人工皮尺测量：容易造成牲畜驱赶应激、人工测量准确性差、测定效率低、复杂性状难以度量等问题</p>\n<p><strong>人工智能无应激识别系统和体况自动评价系统</strong>：有效解决传统测量方法的效率、精度和动物福利问题</p>\n<p>2.参数采集：</p>\n<p>热成像技术：能较清晰捕获动物表面轮廓信息，但热成像设备昂贵，且需从视频流中手动分离相应数据帧，无法实现完全自动化</p>\n<p>图像处理技术：参数大多以像素为单位，当相机参数或物距发生改变时，模型可能不再适用，因此通用性差。另外获取图像时天气、拍摄角度、光照条件影响比较大</p>\n<p>单视角：采集简单不需要融合配准，但只能获取体长、体宽、体高等体尺数据，腹围等体尺无法估测。</p>\n<p><strong>多视角</strong>：获取牲畜各部分深度图像进行各部分点云配准融合、非刚体三维模型点云匹配、体表轮廓描述、家畜体测量交互式软件设计等关键技术都有研究报道。</p>\n<hr>\n<h3 id=\"三、难点\"><a href=\"#三、难点\" class=\"headerlink\" title=\"三、难点\"></a>三、难点</h3><p>当扫描较大面积物体时数据精度丢失严重，同时扫描活体动物时如时间较长容易出现非刚性形变。牲畜全局三维点云重构时，处理数据量大对存储和计算能力要求很高，实时处理是难点。</p>\n<p><strong>解决方案</strong>：</p>\n<p>在测量通道上固定 3 个 KinectV2 相机，通道只能有一头猪单独通过，猪进入相机最佳拍摄位置时，3个深度相机瞬间同步抓取局部点云。采用基于轮廓连贯性点云配准融合全局点云，提取猪体长、体高、体宽、腹围等体尺特征实现对猪的非接触式体尺自动测量。该方法对通道预先设定最佳拍摄位置减少扫描范围，提高数据精度；多视角深度相机同步瞬间抓取减少活体动物运动时非刚性形变；提出各种体尺测量方法，尤其测量腹围时极坐标转换法一方面可以弥补由栏杆遮挡和相机视角未覆盖缺失的点云，另一方面对局部点云相交处轮廓精细配准；并且 KinectV2 为消费级深度设备成本低廉，易于实现产业化。</p>\n<hr>\n<h3 id=\"四、方法\"><a href=\"#四、方法\" class=\"headerlink\" title=\"四、方法\"></a>四、方法</h3><p>1.同时获取瞬间局部点云</p>\n<p>2.采用基于距离查询区域增长方法滤除掉远离群点</p>\n<p>3.对近离群点的消除采用 SVLOF 算法</p>\n<p>4.粗配准：多个深度摄像设备标定中得到相邻子区域的空间变换矩阵和平移向量变换到同一坐标系下</p>\n<p>5.精细配准：配准融合问题就变成一个多目标优化问题，使得顶点融合度和邻层轮廓覆盖率都最小化</p>\n<p>6.最小二乘法拟合中轴平面，确定起始和终止点，微分求体长</p>\n<hr>\n<h3 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h3><p>1.采用 3 个方 向深度相机完成猪体三维重构，与猪体长、体高、胸宽、腹围自动测算试验，其测量数据与实测数据相对误差分析表明本文提出的猪体三维重构和多体尺检测算法稳定、效果较好。</p>\n<p>2.一方面是猪动态行走时姿态不固定，有扭转、拱背、低头等多种形态动作，影响测量准确性，另外人工在猪动态环境下测量准确率也降低。</p>\n<p>3.腹围等 3 围度的测量需要依赖三维点云拼接融合效果，今后需要进一步研究三维点云拼接融合和空缺部分的填补算法。 </p>\n<hr>\n<h3 id=\"六、参考文献\"><a href=\"#六、参考文献\" class=\"headerlink\" title=\"六、参考文献\"></a>六、参考文献</h3><p>1.Halachmi I, Klopčič M, Polak P, et al. Automatic assessment  of dairy cattle body condition score using thermal imaging[J].  Computers &amp; Electronics in Agriculture, 2013, 99(6): 35－ 40. </p>\n<p>2.Azzaro G, Caccamo M, Ferguson J D, et al. Objective  estimation of body condition score by modeling cow body  shape from digital images[J]. Journal of Dairy Science, 2011,  94(4): 2126－2137.</p>\n<p>3.Tedin R , Becerra J A , Duro R J , et al. Computational  intelligence based construction of a body condition  assessment system for cattle[C]// Computational Intelligence  and Virtual Environments for Measurement Systems and  Applications (CIVEMSA), 2013 IEEE International  Conference on. IEEE, 2013.</p>\n<p>4.Bercovich A, Edan Y, Alchanatis V, et al. Development of an  automatic cow body condition scoring using body shape  signature and Fourier descriptors.[J]. Journal of Dairy  Science, 2013, 96(12): 8047－8059. </p>\n<p>5.Kashiha M A, Bahr C, Ott S, et al. Automatic monitoring of  pig locomotion using image analysis[J]. Livestock Science,  2014, 159(1): 141－148.</p>\n<p>6.Vieira A, Brand, O S, Monteiro A, et al. Development and  validation of a visual body condition scoring system for dairy  goats with picture-based training[J]. Journal of Dairy Science,  2015, 98(9): 6597－608.</p>\n<p>7.陈菁菁，彭彦昆. 基于机器视觉技术的生猪活体监测系统[J].  食品安全质量检测学报，2012，3(6)：600－602. </p>\n<p>8.刘建飞. 图像识别技术在奶牛体况评分中的应用研究[D].  济南：山东大学，2012. </p>\n<p>9.吴复争，姜威，张美杰. 核-主成分分析在奶牛体况自动评 分中的应用[J]. 光学技术，2013，39(3)：222－227. </p>\n<p>10.刘同海，滕光辉，付为森，等. 基于机器视觉的猪体体尺 测点提取算法与应用[J]. 农业工程学报，2013，29(2)： 161－168. </p>\n<p>11.Menesatti P, Costa C, Antonucci F, et al. A low-cost  stereovision system to estimate size and weight of live  sheep[J]. Computers &amp; Electronics in Agriculture, 2014,  103(2): 33－38.</p>\n<p>12.Salau J, Haas J H, Junge W, et al. Feasibility of automated  body trait determination using the SR4K time-of-flight  camera in cow barns[J]. Springer Plus, 2014, 3(1): 225. </p>\n<p>13.Weber A, Salau J, Haas J H, et al. Estimation of backfat  thickness using extracted traits from an automatic 3D optical  system in lactating Holstein-Friesian cows[J]. Livestock  Science, 2014, 165(1): 129－137.</p>\n<p>14.Kuzuhara Y, Kawamura K, Yoshitoshi R, et al. A  preliminarily study for predicting body weight and milk  properties in lactating Holstein cows using a three\u0002dimensional camera system[J]. Computers &amp; Electronics in  Agriculture, 2015, 111: 186－193.</p>\n<p>15.Fischer A, Luginbühl T, Delattre L, et al. Rear shape in 3  dimensions summarized by principal component analysis is a  good predictor of body condition score in Holstein dairy  cows[J]. Journal of Dairy Science, 2015, 98(7): 4465－4476. </p>\n<p>16.Pezzuolo A, Guarino M, Sartori L, et al. On-barn pig weight  estimation based on body measurements by a Kinect v1 depth  camera[J]. Computers &amp; Electronics in Agriculture, 2018,  148: 29－36. </p>\n<p>17.付为森，滕光辉. 基于双目视觉技术的猪生长监测系统标 定模式[J]. 农业机械学报，2009，40(S1)：223－227. </p>\n<p>18.李卓，毛涛涛，刘同海，等. 基于机器视觉的猪体质量估 测模型比较与优化[J]. 农业工程学报，2015，31(2)：155－ 161. </p>\n<p>19.Salau J, Haas J H, Junge W, et al. Extrinsic calibration of a  multi-Kinect camera scanning passage for measuring  functional traits in dairy cows[J]. Biosystems Engineering,  2016, 151: 409－424. </p>\n<p>20.王龙. 机器视觉在奶牛体况评定中的应用[D]. 上海：东华 大学，2014. </p>\n<p>21.张温. 基于机器视觉的牲畜体征测量系统的研究[D]. 包 头：内蒙古科技大学，2014. </p>\n<p>22.郭浩. 动物体表三维数据获取与处理算法研究[D]. 北京： 中国农业大学，2015. </p>\n<p>23.李卓，毛涛涛，刘同海，等. 基于机器视觉的猪体质量估 测模型比较与优化[J]. 农业工程学报，2015，31(2)：155－ 161. </p>\n<p>24.司永胜，安露露，刘刚，等. 基于 Kinect 相机的猪体理想 姿态检测与体尺测量[J]. 农业机械学报，2019，50(1)：58－ 65. </p>\n<p>25.王可，郭浩，刘威林，等. 基于点云旋转归一化的猪体体 尺测点提取方法[J]. 农业工程学报，2017，33(增刊 1)： 253－259.</p>\n<p>26.Guo H, Ma X, Ma Q, et al. LSSA_CAU:An interactive 3d  point clouds analysis software for body measurement of  livestock with similar forms of cows or pigs[J]. Computers &amp;  Electronics in Agriculture, 2017, 138: 60－68.</p>\n<p>27.聂建辉，胡英，马孜. 散乱点云离群点的分类识别算法[J].  计算机辅助设计与图形学学报，2011，23(9)：1526－1532.</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"一、信息\"><a href=\"#一、信息\" class=\"headerlink\" title=\"一、信息\"></a>一、信息</h3><p>尹 令，蔡更元，田绪红，孙爱东，石 帅，钟浩杰，梁世豪.多视角深度相机的猪体三维点云重构及体尺测量[J]. 农业工程学报，2019，35(23)：201－208. </p>\n<p>Yin Ling, Cai Gengyuan, Tian Xuhong, Sun Aidong, Shi Shuai, Zhong Haojie, Liang Shihao. Three dimensional point cloud  reconstruction and body size measurement of pigs based on multi-view depth camera[J]. Transactions of the Chinese Society of  Agricultural Engineering (Transactions of the CSAE), 2019, 35(23): 201－208. (in Chinese with English abstract) </p>\n<p>doi： 10.11975/j.issn.1002-6819.2019.23.025 </p>\n<p><a href=\"http://www.tcsae.org/\">http://www.tcsae.org</a> </p>","more":"<hr>\n<h3 id=\"二、对比\"><a href=\"#二、对比\" class=\"headerlink\" title=\"二、对比\"></a>二、对比</h3><p>1.测量方法：</p>\n<p>人工皮尺测量：容易造成牲畜驱赶应激、人工测量准确性差、测定效率低、复杂性状难以度量等问题</p>\n<p><strong>人工智能无应激识别系统和体况自动评价系统</strong>：有效解决传统测量方法的效率、精度和动物福利问题</p>\n<p>2.参数采集：</p>\n<p>热成像技术：能较清晰捕获动物表面轮廓信息，但热成像设备昂贵，且需从视频流中手动分离相应数据帧，无法实现完全自动化</p>\n<p>图像处理技术：参数大多以像素为单位，当相机参数或物距发生改变时，模型可能不再适用，因此通用性差。另外获取图像时天气、拍摄角度、光照条件影响比较大</p>\n<p>单视角：采集简单不需要融合配准，但只能获取体长、体宽、体高等体尺数据，腹围等体尺无法估测。</p>\n<p><strong>多视角</strong>：获取牲畜各部分深度图像进行各部分点云配准融合、非刚体三维模型点云匹配、体表轮廓描述、家畜体测量交互式软件设计等关键技术都有研究报道。</p>\n<hr>\n<h3 id=\"三、难点\"><a href=\"#三、难点\" class=\"headerlink\" title=\"三、难点\"></a>三、难点</h3><p>当扫描较大面积物体时数据精度丢失严重，同时扫描活体动物时如时间较长容易出现非刚性形变。牲畜全局三维点云重构时，处理数据量大对存储和计算能力要求很高，实时处理是难点。</p>\n<p><strong>解决方案</strong>：</p>\n<p>在测量通道上固定 3 个 KinectV2 相机，通道只能有一头猪单独通过，猪进入相机最佳拍摄位置时，3个深度相机瞬间同步抓取局部点云。采用基于轮廓连贯性点云配准融合全局点云，提取猪体长、体高、体宽、腹围等体尺特征实现对猪的非接触式体尺自动测量。该方法对通道预先设定最佳拍摄位置减少扫描范围，提高数据精度；多视角深度相机同步瞬间抓取减少活体动物运动时非刚性形变；提出各种体尺测量方法，尤其测量腹围时极坐标转换法一方面可以弥补由栏杆遮挡和相机视角未覆盖缺失的点云，另一方面对局部点云相交处轮廓精细配准；并且 KinectV2 为消费级深度设备成本低廉，易于实现产业化。</p>\n<hr>\n<h3 id=\"四、方法\"><a href=\"#四、方法\" class=\"headerlink\" title=\"四、方法\"></a>四、方法</h3><p>1.同时获取瞬间局部点云</p>\n<p>2.采用基于距离查询区域增长方法滤除掉远离群点</p>\n<p>3.对近离群点的消除采用 SVLOF 算法</p>\n<p>4.粗配准：多个深度摄像设备标定中得到相邻子区域的空间变换矩阵和平移向量变换到同一坐标系下</p>\n<p>5.精细配准：配准融合问题就变成一个多目标优化问题，使得顶点融合度和邻层轮廓覆盖率都最小化</p>\n<p>6.最小二乘法拟合中轴平面，确定起始和终止点，微分求体长</p>\n<hr>\n<h3 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h3><p>1.采用 3 个方 向深度相机完成猪体三维重构，与猪体长、体高、胸宽、腹围自动测算试验，其测量数据与实测数据相对误差分析表明本文提出的猪体三维重构和多体尺检测算法稳定、效果较好。</p>\n<p>2.一方面是猪动态行走时姿态不固定，有扭转、拱背、低头等多种形态动作，影响测量准确性，另外人工在猪动态环境下测量准确率也降低。</p>\n<p>3.腹围等 3 围度的测量需要依赖三维点云拼接融合效果，今后需要进一步研究三维点云拼接融合和空缺部分的填补算法。 </p>\n<hr>\n<h3 id=\"六、参考文献\"><a href=\"#六、参考文献\" class=\"headerlink\" title=\"六、参考文献\"></a>六、参考文献</h3><p>1.Halachmi I, Klopčič M, Polak P, et al. Automatic assessment  of dairy cattle body condition score using thermal imaging[J].  Computers &amp; Electronics in Agriculture, 2013, 99(6): 35－ 40. </p>\n<p>2.Azzaro G, Caccamo M, Ferguson J D, et al. Objective  estimation of body condition score by modeling cow body  shape from digital images[J]. Journal of Dairy Science, 2011,  94(4): 2126－2137.</p>\n<p>3.Tedin R , Becerra J A , Duro R J , et al. Computational  intelligence based construction of a body condition  assessment system for cattle[C]// Computational Intelligence  and Virtual Environments for Measurement Systems and  Applications (CIVEMSA), 2013 IEEE International  Conference on. IEEE, 2013.</p>\n<p>4.Bercovich A, Edan Y, Alchanatis V, et al. Development of an  automatic cow body condition scoring using body shape  signature and Fourier descriptors.[J]. Journal of Dairy  Science, 2013, 96(12): 8047－8059. </p>\n<p>5.Kashiha M A, Bahr C, Ott S, et al. Automatic monitoring of  pig locomotion using image analysis[J]. Livestock Science,  2014, 159(1): 141－148.</p>\n<p>6.Vieira A, Brand, O S, Monteiro A, et al. Development and  validation of a visual body condition scoring system for dairy  goats with picture-based training[J]. Journal of Dairy Science,  2015, 98(9): 6597－608.</p>\n<p>7.陈菁菁，彭彦昆. 基于机器视觉技术的生猪活体监测系统[J].  食品安全质量检测学报，2012，3(6)：600－602. </p>\n<p>8.刘建飞. 图像识别技术在奶牛体况评分中的应用研究[D].  济南：山东大学，2012. </p>\n<p>9.吴复争，姜威，张美杰. 核-主成分分析在奶牛体况自动评 分中的应用[J]. 光学技术，2013，39(3)：222－227. </p>\n<p>10.刘同海，滕光辉，付为森，等. 基于机器视觉的猪体体尺 测点提取算法与应用[J]. 农业工程学报，2013，29(2)： 161－168. </p>\n<p>11.Menesatti P, Costa C, Antonucci F, et al. A low-cost  stereovision system to estimate size and weight of live  sheep[J]. Computers &amp; Electronics in Agriculture, 2014,  103(2): 33－38.</p>\n<p>12.Salau J, Haas J H, Junge W, et al. Feasibility of automated  body trait determination using the SR4K time-of-flight  camera in cow barns[J]. Springer Plus, 2014, 3(1): 225. </p>\n<p>13.Weber A, Salau J, Haas J H, et al. Estimation of backfat  thickness using extracted traits from an automatic 3D optical  system in lactating Holstein-Friesian cows[J]. Livestock  Science, 2014, 165(1): 129－137.</p>\n<p>14.Kuzuhara Y, Kawamura K, Yoshitoshi R, et al. A  preliminarily study for predicting body weight and milk  properties in lactating Holstein cows using a three\u0002dimensional camera system[J]. Computers &amp; Electronics in  Agriculture, 2015, 111: 186－193.</p>\n<p>15.Fischer A, Luginbühl T, Delattre L, et al. Rear shape in 3  dimensions summarized by principal component analysis is a  good predictor of body condition score in Holstein dairy  cows[J]. Journal of Dairy Science, 2015, 98(7): 4465－4476. </p>\n<p>16.Pezzuolo A, Guarino M, Sartori L, et al. On-barn pig weight  estimation based on body measurements by a Kinect v1 depth  camera[J]. Computers &amp; Electronics in Agriculture, 2018,  148: 29－36. </p>\n<p>17.付为森，滕光辉. 基于双目视觉技术的猪生长监测系统标 定模式[J]. 农业机械学报，2009，40(S1)：223－227. </p>\n<p>18.李卓，毛涛涛，刘同海，等. 基于机器视觉的猪体质量估 测模型比较与优化[J]. 农业工程学报，2015，31(2)：155－ 161. </p>\n<p>19.Salau J, Haas J H, Junge W, et al. Extrinsic calibration of a  multi-Kinect camera scanning passage for measuring  functional traits in dairy cows[J]. Biosystems Engineering,  2016, 151: 409－424. </p>\n<p>20.王龙. 机器视觉在奶牛体况评定中的应用[D]. 上海：东华 大学，2014. </p>\n<p>21.张温. 基于机器视觉的牲畜体征测量系统的研究[D]. 包 头：内蒙古科技大学，2014. </p>\n<p>22.郭浩. 动物体表三维数据获取与处理算法研究[D]. 北京： 中国农业大学，2015. </p>\n<p>23.李卓，毛涛涛，刘同海，等. 基于机器视觉的猪体质量估 测模型比较与优化[J]. 农业工程学报，2015，31(2)：155－ 161. </p>\n<p>24.司永胜，安露露，刘刚，等. 基于 Kinect 相机的猪体理想 姿态检测与体尺测量[J]. 农业机械学报，2019，50(1)：58－ 65. </p>\n<p>25.王可，郭浩，刘威林，等. 基于点云旋转归一化的猪体体 尺测点提取方法[J]. 农业工程学报，2017，33(增刊 1)： 253－259.</p>\n<p>26.Guo H, Ma X, Ma Q, et al. LSSA_CAU:An interactive 3d  point clouds analysis software for body measurement of  livestock with similar forms of cows or pigs[J]. Computers &amp;  Electronics in Agriculture, 2017, 138: 60－68.</p>\n<p>27.聂建辉，胡英，马孜. 散乱点云离群点的分类识别算法[J].  计算机辅助设计与图形学学报，2011，23(9)：1526－1532.</p>"},{"title":"【LeetCode.650】只有两个键的键盘","date":"2021-09-19T05:56:21.000Z","_content":"\n\n\n### \t题目：只有两个键的键盘\n\n最初记事本上只有一个字符 `'A'` 。你每次可以对这个记事本进行两种操作：\n\n`Copy All`（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。\n`Paste`（粘贴）：粘贴 **上一次** 复制的字符。\n给你一个数字 `n` ，你需要使用最少的操作次数，在记事本上输出 **恰好** `n` 个 `'A'` 。返回能够打印出 `n` 个 `'A'` 的最少操作次数。\n\n <!--more-->\n\n\n\n示例 1：\n\n```\n输入：3\n输出：3\n解释：\n最初, 只有一个字符 'A'。\n第 1 步, 使用 Copy All 操作。\n第 2 步, 使用 Paste 操作来获得 'AA'。\n第 3 步, 使用 Paste 操作来获得 'AAA'。\n```\n\n示例 2：\n\n```\n输入：n = 1\n输出：0\n```\n\n\n提示：\n\n`1 <= n <= 1000`\n\n\n\n---\n\n\n\n### 分析：\n\n总问题可以由小问题逐步扩大得到，考虑动态规划\n\n只有复制和粘贴两种操作，如果要得到 i ，那么就一定要先得到它的其中一个因数 j ，由 j 粘贴 i / j - 1 次得到 i \n\n设动态规划数组 `dp[i]` 表示得到 i 个字母需要的最少操作次数\n\n需要从 1 到 i - 1 寻找 i 的因数，可得状态转移方程：`dp[i] = min( (1 ~ i-1) dp[j] * i/j)`\n\n初始边界条件：`dp[1] = 0`\n\n\n\n---\n\n\n\n### 题解：\n\n```\nclass Solution {\npublic:\n    int minSteps(int n) {\n        vector<int> dp(n + 1);\n        dp[1] = 0;\n        for(int i = 2; i <= n; i++){\n            dp[i] = INT_MAX;\n            for(int j = 1; j * j <= i; j++){\n                if(i % j == 0) {\n                    dp[i] = min(dp[i], dp[j] + i / j);\n                    dp[i] = min(dp[i], dp[i / j] + j);\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n时间复杂度O(n根号n)，空间复杂度O(n)\n\n\n\n---\n\n\n\n### 细节：\n\n如果 j 是 i 的因数，那么 i / j 必然也是 i 的因数，因此我们只需要检测到根号 i 为止就足够了，有效降低时间复杂度\n","source":"_posts/2021-09-19-【LeetCode.650】只有两个键的键盘.md","raw":"---\ntitle: 【LeetCode.650】只有两个键的键盘\ndate: 2021-09-19 13:56:21\ncategories:\t算法\ntags:\n  - c++\n  - 动态规划\n---\n\n\n\n### \t题目：只有两个键的键盘\n\n最初记事本上只有一个字符 `'A'` 。你每次可以对这个记事本进行两种操作：\n\n`Copy All`（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。\n`Paste`（粘贴）：粘贴 **上一次** 复制的字符。\n给你一个数字 `n` ，你需要使用最少的操作次数，在记事本上输出 **恰好** `n` 个 `'A'` 。返回能够打印出 `n` 个 `'A'` 的最少操作次数。\n\n <!--more-->\n\n\n\n示例 1：\n\n```\n输入：3\n输出：3\n解释：\n最初, 只有一个字符 'A'。\n第 1 步, 使用 Copy All 操作。\n第 2 步, 使用 Paste 操作来获得 'AA'。\n第 3 步, 使用 Paste 操作来获得 'AAA'。\n```\n\n示例 2：\n\n```\n输入：n = 1\n输出：0\n```\n\n\n提示：\n\n`1 <= n <= 1000`\n\n\n\n---\n\n\n\n### 分析：\n\n总问题可以由小问题逐步扩大得到，考虑动态规划\n\n只有复制和粘贴两种操作，如果要得到 i ，那么就一定要先得到它的其中一个因数 j ，由 j 粘贴 i / j - 1 次得到 i \n\n设动态规划数组 `dp[i]` 表示得到 i 个字母需要的最少操作次数\n\n需要从 1 到 i - 1 寻找 i 的因数，可得状态转移方程：`dp[i] = min( (1 ~ i-1) dp[j] * i/j)`\n\n初始边界条件：`dp[1] = 0`\n\n\n\n---\n\n\n\n### 题解：\n\n```\nclass Solution {\npublic:\n    int minSteps(int n) {\n        vector<int> dp(n + 1);\n        dp[1] = 0;\n        for(int i = 2; i <= n; i++){\n            dp[i] = INT_MAX;\n            for(int j = 1; j * j <= i; j++){\n                if(i % j == 0) {\n                    dp[i] = min(dp[i], dp[j] + i / j);\n                    dp[i] = min(dp[i], dp[i / j] + j);\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n时间复杂度O(n根号n)，空间复杂度O(n)\n\n\n\n---\n\n\n\n### 细节：\n\n如果 j 是 i 的因数，那么 i / j 必然也是 i 的因数，因此我们只需要检测到根号 i 为止就足够了，有效降低时间复杂度\n","slug":"2021-09-19-【LeetCode.650】只有两个键的键盘","published":1,"updated":"2021-10-06T07:09:48.243Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hw00251ou0cs8hama7","content":"<h3 id=\"题目：只有两个键的键盘\"><a href=\"#题目：只有两个键的键盘\" class=\"headerlink\" title=\"题目：只有两个键的键盘\"></a>题目：只有两个键的键盘</h3><p>最初记事本上只有一个字符 <code>&#39;A&#39;</code> 。你每次可以对这个记事本进行两种操作：</p>\n<p><code>Copy All</code>（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。<br><code>Paste</code>（粘贴）：粘贴 <strong>上一次</strong> 复制的字符。<br>给你一个数字 <code>n</code> ，你需要使用最少的操作次数，在记事本上输出 <strong>恰好</strong> <code>n</code> 个 <code>&#39;A&#39;</code> 。返回能够打印出 <code>n</code> 个 <code>&#39;A&#39;</code> 的最少操作次数。</p>\n <span id=\"more\"></span>\n\n\n\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：3</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：</span><br><span class=\"line\">最初, 只有一个字符 &#x27;A&#x27;。</span><br><span class=\"line\">第 1 步, 使用 Copy All 操作。</span><br><span class=\"line\">第 2 步, 使用 Paste 操作来获得 &#x27;AA&#x27;。</span><br><span class=\"line\">第 3 步, 使用 Paste 操作来获得 &#x27;AAA&#x27;。</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 1</span><br><span class=\"line\">输出：0</span><br></pre></td></tr></table></figure>\n\n\n<p>提示：</p>\n<p><code>1 &lt;= n &lt;= 1000</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>总问题可以由小问题逐步扩大得到，考虑动态规划</p>\n<p>只有复制和粘贴两种操作，如果要得到 i ，那么就一定要先得到它的其中一个因数 j ，由 j 粘贴 i / j - 1 次得到 i </p>\n<p>设动态规划数组 <code>dp[i]</code> 表示得到 i 个字母需要的最少操作次数</p>\n<p>需要从 1 到 i - 1 寻找 i 的因数，可得状态转移方程：<code>dp[i] = min( (1 ~ i-1) dp[j] * i/j)</code></p>\n<p>初始边界条件：<code>dp[1] = 0</code></p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int minSteps(int n) &#123;</span><br><span class=\"line\">        vector&lt;int&gt; dp(n + 1);</span><br><span class=\"line\">        dp[1] = 0;</span><br><span class=\"line\">        for(int i = 2; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            dp[i] = INT_MAX;</span><br><span class=\"line\">            for(int j = 1; j * j &lt;= i; j++)&#123;</span><br><span class=\"line\">                if(i % j == 0) &#123;</span><br><span class=\"line\">                    dp[i] = min(dp[i], dp[j] + i / j);</span><br><span class=\"line\">                    dp[i] = min(dp[i], dp[i / j] + j);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n根号n)，空间复杂度O(n)</p>\n<hr>\n<h3 id=\"细节：\"><a href=\"#细节：\" class=\"headerlink\" title=\"细节：\"></a>细节：</h3><p>如果 j 是 i 的因数，那么 i / j 必然也是 i 的因数，因此我们只需要检测到根号 i 为止就足够了，有效降低时间复杂度</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"题目：只有两个键的键盘\"><a href=\"#题目：只有两个键的键盘\" class=\"headerlink\" title=\"题目：只有两个键的键盘\"></a>题目：只有两个键的键盘</h3><p>最初记事本上只有一个字符 <code>&#39;A&#39;</code> 。你每次可以对这个记事本进行两种操作：</p>\n<p><code>Copy All</code>（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。<br><code>Paste</code>（粘贴）：粘贴 <strong>上一次</strong> 复制的字符。<br>给你一个数字 <code>n</code> ，你需要使用最少的操作次数，在记事本上输出 <strong>恰好</strong> <code>n</code> 个 <code>&#39;A&#39;</code> 。返回能够打印出 <code>n</code> 个 <code>&#39;A&#39;</code> 的最少操作次数。</p>","more":"<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：3</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：</span><br><span class=\"line\">最初, 只有一个字符 &#x27;A&#x27;。</span><br><span class=\"line\">第 1 步, 使用 Copy All 操作。</span><br><span class=\"line\">第 2 步, 使用 Paste 操作来获得 &#x27;AA&#x27;。</span><br><span class=\"line\">第 3 步, 使用 Paste 操作来获得 &#x27;AAA&#x27;。</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：n = 1</span><br><span class=\"line\">输出：0</span><br></pre></td></tr></table></figure>\n\n\n<p>提示：</p>\n<p><code>1 &lt;= n &lt;= 1000</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>总问题可以由小问题逐步扩大得到，考虑动态规划</p>\n<p>只有复制和粘贴两种操作，如果要得到 i ，那么就一定要先得到它的其中一个因数 j ，由 j 粘贴 i / j - 1 次得到 i </p>\n<p>设动态规划数组 <code>dp[i]</code> 表示得到 i 个字母需要的最少操作次数</p>\n<p>需要从 1 到 i - 1 寻找 i 的因数，可得状态转移方程：<code>dp[i] = min( (1 ~ i-1) dp[j] * i/j)</code></p>\n<p>初始边界条件：<code>dp[1] = 0</code></p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int minSteps(int n) &#123;</span><br><span class=\"line\">        vector&lt;int&gt; dp(n + 1);</span><br><span class=\"line\">        dp[1] = 0;</span><br><span class=\"line\">        for(int i = 2; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            dp[i] = INT_MAX;</span><br><span class=\"line\">            for(int j = 1; j * j &lt;= i; j++)&#123;</span><br><span class=\"line\">                if(i % j == 0) &#123;</span><br><span class=\"line\">                    dp[i] = min(dp[i], dp[j] + i / j);</span><br><span class=\"line\">                    dp[i] = min(dp[i], dp[i / j] + j);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n根号n)，空间复杂度O(n)</p>\n<hr>\n<h3 id=\"细节：\"><a href=\"#细节：\" class=\"headerlink\" title=\"细节：\"></a>细节：</h3><p>如果 j 是 i 的因数，那么 i / j 必然也是 i 的因数，因此我们只需要检测到根号 i 为止就足够了，有效降低时间复杂度</p>"},{"title":"Pytorch深度学习环境配置","date":"2021-09-29T09:06:39.000Z","_content":"\n\n\n### \t始、Pytorch深度学习快速入门【小土堆】\n\n**版本：**\n\nAnaconda：Anaconda3-5.2.0-Windows-x86.64\n\nCuda：10.2\n\n\n\n**报错汇总：**\n\n1.python.exe无法找到入口\n\n解决方法：找到报错路径下的pythoncom36.dll并删除\n\n\n\n<!--more-->\n\n---\n\n\n\n### 一、安装Anaconda\n\n1.进入Anaconda历史版本页面：https://repo.anaconda.com/\n\n2.选择下载`Anaconda3-5.2.0-Windows-x86.64.exe`\n\n3.跳过安装vs\n\n\n\n---\n\n\n\n### 二、管理环境\n\n1.创建环境：打开Anaconda Prompt，输入`conda create -n pytorch python=3.6`\n\n2.激活环境：输入`conda activate pytorch`\n\n3.查看环境包体：`pip list`\n\n\n\n---\n\n\n\n### 三、安装Pytorch\n\n**普通方法：**\n\n1.打开`Pytorch`首页：https://pytorch.org/\n\n2.依次选择`Stable1.9.1`→`Windows`→`Conda`→`Python`→`CUDA10.2`，执行下方代码行：\n\n```\nconda install pytorch torchvision torchaudio cudatoolkit=10.2 -c pytorch\n```\n\n\n\n**清华源方法：**\n\n1.先添加清华镜像channel：\n\n```\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\nconda config --set show_channel_urls yes\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/\n```\n\n2.执行安装代码行：\n\n```\nconda install pytorch torchvision cudatoolkit=10.2\n```\n\n3.验证是否安装成功：\n\n```\npip list\n```\n\n查看环境中是否有torch工具包\n\n---\n\n\n\n### 四、验证CUDA\n\n1.按顺序输入以下命令：\n\n```\npython\nimport torch\ntorch.cuda.is_available()\n```\n\n如果返回True，则表示Pytorch可以正常使用GPU\n\n\n\n---\n\n\n\n### 五、编辑器\n\n**vscode**：\n\n1.打开vscode官网下载：https://code.visualstudio.com/docs/?dv=win64user，安装包会自动下载\n\n\n\n**jupyter：**\n\n1.在pytorch环境中安装jupyter：打开Anaconda Prompt并进入pytorch环境然后输入`conda install nb_conda`\n\n2.验证是否安装成功：\n\n```\npip list\n```\n\n查看环境中是否有ipykernel工具包\n\n3.启动jupyter：输入`jupyter notebook`\n\n","source":"_posts/2021-09-29-Pytorch深度学习环境配置.md","raw":"---\ntitle: Pytorch深度学习环境配置\ndate: 2021-09-29 17:06:39\ncategories:\t琐碎\ntags:\n  - pytorch\n  - python\n  - anaconda\n---\n\n\n\n### \t始、Pytorch深度学习快速入门【小土堆】\n\n**版本：**\n\nAnaconda：Anaconda3-5.2.0-Windows-x86.64\n\nCuda：10.2\n\n\n\n**报错汇总：**\n\n1.python.exe无法找到入口\n\n解决方法：找到报错路径下的pythoncom36.dll并删除\n\n\n\n<!--more-->\n\n---\n\n\n\n### 一、安装Anaconda\n\n1.进入Anaconda历史版本页面：https://repo.anaconda.com/\n\n2.选择下载`Anaconda3-5.2.0-Windows-x86.64.exe`\n\n3.跳过安装vs\n\n\n\n---\n\n\n\n### 二、管理环境\n\n1.创建环境：打开Anaconda Prompt，输入`conda create -n pytorch python=3.6`\n\n2.激活环境：输入`conda activate pytorch`\n\n3.查看环境包体：`pip list`\n\n\n\n---\n\n\n\n### 三、安装Pytorch\n\n**普通方法：**\n\n1.打开`Pytorch`首页：https://pytorch.org/\n\n2.依次选择`Stable1.9.1`→`Windows`→`Conda`→`Python`→`CUDA10.2`，执行下方代码行：\n\n```\nconda install pytorch torchvision torchaudio cudatoolkit=10.2 -c pytorch\n```\n\n\n\n**清华源方法：**\n\n1.先添加清华镜像channel：\n\n```\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\nconda config --set show_channel_urls yes\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/\n```\n\n2.执行安装代码行：\n\n```\nconda install pytorch torchvision cudatoolkit=10.2\n```\n\n3.验证是否安装成功：\n\n```\npip list\n```\n\n查看环境中是否有torch工具包\n\n---\n\n\n\n### 四、验证CUDA\n\n1.按顺序输入以下命令：\n\n```\npython\nimport torch\ntorch.cuda.is_available()\n```\n\n如果返回True，则表示Pytorch可以正常使用GPU\n\n\n\n---\n\n\n\n### 五、编辑器\n\n**vscode**：\n\n1.打开vscode官网下载：https://code.visualstudio.com/docs/?dv=win64user，安装包会自动下载\n\n\n\n**jupyter：**\n\n1.在pytorch环境中安装jupyter：打开Anaconda Prompt并进入pytorch环境然后输入`conda install nb_conda`\n\n2.验证是否安装成功：\n\n```\npip list\n```\n\n查看环境中是否有ipykernel工具包\n\n3.启动jupyter：输入`jupyter notebook`\n\n","slug":"2021-09-29-Pytorch深度学习环境配置","published":1,"updated":"2021-10-14T10:52:23.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71hy00291ou0fpkpc1xi","content":"<h3 id=\"始、Pytorch深度学习快速入门【小土堆】\"><a href=\"#始、Pytorch深度学习快速入门【小土堆】\" class=\"headerlink\" title=\"始、Pytorch深度学习快速入门【小土堆】\"></a>始、Pytorch深度学习快速入门【小土堆】</h3><p><strong>版本：</strong></p>\n<p>Anaconda：Anaconda3-5.2.0-Windows-x86.64</p>\n<p>Cuda：10.2</p>\n<p><strong>报错汇总：</strong></p>\n<p>1.python.exe无法找到入口</p>\n<p>解决方法：找到报错路径下的pythoncom36.dll并删除</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、安装Anaconda\"><a href=\"#一、安装Anaconda\" class=\"headerlink\" title=\"一、安装Anaconda\"></a>一、安装Anaconda</h3><p>1.进入Anaconda历史版本页面：<a href=\"https://repo.anaconda.com/\">https://repo.anaconda.com/</a></p>\n<p>2.选择下载<code>Anaconda3-5.2.0-Windows-x86.64.exe</code></p>\n<p>3.跳过安装vs</p>\n<hr>\n<h3 id=\"二、管理环境\"><a href=\"#二、管理环境\" class=\"headerlink\" title=\"二、管理环境\"></a>二、管理环境</h3><p>1.创建环境：打开Anaconda Prompt，输入<code>conda create -n pytorch python=3.6</code></p>\n<p>2.激活环境：输入<code>conda activate pytorch</code></p>\n<p>3.查看环境包体：<code>pip list</code></p>\n<hr>\n<h3 id=\"三、安装Pytorch\"><a href=\"#三、安装Pytorch\" class=\"headerlink\" title=\"三、安装Pytorch\"></a>三、安装Pytorch</h3><p><strong>普通方法：</strong></p>\n<p>1.打开<code>Pytorch</code>首页：<a href=\"https://pytorch.org/\">https://pytorch.org/</a></p>\n<p>2.依次选择<code>Stable1.9.1</code>→<code>Windows</code>→<code>Conda</code>→<code>Python</code>→<code>CUDA10.2</code>，执行下方代码行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install pytorch torchvision torchaudio cudatoolkit=10.2 -c pytorch</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>清华源方法：</strong></p>\n<p>1.先添加清华镜像channel：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class=\"line\">conda config --set show_channel_urls yes</span><br><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br></pre></td></tr></table></figure>\n\n<p>2.执行安装代码行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install pytorch torchvision cudatoolkit=10.2</span><br></pre></td></tr></table></figure>\n\n<p>3.验证是否安装成功：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip list</span><br></pre></td></tr></table></figure>\n\n<p>查看环境中是否有torch工具包</p>\n<hr>\n<h3 id=\"四、验证CUDA\"><a href=\"#四、验证CUDA\" class=\"headerlink\" title=\"四、验证CUDA\"></a>四、验证CUDA</h3><p>1.按顺序输入以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python</span><br><span class=\"line\">import torch</span><br><span class=\"line\">torch.cuda.is_available()</span><br></pre></td></tr></table></figure>\n\n<p>如果返回True，则表示Pytorch可以正常使用GPU</p>\n<hr>\n<h3 id=\"五、编辑器\"><a href=\"#五、编辑器\" class=\"headerlink\" title=\"五、编辑器\"></a>五、编辑器</h3><p><strong>vscode</strong>：</p>\n<p>1.打开vscode官网下载：<a href=\"https://code.visualstudio.com/docs/?dv=win64user%EF%BC%8C%E5%AE%89%E8%A3%85%E5%8C%85%E4%BC%9A%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD\">https://code.visualstudio.com/docs/?dv=win64user，安装包会自动下载</a></p>\n<p><strong>jupyter：</strong></p>\n<p>1.在pytorch环境中安装jupyter：打开Anaconda Prompt并进入pytorch环境然后输入<code>conda install nb_conda</code></p>\n<p>2.验证是否安装成功：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip list</span><br></pre></td></tr></table></figure>\n\n<p>查看环境中是否有ipykernel工具包</p>\n<p>3.启动jupyter：输入<code>jupyter notebook</code></p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、Pytorch深度学习快速入门【小土堆】\"><a href=\"#始、Pytorch深度学习快速入门【小土堆】\" class=\"headerlink\" title=\"始、Pytorch深度学习快速入门【小土堆】\"></a>始、Pytorch深度学习快速入门【小土堆】</h3><p><strong>版本：</strong></p>\n<p>Anaconda：Anaconda3-5.2.0-Windows-x86.64</p>\n<p>Cuda：10.2</p>\n<p><strong>报错汇总：</strong></p>\n<p>1.python.exe无法找到入口</p>\n<p>解决方法：找到报错路径下的pythoncom36.dll并删除</p>","more":"<hr>\n<h3 id=\"一、安装Anaconda\"><a href=\"#一、安装Anaconda\" class=\"headerlink\" title=\"一、安装Anaconda\"></a>一、安装Anaconda</h3><p>1.进入Anaconda历史版本页面：<a href=\"https://repo.anaconda.com/\">https://repo.anaconda.com/</a></p>\n<p>2.选择下载<code>Anaconda3-5.2.0-Windows-x86.64.exe</code></p>\n<p>3.跳过安装vs</p>\n<hr>\n<h3 id=\"二、管理环境\"><a href=\"#二、管理环境\" class=\"headerlink\" title=\"二、管理环境\"></a>二、管理环境</h3><p>1.创建环境：打开Anaconda Prompt，输入<code>conda create -n pytorch python=3.6</code></p>\n<p>2.激活环境：输入<code>conda activate pytorch</code></p>\n<p>3.查看环境包体：<code>pip list</code></p>\n<hr>\n<h3 id=\"三、安装Pytorch\"><a href=\"#三、安装Pytorch\" class=\"headerlink\" title=\"三、安装Pytorch\"></a>三、安装Pytorch</h3><p><strong>普通方法：</strong></p>\n<p>1.打开<code>Pytorch</code>首页：<a href=\"https://pytorch.org/\">https://pytorch.org/</a></p>\n<p>2.依次选择<code>Stable1.9.1</code>→<code>Windows</code>→<code>Conda</code>→<code>Python</code>→<code>CUDA10.2</code>，执行下方代码行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install pytorch torchvision torchaudio cudatoolkit=10.2 -c pytorch</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>清华源方法：</strong></p>\n<p>1.先添加清华镜像channel：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class=\"line\">conda config --set show_channel_urls yes</span><br><span class=\"line\">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br></pre></td></tr></table></figure>\n\n<p>2.执行安装代码行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda install pytorch torchvision cudatoolkit=10.2</span><br></pre></td></tr></table></figure>\n\n<p>3.验证是否安装成功：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip list</span><br></pre></td></tr></table></figure>\n\n<p>查看环境中是否有torch工具包</p>\n<hr>\n<h3 id=\"四、验证CUDA\"><a href=\"#四、验证CUDA\" class=\"headerlink\" title=\"四、验证CUDA\"></a>四、验证CUDA</h3><p>1.按顺序输入以下命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python</span><br><span class=\"line\">import torch</span><br><span class=\"line\">torch.cuda.is_available()</span><br></pre></td></tr></table></figure>\n\n<p>如果返回True，则表示Pytorch可以正常使用GPU</p>\n<hr>\n<h3 id=\"五、编辑器\"><a href=\"#五、编辑器\" class=\"headerlink\" title=\"五、编辑器\"></a>五、编辑器</h3><p><strong>vscode</strong>：</p>\n<p>1.打开vscode官网下载：<a href=\"https://code.visualstudio.com/docs/?dv=win64user%EF%BC%8C%E5%AE%89%E8%A3%85%E5%8C%85%E4%BC%9A%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD\">https://code.visualstudio.com/docs/?dv=win64user，安装包会自动下载</a></p>\n<p><strong>jupyter：</strong></p>\n<p>1.在pytorch环境中安装jupyter：打开Anaconda Prompt并进入pytorch环境然后输入<code>conda install nb_conda</code></p>\n<p>2.验证是否安装成功：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip list</span><br></pre></td></tr></table></figure>\n\n<p>查看环境中是否有ipykernel工具包</p>\n<p>3.启动jupyter：输入<code>jupyter notebook</code></p>"},{"title":"Python学习日志Day1","date":"2021-09-30T05:00:45.000Z","_content":"\n\n\n### 一、Python注释\n\n1.单行注释`#`\n\n2.多行注释`''' '''`\n\n<!--more-->\n\n---\n\n\n\n### 二、数据类型和命名\n\n1.数字int、布尔值bool、字符串str、字典dict、元组tuple、列表list\n\n2.type()方法可以查看类型\n\n```\n#数据类型\na = 10086\nprint(type(a))\na = 'fa♂q'\nprint(type(a))\na = 12.45\nprint(type(a))\na = True\nprint(type(a))\nprint(a)\n\n#高级类型\nb = ()\nprint(type(b))\nb = []\nprint(type(b))\nb = {}\nprint(type(b))\n```\n\n```\n<class 'int'>\n<class 'str'>\n<class 'float'>\n<class 'bool'>\nTrue\n<class 'tuple'>\n<class 'list'>\n<class 'dict'>\n```\n\n\n\n---\n\n\n\n### 三、基本操作符\n\n1.算数运算符：+、-、*、/、**、//\n\n2.比较运算符：==、！=、>、<、>=、<=\n\n3.逻辑运算符：and、or、not\n\n4.赋值运算符：=、+=、-=、*=、/=、%=、**=、//=\n\n\n\n---\n\n\n\n### 四、格式化输入和输出\n\n1.输入：`input`\n\n2.输出：`%s`  `%d`  `%f`  `{}.format`\n\n```\n#格式化输出\nname = '张三'\nage = 25\nprint('我的名字是：%s, \\n我今年%d岁'%(name, age))\nprint('姓名：{}，年龄：{}'.format(name,age))\n\n#input输入\nname = input('请输入你的名字：')\nprint('姓名：{}'.format(name))\n```\n\n","source":"_posts/2021-09-30-Python学习日志Day1.md","raw":"---\ntitle: Python学习日志Day1\ndate: 2021-09-30 13:00:45\ncategories:\tpython\ntags:\n  - python\n---\n\n\n\n### 一、Python注释\n\n1.单行注释`#`\n\n2.多行注释`''' '''`\n\n<!--more-->\n\n---\n\n\n\n### 二、数据类型和命名\n\n1.数字int、布尔值bool、字符串str、字典dict、元组tuple、列表list\n\n2.type()方法可以查看类型\n\n```\n#数据类型\na = 10086\nprint(type(a))\na = 'fa♂q'\nprint(type(a))\na = 12.45\nprint(type(a))\na = True\nprint(type(a))\nprint(a)\n\n#高级类型\nb = ()\nprint(type(b))\nb = []\nprint(type(b))\nb = {}\nprint(type(b))\n```\n\n```\n<class 'int'>\n<class 'str'>\n<class 'float'>\n<class 'bool'>\nTrue\n<class 'tuple'>\n<class 'list'>\n<class 'dict'>\n```\n\n\n\n---\n\n\n\n### 三、基本操作符\n\n1.算数运算符：+、-、*、/、**、//\n\n2.比较运算符：==、！=、>、<、>=、<=\n\n3.逻辑运算符：and、or、not\n\n4.赋值运算符：=、+=、-=、*=、/=、%=、**=、//=\n\n\n\n---\n\n\n\n### 四、格式化输入和输出\n\n1.输入：`input`\n\n2.输出：`%s`  `%d`  `%f`  `{}.format`\n\n```\n#格式化输出\nname = '张三'\nage = 25\nprint('我的名字是：%s, \\n我今年%d岁'%(name, age))\nprint('姓名：{}，年龄：{}'.format(name,age))\n\n#input输入\nname = input('请输入你的名字：')\nprint('姓名：{}'.format(name))\n```\n\n","slug":"2021-09-30-Python学习日志Day1","published":1,"updated":"2021-09-30T05:37:38.611Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71i0002d1ou06qy49h26","content":"<h3 id=\"一、Python注释\"><a href=\"#一、Python注释\" class=\"headerlink\" title=\"一、Python注释\"></a>一、Python注释</h3><p>1.单行注释<code>#</code></p>\n<p>2.多行注释<code>&#39;&#39;&#39; &#39;&#39;&#39;</code></p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"二、数据类型和命名\"><a href=\"#二、数据类型和命名\" class=\"headerlink\" title=\"二、数据类型和命名\"></a>二、数据类型和命名</h3><p>1.数字int、布尔值bool、字符串str、字典dict、元组tuple、列表list</p>\n<p>2.type()方法可以查看类型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#数据类型</span><br><span class=\"line\">a = 10086</span><br><span class=\"line\">print(type(a))</span><br><span class=\"line\">a = &#x27;fa♂q&#x27;</span><br><span class=\"line\">print(type(a))</span><br><span class=\"line\">a = 12.45</span><br><span class=\"line\">print(type(a))</span><br><span class=\"line\">a = True</span><br><span class=\"line\">print(type(a))</span><br><span class=\"line\">print(a)</span><br><span class=\"line\"></span><br><span class=\"line\">#高级类型</span><br><span class=\"line\">b = ()</span><br><span class=\"line\">print(type(b))</span><br><span class=\"line\">b = []</span><br><span class=\"line\">print(type(b))</span><br><span class=\"line\">b = &#123;&#125;</span><br><span class=\"line\">print(type(b))</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &#x27;int&#x27;&gt;</span><br><span class=\"line\">&lt;class &#x27;str&#x27;&gt;</span><br><span class=\"line\">&lt;class &#x27;float&#x27;&gt;</span><br><span class=\"line\">&lt;class &#x27;bool&#x27;&gt;</span><br><span class=\"line\">True</span><br><span class=\"line\">&lt;class &#x27;tuple&#x27;&gt;</span><br><span class=\"line\">&lt;class &#x27;list&#x27;&gt;</span><br><span class=\"line\">&lt;class &#x27;dict&#x27;&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"三、基本操作符\"><a href=\"#三、基本操作符\" class=\"headerlink\" title=\"三、基本操作符\"></a>三、基本操作符</h3><p>1.算数运算符：+、-、*、/、**、//</p>\n<p>2.比较运算符：==、！=、&gt;、&lt;、&gt;=、&lt;=</p>\n<p>3.逻辑运算符：and、or、not</p>\n<p>4.赋值运算符：=、+=、-=、*=、/=、%=、**=、//=</p>\n<hr>\n<h3 id=\"四、格式化输入和输出\"><a href=\"#四、格式化输入和输出\" class=\"headerlink\" title=\"四、格式化输入和输出\"></a>四、格式化输入和输出</h3><p>1.输入：<code>input</code></p>\n<p>2.输出：<code>%s</code>  <code>%d</code>  <code>%f</code>  <code>&#123;&#125;.format</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#格式化输出</span><br><span class=\"line\">name = &#x27;张三&#x27;</span><br><span class=\"line\">age = 25</span><br><span class=\"line\">print(&#x27;我的名字是：%s, \\n我今年%d岁&#x27;%(name, age))</span><br><span class=\"line\">print(&#x27;姓名：&#123;&#125;，年龄：&#123;&#125;&#x27;.format(name,age))</span><br><span class=\"line\"></span><br><span class=\"line\">#input输入</span><br><span class=\"line\">name = input(&#x27;请输入你的名字：&#x27;)</span><br><span class=\"line\">print(&#x27;姓名：&#123;&#125;&#x27;.format(name))</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"一、Python注释\"><a href=\"#一、Python注释\" class=\"headerlink\" title=\"一、Python注释\"></a>一、Python注释</h3><p>1.单行注释<code>#</code></p>\n<p>2.多行注释<code>&#39;&#39;&#39; &#39;&#39;&#39;</code></p>","more":"<hr>\n<h3 id=\"二、数据类型和命名\"><a href=\"#二、数据类型和命名\" class=\"headerlink\" title=\"二、数据类型和命名\"></a>二、数据类型和命名</h3><p>1.数字int、布尔值bool、字符串str、字典dict、元组tuple、列表list</p>\n<p>2.type()方法可以查看类型</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#数据类型</span><br><span class=\"line\">a = 10086</span><br><span class=\"line\">print(type(a))</span><br><span class=\"line\">a = &#x27;fa♂q&#x27;</span><br><span class=\"line\">print(type(a))</span><br><span class=\"line\">a = 12.45</span><br><span class=\"line\">print(type(a))</span><br><span class=\"line\">a = True</span><br><span class=\"line\">print(type(a))</span><br><span class=\"line\">print(a)</span><br><span class=\"line\"></span><br><span class=\"line\">#高级类型</span><br><span class=\"line\">b = ()</span><br><span class=\"line\">print(type(b))</span><br><span class=\"line\">b = []</span><br><span class=\"line\">print(type(b))</span><br><span class=\"line\">b = &#123;&#125;</span><br><span class=\"line\">print(type(b))</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &#x27;int&#x27;&gt;</span><br><span class=\"line\">&lt;class &#x27;str&#x27;&gt;</span><br><span class=\"line\">&lt;class &#x27;float&#x27;&gt;</span><br><span class=\"line\">&lt;class &#x27;bool&#x27;&gt;</span><br><span class=\"line\">True</span><br><span class=\"line\">&lt;class &#x27;tuple&#x27;&gt;</span><br><span class=\"line\">&lt;class &#x27;list&#x27;&gt;</span><br><span class=\"line\">&lt;class &#x27;dict&#x27;&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"三、基本操作符\"><a href=\"#三、基本操作符\" class=\"headerlink\" title=\"三、基本操作符\"></a>三、基本操作符</h3><p>1.算数运算符：+、-、*、/、**、//</p>\n<p>2.比较运算符：==、！=、&gt;、&lt;、&gt;=、&lt;=</p>\n<p>3.逻辑运算符：and、or、not</p>\n<p>4.赋值运算符：=、+=、-=、*=、/=、%=、**=、//=</p>\n<hr>\n<h3 id=\"四、格式化输入和输出\"><a href=\"#四、格式化输入和输出\" class=\"headerlink\" title=\"四、格式化输入和输出\"></a>四、格式化输入和输出</h3><p>1.输入：<code>input</code></p>\n<p>2.输出：<code>%s</code>  <code>%d</code>  <code>%f</code>  <code>&#123;&#125;.format</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#格式化输出</span><br><span class=\"line\">name = &#x27;张三&#x27;</span><br><span class=\"line\">age = 25</span><br><span class=\"line\">print(&#x27;我的名字是：%s, \\n我今年%d岁&#x27;%(name, age))</span><br><span class=\"line\">print(&#x27;姓名：&#123;&#125;，年龄：&#123;&#125;&#x27;.format(name,age))</span><br><span class=\"line\"></span><br><span class=\"line\">#input输入</span><br><span class=\"line\">name = input(&#x27;请输入你的名字：&#x27;)</span><br><span class=\"line\">print(&#x27;姓名：&#123;&#125;&#x27;.format(name))</span><br></pre></td></tr></table></figure>"},{"title":"【LeetCode.284】顶端迭代器","date":"2021-10-05T13:40:56.000Z","_content":"\n\n\n### \t题目：顶端迭代器\n\n请你设计一个迭代器，除了支持 `hasNext` 和 `next` 操作外，还支持 `peek` 操作。\n\n实现 `PeekingIterator` 类：\n\n`PeekingIterator(int[] nums)` 使用指定整数数组 `nums` 初始化迭代器。\n`int next()` 返回数组中的下一个元素，并将指针移动到下个元素处。\n`bool hasNext()` 如果数组中存在下一个元素，返回 `true` ；否则，返回 `false` 。\n`int peek()` 返回数组中的下一个元素，但 **不** 移动指针。\n\n<!--more-->\n\n\n\n\n示例：\n\n```\n输入：\n[\"PeekingIterator\", \"next\", \"peek\", \"next\", \"next\", \"hasNext\"]\n[[[1, 2, 3]], [], [], [], [], []]\n输出：\n[null, 1, 2, 2, 3, false]\n\n解释：\nPeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]\npeekingIterator.next();    // 返回 1 ，指针移动到下一个元素 [1,2,3]\npeekingIterator.peek();    // 返回 2 ，指针未发生移动 [1,2,3]\npeekingIterator.next();    // 返回 2 ，指针移动到下一个元素 [1,2,3]\npeekingIterator.next();    // 返回 3 ，指针移动到下一个元素 [1,2,3]\npeekingIterator.hasNext(); // 返回 False\n```\n\n\n\n提示：\n\n`1 <= nums.length <= 1000`\n`1 <= nums[i] <= 1000`\n`对 next 和 peek 的调用均有效`\n`next、hasNext 和 peek 最多调用  1000 次`\n\n\n\n\n进阶：你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？\n\n\n\n---\n\n\n\n### 分析：\n\n顶端迭代器需要实现以下三种操作：\n\n`next`：返回迭代器的下一个元素，并将指针向后移动一位；\n\n`hasNext`：判断迭代器中是否还有剩余的元素；\n\n`peek`：返回迭代器的下一个元素，不改变指针。\n\n\n\n每种编程语言自带的迭代器可能支持上述一种或多种操作，但是不一定支持上述全部操作。如果编程语言自带的迭代器本身就支持上述操作，可以直接使用，否则需要自定义实现。\n\n\n\n1. C++中`PeekingIterator`继承父类`Iterator`，`Iterator`已经实现方法`next`和`hasNext`，在此我们在`PeekingIterator`中主要实现`peek`方法即可。我们使用`flag`标记迭代器是否还有剩余元素，使用`nextElement`存储迭代器的下一个元素。\n\n`next`：首先用`ret`存储`nextElement`表示返回值，`flag`保存`Iterator`调用`hasNext`方法的返回结果，然后将`nextElement`向后移动一位，最后返回`ret`；\n\n`hasNext`：返回`flag`；\n\n`peek`：由于peek操作不改变指针，因此返回`nextElement`。\n\n\n\n2. C#的`IEnumerator`接口包含属性Current和方法`MoveNext`（该方法的返回值类型是`bool`，表示是否成功移动到下一个元素），三种操作都需要自定义实现，需要使用flag存储迭代器是否还有剩余的元素。\n\n`next`：首先用`ret`存储`iterator.Current`表示返回值，然后对`iterator`调用`MoveNext`方法使其向后移动一位并将该方法的结果赋值给`flag`，最后返回`ret`；\n\n`hasNext`：返回flag；\n\n`peek`：由于`peek`操作不改变指针，因此返回`iterator.Current`。\n\n\n\n---\n\n\n\n### 题解：\n\n1. C++\n\n```c++\nclass PeekingIterator : public Iterator {\npublic:\n\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\n\t    // Initialize any member here.\n\t    // **DO NOT** save a copy of nums and manipulate it directly.\n\t    // You should only use the Iterator interface methods.\n\t    flag = Iterator::hasNext();\n        if(flag){\n            nextElement = Iterator::next();\n        }\n\t}\n\t\n    // Returns the next element in the iteration without advancing the iterator.\n\tint peek() {\n        return nextElement;\n\t}\n\t\n\t// hasNext() and next() should behave the same as in the Iterator interface.\n\t// Override them if needed.\n\tint next() {\n\t    int ret = nextElement;\n        flag = Iterator::hasNext();\n        if(flag){\n            nextElement = Iterator::next();\n        }\n        return ret;\n\t}\n\t\n\tbool hasNext() const {\n\t    return flag;\n\t}\nprivate:\n    bool flag;\n    int nextElement;\n};\n```\n\n2. C#\n\n```c#\nclass PeekingIterator {\n    private IEnumerator<int> iterator;\n    private bool flag;\n\n    // iterators refers to the first element of the array.\n    public PeekingIterator(IEnumerator<int> iterator) {\n        // initialize any member here.\n        this.iterator = iterator;\n        flag = true;\n    }\n    \n    // Returns the next element in the iteration without advancing the iterator.\n    public int Peek() {\n        return iterator.Current;\n    }\n    \n    // Returns the next element in the iteration and advances the iterator.\n    public int Next() {\n        int ret = iterator.Current;\n        flag = iterator.MoveNext();\n        return ret;\n    }\n    \n    // Returns false if the iterator is refering to the end of the array of true otherwise.\n    public bool HasNext() {\n        return flag;\t\n    }\n}\n```\n\n\n\n---\n\n\n\n### 进阶：\n\n**进阶问题**\n进阶问题要求拓展顶端迭代器的设计，使其适用于所有类型，不局限于整数。\n\n对于动态类型语言如 `JavaScript` 和 `Python`，不需要拓展上述设计。\n\n对于静态类型语言如 `Java`、`C#` 和 `C++`，可以通过使用泛型的方式拓展设计，在 `PeekingIterator` 类中定义泛型，使用时可以用任意类型。\n\n\n\n---\n\n\n\n### 总结：\n\n以前习惯将迭代器当作指针来看到，因为感觉上是大同小异，现在加深了对两者区别的理解：迭代器像是有固定方法的指针，不像指针那么随意，更像是名称所展示的那样包含“迭代”的思想\n\n","source":"_posts/2021-10-05-【LeetCode.284】顶端迭代器.md","raw":"---\ntitle: 【LeetCode.284】顶端迭代器\ndate: 2021-10-05 21:40:56\ncategories:\t算法\ntags:\n  - c++\n  - c#\n  - 迭代器\n---\n\n\n\n### \t题目：顶端迭代器\n\n请你设计一个迭代器，除了支持 `hasNext` 和 `next` 操作外，还支持 `peek` 操作。\n\n实现 `PeekingIterator` 类：\n\n`PeekingIterator(int[] nums)` 使用指定整数数组 `nums` 初始化迭代器。\n`int next()` 返回数组中的下一个元素，并将指针移动到下个元素处。\n`bool hasNext()` 如果数组中存在下一个元素，返回 `true` ；否则，返回 `false` 。\n`int peek()` 返回数组中的下一个元素，但 **不** 移动指针。\n\n<!--more-->\n\n\n\n\n示例：\n\n```\n输入：\n[\"PeekingIterator\", \"next\", \"peek\", \"next\", \"next\", \"hasNext\"]\n[[[1, 2, 3]], [], [], [], [], []]\n输出：\n[null, 1, 2, 2, 3, false]\n\n解释：\nPeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]\npeekingIterator.next();    // 返回 1 ，指针移动到下一个元素 [1,2,3]\npeekingIterator.peek();    // 返回 2 ，指针未发生移动 [1,2,3]\npeekingIterator.next();    // 返回 2 ，指针移动到下一个元素 [1,2,3]\npeekingIterator.next();    // 返回 3 ，指针移动到下一个元素 [1,2,3]\npeekingIterator.hasNext(); // 返回 False\n```\n\n\n\n提示：\n\n`1 <= nums.length <= 1000`\n`1 <= nums[i] <= 1000`\n`对 next 和 peek 的调用均有效`\n`next、hasNext 和 peek 最多调用  1000 次`\n\n\n\n\n进阶：你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？\n\n\n\n---\n\n\n\n### 分析：\n\n顶端迭代器需要实现以下三种操作：\n\n`next`：返回迭代器的下一个元素，并将指针向后移动一位；\n\n`hasNext`：判断迭代器中是否还有剩余的元素；\n\n`peek`：返回迭代器的下一个元素，不改变指针。\n\n\n\n每种编程语言自带的迭代器可能支持上述一种或多种操作，但是不一定支持上述全部操作。如果编程语言自带的迭代器本身就支持上述操作，可以直接使用，否则需要自定义实现。\n\n\n\n1. C++中`PeekingIterator`继承父类`Iterator`，`Iterator`已经实现方法`next`和`hasNext`，在此我们在`PeekingIterator`中主要实现`peek`方法即可。我们使用`flag`标记迭代器是否还有剩余元素，使用`nextElement`存储迭代器的下一个元素。\n\n`next`：首先用`ret`存储`nextElement`表示返回值，`flag`保存`Iterator`调用`hasNext`方法的返回结果，然后将`nextElement`向后移动一位，最后返回`ret`；\n\n`hasNext`：返回`flag`；\n\n`peek`：由于peek操作不改变指针，因此返回`nextElement`。\n\n\n\n2. C#的`IEnumerator`接口包含属性Current和方法`MoveNext`（该方法的返回值类型是`bool`，表示是否成功移动到下一个元素），三种操作都需要自定义实现，需要使用flag存储迭代器是否还有剩余的元素。\n\n`next`：首先用`ret`存储`iterator.Current`表示返回值，然后对`iterator`调用`MoveNext`方法使其向后移动一位并将该方法的结果赋值给`flag`，最后返回`ret`；\n\n`hasNext`：返回flag；\n\n`peek`：由于`peek`操作不改变指针，因此返回`iterator.Current`。\n\n\n\n---\n\n\n\n### 题解：\n\n1. C++\n\n```c++\nclass PeekingIterator : public Iterator {\npublic:\n\tPeekingIterator(const vector<int>& nums) : Iterator(nums) {\n\t    // Initialize any member here.\n\t    // **DO NOT** save a copy of nums and manipulate it directly.\n\t    // You should only use the Iterator interface methods.\n\t    flag = Iterator::hasNext();\n        if(flag){\n            nextElement = Iterator::next();\n        }\n\t}\n\t\n    // Returns the next element in the iteration without advancing the iterator.\n\tint peek() {\n        return nextElement;\n\t}\n\t\n\t// hasNext() and next() should behave the same as in the Iterator interface.\n\t// Override them if needed.\n\tint next() {\n\t    int ret = nextElement;\n        flag = Iterator::hasNext();\n        if(flag){\n            nextElement = Iterator::next();\n        }\n        return ret;\n\t}\n\t\n\tbool hasNext() const {\n\t    return flag;\n\t}\nprivate:\n    bool flag;\n    int nextElement;\n};\n```\n\n2. C#\n\n```c#\nclass PeekingIterator {\n    private IEnumerator<int> iterator;\n    private bool flag;\n\n    // iterators refers to the first element of the array.\n    public PeekingIterator(IEnumerator<int> iterator) {\n        // initialize any member here.\n        this.iterator = iterator;\n        flag = true;\n    }\n    \n    // Returns the next element in the iteration without advancing the iterator.\n    public int Peek() {\n        return iterator.Current;\n    }\n    \n    // Returns the next element in the iteration and advances the iterator.\n    public int Next() {\n        int ret = iterator.Current;\n        flag = iterator.MoveNext();\n        return ret;\n    }\n    \n    // Returns false if the iterator is refering to the end of the array of true otherwise.\n    public bool HasNext() {\n        return flag;\t\n    }\n}\n```\n\n\n\n---\n\n\n\n### 进阶：\n\n**进阶问题**\n进阶问题要求拓展顶端迭代器的设计，使其适用于所有类型，不局限于整数。\n\n对于动态类型语言如 `JavaScript` 和 `Python`，不需要拓展上述设计。\n\n对于静态类型语言如 `Java`、`C#` 和 `C++`，可以通过使用泛型的方式拓展设计，在 `PeekingIterator` 类中定义泛型，使用时可以用任意类型。\n\n\n\n---\n\n\n\n### 总结：\n\n以前习惯将迭代器当作指针来看到，因为感觉上是大同小异，现在加深了对两者区别的理解：迭代器像是有固定方法的指针，不像指针那么随意，更像是名称所展示的那样包含“迭代”的思想\n\n","slug":"2021-10-05-【LeetCode.284】顶端迭代器","published":1,"updated":"2021-10-06T09:00:00.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71i2002g1ou05ve3gacx","content":"<h3 id=\"题目：顶端迭代器\"><a href=\"#题目：顶端迭代器\" class=\"headerlink\" title=\"题目：顶端迭代器\"></a>题目：顶端迭代器</h3><p>请你设计一个迭代器，除了支持 <code>hasNext</code> 和 <code>next</code> 操作外，还支持 <code>peek</code> 操作。</p>\n<p>实现 <code>PeekingIterator</code> 类：</p>\n<p><code>PeekingIterator(int[] nums)</code> 使用指定整数数组 <code>nums</code> 初始化迭代器。<br><code>int next()</code> 返回数组中的下一个元素，并将指针移动到下个元素处。<br><code>bool hasNext()</code> 如果数组中存在下一个元素，返回 <code>true</code> ；否则，返回 <code>false</code> 。<br><code>int peek()</code> 返回数组中的下一个元素，但 <strong>不</strong> 移动指针。</p>\n<span id=\"more\"></span>\n\n\n\n\n<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;PeekingIterator&quot;, &quot;next&quot;, &quot;peek&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;]</span><br><span class=\"line\">[[[1, 2, 3]], [], [], [], [], []]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null, 1, 2, 2, 3, false]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]</span><br><span class=\"line\">peekingIterator.next();    // 返回 1 ，指针移动到下一个元素 [1,2,3]</span><br><span class=\"line\">peekingIterator.peek();    // 返回 2 ，指针未发生移动 [1,2,3]</span><br><span class=\"line\">peekingIterator.next();    // 返回 2 ，指针移动到下一个元素 [1,2,3]</span><br><span class=\"line\">peekingIterator.next();    // 返回 3 ，指针移动到下一个元素 [1,2,3]</span><br><span class=\"line\">peekingIterator.hasNext(); // 返回 False</span><br></pre></td></tr></table></figure>\n\n\n\n<p>提示：</p>\n<p><code>1 &lt;= nums.length &lt;= 1000</code><br><code>1 &lt;= nums[i] &lt;= 1000</code><br><code>对 next 和 peek 的调用均有效</code><br><code>next、hasNext 和 peek 最多调用  1000 次</code></p>\n<p>进阶：你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？</p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>顶端迭代器需要实现以下三种操作：</p>\n<p><code>next</code>：返回迭代器的下一个元素，并将指针向后移动一位；</p>\n<p><code>hasNext</code>：判断迭代器中是否还有剩余的元素；</p>\n<p><code>peek</code>：返回迭代器的下一个元素，不改变指针。</p>\n<p>每种编程语言自带的迭代器可能支持上述一种或多种操作，但是不一定支持上述全部操作。如果编程语言自带的迭代器本身就支持上述操作，可以直接使用，否则需要自定义实现。</p>\n<ol>\n<li>C++中<code>PeekingIterator</code>继承父类<code>Iterator</code>，<code>Iterator</code>已经实现方法<code>next</code>和<code>hasNext</code>，在此我们在<code>PeekingIterator</code>中主要实现<code>peek</code>方法即可。我们使用<code>flag</code>标记迭代器是否还有剩余元素，使用<code>nextElement</code>存储迭代器的下一个元素。</li>\n</ol>\n<p><code>next</code>：首先用<code>ret</code>存储<code>nextElement</code>表示返回值，<code>flag</code>保存<code>Iterator</code>调用<code>hasNext</code>方法的返回结果，然后将<code>nextElement</code>向后移动一位，最后返回<code>ret</code>；</p>\n<p><code>hasNext</code>：返回<code>flag</code>；</p>\n<p><code>peek</code>：由于peek操作不改变指针，因此返回<code>nextElement</code>。</p>\n<ol start=\"2\">\n<li>C#的<code>IEnumerator</code>接口包含属性Current和方法<code>MoveNext</code>（该方法的返回值类型是<code>bool</code>，表示是否成功移动到下一个元素），三种操作都需要自定义实现，需要使用flag存储迭代器是否还有剩余的元素。</li>\n</ol>\n<p><code>next</code>：首先用<code>ret</code>存储<code>iterator.Current</code>表示返回值，然后对<code>iterator</code>调用<code>MoveNext</code>方法使其向后移动一位并将该方法的结果赋值给<code>flag</code>，最后返回<code>ret</code>；</p>\n<p><code>hasNext</code>：返回flag；</p>\n<p><code>peek</code>：由于<code>peek</code>操作不改变指针，因此返回<code>iterator.Current</code>。</p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><ol>\n<li>C++</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PeekingIterator</span> :</span> <span class=\"keyword\">public</span> Iterator &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">PeekingIterator</span>(<span class=\"keyword\">const</span> vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) : <span class=\"built_in\">Iterator</span>(nums) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// Initialize any member here.</span></span><br><span class=\"line\">\t    <span class=\"comment\">// **DO NOT** save a copy of nums and manipulate it directly.</span></span><br><span class=\"line\">\t    <span class=\"comment\">// You should only use the Iterator interface methods.</span></span><br><span class=\"line\">\t    flag = Iterator::<span class=\"built_in\">hasNext</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag)&#123;</span><br><span class=\"line\">            nextElement = Iterator::<span class=\"built_in\">next</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// Returns the next element in the iteration without advancing the iterator.</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextElement;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// hasNext() and next() should behave the same as in the Iterator interface.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Override them if needed.</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">int</span> ret = nextElement;</span><br><span class=\"line\">        flag = Iterator::<span class=\"built_in\">hasNext</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag)&#123;</span><br><span class=\"line\">            nextElement = Iterator::<span class=\"built_in\">next</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextElement;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>C#</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class PeekingIterator &#123;</span><br><span class=\"line\">    private IEnumerator&lt;int&gt; iterator;</span><br><span class=\"line\">    private bool flag;</span><br><span class=\"line\"></span><br><span class=\"line\">    // iterators refers to the first element of the array.</span><br><span class=\"line\">    public PeekingIterator(IEnumerator&lt;int&gt; iterator) &#123;</span><br><span class=\"line\">        // initialize any member here.</span><br><span class=\"line\">        this.iterator = iterator;</span><br><span class=\"line\">        flag = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Returns the next element in the iteration without advancing the iterator.</span><br><span class=\"line\">    public int Peek() &#123;</span><br><span class=\"line\">        return iterator.Current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Returns the next element in the iteration and advances the iterator.</span><br><span class=\"line\">    public int Next() &#123;</span><br><span class=\"line\">        int ret = iterator.Current;</span><br><span class=\"line\">        flag = iterator.MoveNext();</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Returns false if the iterator is refering to the end of the array of true otherwise.</span><br><span class=\"line\">    public bool HasNext() &#123;</span><br><span class=\"line\">        return flag;\t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"进阶：\"><a href=\"#进阶：\" class=\"headerlink\" title=\"进阶：\"></a>进阶：</h3><p><strong>进阶问题</strong><br>进阶问题要求拓展顶端迭代器的设计，使其适用于所有类型，不局限于整数。</p>\n<p>对于动态类型语言如 <code>JavaScript</code> 和 <code>Python</code>，不需要拓展上述设计。</p>\n<p>对于静态类型语言如 <code>Java</code>、<code>C#</code> 和 <code>C++</code>，可以通过使用泛型的方式拓展设计，在 <code>PeekingIterator</code> 类中定义泛型，使用时可以用任意类型。</p>\n<hr>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>以前习惯将迭代器当作指针来看到，因为感觉上是大同小异，现在加深了对两者区别的理解：迭代器像是有固定方法的指针，不像指针那么随意，更像是名称所展示的那样包含“迭代”的思想</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"题目：顶端迭代器\"><a href=\"#题目：顶端迭代器\" class=\"headerlink\" title=\"题目：顶端迭代器\"></a>题目：顶端迭代器</h3><p>请你设计一个迭代器，除了支持 <code>hasNext</code> 和 <code>next</code> 操作外，还支持 <code>peek</code> 操作。</p>\n<p>实现 <code>PeekingIterator</code> 类：</p>\n<p><code>PeekingIterator(int[] nums)</code> 使用指定整数数组 <code>nums</code> 初始化迭代器。<br><code>int next()</code> 返回数组中的下一个元素，并将指针移动到下个元素处。<br><code>bool hasNext()</code> 如果数组中存在下一个元素，返回 <code>true</code> ；否则，返回 <code>false</code> 。<br><code>int peek()</code> 返回数组中的下一个元素，但 <strong>不</strong> 移动指针。</p>","more":"<p>示例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;PeekingIterator&quot;, &quot;next&quot;, &quot;peek&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;]</span><br><span class=\"line\">[[[1, 2, 3]], [], [], [], [], []]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null, 1, 2, 2, 3, false]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]</span><br><span class=\"line\">peekingIterator.next();    // 返回 1 ，指针移动到下一个元素 [1,2,3]</span><br><span class=\"line\">peekingIterator.peek();    // 返回 2 ，指针未发生移动 [1,2,3]</span><br><span class=\"line\">peekingIterator.next();    // 返回 2 ，指针移动到下一个元素 [1,2,3]</span><br><span class=\"line\">peekingIterator.next();    // 返回 3 ，指针移动到下一个元素 [1,2,3]</span><br><span class=\"line\">peekingIterator.hasNext(); // 返回 False</span><br></pre></td></tr></table></figure>\n\n\n\n<p>提示：</p>\n<p><code>1 &lt;= nums.length &lt;= 1000</code><br><code>1 &lt;= nums[i] &lt;= 1000</code><br><code>对 next 和 peek 的调用均有效</code><br><code>next、hasNext 和 peek 最多调用  1000 次</code></p>\n<p>进阶：你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？</p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>顶端迭代器需要实现以下三种操作：</p>\n<p><code>next</code>：返回迭代器的下一个元素，并将指针向后移动一位；</p>\n<p><code>hasNext</code>：判断迭代器中是否还有剩余的元素；</p>\n<p><code>peek</code>：返回迭代器的下一个元素，不改变指针。</p>\n<p>每种编程语言自带的迭代器可能支持上述一种或多种操作，但是不一定支持上述全部操作。如果编程语言自带的迭代器本身就支持上述操作，可以直接使用，否则需要自定义实现。</p>\n<ol>\n<li>C++中<code>PeekingIterator</code>继承父类<code>Iterator</code>，<code>Iterator</code>已经实现方法<code>next</code>和<code>hasNext</code>，在此我们在<code>PeekingIterator</code>中主要实现<code>peek</code>方法即可。我们使用<code>flag</code>标记迭代器是否还有剩余元素，使用<code>nextElement</code>存储迭代器的下一个元素。</li>\n</ol>\n<p><code>next</code>：首先用<code>ret</code>存储<code>nextElement</code>表示返回值，<code>flag</code>保存<code>Iterator</code>调用<code>hasNext</code>方法的返回结果，然后将<code>nextElement</code>向后移动一位，最后返回<code>ret</code>；</p>\n<p><code>hasNext</code>：返回<code>flag</code>；</p>\n<p><code>peek</code>：由于peek操作不改变指针，因此返回<code>nextElement</code>。</p>\n<ol start=\"2\">\n<li>C#的<code>IEnumerator</code>接口包含属性Current和方法<code>MoveNext</code>（该方法的返回值类型是<code>bool</code>，表示是否成功移动到下一个元素），三种操作都需要自定义实现，需要使用flag存储迭代器是否还有剩余的元素。</li>\n</ol>\n<p><code>next</code>：首先用<code>ret</code>存储<code>iterator.Current</code>表示返回值，然后对<code>iterator</code>调用<code>MoveNext</code>方法使其向后移动一位并将该方法的结果赋值给<code>flag</code>，最后返回<code>ret</code>；</p>\n<p><code>hasNext</code>：返回flag；</p>\n<p><code>peek</code>：由于<code>peek</code>操作不改变指针，因此返回<code>iterator.Current</code>。</p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><ol>\n<li>C++</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PeekingIterator</span> :</span> <span class=\"keyword\">public</span> Iterator &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">PeekingIterator</span>(<span class=\"keyword\">const</span> vector&lt;<span class=\"keyword\">int</span>&gt;&amp; nums) : <span class=\"built_in\">Iterator</span>(nums) &#123;</span><br><span class=\"line\">\t    <span class=\"comment\">// Initialize any member here.</span></span><br><span class=\"line\">\t    <span class=\"comment\">// **DO NOT** save a copy of nums and manipulate it directly.</span></span><br><span class=\"line\">\t    <span class=\"comment\">// You should only use the Iterator interface methods.</span></span><br><span class=\"line\">\t    flag = Iterator::<span class=\"built_in\">hasNext</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag)&#123;</span><br><span class=\"line\">            nextElement = Iterator::<span class=\"built_in\">next</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"comment\">// Returns the next element in the iteration without advancing the iterator.</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nextElement;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// hasNext() and next() should behave the same as in the Iterator interface.</span></span><br><span class=\"line\">\t<span class=\"comment\">// Override them if needed.</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">int</span> ret = nextElement;</span><br><span class=\"line\">        flag = Iterator::<span class=\"built_in\">hasNext</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag)&#123;</span><br><span class=\"line\">            nextElement = Iterator::<span class=\"built_in\">next</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nextElement;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>C#</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class PeekingIterator &#123;</span><br><span class=\"line\">    private IEnumerator&lt;int&gt; iterator;</span><br><span class=\"line\">    private bool flag;</span><br><span class=\"line\"></span><br><span class=\"line\">    // iterators refers to the first element of the array.</span><br><span class=\"line\">    public PeekingIterator(IEnumerator&lt;int&gt; iterator) &#123;</span><br><span class=\"line\">        // initialize any member here.</span><br><span class=\"line\">        this.iterator = iterator;</span><br><span class=\"line\">        flag = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Returns the next element in the iteration without advancing the iterator.</span><br><span class=\"line\">    public int Peek() &#123;</span><br><span class=\"line\">        return iterator.Current;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Returns the next element in the iteration and advances the iterator.</span><br><span class=\"line\">    public int Next() &#123;</span><br><span class=\"line\">        int ret = iterator.Current;</span><br><span class=\"line\">        flag = iterator.MoveNext();</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    // Returns false if the iterator is refering to the end of the array of true otherwise.</span><br><span class=\"line\">    public bool HasNext() &#123;</span><br><span class=\"line\">        return flag;\t</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"进阶：\"><a href=\"#进阶：\" class=\"headerlink\" title=\"进阶：\"></a>进阶：</h3><p><strong>进阶问题</strong><br>进阶问题要求拓展顶端迭代器的设计，使其适用于所有类型，不局限于整数。</p>\n<p>对于动态类型语言如 <code>JavaScript</code> 和 <code>Python</code>，不需要拓展上述设计。</p>\n<p>对于静态类型语言如 <code>Java</code>、<code>C#</code> 和 <code>C++</code>，可以通过使用泛型的方式拓展设计，在 <code>PeekingIterator</code> 类中定义泛型，使用时可以用任意类型。</p>\n<hr>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>以前习惯将迭代器当作指针来看到，因为感觉上是大同小异，现在加深了对两者区别的理解：迭代器像是有固定方法的指针，不像指针那么随意，更像是名称所展示的那样包含“迭代”的思想</p>"},{"title":"Python学习日志Day2","date":"2021-10-05T13:39:58.000Z","_content":"\n\n\n\n\n### \t一、if-else语句\n\n1.单分支if-else\n\n```\nscore = 60\nif score >= 60:\n    print('成绩及格')\n    pass\nelse:\n    print('成绩不及格')\n    pass\n```\n\n<!--more-->\n\n\n\n2.多分支elif\n\n```\nscore = 75\nif score >= 90:\n    print('您的成绩是A')\n    pass\nelif score >= 80:\n    print('您的成绩是B')\n    pass\nelif score >= 70:\n    print('您的成绩是C')\n    pass\nelif score >= 60:\n    print('您的成绩是D')\n    pass\nelse:\n    print('您的成绩是E')\n    pass\n```\n\n3.多分支if-else嵌套\n\n\n\n---\n\n\n\n### \t二、while循环\n\n1.猜拳机\n\n```\n#猜拳机\nimport random\ni = 1\nwhile i <= 3:\n    person = int(input('请出拳：[0：石头、1：剪刀、2：布]：'))\n    computer = random.randint(0, 2)\n    if person == 2 and computer == 0:\n        print('胜利！')\n        pass\n    elif person == 1 and computer == 2:\n        print('胜利！')\n        pass\n    elif person == 0 and computer == 1:\n        print('胜利！')\n        pass\n    elif person == computer:\n        print('平局')\n        pass\n    else:\n        print('失败~')\n        pass\n    i += 1\n    pass\n```\n\n\n\n---\n\n\n\n### 三、for循环\n\n1.遍历容器\n\n```\nfor data in range(1, 101):\n    print(data, end = ' ')\n    pass\n```\n\n\n\n---\n\n\n\n### 四、break、continue语句\n\n1.break和continue语句必须在循环当中使用\n\n2.continue结束当前循环并进入下一个循环\n\n3.break结束整个循环不再继续（while-else结构、for-else结构也是如此，不再执行else）\n\n","source":"_posts/2021-10-05-Python学习日志Day2.md","raw":"---\ntitle: Python学习日志Day2\ndate: 2021-10-05 21:39:58\ncategories:\tpython\ntags:\n  - pyhton\n---\n\n\n\n\n\n### \t一、if-else语句\n\n1.单分支if-else\n\n```\nscore = 60\nif score >= 60:\n    print('成绩及格')\n    pass\nelse:\n    print('成绩不及格')\n    pass\n```\n\n<!--more-->\n\n\n\n2.多分支elif\n\n```\nscore = 75\nif score >= 90:\n    print('您的成绩是A')\n    pass\nelif score >= 80:\n    print('您的成绩是B')\n    pass\nelif score >= 70:\n    print('您的成绩是C')\n    pass\nelif score >= 60:\n    print('您的成绩是D')\n    pass\nelse:\n    print('您的成绩是E')\n    pass\n```\n\n3.多分支if-else嵌套\n\n\n\n---\n\n\n\n### \t二、while循环\n\n1.猜拳机\n\n```\n#猜拳机\nimport random\ni = 1\nwhile i <= 3:\n    person = int(input('请出拳：[0：石头、1：剪刀、2：布]：'))\n    computer = random.randint(0, 2)\n    if person == 2 and computer == 0:\n        print('胜利！')\n        pass\n    elif person == 1 and computer == 2:\n        print('胜利！')\n        pass\n    elif person == 0 and computer == 1:\n        print('胜利！')\n        pass\n    elif person == computer:\n        print('平局')\n        pass\n    else:\n        print('失败~')\n        pass\n    i += 1\n    pass\n```\n\n\n\n---\n\n\n\n### 三、for循环\n\n1.遍历容器\n\n```\nfor data in range(1, 101):\n    print(data, end = ' ')\n    pass\n```\n\n\n\n---\n\n\n\n### 四、break、continue语句\n\n1.break和continue语句必须在循环当中使用\n\n2.continue结束当前循环并进入下一个循环\n\n3.break结束整个循环不再继续（while-else结构、for-else结构也是如此，不再执行else）\n\n","slug":"2021-10-05-Python学习日志Day2","published":1,"updated":"2021-10-06T07:05:39.339Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71i5002k1ou07gzv7ezc","content":"<h3 id=\"一、if-else语句\"><a href=\"#一、if-else语句\" class=\"headerlink\" title=\"一、if-else语句\"></a>一、if-else语句</h3><p>1.单分支if-else</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">score = 60</span><br><span class=\"line\">if score &gt;= 60:</span><br><span class=\"line\">    print(&#x27;成绩及格&#x27;)</span><br><span class=\"line\">    pass</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&#x27;成绩不及格&#x27;)</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n\n\n<p>2.多分支elif</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">score = 75</span><br><span class=\"line\">if score &gt;= 90:</span><br><span class=\"line\">    print(&#x27;您的成绩是A&#x27;)</span><br><span class=\"line\">    pass</span><br><span class=\"line\">elif score &gt;= 80:</span><br><span class=\"line\">    print(&#x27;您的成绩是B&#x27;)</span><br><span class=\"line\">    pass</span><br><span class=\"line\">elif score &gt;= 70:</span><br><span class=\"line\">    print(&#x27;您的成绩是C&#x27;)</span><br><span class=\"line\">    pass</span><br><span class=\"line\">elif score &gt;= 60:</span><br><span class=\"line\">    print(&#x27;您的成绩是D&#x27;)</span><br><span class=\"line\">    pass</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&#x27;您的成绩是E&#x27;)</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure>\n\n<p>3.多分支if-else嵌套</p>\n<hr>\n<h3 id=\"二、while循环\"><a href=\"#二、while循环\" class=\"headerlink\" title=\"二、while循环\"></a>二、while循环</h3><p>1.猜拳机</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#猜拳机</span><br><span class=\"line\">import random</span><br><span class=\"line\">i = 1</span><br><span class=\"line\">while i &lt;= 3:</span><br><span class=\"line\">    person = int(input(&#x27;请出拳：[0：石头、1：剪刀、2：布]：&#x27;))</span><br><span class=\"line\">    computer = random.randint(0, 2)</span><br><span class=\"line\">    if person == 2 and computer == 0:</span><br><span class=\"line\">        print(&#x27;胜利！&#x27;)</span><br><span class=\"line\">        pass</span><br><span class=\"line\">    elif person == 1 and computer == 2:</span><br><span class=\"line\">        print(&#x27;胜利！&#x27;)</span><br><span class=\"line\">        pass</span><br><span class=\"line\">    elif person == 0 and computer == 1:</span><br><span class=\"line\">        print(&#x27;胜利！&#x27;)</span><br><span class=\"line\">        pass</span><br><span class=\"line\">    elif person == computer:</span><br><span class=\"line\">        print(&#x27;平局&#x27;)</span><br><span class=\"line\">        pass</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(&#x27;失败~&#x27;)</span><br><span class=\"line\">        pass</span><br><span class=\"line\">    i += 1</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"三、for循环\"><a href=\"#三、for循环\" class=\"headerlink\" title=\"三、for循环\"></a>三、for循环</h3><p>1.遍历容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for data in range(1, 101):</span><br><span class=\"line\">    print(data, end = &#x27; &#x27;)</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"四、break、continue语句\"><a href=\"#四、break、continue语句\" class=\"headerlink\" title=\"四、break、continue语句\"></a>四、break、continue语句</h3><p>1.break和continue语句必须在循环当中使用</p>\n<p>2.continue结束当前循环并进入下一个循环</p>\n<p>3.break结束整个循环不再继续（while-else结构、for-else结构也是如此，不再执行else）</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"一、if-else语句\"><a href=\"#一、if-else语句\" class=\"headerlink\" title=\"一、if-else语句\"></a>一、if-else语句</h3><p>1.单分支if-else</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">score = 60</span><br><span class=\"line\">if score &gt;= 60:</span><br><span class=\"line\">    print(&#x27;成绩及格&#x27;)</span><br><span class=\"line\">    pass</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&#x27;成绩不及格&#x27;)</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure>","more":"<p>2.多分支elif</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">score = 75</span><br><span class=\"line\">if score &gt;= 90:</span><br><span class=\"line\">    print(&#x27;您的成绩是A&#x27;)</span><br><span class=\"line\">    pass</span><br><span class=\"line\">elif score &gt;= 80:</span><br><span class=\"line\">    print(&#x27;您的成绩是B&#x27;)</span><br><span class=\"line\">    pass</span><br><span class=\"line\">elif score &gt;= 70:</span><br><span class=\"line\">    print(&#x27;您的成绩是C&#x27;)</span><br><span class=\"line\">    pass</span><br><span class=\"line\">elif score &gt;= 60:</span><br><span class=\"line\">    print(&#x27;您的成绩是D&#x27;)</span><br><span class=\"line\">    pass</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(&#x27;您的成绩是E&#x27;)</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure>\n\n<p>3.多分支if-else嵌套</p>\n<hr>\n<h3 id=\"二、while循环\"><a href=\"#二、while循环\" class=\"headerlink\" title=\"二、while循环\"></a>二、while循环</h3><p>1.猜拳机</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#猜拳机</span><br><span class=\"line\">import random</span><br><span class=\"line\">i = 1</span><br><span class=\"line\">while i &lt;= 3:</span><br><span class=\"line\">    person = int(input(&#x27;请出拳：[0：石头、1：剪刀、2：布]：&#x27;))</span><br><span class=\"line\">    computer = random.randint(0, 2)</span><br><span class=\"line\">    if person == 2 and computer == 0:</span><br><span class=\"line\">        print(&#x27;胜利！&#x27;)</span><br><span class=\"line\">        pass</span><br><span class=\"line\">    elif person == 1 and computer == 2:</span><br><span class=\"line\">        print(&#x27;胜利！&#x27;)</span><br><span class=\"line\">        pass</span><br><span class=\"line\">    elif person == 0 and computer == 1:</span><br><span class=\"line\">        print(&#x27;胜利！&#x27;)</span><br><span class=\"line\">        pass</span><br><span class=\"line\">    elif person == computer:</span><br><span class=\"line\">        print(&#x27;平局&#x27;)</span><br><span class=\"line\">        pass</span><br><span class=\"line\">    else:</span><br><span class=\"line\">        print(&#x27;失败~&#x27;)</span><br><span class=\"line\">        pass</span><br><span class=\"line\">    i += 1</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"三、for循环\"><a href=\"#三、for循环\" class=\"headerlink\" title=\"三、for循环\"></a>三、for循环</h3><p>1.遍历容器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for data in range(1, 101):</span><br><span class=\"line\">    print(data, end = &#x27; &#x27;)</span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"四、break、continue语句\"><a href=\"#四、break、continue语句\" class=\"headerlink\" title=\"四、break、continue语句\"></a>四、break、continue语句</h3><p>1.break和continue语句必须在循环当中使用</p>\n<p>2.continue结束当前循环并进入下一个循环</p>\n<p>3.break结束整个循环不再继续（while-else结构、for-else结构也是如此，不再执行else）</p>"},{"title":"Python学习日志Day3","date":"2021-10-06T06:43:22.000Z","_content":"\n\n\n### \t始、Python数据类型\n\n序列：一组按照顺序排列的数据集合\n\nPython中有三种内置的序列类型：**字符串、列表、元组**\n\n​\t优点：支持**索引**和**切片**操作\n\n​\t特征：第一个正索引为0，指向左端，第一个索引为**负**数的时候指向**右**端\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、字符串\n\n切片：截取字符串中的其中一段内容\n\n语法：[起始下标：结束下标：步长]，`[start: end: step]`，不包含end，step默认是1\n\n```\n#切片\nstrMsg = 'hello world'\n#slice[start: end: step] 左闭右开\nprint(strMsg)\nprint(strMsg[2: 7: 1])\nprint(strMsg[2:])\nprint(strMsg[: 3])\nprint(strMsg[: : -1])\nprint(strMsg[: : -2])\n```\n\n输出：\n\n```\ni love python\nI LOVE PYTHON\nhello world\nllo w\nllo world\nhel\ndlrow olleh\ndrwolh\n```\n\n**下标会越界，切片不会**\n\n\n\n常用函数：\n\n1.`capitalize()`：将字符串首字母变成大写\n\n2.`strip()`：去除字符串中的空格\n\n3.`lstrip()`：去除字符串左边空格\n\n4.`rstrip()`：去除字符串右边空格\n\n5.`id()`：查看对象的内存地址\n\n6.`find()`：查找对象是否在序列中，返回第一个对象下标，不存在返回`-1`\n\n7.`index()`：检测字符串中是否包含子字符串，返回下标，不存在则报错\n\n8.`startswith()`：判断是否以某子串开头\n\n9.`endswith()`：判断是否以某子串结尾\n\n10.`lower()`：转换成小写\n\n11.`upper()`：转换成大写\n\n12.`join()`：循环取出所有值用xx去连接\n\n13.`split()`：切割字符串\n\n14.`count()`：统计出现的次数\n\n...\n\n```\n#常用函数\nname = 'peter'\nprint(name.capitalize())\n#\na = '          hello    '\nb = a.strip()\nprint(a)\nprint(b)\n#\nb = a\nprint('a的内存地址%d'%id(a))\nprint('b的内存地址%d'%id(b))\n#\ndataStr = 'I love python'\nprint(dataStr.find('p'))\nprint(dataStr.find('a'))\nprint(dataStr.index('o'))\n#\nprint(dataStr.startswith('I'))\nprint(dataStr.endswith('o'))\n#\nprint(dataStr.lower())\nprint(dataStr.upper())\n```\n\n输出：\n\n```\nPeter\n          hello\nhello\na的内存地址2290605664992\nb的内存地址2290605664992\n7\n3\nTrue\nFalse\ni love python\nI LOVE PYTHON\n```\n\n\n\n---\n\n\n\n### 二、元组\n\n元组是一种不可变的序列，创建之后不能做任何的修改，特点：\n\n​\t1.不可变\n\n​\t2.用（）创建元组类型，数据项之间用逗号分隔，数据项可以是任意数据类型\n\n​\t3.元组中只有一个元素时，要加逗号以免被当作其他类型\n\n​\t4.支持切片操作\n\n\n\n**元组不可修改，但是元组中的列表中的元素可以修改**\n\n常用方法与列表相似：\n\n```\ntupleA = (1, )\nprint(type(tupleA))\nprint(id(tupleA))\n\ntupleA = ('abcd', 66, 1.255, [22, 'fafa'])\nprint(tupleA)\nprint(id(tupleA))\n\nfor item in tupleA:\n    print(item, end = ' ')\n    pass\nprint()\n\nprint(tupleA[2: 4])\nprint(tupleA[-1: -4: -2]) #反向遍历下标从-1开始\nprint(tupleA[-4: -2: ])\n\ntupleA[3][0] = 66\nprint(tupleA)\n\nprint(tupleA.count(66)) #统计元素出现的次数\n```\n\n输出：\n\n```\n<class 'tuple'>\n1350340798616\n('abcd', 66, 1.255, [22, 'fafa'])\n1350340804424\nabcd 66 1.255 [22, 'fafa']\n(1.255, [22, 'fafa'])\n([22, 'fafa'], 66)\n('abcd', 66)\n('abcd', 66, 1.255, [66, 'fafa'])\n1\n```\n\n\n\n\n\n---\n\n\n\n### 三、列表\n\n列表是一种有序的数据集合，特点：\n\n​\t1.支持增删查改\n\n​\t2.列表中的数据可以变化\n\n​\t3.用[ ]表示列表类型，数据项之间用逗号分隔，数据项可以是任意数据类型\n\n​\t4.支持索引和切片操作\n\n\n\n常用方法：\n\n1.`append()`：在列表后面追加元素\n\n2.`count()`：统计元素出现的次数\n\n3.`extend()`：扩展，相当于批量添加\n\n4.`index()`：获取指定元素索引号\n\n5.`insert()`：在指定位置插入\n\n6.`pop()`：删除最后一个元素\n\n7.`remove()`：移除左边找到的第一个元素\n\n8.`reverse()`：反转列表\n\n9.`sort()`：列表排序\n\n10.`len()`：获取列表对象的数据个数\n\n\n\n```\n#列表\nli = []\nprint(type(li))\nli = [1, 2, 3, '你好']\nprint(len(li))\n\n#查找、遍历\nlistA = ['abcd', 785, 12.23, 'qiuzhi', True]\nprint(listA[3])\nprint(listA[1: 4]) #左闭右开\nprint(listA * 3)\nprint(listA.index(True))\n\n#增加\nlistA.append(['fff', 'ddd'])\nprint(listA)\nlistA.insert(1, '插入')\nprint(listA)\nrsData = list(range(10))\nlistA.append(rsData)\nprint(listA)\n\n#修改\nlistA[0] = 'peter'\nprint(listA)\n\n#删除\ndel listA[7]\nprint(listA)\ndel listA[1: 7: 5] #切片批量删除\nprint(listA)\nlistA.remove(785)\nprint(listA)\nlistA.pop()\nprint(listA)\nlistA.pop(0)\nprint(listA)\n```\n\n输出：\n\n```\n<class 'list'>\n4\nqiuzhi\n[785, 12.23, 'qiuzhi']\n['abcd', 785, 12.23, 'qiuzhi', True, 'abcd', 785, 12.23, 'qiuzhi', True, 'abcd', 785, 12.23, 'qiuzhi', True]\n4\n['abcd', 785, 12.23, 'qiuzhi', True, ['fff', 'ddd']]\n['abcd', '插入', 785, 12.23, 'qiuzhi', True, ['fff', 'ddd']]\n['abcd', '插入', 785, 12.23, 'qiuzhi', True, ['fff', 'ddd'], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]\n['peter', '插入', 785, 12.23, 'qiuzhi', True, ['fff', 'ddd'], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]\n['peter', '插入', 785, 12.23, 'qiuzhi', True, ['fff', 'ddd']]\n['peter', 785, 12.23, 'qiuzhi', True]\n['peter', 12.23, 'qiuzhi', True]\n['peter', 12.23, 'qiuzhi']\n[12.23, 'qiuzhi']\n```\n\n\n\n\n\n---\n\n\n\n### 四、字典\n\n字典是以键值对 `{‘key': 'value’}` 的形式创建并可以存储任意对象的数据类型\n\n键（key）不能重复，值（value）可以重复\n\n键（key）只能是不可变类型，如数字、字符串、元组\n\n字典不是序列类型， **没有下标**的概念，是一个无序的键值集合\n\n\n\n常用方法：\n\n1.`keys()`：获取所有的键\n\n2.`values()`：获取所有的值\n\n3.`items()`：获取所有的键值对\n\n4.`update()`：更新键值对，可以修改也可以添加\n\n5.`pop()`：删除指定键\n\n\n\n```\n#初始化\nfrom typing import ItemsView\ndictA = {'pro': '艺术', 'school': '北影'}\nprint(type(dictA))\n#赋值\ndictA['name'] = '刘德华'\ndictA['age'] = '50'\ndictA['pos'] = '影星'\nprint(dictA)\nprint(len(dictA))\nprint(dictA['name'])\n#修改\ndictA['name'] = '张家辉'\ndictA['school'] = '港大'\ndictA.update({'age': '40'})\ndictA.update({'height': '180'})\nprint(dictA)\n#输出\nprint(dictA.keys())\nprint(dictA.values())\nprint(dictA.items())\nfor key,value in dictA.items():\n    print('%s==%s'%(key, value))\n    pass\n#删除\ndel dictA['name']\ndictA.pop('age')\nprint(dictA)\n#排序\nprint(sorted(dictA.items(), key = lambda d: d[0]))\nprint(sorted(dictA.items(), key = lambda d: d[1]))\n```\n\n输出：\n\n```\n<class 'dict'>\n{'pro': '艺术', 'school': '北影', 'name': '刘德华', 'age': '50', 'pos': '影星'}\n5\n刘德华\n{'pro': '艺术', 'school': '港大', 'name': '张家辉', 'age': '40', 'pos': '影星', 'height': '180'}\ndict_keys(['pro', 'school', 'name', 'age', 'pos', 'height'])\ndict_values(['艺术', '港大', '张家辉', '40', '影星', '180'])\ndict_items([('pro', '艺术'), ('school', '港大'), ('name', '张家辉'), ('age', '40'), ('pos', '影星'), ('height', '180')])\npro==艺术\nschool==港大\nname==张家辉\nage==40\npos==影星\nheight==180\n{'pro': '艺术', 'school': '港大', 'pos': '影星', 'height': '180'}\n[('height', '180'), ('pos', '影星'), ('pro', '艺术'), ('school', '港大')]\n[('height', '180'), ('pos', '影星'), ('school', '港大'), ('pro', '艺术')]\n```\n\n\n\n\n\n\n\n---\n\n\n\n### 五、通用操作\n\n1.`+`：合并两个对象\n\n2.`*`：对象自身按指定次数复制合并\n\n3.`in`：判断元素是否存在\n\n\n\n```\n#\nstrA = '人生苦短'\nstrB = '我用Python'\nprint(strA + strB)\nlistA = list(range(11))\nlistB = list(range(11, 20))\nprint(listA + listB)\n#\nprint(strA * 3)\nprint(listA * 2)\n#\nprint('生' in strA)\nprint(8 in listA)\nprint(10 in listB)\ndictA = {'name': 'peter'}\nprint('name' in dictA)\n```\n\n输出：\n\n```\n人生苦短我用Python\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n人生苦短人生苦短人生苦短\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nTrue\nTrue\nFalse\nTrue\n```\n\n","source":"_posts/2021-10-06-Python学习日志Day3.md","raw":"---\ntitle: Python学习日志Day3\ndate: 2021-10-06 14:43:22\ncategories:\tpython\ntags:\n  - python\n  - 数据结构\n---\n\n\n\n### \t始、Python数据类型\n\n序列：一组按照顺序排列的数据集合\n\nPython中有三种内置的序列类型：**字符串、列表、元组**\n\n​\t优点：支持**索引**和**切片**操作\n\n​\t特征：第一个正索引为0，指向左端，第一个索引为**负**数的时候指向**右**端\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、字符串\n\n切片：截取字符串中的其中一段内容\n\n语法：[起始下标：结束下标：步长]，`[start: end: step]`，不包含end，step默认是1\n\n```\n#切片\nstrMsg = 'hello world'\n#slice[start: end: step] 左闭右开\nprint(strMsg)\nprint(strMsg[2: 7: 1])\nprint(strMsg[2:])\nprint(strMsg[: 3])\nprint(strMsg[: : -1])\nprint(strMsg[: : -2])\n```\n\n输出：\n\n```\ni love python\nI LOVE PYTHON\nhello world\nllo w\nllo world\nhel\ndlrow olleh\ndrwolh\n```\n\n**下标会越界，切片不会**\n\n\n\n常用函数：\n\n1.`capitalize()`：将字符串首字母变成大写\n\n2.`strip()`：去除字符串中的空格\n\n3.`lstrip()`：去除字符串左边空格\n\n4.`rstrip()`：去除字符串右边空格\n\n5.`id()`：查看对象的内存地址\n\n6.`find()`：查找对象是否在序列中，返回第一个对象下标，不存在返回`-1`\n\n7.`index()`：检测字符串中是否包含子字符串，返回下标，不存在则报错\n\n8.`startswith()`：判断是否以某子串开头\n\n9.`endswith()`：判断是否以某子串结尾\n\n10.`lower()`：转换成小写\n\n11.`upper()`：转换成大写\n\n12.`join()`：循环取出所有值用xx去连接\n\n13.`split()`：切割字符串\n\n14.`count()`：统计出现的次数\n\n...\n\n```\n#常用函数\nname = 'peter'\nprint(name.capitalize())\n#\na = '          hello    '\nb = a.strip()\nprint(a)\nprint(b)\n#\nb = a\nprint('a的内存地址%d'%id(a))\nprint('b的内存地址%d'%id(b))\n#\ndataStr = 'I love python'\nprint(dataStr.find('p'))\nprint(dataStr.find('a'))\nprint(dataStr.index('o'))\n#\nprint(dataStr.startswith('I'))\nprint(dataStr.endswith('o'))\n#\nprint(dataStr.lower())\nprint(dataStr.upper())\n```\n\n输出：\n\n```\nPeter\n          hello\nhello\na的内存地址2290605664992\nb的内存地址2290605664992\n7\n3\nTrue\nFalse\ni love python\nI LOVE PYTHON\n```\n\n\n\n---\n\n\n\n### 二、元组\n\n元组是一种不可变的序列，创建之后不能做任何的修改，特点：\n\n​\t1.不可变\n\n​\t2.用（）创建元组类型，数据项之间用逗号分隔，数据项可以是任意数据类型\n\n​\t3.元组中只有一个元素时，要加逗号以免被当作其他类型\n\n​\t4.支持切片操作\n\n\n\n**元组不可修改，但是元组中的列表中的元素可以修改**\n\n常用方法与列表相似：\n\n```\ntupleA = (1, )\nprint(type(tupleA))\nprint(id(tupleA))\n\ntupleA = ('abcd', 66, 1.255, [22, 'fafa'])\nprint(tupleA)\nprint(id(tupleA))\n\nfor item in tupleA:\n    print(item, end = ' ')\n    pass\nprint()\n\nprint(tupleA[2: 4])\nprint(tupleA[-1: -4: -2]) #反向遍历下标从-1开始\nprint(tupleA[-4: -2: ])\n\ntupleA[3][0] = 66\nprint(tupleA)\n\nprint(tupleA.count(66)) #统计元素出现的次数\n```\n\n输出：\n\n```\n<class 'tuple'>\n1350340798616\n('abcd', 66, 1.255, [22, 'fafa'])\n1350340804424\nabcd 66 1.255 [22, 'fafa']\n(1.255, [22, 'fafa'])\n([22, 'fafa'], 66)\n('abcd', 66)\n('abcd', 66, 1.255, [66, 'fafa'])\n1\n```\n\n\n\n\n\n---\n\n\n\n### 三、列表\n\n列表是一种有序的数据集合，特点：\n\n​\t1.支持增删查改\n\n​\t2.列表中的数据可以变化\n\n​\t3.用[ ]表示列表类型，数据项之间用逗号分隔，数据项可以是任意数据类型\n\n​\t4.支持索引和切片操作\n\n\n\n常用方法：\n\n1.`append()`：在列表后面追加元素\n\n2.`count()`：统计元素出现的次数\n\n3.`extend()`：扩展，相当于批量添加\n\n4.`index()`：获取指定元素索引号\n\n5.`insert()`：在指定位置插入\n\n6.`pop()`：删除最后一个元素\n\n7.`remove()`：移除左边找到的第一个元素\n\n8.`reverse()`：反转列表\n\n9.`sort()`：列表排序\n\n10.`len()`：获取列表对象的数据个数\n\n\n\n```\n#列表\nli = []\nprint(type(li))\nli = [1, 2, 3, '你好']\nprint(len(li))\n\n#查找、遍历\nlistA = ['abcd', 785, 12.23, 'qiuzhi', True]\nprint(listA[3])\nprint(listA[1: 4]) #左闭右开\nprint(listA * 3)\nprint(listA.index(True))\n\n#增加\nlistA.append(['fff', 'ddd'])\nprint(listA)\nlistA.insert(1, '插入')\nprint(listA)\nrsData = list(range(10))\nlistA.append(rsData)\nprint(listA)\n\n#修改\nlistA[0] = 'peter'\nprint(listA)\n\n#删除\ndel listA[7]\nprint(listA)\ndel listA[1: 7: 5] #切片批量删除\nprint(listA)\nlistA.remove(785)\nprint(listA)\nlistA.pop()\nprint(listA)\nlistA.pop(0)\nprint(listA)\n```\n\n输出：\n\n```\n<class 'list'>\n4\nqiuzhi\n[785, 12.23, 'qiuzhi']\n['abcd', 785, 12.23, 'qiuzhi', True, 'abcd', 785, 12.23, 'qiuzhi', True, 'abcd', 785, 12.23, 'qiuzhi', True]\n4\n['abcd', 785, 12.23, 'qiuzhi', True, ['fff', 'ddd']]\n['abcd', '插入', 785, 12.23, 'qiuzhi', True, ['fff', 'ddd']]\n['abcd', '插入', 785, 12.23, 'qiuzhi', True, ['fff', 'ddd'], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]\n['peter', '插入', 785, 12.23, 'qiuzhi', True, ['fff', 'ddd'], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]\n['peter', '插入', 785, 12.23, 'qiuzhi', True, ['fff', 'ddd']]\n['peter', 785, 12.23, 'qiuzhi', True]\n['peter', 12.23, 'qiuzhi', True]\n['peter', 12.23, 'qiuzhi']\n[12.23, 'qiuzhi']\n```\n\n\n\n\n\n---\n\n\n\n### 四、字典\n\n字典是以键值对 `{‘key': 'value’}` 的形式创建并可以存储任意对象的数据类型\n\n键（key）不能重复，值（value）可以重复\n\n键（key）只能是不可变类型，如数字、字符串、元组\n\n字典不是序列类型， **没有下标**的概念，是一个无序的键值集合\n\n\n\n常用方法：\n\n1.`keys()`：获取所有的键\n\n2.`values()`：获取所有的值\n\n3.`items()`：获取所有的键值对\n\n4.`update()`：更新键值对，可以修改也可以添加\n\n5.`pop()`：删除指定键\n\n\n\n```\n#初始化\nfrom typing import ItemsView\ndictA = {'pro': '艺术', 'school': '北影'}\nprint(type(dictA))\n#赋值\ndictA['name'] = '刘德华'\ndictA['age'] = '50'\ndictA['pos'] = '影星'\nprint(dictA)\nprint(len(dictA))\nprint(dictA['name'])\n#修改\ndictA['name'] = '张家辉'\ndictA['school'] = '港大'\ndictA.update({'age': '40'})\ndictA.update({'height': '180'})\nprint(dictA)\n#输出\nprint(dictA.keys())\nprint(dictA.values())\nprint(dictA.items())\nfor key,value in dictA.items():\n    print('%s==%s'%(key, value))\n    pass\n#删除\ndel dictA['name']\ndictA.pop('age')\nprint(dictA)\n#排序\nprint(sorted(dictA.items(), key = lambda d: d[0]))\nprint(sorted(dictA.items(), key = lambda d: d[1]))\n```\n\n输出：\n\n```\n<class 'dict'>\n{'pro': '艺术', 'school': '北影', 'name': '刘德华', 'age': '50', 'pos': '影星'}\n5\n刘德华\n{'pro': '艺术', 'school': '港大', 'name': '张家辉', 'age': '40', 'pos': '影星', 'height': '180'}\ndict_keys(['pro', 'school', 'name', 'age', 'pos', 'height'])\ndict_values(['艺术', '港大', '张家辉', '40', '影星', '180'])\ndict_items([('pro', '艺术'), ('school', '港大'), ('name', '张家辉'), ('age', '40'), ('pos', '影星'), ('height', '180')])\npro==艺术\nschool==港大\nname==张家辉\nage==40\npos==影星\nheight==180\n{'pro': '艺术', 'school': '港大', 'pos': '影星', 'height': '180'}\n[('height', '180'), ('pos', '影星'), ('pro', '艺术'), ('school', '港大')]\n[('height', '180'), ('pos', '影星'), ('school', '港大'), ('pro', '艺术')]\n```\n\n\n\n\n\n\n\n---\n\n\n\n### 五、通用操作\n\n1.`+`：合并两个对象\n\n2.`*`：对象自身按指定次数复制合并\n\n3.`in`：判断元素是否存在\n\n\n\n```\n#\nstrA = '人生苦短'\nstrB = '我用Python'\nprint(strA + strB)\nlistA = list(range(11))\nlistB = list(range(11, 20))\nprint(listA + listB)\n#\nprint(strA * 3)\nprint(listA * 2)\n#\nprint('生' in strA)\nprint(8 in listA)\nprint(10 in listB)\ndictA = {'name': 'peter'}\nprint('name' in dictA)\n```\n\n输出：\n\n```\n人生苦短我用Python\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n人生苦短人生苦短人生苦短\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nTrue\nTrue\nFalse\nTrue\n```\n\n","slug":"2021-10-06-Python学习日志Day3","published":1,"updated":"2021-10-14T07:39:56.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71i6002m1ou0702ca658","content":"<h3 id=\"始、Python数据类型\"><a href=\"#始、Python数据类型\" class=\"headerlink\" title=\"始、Python数据类型\"></a>始、Python数据类型</h3><p>序列：一组按照顺序排列的数据集合</p>\n<p>Python中有三种内置的序列类型：<strong>字符串、列表、元组</strong></p>\n<p>​    优点：支持<strong>索引</strong>和<strong>切片</strong>操作</p>\n<p>​    特征：第一个正索引为0，指向左端，第一个索引为<strong>负</strong>数的时候指向<strong>右</strong>端</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、字符串\"><a href=\"#一、字符串\" class=\"headerlink\" title=\"一、字符串\"></a>一、字符串</h3><p>切片：截取字符串中的其中一段内容</p>\n<p>语法：[起始下标：结束下标：步长]，<code>[start: end: step]</code>，不包含end，step默认是1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#切片</span><br><span class=\"line\">strMsg = &#x27;hello world&#x27;</span><br><span class=\"line\">#slice[start: end: step] 左闭右开</span><br><span class=\"line\">print(strMsg)</span><br><span class=\"line\">print(strMsg[2: 7: 1])</span><br><span class=\"line\">print(strMsg[2:])</span><br><span class=\"line\">print(strMsg[: 3])</span><br><span class=\"line\">print(strMsg[: : -1])</span><br><span class=\"line\">print(strMsg[: : -2])</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i love python</span><br><span class=\"line\">I LOVE PYTHON</span><br><span class=\"line\">hello world</span><br><span class=\"line\">llo w</span><br><span class=\"line\">llo world</span><br><span class=\"line\">hel</span><br><span class=\"line\">dlrow olleh</span><br><span class=\"line\">drwolh</span><br></pre></td></tr></table></figure>\n\n<p><strong>下标会越界，切片不会</strong></p>\n<p>常用函数：</p>\n<p>1.<code>capitalize()</code>：将字符串首字母变成大写</p>\n<p>2.<code>strip()</code>：去除字符串中的空格</p>\n<p>3.<code>lstrip()</code>：去除字符串左边空格</p>\n<p>4.<code>rstrip()</code>：去除字符串右边空格</p>\n<p>5.<code>id()</code>：查看对象的内存地址</p>\n<p>6.<code>find()</code>：查找对象是否在序列中，返回第一个对象下标，不存在返回<code>-1</code></p>\n<p>7.<code>index()</code>：检测字符串中是否包含子字符串，返回下标，不存在则报错</p>\n<p>8.<code>startswith()</code>：判断是否以某子串开头</p>\n<p>9.<code>endswith()</code>：判断是否以某子串结尾</p>\n<p>10.<code>lower()</code>：转换成小写</p>\n<p>11.<code>upper()</code>：转换成大写</p>\n<p>12.<code>join()</code>：循环取出所有值用xx去连接</p>\n<p>13.<code>split()</code>：切割字符串</p>\n<p>14.<code>count()</code>：统计出现的次数</p>\n<p>…</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#常用函数</span><br><span class=\"line\">name = &#x27;peter&#x27;</span><br><span class=\"line\">print(name.capitalize())</span><br><span class=\"line\">#</span><br><span class=\"line\">a = &#x27;          hello    &#x27;</span><br><span class=\"line\">b = a.strip()</span><br><span class=\"line\">print(a)</span><br><span class=\"line\">print(b)</span><br><span class=\"line\">#</span><br><span class=\"line\">b = a</span><br><span class=\"line\">print(&#x27;a的内存地址%d&#x27;%id(a))</span><br><span class=\"line\">print(&#x27;b的内存地址%d&#x27;%id(b))</span><br><span class=\"line\">#</span><br><span class=\"line\">dataStr = &#x27;I love python&#x27;</span><br><span class=\"line\">print(dataStr.find(&#x27;p&#x27;))</span><br><span class=\"line\">print(dataStr.find(&#x27;a&#x27;))</span><br><span class=\"line\">print(dataStr.index(&#x27;o&#x27;))</span><br><span class=\"line\">#</span><br><span class=\"line\">print(dataStr.startswith(&#x27;I&#x27;))</span><br><span class=\"line\">print(dataStr.endswith(&#x27;o&#x27;))</span><br><span class=\"line\">#</span><br><span class=\"line\">print(dataStr.lower())</span><br><span class=\"line\">print(dataStr.upper())</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Peter</span><br><span class=\"line\">          hello</span><br><span class=\"line\">hello</span><br><span class=\"line\">a的内存地址2290605664992</span><br><span class=\"line\">b的内存地址2290605664992</span><br><span class=\"line\">7</span><br><span class=\"line\">3</span><br><span class=\"line\">True</span><br><span class=\"line\">False</span><br><span class=\"line\">i love python</span><br><span class=\"line\">I LOVE PYTHON</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"二、元组\"><a href=\"#二、元组\" class=\"headerlink\" title=\"二、元组\"></a>二、元组</h3><p>元组是一种不可变的序列，创建之后不能做任何的修改，特点：</p>\n<p>​    1.不可变</p>\n<p>​    2.用（）创建元组类型，数据项之间用逗号分隔，数据项可以是任意数据类型</p>\n<p>​    3.元组中只有一个元素时，要加逗号以免被当作其他类型</p>\n<p>​    4.支持切片操作</p>\n<p><strong>元组不可修改，但是元组中的列表中的元素可以修改</strong></p>\n<p>常用方法与列表相似：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tupleA = (1, )</span><br><span class=\"line\">print(type(tupleA))</span><br><span class=\"line\">print(id(tupleA))</span><br><span class=\"line\"></span><br><span class=\"line\">tupleA = (&#x27;abcd&#x27;, 66, 1.255, [22, &#x27;fafa&#x27;])</span><br><span class=\"line\">print(tupleA)</span><br><span class=\"line\">print(id(tupleA))</span><br><span class=\"line\"></span><br><span class=\"line\">for item in tupleA:</span><br><span class=\"line\">    print(item, end = &#x27; &#x27;)</span><br><span class=\"line\">    pass</span><br><span class=\"line\">print()</span><br><span class=\"line\"></span><br><span class=\"line\">print(tupleA[2: 4])</span><br><span class=\"line\">print(tupleA[-1: -4: -2]) #反向遍历下标从-1开始</span><br><span class=\"line\">print(tupleA[-4: -2: ])</span><br><span class=\"line\"></span><br><span class=\"line\">tupleA[3][0] = 66</span><br><span class=\"line\">print(tupleA)</span><br><span class=\"line\"></span><br><span class=\"line\">print(tupleA.count(66)) #统计元素出现的次数</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &#x27;tuple&#x27;&gt;</span><br><span class=\"line\">1350340798616</span><br><span class=\"line\">(&#x27;abcd&#x27;, 66, 1.255, [22, &#x27;fafa&#x27;])</span><br><span class=\"line\">1350340804424</span><br><span class=\"line\">abcd 66 1.255 [22, &#x27;fafa&#x27;]</span><br><span class=\"line\">(1.255, [22, &#x27;fafa&#x27;])</span><br><span class=\"line\">([22, &#x27;fafa&#x27;], 66)</span><br><span class=\"line\">(&#x27;abcd&#x27;, 66)</span><br><span class=\"line\">(&#x27;abcd&#x27;, 66, 1.255, [66, &#x27;fafa&#x27;])</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<hr>\n<h3 id=\"三、列表\"><a href=\"#三、列表\" class=\"headerlink\" title=\"三、列表\"></a>三、列表</h3><p>列表是一种有序的数据集合，特点：</p>\n<p>​    1.支持增删查改</p>\n<p>​    2.列表中的数据可以变化</p>\n<p>​    3.用[ ]表示列表类型，数据项之间用逗号分隔，数据项可以是任意数据类型</p>\n<p>​    4.支持索引和切片操作</p>\n<p>常用方法：</p>\n<p>1.<code>append()</code>：在列表后面追加元素</p>\n<p>2.<code>count()</code>：统计元素出现的次数</p>\n<p>3.<code>extend()</code>：扩展，相当于批量添加</p>\n<p>4.<code>index()</code>：获取指定元素索引号</p>\n<p>5.<code>insert()</code>：在指定位置插入</p>\n<p>6.<code>pop()</code>：删除最后一个元素</p>\n<p>7.<code>remove()</code>：移除左边找到的第一个元素</p>\n<p>8.<code>reverse()</code>：反转列表</p>\n<p>9.<code>sort()</code>：列表排序</p>\n<p>10.<code>len()</code>：获取列表对象的数据个数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#列表</span><br><span class=\"line\">li = []</span><br><span class=\"line\">print(type(li))</span><br><span class=\"line\">li = [1, 2, 3, &#x27;你好&#x27;]</span><br><span class=\"line\">print(len(li))</span><br><span class=\"line\"></span><br><span class=\"line\">#查找、遍历</span><br><span class=\"line\">listA = [&#x27;abcd&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True]</span><br><span class=\"line\">print(listA[3])</span><br><span class=\"line\">print(listA[1: 4]) #左闭右开</span><br><span class=\"line\">print(listA * 3)</span><br><span class=\"line\">print(listA.index(True))</span><br><span class=\"line\"></span><br><span class=\"line\">#增加</span><br><span class=\"line\">listA.append([&#x27;fff&#x27;, &#x27;ddd&#x27;])</span><br><span class=\"line\">print(listA)</span><br><span class=\"line\">listA.insert(1, &#x27;插入&#x27;)</span><br><span class=\"line\">print(listA)</span><br><span class=\"line\">rsData = list(range(10))</span><br><span class=\"line\">listA.append(rsData)</span><br><span class=\"line\">print(listA)</span><br><span class=\"line\"></span><br><span class=\"line\">#修改</span><br><span class=\"line\">listA[0] = &#x27;peter&#x27;</span><br><span class=\"line\">print(listA)</span><br><span class=\"line\"></span><br><span class=\"line\">#删除</span><br><span class=\"line\">del listA[7]</span><br><span class=\"line\">print(listA)</span><br><span class=\"line\">del listA[1: 7: 5] #切片批量删除</span><br><span class=\"line\">print(listA)</span><br><span class=\"line\">listA.remove(785)</span><br><span class=\"line\">print(listA)</span><br><span class=\"line\">listA.pop()</span><br><span class=\"line\">print(listA)</span><br><span class=\"line\">listA.pop(0)</span><br><span class=\"line\">print(listA)</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &#x27;list&#x27;&gt;</span><br><span class=\"line\">4</span><br><span class=\"line\">qiuzhi</span><br><span class=\"line\">[785, 12.23, &#x27;qiuzhi&#x27;]</span><br><span class=\"line\">[&#x27;abcd&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, &#x27;abcd&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, &#x27;abcd&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True]</span><br><span class=\"line\">4</span><br><span class=\"line\">[&#x27;abcd&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, [&#x27;fff&#x27;, &#x27;ddd&#x27;]]</span><br><span class=\"line\">[&#x27;abcd&#x27;, &#x27;插入&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, [&#x27;fff&#x27;, &#x27;ddd&#x27;]]</span><br><span class=\"line\">[&#x27;abcd&#x27;, &#x27;插入&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, [&#x27;fff&#x27;, &#x27;ddd&#x27;], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]</span><br><span class=\"line\">[&#x27;peter&#x27;, &#x27;插入&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, [&#x27;fff&#x27;, &#x27;ddd&#x27;], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]</span><br><span class=\"line\">[&#x27;peter&#x27;, &#x27;插入&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, [&#x27;fff&#x27;, &#x27;ddd&#x27;]]</span><br><span class=\"line\">[&#x27;peter&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True]</span><br><span class=\"line\">[&#x27;peter&#x27;, 12.23, &#x27;qiuzhi&#x27;, True]</span><br><span class=\"line\">[&#x27;peter&#x27;, 12.23, &#x27;qiuzhi&#x27;]</span><br><span class=\"line\">[12.23, &#x27;qiuzhi&#x27;]</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<hr>\n<h3 id=\"四、字典\"><a href=\"#四、字典\" class=\"headerlink\" title=\"四、字典\"></a>四、字典</h3><p>字典是以键值对 <code>&#123;‘key&#39;: &#39;value’&#125;</code> 的形式创建并可以存储任意对象的数据类型</p>\n<p>键（key）不能重复，值（value）可以重复</p>\n<p>键（key）只能是不可变类型，如数字、字符串、元组</p>\n<p>字典不是序列类型， <strong>没有下标</strong>的概念，是一个无序的键值集合</p>\n<p>常用方法：</p>\n<p>1.<code>keys()</code>：获取所有的键</p>\n<p>2.<code>values()</code>：获取所有的值</p>\n<p>3.<code>items()</code>：获取所有的键值对</p>\n<p>4.<code>update()</code>：更新键值对，可以修改也可以添加</p>\n<p>5.<code>pop()</code>：删除指定键</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#初始化</span><br><span class=\"line\">from typing import ItemsView</span><br><span class=\"line\">dictA = &#123;&#x27;pro&#x27;: &#x27;艺术&#x27;, &#x27;school&#x27;: &#x27;北影&#x27;&#125;</span><br><span class=\"line\">print(type(dictA))</span><br><span class=\"line\">#赋值</span><br><span class=\"line\">dictA[&#x27;name&#x27;] = &#x27;刘德华&#x27;</span><br><span class=\"line\">dictA[&#x27;age&#x27;] = &#x27;50&#x27;</span><br><span class=\"line\">dictA[&#x27;pos&#x27;] = &#x27;影星&#x27;</span><br><span class=\"line\">print(dictA)</span><br><span class=\"line\">print(len(dictA))</span><br><span class=\"line\">print(dictA[&#x27;name&#x27;])</span><br><span class=\"line\">#修改</span><br><span class=\"line\">dictA[&#x27;name&#x27;] = &#x27;张家辉&#x27;</span><br><span class=\"line\">dictA[&#x27;school&#x27;] = &#x27;港大&#x27;</span><br><span class=\"line\">dictA.update(&#123;&#x27;age&#x27;: &#x27;40&#x27;&#125;)</span><br><span class=\"line\">dictA.update(&#123;&#x27;height&#x27;: &#x27;180&#x27;&#125;)</span><br><span class=\"line\">print(dictA)</span><br><span class=\"line\">#输出</span><br><span class=\"line\">print(dictA.keys())</span><br><span class=\"line\">print(dictA.values())</span><br><span class=\"line\">print(dictA.items())</span><br><span class=\"line\">for key,value in dictA.items():</span><br><span class=\"line\">    print(&#x27;%s==%s&#x27;%(key, value))</span><br><span class=\"line\">    pass</span><br><span class=\"line\">#删除</span><br><span class=\"line\">del dictA[&#x27;name&#x27;]</span><br><span class=\"line\">dictA.pop(&#x27;age&#x27;)</span><br><span class=\"line\">print(dictA)</span><br><span class=\"line\">#排序</span><br><span class=\"line\">print(sorted(dictA.items(), key = lambda d: d[0]))</span><br><span class=\"line\">print(sorted(dictA.items(), key = lambda d: d[1]))</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &#x27;dict&#x27;&gt;</span><br><span class=\"line\">&#123;&#x27;pro&#x27;: &#x27;艺术&#x27;, &#x27;school&#x27;: &#x27;北影&#x27;, &#x27;name&#x27;: &#x27;刘德华&#x27;, &#x27;age&#x27;: &#x27;50&#x27;, &#x27;pos&#x27;: &#x27;影星&#x27;&#125;</span><br><span class=\"line\">5</span><br><span class=\"line\">刘德华</span><br><span class=\"line\">&#123;&#x27;pro&#x27;: &#x27;艺术&#x27;, &#x27;school&#x27;: &#x27;港大&#x27;, &#x27;name&#x27;: &#x27;张家辉&#x27;, &#x27;age&#x27;: &#x27;40&#x27;, &#x27;pos&#x27;: &#x27;影星&#x27;, &#x27;height&#x27;: &#x27;180&#x27;&#125;</span><br><span class=\"line\">dict_keys([&#x27;pro&#x27;, &#x27;school&#x27;, &#x27;name&#x27;, &#x27;age&#x27;, &#x27;pos&#x27;, &#x27;height&#x27;])</span><br><span class=\"line\">dict_values([&#x27;艺术&#x27;, &#x27;港大&#x27;, &#x27;张家辉&#x27;, &#x27;40&#x27;, &#x27;影星&#x27;, &#x27;180&#x27;])</span><br><span class=\"line\">dict_items([(&#x27;pro&#x27;, &#x27;艺术&#x27;), (&#x27;school&#x27;, &#x27;港大&#x27;), (&#x27;name&#x27;, &#x27;张家辉&#x27;), (&#x27;age&#x27;, &#x27;40&#x27;), (&#x27;pos&#x27;, &#x27;影星&#x27;), (&#x27;height&#x27;, &#x27;180&#x27;)])</span><br><span class=\"line\">pro==艺术</span><br><span class=\"line\">school==港大</span><br><span class=\"line\">name==张家辉</span><br><span class=\"line\">age==40</span><br><span class=\"line\">pos==影星</span><br><span class=\"line\">height==180</span><br><span class=\"line\">&#123;&#x27;pro&#x27;: &#x27;艺术&#x27;, &#x27;school&#x27;: &#x27;港大&#x27;, &#x27;pos&#x27;: &#x27;影星&#x27;, &#x27;height&#x27;: &#x27;180&#x27;&#125;</span><br><span class=\"line\">[(&#x27;height&#x27;, &#x27;180&#x27;), (&#x27;pos&#x27;, &#x27;影星&#x27;), (&#x27;pro&#x27;, &#x27;艺术&#x27;), (&#x27;school&#x27;, &#x27;港大&#x27;)]</span><br><span class=\"line\">[(&#x27;height&#x27;, &#x27;180&#x27;), (&#x27;pos&#x27;, &#x27;影星&#x27;), (&#x27;school&#x27;, &#x27;港大&#x27;), (&#x27;pro&#x27;, &#x27;艺术&#x27;)]</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<hr>\n<h3 id=\"五、通用操作\"><a href=\"#五、通用操作\" class=\"headerlink\" title=\"五、通用操作\"></a>五、通用操作</h3><p>1.<code>+</code>：合并两个对象</p>\n<p>2.<code>*</code>：对象自身按指定次数复制合并</p>\n<p>3.<code>in</code>：判断元素是否存在</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#</span><br><span class=\"line\">strA = &#x27;人生苦短&#x27;</span><br><span class=\"line\">strB = &#x27;我用Python&#x27;</span><br><span class=\"line\">print(strA + strB)</span><br><span class=\"line\">listA = list(range(11))</span><br><span class=\"line\">listB = list(range(11, 20))</span><br><span class=\"line\">print(listA + listB)</span><br><span class=\"line\">#</span><br><span class=\"line\">print(strA * 3)</span><br><span class=\"line\">print(listA * 2)</span><br><span class=\"line\">#</span><br><span class=\"line\">print(&#x27;生&#x27; in strA)</span><br><span class=\"line\">print(8 in listA)</span><br><span class=\"line\">print(10 in listB)</span><br><span class=\"line\">dictA = &#123;&#x27;name&#x27;: &#x27;peter&#x27;&#125;</span><br><span class=\"line\">print(&#x27;name&#x27; in dictA)</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">人生苦短我用Python</span><br><span class=\"line\">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span><br><span class=\"line\">人生苦短人生苦短人生苦短</span><br><span class=\"line\">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class=\"line\">True</span><br><span class=\"line\">True</span><br><span class=\"line\">False</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、Python数据类型\"><a href=\"#始、Python数据类型\" class=\"headerlink\" title=\"始、Python数据类型\"></a>始、Python数据类型</h3><p>序列：一组按照顺序排列的数据集合</p>\n<p>Python中有三种内置的序列类型：<strong>字符串、列表、元组</strong></p>\n<p>​    优点：支持<strong>索引</strong>和<strong>切片</strong>操作</p>\n<p>​    特征：第一个正索引为0，指向左端，第一个索引为<strong>负</strong>数的时候指向<strong>右</strong>端</p>","more":"<hr>\n<h3 id=\"一、字符串\"><a href=\"#一、字符串\" class=\"headerlink\" title=\"一、字符串\"></a>一、字符串</h3><p>切片：截取字符串中的其中一段内容</p>\n<p>语法：[起始下标：结束下标：步长]，<code>[start: end: step]</code>，不包含end，step默认是1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#切片</span><br><span class=\"line\">strMsg = &#x27;hello world&#x27;</span><br><span class=\"line\">#slice[start: end: step] 左闭右开</span><br><span class=\"line\">print(strMsg)</span><br><span class=\"line\">print(strMsg[2: 7: 1])</span><br><span class=\"line\">print(strMsg[2:])</span><br><span class=\"line\">print(strMsg[: 3])</span><br><span class=\"line\">print(strMsg[: : -1])</span><br><span class=\"line\">print(strMsg[: : -2])</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i love python</span><br><span class=\"line\">I LOVE PYTHON</span><br><span class=\"line\">hello world</span><br><span class=\"line\">llo w</span><br><span class=\"line\">llo world</span><br><span class=\"line\">hel</span><br><span class=\"line\">dlrow olleh</span><br><span class=\"line\">drwolh</span><br></pre></td></tr></table></figure>\n\n<p><strong>下标会越界，切片不会</strong></p>\n<p>常用函数：</p>\n<p>1.<code>capitalize()</code>：将字符串首字母变成大写</p>\n<p>2.<code>strip()</code>：去除字符串中的空格</p>\n<p>3.<code>lstrip()</code>：去除字符串左边空格</p>\n<p>4.<code>rstrip()</code>：去除字符串右边空格</p>\n<p>5.<code>id()</code>：查看对象的内存地址</p>\n<p>6.<code>find()</code>：查找对象是否在序列中，返回第一个对象下标，不存在返回<code>-1</code></p>\n<p>7.<code>index()</code>：检测字符串中是否包含子字符串，返回下标，不存在则报错</p>\n<p>8.<code>startswith()</code>：判断是否以某子串开头</p>\n<p>9.<code>endswith()</code>：判断是否以某子串结尾</p>\n<p>10.<code>lower()</code>：转换成小写</p>\n<p>11.<code>upper()</code>：转换成大写</p>\n<p>12.<code>join()</code>：循环取出所有值用xx去连接</p>\n<p>13.<code>split()</code>：切割字符串</p>\n<p>14.<code>count()</code>：统计出现的次数</p>\n<p>…</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#常用函数</span><br><span class=\"line\">name = &#x27;peter&#x27;</span><br><span class=\"line\">print(name.capitalize())</span><br><span class=\"line\">#</span><br><span class=\"line\">a = &#x27;          hello    &#x27;</span><br><span class=\"line\">b = a.strip()</span><br><span class=\"line\">print(a)</span><br><span class=\"line\">print(b)</span><br><span class=\"line\">#</span><br><span class=\"line\">b = a</span><br><span class=\"line\">print(&#x27;a的内存地址%d&#x27;%id(a))</span><br><span class=\"line\">print(&#x27;b的内存地址%d&#x27;%id(b))</span><br><span class=\"line\">#</span><br><span class=\"line\">dataStr = &#x27;I love python&#x27;</span><br><span class=\"line\">print(dataStr.find(&#x27;p&#x27;))</span><br><span class=\"line\">print(dataStr.find(&#x27;a&#x27;))</span><br><span class=\"line\">print(dataStr.index(&#x27;o&#x27;))</span><br><span class=\"line\">#</span><br><span class=\"line\">print(dataStr.startswith(&#x27;I&#x27;))</span><br><span class=\"line\">print(dataStr.endswith(&#x27;o&#x27;))</span><br><span class=\"line\">#</span><br><span class=\"line\">print(dataStr.lower())</span><br><span class=\"line\">print(dataStr.upper())</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Peter</span><br><span class=\"line\">          hello</span><br><span class=\"line\">hello</span><br><span class=\"line\">a的内存地址2290605664992</span><br><span class=\"line\">b的内存地址2290605664992</span><br><span class=\"line\">7</span><br><span class=\"line\">3</span><br><span class=\"line\">True</span><br><span class=\"line\">False</span><br><span class=\"line\">i love python</span><br><span class=\"line\">I LOVE PYTHON</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"二、元组\"><a href=\"#二、元组\" class=\"headerlink\" title=\"二、元组\"></a>二、元组</h3><p>元组是一种不可变的序列，创建之后不能做任何的修改，特点：</p>\n<p>​    1.不可变</p>\n<p>​    2.用（）创建元组类型，数据项之间用逗号分隔，数据项可以是任意数据类型</p>\n<p>​    3.元组中只有一个元素时，要加逗号以免被当作其他类型</p>\n<p>​    4.支持切片操作</p>\n<p><strong>元组不可修改，但是元组中的列表中的元素可以修改</strong></p>\n<p>常用方法与列表相似：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tupleA = (1, )</span><br><span class=\"line\">print(type(tupleA))</span><br><span class=\"line\">print(id(tupleA))</span><br><span class=\"line\"></span><br><span class=\"line\">tupleA = (&#x27;abcd&#x27;, 66, 1.255, [22, &#x27;fafa&#x27;])</span><br><span class=\"line\">print(tupleA)</span><br><span class=\"line\">print(id(tupleA))</span><br><span class=\"line\"></span><br><span class=\"line\">for item in tupleA:</span><br><span class=\"line\">    print(item, end = &#x27; &#x27;)</span><br><span class=\"line\">    pass</span><br><span class=\"line\">print()</span><br><span class=\"line\"></span><br><span class=\"line\">print(tupleA[2: 4])</span><br><span class=\"line\">print(tupleA[-1: -4: -2]) #反向遍历下标从-1开始</span><br><span class=\"line\">print(tupleA[-4: -2: ])</span><br><span class=\"line\"></span><br><span class=\"line\">tupleA[3][0] = 66</span><br><span class=\"line\">print(tupleA)</span><br><span class=\"line\"></span><br><span class=\"line\">print(tupleA.count(66)) #统计元素出现的次数</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &#x27;tuple&#x27;&gt;</span><br><span class=\"line\">1350340798616</span><br><span class=\"line\">(&#x27;abcd&#x27;, 66, 1.255, [22, &#x27;fafa&#x27;])</span><br><span class=\"line\">1350340804424</span><br><span class=\"line\">abcd 66 1.255 [22, &#x27;fafa&#x27;]</span><br><span class=\"line\">(1.255, [22, &#x27;fafa&#x27;])</span><br><span class=\"line\">([22, &#x27;fafa&#x27;], 66)</span><br><span class=\"line\">(&#x27;abcd&#x27;, 66)</span><br><span class=\"line\">(&#x27;abcd&#x27;, 66, 1.255, [66, &#x27;fafa&#x27;])</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<hr>\n<h3 id=\"三、列表\"><a href=\"#三、列表\" class=\"headerlink\" title=\"三、列表\"></a>三、列表</h3><p>列表是一种有序的数据集合，特点：</p>\n<p>​    1.支持增删查改</p>\n<p>​    2.列表中的数据可以变化</p>\n<p>​    3.用[ ]表示列表类型，数据项之间用逗号分隔，数据项可以是任意数据类型</p>\n<p>​    4.支持索引和切片操作</p>\n<p>常用方法：</p>\n<p>1.<code>append()</code>：在列表后面追加元素</p>\n<p>2.<code>count()</code>：统计元素出现的次数</p>\n<p>3.<code>extend()</code>：扩展，相当于批量添加</p>\n<p>4.<code>index()</code>：获取指定元素索引号</p>\n<p>5.<code>insert()</code>：在指定位置插入</p>\n<p>6.<code>pop()</code>：删除最后一个元素</p>\n<p>7.<code>remove()</code>：移除左边找到的第一个元素</p>\n<p>8.<code>reverse()</code>：反转列表</p>\n<p>9.<code>sort()</code>：列表排序</p>\n<p>10.<code>len()</code>：获取列表对象的数据个数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#列表</span><br><span class=\"line\">li = []</span><br><span class=\"line\">print(type(li))</span><br><span class=\"line\">li = [1, 2, 3, &#x27;你好&#x27;]</span><br><span class=\"line\">print(len(li))</span><br><span class=\"line\"></span><br><span class=\"line\">#查找、遍历</span><br><span class=\"line\">listA = [&#x27;abcd&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True]</span><br><span class=\"line\">print(listA[3])</span><br><span class=\"line\">print(listA[1: 4]) #左闭右开</span><br><span class=\"line\">print(listA * 3)</span><br><span class=\"line\">print(listA.index(True))</span><br><span class=\"line\"></span><br><span class=\"line\">#增加</span><br><span class=\"line\">listA.append([&#x27;fff&#x27;, &#x27;ddd&#x27;])</span><br><span class=\"line\">print(listA)</span><br><span class=\"line\">listA.insert(1, &#x27;插入&#x27;)</span><br><span class=\"line\">print(listA)</span><br><span class=\"line\">rsData = list(range(10))</span><br><span class=\"line\">listA.append(rsData)</span><br><span class=\"line\">print(listA)</span><br><span class=\"line\"></span><br><span class=\"line\">#修改</span><br><span class=\"line\">listA[0] = &#x27;peter&#x27;</span><br><span class=\"line\">print(listA)</span><br><span class=\"line\"></span><br><span class=\"line\">#删除</span><br><span class=\"line\">del listA[7]</span><br><span class=\"line\">print(listA)</span><br><span class=\"line\">del listA[1: 7: 5] #切片批量删除</span><br><span class=\"line\">print(listA)</span><br><span class=\"line\">listA.remove(785)</span><br><span class=\"line\">print(listA)</span><br><span class=\"line\">listA.pop()</span><br><span class=\"line\">print(listA)</span><br><span class=\"line\">listA.pop(0)</span><br><span class=\"line\">print(listA)</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &#x27;list&#x27;&gt;</span><br><span class=\"line\">4</span><br><span class=\"line\">qiuzhi</span><br><span class=\"line\">[785, 12.23, &#x27;qiuzhi&#x27;]</span><br><span class=\"line\">[&#x27;abcd&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, &#x27;abcd&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, &#x27;abcd&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True]</span><br><span class=\"line\">4</span><br><span class=\"line\">[&#x27;abcd&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, [&#x27;fff&#x27;, &#x27;ddd&#x27;]]</span><br><span class=\"line\">[&#x27;abcd&#x27;, &#x27;插入&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, [&#x27;fff&#x27;, &#x27;ddd&#x27;]]</span><br><span class=\"line\">[&#x27;abcd&#x27;, &#x27;插入&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, [&#x27;fff&#x27;, &#x27;ddd&#x27;], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]</span><br><span class=\"line\">[&#x27;peter&#x27;, &#x27;插入&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, [&#x27;fff&#x27;, &#x27;ddd&#x27;], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]</span><br><span class=\"line\">[&#x27;peter&#x27;, &#x27;插入&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, [&#x27;fff&#x27;, &#x27;ddd&#x27;]]</span><br><span class=\"line\">[&#x27;peter&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True]</span><br><span class=\"line\">[&#x27;peter&#x27;, 12.23, &#x27;qiuzhi&#x27;, True]</span><br><span class=\"line\">[&#x27;peter&#x27;, 12.23, &#x27;qiuzhi&#x27;]</span><br><span class=\"line\">[12.23, &#x27;qiuzhi&#x27;]</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<hr>\n<h3 id=\"四、字典\"><a href=\"#四、字典\" class=\"headerlink\" title=\"四、字典\"></a>四、字典</h3><p>字典是以键值对 <code>&#123;‘key&#39;: &#39;value’&#125;</code> 的形式创建并可以存储任意对象的数据类型</p>\n<p>键（key）不能重复，值（value）可以重复</p>\n<p>键（key）只能是不可变类型，如数字、字符串、元组</p>\n<p>字典不是序列类型， <strong>没有下标</strong>的概念，是一个无序的键值集合</p>\n<p>常用方法：</p>\n<p>1.<code>keys()</code>：获取所有的键</p>\n<p>2.<code>values()</code>：获取所有的值</p>\n<p>3.<code>items()</code>：获取所有的键值对</p>\n<p>4.<code>update()</code>：更新键值对，可以修改也可以添加</p>\n<p>5.<code>pop()</code>：删除指定键</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#初始化</span><br><span class=\"line\">from typing import ItemsView</span><br><span class=\"line\">dictA = &#123;&#x27;pro&#x27;: &#x27;艺术&#x27;, &#x27;school&#x27;: &#x27;北影&#x27;&#125;</span><br><span class=\"line\">print(type(dictA))</span><br><span class=\"line\">#赋值</span><br><span class=\"line\">dictA[&#x27;name&#x27;] = &#x27;刘德华&#x27;</span><br><span class=\"line\">dictA[&#x27;age&#x27;] = &#x27;50&#x27;</span><br><span class=\"line\">dictA[&#x27;pos&#x27;] = &#x27;影星&#x27;</span><br><span class=\"line\">print(dictA)</span><br><span class=\"line\">print(len(dictA))</span><br><span class=\"line\">print(dictA[&#x27;name&#x27;])</span><br><span class=\"line\">#修改</span><br><span class=\"line\">dictA[&#x27;name&#x27;] = &#x27;张家辉&#x27;</span><br><span class=\"line\">dictA[&#x27;school&#x27;] = &#x27;港大&#x27;</span><br><span class=\"line\">dictA.update(&#123;&#x27;age&#x27;: &#x27;40&#x27;&#125;)</span><br><span class=\"line\">dictA.update(&#123;&#x27;height&#x27;: &#x27;180&#x27;&#125;)</span><br><span class=\"line\">print(dictA)</span><br><span class=\"line\">#输出</span><br><span class=\"line\">print(dictA.keys())</span><br><span class=\"line\">print(dictA.values())</span><br><span class=\"line\">print(dictA.items())</span><br><span class=\"line\">for key,value in dictA.items():</span><br><span class=\"line\">    print(&#x27;%s==%s&#x27;%(key, value))</span><br><span class=\"line\">    pass</span><br><span class=\"line\">#删除</span><br><span class=\"line\">del dictA[&#x27;name&#x27;]</span><br><span class=\"line\">dictA.pop(&#x27;age&#x27;)</span><br><span class=\"line\">print(dictA)</span><br><span class=\"line\">#排序</span><br><span class=\"line\">print(sorted(dictA.items(), key = lambda d: d[0]))</span><br><span class=\"line\">print(sorted(dictA.items(), key = lambda d: d[1]))</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;class &#x27;dict&#x27;&gt;</span><br><span class=\"line\">&#123;&#x27;pro&#x27;: &#x27;艺术&#x27;, &#x27;school&#x27;: &#x27;北影&#x27;, &#x27;name&#x27;: &#x27;刘德华&#x27;, &#x27;age&#x27;: &#x27;50&#x27;, &#x27;pos&#x27;: &#x27;影星&#x27;&#125;</span><br><span class=\"line\">5</span><br><span class=\"line\">刘德华</span><br><span class=\"line\">&#123;&#x27;pro&#x27;: &#x27;艺术&#x27;, &#x27;school&#x27;: &#x27;港大&#x27;, &#x27;name&#x27;: &#x27;张家辉&#x27;, &#x27;age&#x27;: &#x27;40&#x27;, &#x27;pos&#x27;: &#x27;影星&#x27;, &#x27;height&#x27;: &#x27;180&#x27;&#125;</span><br><span class=\"line\">dict_keys([&#x27;pro&#x27;, &#x27;school&#x27;, &#x27;name&#x27;, &#x27;age&#x27;, &#x27;pos&#x27;, &#x27;height&#x27;])</span><br><span class=\"line\">dict_values([&#x27;艺术&#x27;, &#x27;港大&#x27;, &#x27;张家辉&#x27;, &#x27;40&#x27;, &#x27;影星&#x27;, &#x27;180&#x27;])</span><br><span class=\"line\">dict_items([(&#x27;pro&#x27;, &#x27;艺术&#x27;), (&#x27;school&#x27;, &#x27;港大&#x27;), (&#x27;name&#x27;, &#x27;张家辉&#x27;), (&#x27;age&#x27;, &#x27;40&#x27;), (&#x27;pos&#x27;, &#x27;影星&#x27;), (&#x27;height&#x27;, &#x27;180&#x27;)])</span><br><span class=\"line\">pro==艺术</span><br><span class=\"line\">school==港大</span><br><span class=\"line\">name==张家辉</span><br><span class=\"line\">age==40</span><br><span class=\"line\">pos==影星</span><br><span class=\"line\">height==180</span><br><span class=\"line\">&#123;&#x27;pro&#x27;: &#x27;艺术&#x27;, &#x27;school&#x27;: &#x27;港大&#x27;, &#x27;pos&#x27;: &#x27;影星&#x27;, &#x27;height&#x27;: &#x27;180&#x27;&#125;</span><br><span class=\"line\">[(&#x27;height&#x27;, &#x27;180&#x27;), (&#x27;pos&#x27;, &#x27;影星&#x27;), (&#x27;pro&#x27;, &#x27;艺术&#x27;), (&#x27;school&#x27;, &#x27;港大&#x27;)]</span><br><span class=\"line\">[(&#x27;height&#x27;, &#x27;180&#x27;), (&#x27;pos&#x27;, &#x27;影星&#x27;), (&#x27;school&#x27;, &#x27;港大&#x27;), (&#x27;pro&#x27;, &#x27;艺术&#x27;)]</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<hr>\n<h3 id=\"五、通用操作\"><a href=\"#五、通用操作\" class=\"headerlink\" title=\"五、通用操作\"></a>五、通用操作</h3><p>1.<code>+</code>：合并两个对象</p>\n<p>2.<code>*</code>：对象自身按指定次数复制合并</p>\n<p>3.<code>in</code>：判断元素是否存在</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#</span><br><span class=\"line\">strA = &#x27;人生苦短&#x27;</span><br><span class=\"line\">strB = &#x27;我用Python&#x27;</span><br><span class=\"line\">print(strA + strB)</span><br><span class=\"line\">listA = list(range(11))</span><br><span class=\"line\">listB = list(range(11, 20))</span><br><span class=\"line\">print(listA + listB)</span><br><span class=\"line\">#</span><br><span class=\"line\">print(strA * 3)</span><br><span class=\"line\">print(listA * 2)</span><br><span class=\"line\">#</span><br><span class=\"line\">print(&#x27;生&#x27; in strA)</span><br><span class=\"line\">print(8 in listA)</span><br><span class=\"line\">print(10 in listB)</span><br><span class=\"line\">dictA = &#123;&#x27;name&#x27;: &#x27;peter&#x27;&#125;</span><br><span class=\"line\">print(&#x27;name&#x27; in dictA)</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">人生苦短我用Python</span><br><span class=\"line\">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span><br><span class=\"line\">人生苦短人生苦短人生苦短</span><br><span class=\"line\">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class=\"line\">True</span><br><span class=\"line\">True</span><br><span class=\"line\">False</span><br><span class=\"line\">True</span><br></pre></td></tr></table></figure>"},{"title":"Jupyter Notebook修改默认路径","date":"2021-10-14T10:50:56.000Z","_content":"\n\n\n### \t始、修改默认路径\n\n1.打开Anaconda Prompt，输入`jupyter notebook --generate-config`\n\n2.打开上一步生成的配置文件：\n\n`C:\\Users\\Administrator\\.jupyter\\jupyter_notebook_config.py`\n\n其中C:\\Users\\Administrator就是`Jupyter notebook`的默认路径：\n\n3.打开`jupyter_notebook_config.py`，搜索`#c.NotebookApp.notebook_dir = ''`（214行），删除井号修改成你希望设置的目录路径，这里我修改成`c.NotebookApp.notebook_dir = 'D:\\DeskTopD\\JupyterProject'`\n\n4.在win开始菜单中找到`jupyter notebook`快捷图标，鼠标右键>>属性>>快捷方式>>目标\n\n删除最后的 `\"%USERPROFILE%/\"` ，如果是通过`Anaconda`控制台打开`jupyter notebook`则无需更改此项\n\n","source":"_posts/2021-10-14-Jupyter Notebook修改默认路径.md","raw":"---\ntitle: Jupyter Notebook修改默认路径\ndate: 2021-10-14 18:50:56\ncategories:\t琐碎\ntags:\n  - jupyter\n  - windows\n---\n\n\n\n### \t始、修改默认路径\n\n1.打开Anaconda Prompt，输入`jupyter notebook --generate-config`\n\n2.打开上一步生成的配置文件：\n\n`C:\\Users\\Administrator\\.jupyter\\jupyter_notebook_config.py`\n\n其中C:\\Users\\Administrator就是`Jupyter notebook`的默认路径：\n\n3.打开`jupyter_notebook_config.py`，搜索`#c.NotebookApp.notebook_dir = ''`（214行），删除井号修改成你希望设置的目录路径，这里我修改成`c.NotebookApp.notebook_dir = 'D:\\DeskTopD\\JupyterProject'`\n\n4.在win开始菜单中找到`jupyter notebook`快捷图标，鼠标右键>>属性>>快捷方式>>目标\n\n删除最后的 `\"%USERPROFILE%/\"` ，如果是通过`Anaconda`控制台打开`jupyter notebook`则无需更改此项\n\n","slug":"2021-10-14-Jupyter Notebook修改默认路径","published":1,"updated":"2021-11-01T05:58:13.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71i7002o1ou0dgri1uqu","content":"<h3 id=\"始、修改默认路径\"><a href=\"#始、修改默认路径\" class=\"headerlink\" title=\"始、修改默认路径\"></a>始、修改默认路径</h3><p>1.打开Anaconda Prompt，输入<code>jupyter notebook --generate-config</code></p>\n<p>2.打开上一步生成的配置文件：</p>\n<p><code>C:\\Users\\Administrator\\.jupyter\\jupyter_notebook_config.py</code></p>\n<p>其中C:\\Users\\Administrator就是<code>Jupyter notebook</code>的默认路径：</p>\n<p>3.打开<code>jupyter_notebook_config.py</code>，搜索<code>#c.NotebookApp.notebook_dir = &#39;&#39;</code>（214行），删除井号修改成你希望设置的目录路径，这里我修改成<code>c.NotebookApp.notebook_dir = &#39;D:\\DeskTopD\\JupyterProject&#39;</code></p>\n<p>4.在win开始菜单中找到<code>jupyter notebook</code>快捷图标，鼠标右键&gt;&gt;属性&gt;&gt;快捷方式&gt;&gt;目标</p>\n<p>删除最后的 <code>&quot;%USERPROFILE%/&quot;</code> ，如果是通过<code>Anaconda</code>控制台打开<code>jupyter notebook</code>则无需更改此项</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"","more":"<h3 id=\"始、修改默认路径\"><a href=\"#始、修改默认路径\" class=\"headerlink\" title=\"始、修改默认路径\"></a>始、修改默认路径</h3><p>1.打开Anaconda Prompt，输入<code>jupyter notebook --generate-config</code></p>\n<p>2.打开上一步生成的配置文件：</p>\n<p><code>C:\\Users\\Administrator\\.jupyter\\jupyter_notebook_config.py</code></p>\n<p>其中C:\\Users\\Administrator就是<code>Jupyter notebook</code>的默认路径：</p>\n<p>3.打开<code>jupyter_notebook_config.py</code>，搜索<code>#c.NotebookApp.notebook_dir = &#39;&#39;</code>（214行），删除井号修改成你希望设置的目录路径，这里我修改成<code>c.NotebookApp.notebook_dir = &#39;D:\\DeskTopD\\JupyterProject&#39;</code></p>\n<p>4.在win开始菜单中找到<code>jupyter notebook</code>快捷图标，鼠标右键&gt;&gt;属性&gt;&gt;快捷方式&gt;&gt;目标</p>\n<p>删除最后的 <code>&quot;%USERPROFILE%/&quot;</code> ，如果是通过<code>Anaconda</code>控制台打开<code>jupyter notebook</code>则无需更改此项</p>\n"},{"title":"八爪鱼零编程爬虫入门","date":"2021-10-16T09:13:41.000Z","_content":"\n\n\n### \t始、前言\n\n“还在捣鼓python爬虫？不如先来试试零编程爬虫”\n\n最近需要爬很多很多数据集，尝试了一下python爬虫，出现很多奇奇怪怪的问题，还是先来学习下八爪鱼无编程爬虫怎么用吧\n\n这次的任务是**在百度搜索中获取“鸡”的图片**\n\n\n\n<!--more-->\n\n---\n\n\n\n### 一、图片链接采集\n\n1.在首页【输入框】中输入目标网址  `https://image.baidu.com/search/index?tn=baiduimage&ipn=r&ct=201326592&cl=2&lm=-1&st=-1&fm=result&fr=&sf=1&fmq=1586763732362_R&pv=&ic=&nc=1&z=&hd=&latest=&copyright=&se=1&showtab=0&fb=0&width=&height=&face=0&istype=2&ie=utf-8&sid=&word=鸡`，点击【开始采集】，八爪鱼自动打开网页。（打开网页后，如果开始【自动识别】，请点击【不再自动识别】或【取消识别】将其关掉。）\n\n\n\n2.添加一个【循环】，进入【循环】设置页面。选择循环方式为【文本列表】，点击编辑按钮，将我们准备好的关键字输进去后保存。（可同时输入多个关键字，一行一个即可，如“公鸡”、“母鸡”、“小鸡”，可根据自身需求进行替换）\n\n\n\n3.选中页面中的搜索框，在黄色操作提示框中，选择【输入文本】后点击【确定】，将【输入文本】步骤拖入【循环】中。**然后进入【输入文本】设置页面，勾选【使用当前循环里的文本来填充输入框】后保存。**\n\n\n\n4.在【循环】中选择一个关键词，再点击【输入文本】，可以看到，关键词成功输入进网页的文本框中。然后选中【百度一下】按钮，在操作提示框中点击【点击该按钮】，出现关键词的搜索结果列表页。\n\n\n\n5.向下滚动页面，会加载出新的图片列表，在八爪鱼中也需设置滚动，进入【点击元素】设置页面，点开【页面加载后】，设置【页面加载后向下滚动】，滚动方式为【滚动到底部】，【滚动次数】为10次，【每次间隔】1秒 ，设置后保存。\n\n同时也可以设置 【Ajax超时】10秒 和【执行前等待】3 秒，以便采集更全数据。\n\n\n\n6.创建【循环列表】，采集所有图片地址：\n\n① 选中页面上1个图片列表\n\n② 在黄色操作提示框中，点击【选中全部】\n\n③ 点击【采集以下图片地址】\n\n\n\n7.自动生成的【循环列表】定位`XPath`，默认只定位到前21个图片。我们需要修改一下，使其定位到所有的图片。进入【循环列表】设置界面，修改`XPath`为：**`//div[@class=\"imgpage\"]/ul/li`** 后保存。\n\n\n\n8.八爪鱼自动为我们提取了列表中的所有字段。但是有些字段没提取到，比如关键词的文本。我们可以手动提取。选中页面的输入框，在操作提示框中选择【采集文本框的值】，将输入的关键词文本采集下来。\n\n\n\n9.在【当前页面数据预览】页面，可删除多余字段，修改字段名，移动字段顺序等。\n\n\n\n10.单击【采集】并【启动本地采集】。启动后八爪鱼开始自动采集数据。采集完成后，选择合适的导出方式导出数据。支持导出为Excel、CSV、HTML、数据库等。这里导出为Excel。\n\n \n\n经过如上操作，我们已经得到了要采集的图片的URL。\n\n接下来，可通过八爪鱼提供的图片批量下载工具，将采集到的图片URL中的图片，下载并保存到本地电脑中。\n\n\n\n---\n\n\n\n### 二、图片保存及处理\n\n1.下载八爪鱼图片批量下载工具：**[https://pan.baidu.com/s/1c2n60NI]**下载完成后，双击文件中的`MyDownloader.app.exe`，打开软件，点击【File】，选择从EXCEL导入（目前只支持EXCEL格式文件）\n\n\n\n2.进行相关设置：\n\n选择EXCEL文件：导入需要下载图片地址的EXCEL文件\n\nEXCEL表名：对应数据表的名称\n\n文件URL列名：表内图片URL所在的列名称  \n\n保存文件夹列名：EXCEL中需要单独一个列，列出图片想要保存到本地的路径（哪个文件夹）。\n\n列名可自定义设置。\n\n列中的数据有固定格式：【D:\\图片保存文件夹名\\】，其中存储盘和文件夹名可自定义设置，【D:\\\\】需在英文状态下输入，不可用中文输入。**（注意路径结尾还有一个“\\”）**\n\n配置完成后，点击【OK】保存。\n\n\n\n3.在文件夹内新建文本文档，文档名称随意，在文档内输入 `ren *.* *.jpg`，另保存为【新建文本文档.bat】，运行文件（bat是dos下的批处理文件）\n\n这样就将文件夹内所有图片转换成`.jpg`格式\n\n","source":"_posts/2021-10-16-八爪鱼零编程爬虫入门.md","raw":"---\ntitle: 八爪鱼零编程爬虫入门\ndate: 2021-10-16 17:13:41\ncategories:\t琐碎\ntags:\n  - 爬虫\n  - windows\n---\n\n\n\n### \t始、前言\n\n“还在捣鼓python爬虫？不如先来试试零编程爬虫”\n\n最近需要爬很多很多数据集，尝试了一下python爬虫，出现很多奇奇怪怪的问题，还是先来学习下八爪鱼无编程爬虫怎么用吧\n\n这次的任务是**在百度搜索中获取“鸡”的图片**\n\n\n\n<!--more-->\n\n---\n\n\n\n### 一、图片链接采集\n\n1.在首页【输入框】中输入目标网址  `https://image.baidu.com/search/index?tn=baiduimage&ipn=r&ct=201326592&cl=2&lm=-1&st=-1&fm=result&fr=&sf=1&fmq=1586763732362_R&pv=&ic=&nc=1&z=&hd=&latest=&copyright=&se=1&showtab=0&fb=0&width=&height=&face=0&istype=2&ie=utf-8&sid=&word=鸡`，点击【开始采集】，八爪鱼自动打开网页。（打开网页后，如果开始【自动识别】，请点击【不再自动识别】或【取消识别】将其关掉。）\n\n\n\n2.添加一个【循环】，进入【循环】设置页面。选择循环方式为【文本列表】，点击编辑按钮，将我们准备好的关键字输进去后保存。（可同时输入多个关键字，一行一个即可，如“公鸡”、“母鸡”、“小鸡”，可根据自身需求进行替换）\n\n\n\n3.选中页面中的搜索框，在黄色操作提示框中，选择【输入文本】后点击【确定】，将【输入文本】步骤拖入【循环】中。**然后进入【输入文本】设置页面，勾选【使用当前循环里的文本来填充输入框】后保存。**\n\n\n\n4.在【循环】中选择一个关键词，再点击【输入文本】，可以看到，关键词成功输入进网页的文本框中。然后选中【百度一下】按钮，在操作提示框中点击【点击该按钮】，出现关键词的搜索结果列表页。\n\n\n\n5.向下滚动页面，会加载出新的图片列表，在八爪鱼中也需设置滚动，进入【点击元素】设置页面，点开【页面加载后】，设置【页面加载后向下滚动】，滚动方式为【滚动到底部】，【滚动次数】为10次，【每次间隔】1秒 ，设置后保存。\n\n同时也可以设置 【Ajax超时】10秒 和【执行前等待】3 秒，以便采集更全数据。\n\n\n\n6.创建【循环列表】，采集所有图片地址：\n\n① 选中页面上1个图片列表\n\n② 在黄色操作提示框中，点击【选中全部】\n\n③ 点击【采集以下图片地址】\n\n\n\n7.自动生成的【循环列表】定位`XPath`，默认只定位到前21个图片。我们需要修改一下，使其定位到所有的图片。进入【循环列表】设置界面，修改`XPath`为：**`//div[@class=\"imgpage\"]/ul/li`** 后保存。\n\n\n\n8.八爪鱼自动为我们提取了列表中的所有字段。但是有些字段没提取到，比如关键词的文本。我们可以手动提取。选中页面的输入框，在操作提示框中选择【采集文本框的值】，将输入的关键词文本采集下来。\n\n\n\n9.在【当前页面数据预览】页面，可删除多余字段，修改字段名，移动字段顺序等。\n\n\n\n10.单击【采集】并【启动本地采集】。启动后八爪鱼开始自动采集数据。采集完成后，选择合适的导出方式导出数据。支持导出为Excel、CSV、HTML、数据库等。这里导出为Excel。\n\n \n\n经过如上操作，我们已经得到了要采集的图片的URL。\n\n接下来，可通过八爪鱼提供的图片批量下载工具，将采集到的图片URL中的图片，下载并保存到本地电脑中。\n\n\n\n---\n\n\n\n### 二、图片保存及处理\n\n1.下载八爪鱼图片批量下载工具：**[https://pan.baidu.com/s/1c2n60NI]**下载完成后，双击文件中的`MyDownloader.app.exe`，打开软件，点击【File】，选择从EXCEL导入（目前只支持EXCEL格式文件）\n\n\n\n2.进行相关设置：\n\n选择EXCEL文件：导入需要下载图片地址的EXCEL文件\n\nEXCEL表名：对应数据表的名称\n\n文件URL列名：表内图片URL所在的列名称  \n\n保存文件夹列名：EXCEL中需要单独一个列，列出图片想要保存到本地的路径（哪个文件夹）。\n\n列名可自定义设置。\n\n列中的数据有固定格式：【D:\\图片保存文件夹名\\】，其中存储盘和文件夹名可自定义设置，【D:\\\\】需在英文状态下输入，不可用中文输入。**（注意路径结尾还有一个“\\”）**\n\n配置完成后，点击【OK】保存。\n\n\n\n3.在文件夹内新建文本文档，文档名称随意，在文档内输入 `ren *.* *.jpg`，另保存为【新建文本文档.bat】，运行文件（bat是dos下的批处理文件）\n\n这样就将文件夹内所有图片转换成`.jpg`格式\n\n","slug":"2021-10-16-八爪鱼零编程爬虫入门","published":1,"updated":"2021-10-20T03:41:34.172Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71i8002t1ou0dy0m1tgo","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>“还在捣鼓python爬虫？不如先来试试零编程爬虫”</p>\n<p>最近需要爬很多很多数据集，尝试了一下python爬虫，出现很多奇奇怪怪的问题，还是先来学习下八爪鱼无编程爬虫怎么用吧</p>\n<p>这次的任务是<strong>在百度搜索中获取“鸡”的图片</strong></p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、图片链接采集\"><a href=\"#一、图片链接采集\" class=\"headerlink\" title=\"一、图片链接采集\"></a>一、图片链接采集</h3><p>1.在首页【输入框】中输入目标网址  <code>https://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=result&amp;fr=&amp;sf=1&amp;fmq=1586763732362_R&amp;pv=&amp;ic=&amp;nc=1&amp;z=&amp;hd=&amp;latest=&amp;copyright=&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;sid=&amp;word=鸡</code>，点击【开始采集】，八爪鱼自动打开网页。（打开网页后，如果开始【自动识别】，请点击【不再自动识别】或【取消识别】将其关掉。）</p>\n<p>2.添加一个【循环】，进入【循环】设置页面。选择循环方式为【文本列表】，点击编辑按钮，将我们准备好的关键字输进去后保存。（可同时输入多个关键字，一行一个即可，如“公鸡”、“母鸡”、“小鸡”，可根据自身需求进行替换）</p>\n<p>3.选中页面中的搜索框，在黄色操作提示框中，选择【输入文本】后点击【确定】，将【输入文本】步骤拖入【循环】中。<strong>然后进入【输入文本】设置页面，勾选【使用当前循环里的文本来填充输入框】后保存。</strong></p>\n<p>4.在【循环】中选择一个关键词，再点击【输入文本】，可以看到，关键词成功输入进网页的文本框中。然后选中【百度一下】按钮，在操作提示框中点击【点击该按钮】，出现关键词的搜索结果列表页。</p>\n<p>5.向下滚动页面，会加载出新的图片列表，在八爪鱼中也需设置滚动，进入【点击元素】设置页面，点开【页面加载后】，设置【页面加载后向下滚动】，滚动方式为【滚动到底部】，【滚动次数】为10次，【每次间隔】1秒 ，设置后保存。</p>\n<p>同时也可以设置 【Ajax超时】10秒 和【执行前等待】3 秒，以便采集更全数据。</p>\n<p>6.创建【循环列表】，采集所有图片地址：</p>\n<p>① 选中页面上1个图片列表</p>\n<p>② 在黄色操作提示框中，点击【选中全部】</p>\n<p>③ 点击【采集以下图片地址】</p>\n<p>7.自动生成的【循环列表】定位<code>XPath</code>，默认只定位到前21个图片。我们需要修改一下，使其定位到所有的图片。进入【循环列表】设置界面，修改<code>XPath</code>为：**<code>//div[@class=&quot;imgpage&quot;]/ul/li</code>** 后保存。</p>\n<p>8.八爪鱼自动为我们提取了列表中的所有字段。但是有些字段没提取到，比如关键词的文本。我们可以手动提取。选中页面的输入框，在操作提示框中选择【采集文本框的值】，将输入的关键词文本采集下来。</p>\n<p>9.在【当前页面数据预览】页面，可删除多余字段，修改字段名，移动字段顺序等。</p>\n<p>10.单击【采集】并【启动本地采集】。启动后八爪鱼开始自动采集数据。采集完成后，选择合适的导出方式导出数据。支持导出为Excel、CSV、HTML、数据库等。这里导出为Excel。</p>\n<p>经过如上操作，我们已经得到了要采集的图片的URL。</p>\n<p>接下来，可通过八爪鱼提供的图片批量下载工具，将采集到的图片URL中的图片，下载并保存到本地电脑中。</p>\n<hr>\n<h3 id=\"二、图片保存及处理\"><a href=\"#二、图片保存及处理\" class=\"headerlink\" title=\"二、图片保存及处理\"></a>二、图片保存及处理</h3><p>1.下载八爪鱼图片批量下载工具：**[<a href=\"https://pan.baidu.com/s/1c2n60NI]**%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E5%8F%8C%E5%87%BB%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%60MyDownloader.app.exe%60%EF%BC%8C%E6%89%93%E5%BC%80%E8%BD%AF%E4%BB%B6%EF%BC%8C%E7%82%B9%E5%87%BB%E3%80%90File%E3%80%91%EF%BC%8C%E9%80%89%E6%8B%A9%E4%BB%8EEXCEL%E5%AF%BC%E5%85%A5%EF%BC%88%E7%9B%AE%E5%89%8D%E5%8F%AA%E6%94%AF%E6%8C%81EXCEL%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%EF%BC%89\">https://pan.baidu.com/s/1c2n60NI]**下载完成后，双击文件中的`MyDownloader.app.exe`，打开软件，点击【File】，选择从EXCEL导入（目前只支持EXCEL格式文件）</a></p>\n<p>2.进行相关设置：</p>\n<p>选择EXCEL文件：导入需要下载图片地址的EXCEL文件</p>\n<p>EXCEL表名：对应数据表的名称</p>\n<p>文件URL列名：表内图片URL所在的列名称  </p>\n<p>保存文件夹列名：EXCEL中需要单独一个列，列出图片想要保存到本地的路径（哪个文件夹）。</p>\n<p>列名可自定义设置。</p>\n<p>列中的数据有固定格式：【D:\\图片保存文件夹名\\】，其中存储盘和文件夹名可自定义设置，【D:\\】需在英文状态下输入，不可用中文输入。<strong>（注意路径结尾还有一个“\\”）</strong></p>\n<p>配置完成后，点击【OK】保存。</p>\n<p>3.在文件夹内新建文本文档，文档名称随意，在文档内输入 <code>ren *.* *.jpg</code>，另保存为【新建文本文档.bat】，运行文件（bat是dos下的批处理文件）</p>\n<p>这样就将文件夹内所有图片转换成<code>.jpg</code>格式</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>“还在捣鼓python爬虫？不如先来试试零编程爬虫”</p>\n<p>最近需要爬很多很多数据集，尝试了一下python爬虫，出现很多奇奇怪怪的问题，还是先来学习下八爪鱼无编程爬虫怎么用吧</p>\n<p>这次的任务是<strong>在百度搜索中获取“鸡”的图片</strong></p>","more":"<hr>\n<h3 id=\"一、图片链接采集\"><a href=\"#一、图片链接采集\" class=\"headerlink\" title=\"一、图片链接采集\"></a>一、图片链接采集</h3><p>1.在首页【输入框】中输入目标网址  <code>https://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=result&amp;fr=&amp;sf=1&amp;fmq=1586763732362_R&amp;pv=&amp;ic=&amp;nc=1&amp;z=&amp;hd=&amp;latest=&amp;copyright=&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;sid=&amp;word=鸡</code>，点击【开始采集】，八爪鱼自动打开网页。（打开网页后，如果开始【自动识别】，请点击【不再自动识别】或【取消识别】将其关掉。）</p>\n<p>2.添加一个【循环】，进入【循环】设置页面。选择循环方式为【文本列表】，点击编辑按钮，将我们准备好的关键字输进去后保存。（可同时输入多个关键字，一行一个即可，如“公鸡”、“母鸡”、“小鸡”，可根据自身需求进行替换）</p>\n<p>3.选中页面中的搜索框，在黄色操作提示框中，选择【输入文本】后点击【确定】，将【输入文本】步骤拖入【循环】中。<strong>然后进入【输入文本】设置页面，勾选【使用当前循环里的文本来填充输入框】后保存。</strong></p>\n<p>4.在【循环】中选择一个关键词，再点击【输入文本】，可以看到，关键词成功输入进网页的文本框中。然后选中【百度一下】按钮，在操作提示框中点击【点击该按钮】，出现关键词的搜索结果列表页。</p>\n<p>5.向下滚动页面，会加载出新的图片列表，在八爪鱼中也需设置滚动，进入【点击元素】设置页面，点开【页面加载后】，设置【页面加载后向下滚动】，滚动方式为【滚动到底部】，【滚动次数】为10次，【每次间隔】1秒 ，设置后保存。</p>\n<p>同时也可以设置 【Ajax超时】10秒 和【执行前等待】3 秒，以便采集更全数据。</p>\n<p>6.创建【循环列表】，采集所有图片地址：</p>\n<p>① 选中页面上1个图片列表</p>\n<p>② 在黄色操作提示框中，点击【选中全部】</p>\n<p>③ 点击【采集以下图片地址】</p>\n<p>7.自动生成的【循环列表】定位<code>XPath</code>，默认只定位到前21个图片。我们需要修改一下，使其定位到所有的图片。进入【循环列表】设置界面，修改<code>XPath</code>为：**<code>//div[@class=&quot;imgpage&quot;]/ul/li</code>** 后保存。</p>\n<p>8.八爪鱼自动为我们提取了列表中的所有字段。但是有些字段没提取到，比如关键词的文本。我们可以手动提取。选中页面的输入框，在操作提示框中选择【采集文本框的值】，将输入的关键词文本采集下来。</p>\n<p>9.在【当前页面数据预览】页面，可删除多余字段，修改字段名，移动字段顺序等。</p>\n<p>10.单击【采集】并【启动本地采集】。启动后八爪鱼开始自动采集数据。采集完成后，选择合适的导出方式导出数据。支持导出为Excel、CSV、HTML、数据库等。这里导出为Excel。</p>\n<p>经过如上操作，我们已经得到了要采集的图片的URL。</p>\n<p>接下来，可通过八爪鱼提供的图片批量下载工具，将采集到的图片URL中的图片，下载并保存到本地电脑中。</p>\n<hr>\n<h3 id=\"二、图片保存及处理\"><a href=\"#二、图片保存及处理\" class=\"headerlink\" title=\"二、图片保存及处理\"></a>二、图片保存及处理</h3><p>1.下载八爪鱼图片批量下载工具：**[<a href=\"https://pan.baidu.com/s/1c2n60NI]**%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E5%8F%8C%E5%87%BB%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%60MyDownloader.app.exe%60%EF%BC%8C%E6%89%93%E5%BC%80%E8%BD%AF%E4%BB%B6%EF%BC%8C%E7%82%B9%E5%87%BB%E3%80%90File%E3%80%91%EF%BC%8C%E9%80%89%E6%8B%A9%E4%BB%8EEXCEL%E5%AF%BC%E5%85%A5%EF%BC%88%E7%9B%AE%E5%89%8D%E5%8F%AA%E6%94%AF%E6%8C%81EXCEL%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%EF%BC%89\">https://pan.baidu.com/s/1c2n60NI]**下载完成后，双击文件中的`MyDownloader.app.exe`，打开软件，点击【File】，选择从EXCEL导入（目前只支持EXCEL格式文件）</a></p>\n<p>2.进行相关设置：</p>\n<p>选择EXCEL文件：导入需要下载图片地址的EXCEL文件</p>\n<p>EXCEL表名：对应数据表的名称</p>\n<p>文件URL列名：表内图片URL所在的列名称  </p>\n<p>保存文件夹列名：EXCEL中需要单独一个列，列出图片想要保存到本地的路径（哪个文件夹）。</p>\n<p>列名可自定义设置。</p>\n<p>列中的数据有固定格式：【D:\\图片保存文件夹名\\】，其中存储盘和文件夹名可自定义设置，【D:\\】需在英文状态下输入，不可用中文输入。<strong>（注意路径结尾还有一个“\\”）</strong></p>\n<p>配置完成后，点击【OK】保存。</p>\n<p>3.在文件夹内新建文本文档，文档名称随意，在文档内输入 <code>ren *.* *.jpg</code>，另保存为【新建文本文档.bat】，运行文件（bat是dos下的批处理文件）</p>\n<p>这样就将文件夹内所有图片转换成<code>.jpg</code>格式</p>"},{"title":"《Computational Methods of Acquisition and Processing of 3D Point Cloud Data for Construction Applications》阅读笔记","date":"2021-10-30T09:09:36.000Z","_content":"\n\n\n### \t一、信息\n\nQian Wang1 · Yi Tan2,3  · Zhongya Mei4\nReceived: 12 August 2018 / Accepted: 18 February 2019 \n© CIMNE, Barcelona, Spain 2019\n\nArchives of Computational Methods in Engineering \n\nhttps://doi.org/10.1007/s11831-019-09320-4\n\n\n\n<!--more-->\n\n---\n\n\n\n### 二、点云数据采集方法\n\n1.**3D激光扫描**：\n\n激光扫描仪通过发射激光束来测量与目标的距离并从目标中检测反射信号。主要有两种不同的测量方法，飞行时间技术和相移技术。\n\n飞行时间技术：使用飞行时间技术的扫描仪发射激光脉冲并测量反射脉冲的行 进时间t。由于激光的速度是已知的，因此可以从行进时间推断距离测量T。\n\n相移技术：使用相移技术的扫描仪发出幅度调制的连续波（AMCW）并测量发射和反射信号之间的相移。可以基于相位获得距离测量转换和调制连续波的波长。\n\n使用相移原理的扫描仪比使用飞行时间技术的扫描仪的测距精度和测量速度更高 ，使用飞行时间技术的扫描仪有更大的测量范围。\n\n\n\n2.**摄影测量**：\n\n摄影测量定义为获得有关物理对象和环境的可靠信息的艺术、科学和技术，是一种通过记录、测量和解释摄影图像和记录的辐射图案、电磁能量和其他现象的过程。\n\n这些图像仅使用来自不同位置的相机拍摄，从而捕获目标对象的不同部分。然后，算法将估计这些图像的相对位置，并最终将这些图像转换为3D点云。\n\n\n\n3.**视频测量**：\n\n类似于摄影测量，但将视频流作为输入数据而不是图像集合。视频测量可以使点云数据逐步重建，因为视频帧是连续的并且信息都建立在前一帧的基础上。\n\n视频测量对比摄影测量的一个优点是重建过程中较少的人工干预，因为可以通过测量或跟踪连续的视频帧之间的有趣特征来实现不同图像中的目标点的搜索。\n\n\n\n4.**RGB-D相机**：\n\n由RGB相机和深度传感器组成，RGB相机采用RGB图像，深度传感器以每像素为基础找到深度信息。最终，通过用深度信息映射RGB图像来生成彩色点云（包含XYZ坐标和RGB颜色）。\n\n\n\n5.**立体相机**：\n\n立体相机是一种相机系统，具有两个或多个具有单独图像传感器的镜头。由于一个镜头相对于另一个镜头的相对位置和方向已知，因此可以基于所获取的2D图像获得3D点云数据。\n\n\n\n---\n\n\n\n### 三、点云数据处理过程\n\n1.**数据清洗**：\n\n由于实际施工现场环境的复杂性，所获取的点云数据始终包含各种类型的噪声数据，这对于预期目的而言是无用的。此外，由于特定传感器的局限性，也发生各种类型的错误数据。因此，需要用于滤除噪声的算法来滤除无用数据并仅保留感兴趣的数据。\n\n混合像素：一种错误的激光扫描点，它发生在激光束正好落在物体边缘并一分为二的时候。激光束的两个部分落在两个不同的物体上，产生两种不同的反射激光信号。最后，激光扫描仪接收到两个反射信号并产生混合像素。\n\n传感器环绕噪声：激光扫描数据中另一种类型的噪声数据，当距离扫描仪到目标对象的实际距离超过激光扫描仪的非模糊距离时发生。\n\n幽灵几何：在激光扫描数据中捕获人或设备是不可避免的，这种移动物体只出现在一些扫描中， 并导致多次扫描数据不一致。\n\n\n\n2.**数据配准**：\n\n对准从公共坐标系中的不同位置收集的多个点云。由于大尺寸对象和遮挡物体，始终需要在不同位置进行数据采集（特别是激光扫描）以捕获目标对象的不同部分。在共享坐标系中对齐这些点云的过程称为数据配准，数据配准可以分为粗配准和精细配准。\n\n粗配准：包括点描述符定义，关键点检测，粗配准。首先定义点描述符描述每个点，突出重要特征，然后从点云检测关键点，原始点云减少到稀疏的关键点集。最后，通过两个点云重叠区域上检测到的关键点提取变换矩阵并配准两个点云。\n\n精细配准：最常用的方法是迭代最接近点（ICP）算法。\n\n\n\n3.**数据分割**：\n\n将点云数据分段为多个有意义的段或群集。这些段可以代表不同的对象或者代表可以促进点云数据的进一步处理的不同几何基元。所有方法都分为六个类别，包括基于聚类、基于边缘、基于区域、基于图形、基于模型拟合、混合的。\n\n**基于聚类**：根据点的某些特征使用聚类算法进行分段点云数据。\n\n**基于边缘**：基于边缘的分割算法检测3D点云数据中区域的边界以获得分段区域。\n\n**基于区域**：通常从一个或多个种子点开始一个区域 ，然后迭代地生长区域以包括根据某些标准的相邻点。但也存在一些不需要种子点的方法。这种类别的方法称为未特性区域分割方法。\n\n**基于图形**：在图形模型中，每个顶点对应于点云数据中的点，而图形的边缘用于连接相邻点。\n\n**基于模型拟合的分段方法**：基于模型拟合的分段方法起源于人造物体通常可以分解成简单的几何基元，例如平面、球形、圆柱体和其他基元。因此 ，原始形状装配到点云数据中，具有相同数学表示的点被标记为一个段。在现有的基于模型拟合的分段方法中，Hough 变换（HT）和随机样本共识（RANSAC）方法是最广泛的采用。\n\n**混合**：在混合技术中，组合两个或多于两种方法以从点云数据中检测。\n\n\n\n**优缺点**：\n\n基于聚类：优点：易于理解和实现。缺点：准确性问题，对数据中的噪声敏感，受邻域定义的影响。\n\n基于边缘：优点：快速分割。缺点：精度问题，对噪声敏感，对不均匀密度的点云敏感。\n\n基于区域：优点：处理噪音更准确。缺点：在分割和确定区域边界的准确性上有问题。\n\n基于图形：优点：处理不均匀密度或噪音复杂点云数据有更好的性能。缺点：无法实时处理，并且需要培训或其他系统来协助。\n\n基于模型拟合的分段方法：\n\n1.Hough变换（HT）：优点：快速且稳健地对抗异常值。缺点：较慢，对分段参数更敏感；\n\n2.随机样本共识（RANSAC）：优点：快速且稳健地对抗异常值，能够在合理短的时间段内处理大量点云数据。缺点：在处理不同点云源时的数据准确性。\n\n混合：优点：多种方法的优点使结果更准确。缺点：包含所选方法的所有缺点\n\n\n\n4.**对象识别**：\n\n识别点云数据中的某些对象。例如，要从点云数据中创建语义丰富的建筑物，建筑元素，如墙壁，窗口和门，必须从点云数据中识别。\n\n**几何形状描述符**：不同的对象实例或对象类通常具有不同的几何形状。因此，几何形状描述符描述了基于某些几何特征的对象形状，通常用于识别某个对象实例或对象类。通常以三个步骤执行：离线库生成，在线搜索，最终验证。\n\n**硬编码知识**：对于墙壁、屋顶和地板等主要建筑部件，它们通常具有不同的几何特性，使用硬编码知识将这些段分类为对象类法是一种简单有效的识别算法。但是，它仅适用于在硬编码知识中定义的约束情况，难以将该方法扩展到具有更复杂几何形状的其他物体类别。\n\n**监督学习**：使用机器学习算法来训练可以将点云数据分类为对象类的分类器。基于学习的物体识别有两种策略，基于点的分类，每个点使用点的本地特征分别分类为对象类。对于基于段的分类，点云数据通常使用数据分段算法划分为有意义的段，并且每个数据段都使用每个段的特征分类为对象类。\n\n**BIM‑vs‑Scan**：当整个结构建筑信息模型（Building Information Modeling）可用时，普遍采用更简单的基于BIM‑vs‑Scan的对象识别方法。\n\n\n\n\n\n---\n\n\n\n### 四、参考文献（前20）\n\n1.Bradley C, Vickers G, Milroy M (1994) Reverse engineering of  quadric surfaces employing threedimensional laser scanning.  Proc Inst Mech Eng Part B J Eng Manuf 208(1):21–28\n\n2.Son S, Park H, Lee KH (2002) Automated laser scanning system for reverse engineering and inspection. Int J Mach Tools  Manuf 42(8):889–897\n\n3.Varady T, Martin RR, Cox J (1997) Reverse engineering  of geometric models—an introduction. Comput Aided Des  29(4):255–268\n\n4.Yu X, Hyyppä J, Kaartinen H, Maltamo M (2004) Automatic detection of harvested trees and determination of forest  growth using airborne laser scanning. Remote Sens Environ  90(4):451–462\n\n5.Gaveau DL, Hill RA (2003) Quantifying canopy height underestimation by laser pulse penetration in small-footprint airborne laser scanning data. Can J Remote Sens 29(5):650–657\n\n6.Hollaus M, Wagner W, Maier B, Schadauer K (2007) Airborne  laser scanning of forest stem volume in a mountainous environment. Sensors 7(8):1559–1577\n\n7.Rosser N, Petley D, Lim M, Dunning S, Allison R (2005) Terrestrial laser scanning for monitoring the process of hard rock  coastal clif erosion. Q J Eng Geol Hydrogeol 38(4):363–375\n\n8.Heritage GL, Milan DJ (2009) Terrestrial laser scanning  of grain roughness in a gravel-bed river. Geomorphology  113(1–2):4–11\n\n9.Liu X (2008) Airborne LiDAR for DEM generation: some critical issues. Prog Phys Geogr 32(1):31–49\n\n10.Fröhlich C, Mettenleiter M (2004) Terrestrial laser scanning— new perspectives in 3D surveying. Int Arch Photogramm  Remote Sens Spat Inf Sci 36(Part 8):W2\n\n11.Olsen MJ, Kuester F, Chang BJ, Hutchinson TC (2009) Terrestrial laser scanning-based structural damage assessment. J  Comput Civ Eng 24(3):264–272\n\n12.Zhang C, Arditi D (2013) Automated progress control using  laser scanning technology. Autom Constr 36:108–116\n\n13.Leite F, Cho Y, Behzadan AH, Lee S, Choe S, Fang Y, Akhavian R, Hwang S (2016) Visualization, information modeling,  and simulation: grand challenges in the construction industry.  J Comput Civ Eng 30(6):04016035\n\n14.Kwon S, Lee M, Lee M, Lee S, Lee J (2013) Development of  optimized point cloud merging algorithms for accurate processing to create earthwork site models. Autom Constr 35:618–624\n\n15.Bosche F, Haas CT, Akinci B (2009) Automated recognition  of 3D CAD objects in site laser scans for project 3D status  visualization and performance control. J Comput Civ Eng  23(6):311–318\n\n16.Wang C, Cho YK (2015) Smart scanning and near real-time  3D surface modeling of dynamic construction equipment from  a point cloud. Autom Constr 49:239–249\n\n17.Tang P, Huber D, Akinci B, Lipman R, Lytle A (2010) Automatic reconstruction of as-built building information models  from laser-scanned point clouds: a review of related techniques. Autom Constr 19(7):829–843\n\n18.Wang Q, Kim M-K, Cheng JC, Sohn H (2016) Automated quality  assessment of precast concrete elements with geometry irregularities using terrestrial laser scanning. Autom Constr 68:170–182\n\n19.Volk R, Stengel J, Schultmann F (2014) Building information  modeling (BIM) for existing buildings—literature review and  future needs. Autom Constr 38:109–127\n\n20.Kim M-K, Cheng JC, Sohn H, Chang C-C (2015) A framework for dimensional and surface quality assessment of precast  concrete elements using BIM and 3D laser scanning. Autom  Constr 49:225-238\n\n","source":"_posts/2021-10-30-《Computational Methods of Acquisition and Processing of 3D Point Cloud Data for Construction Applications》阅读笔记.md","raw":"---\ntitle: 《Computational Methods of Acquisition and Processing of 3D Point Cloud Data for Construction Applications》阅读笔记\ndate: 2021-10-30 17:09:36\ncategories:\t阅读笔记\ntags:\n  - 三维点云\n---\n\n\n\n### \t一、信息\n\nQian Wang1 · Yi Tan2,3  · Zhongya Mei4\nReceived: 12 August 2018 / Accepted: 18 February 2019 \n© CIMNE, Barcelona, Spain 2019\n\nArchives of Computational Methods in Engineering \n\nhttps://doi.org/10.1007/s11831-019-09320-4\n\n\n\n<!--more-->\n\n---\n\n\n\n### 二、点云数据采集方法\n\n1.**3D激光扫描**：\n\n激光扫描仪通过发射激光束来测量与目标的距离并从目标中检测反射信号。主要有两种不同的测量方法，飞行时间技术和相移技术。\n\n飞行时间技术：使用飞行时间技术的扫描仪发射激光脉冲并测量反射脉冲的行 进时间t。由于激光的速度是已知的，因此可以从行进时间推断距离测量T。\n\n相移技术：使用相移技术的扫描仪发出幅度调制的连续波（AMCW）并测量发射和反射信号之间的相移。可以基于相位获得距离测量转换和调制连续波的波长。\n\n使用相移原理的扫描仪比使用飞行时间技术的扫描仪的测距精度和测量速度更高 ，使用飞行时间技术的扫描仪有更大的测量范围。\n\n\n\n2.**摄影测量**：\n\n摄影测量定义为获得有关物理对象和环境的可靠信息的艺术、科学和技术，是一种通过记录、测量和解释摄影图像和记录的辐射图案、电磁能量和其他现象的过程。\n\n这些图像仅使用来自不同位置的相机拍摄，从而捕获目标对象的不同部分。然后，算法将估计这些图像的相对位置，并最终将这些图像转换为3D点云。\n\n\n\n3.**视频测量**：\n\n类似于摄影测量，但将视频流作为输入数据而不是图像集合。视频测量可以使点云数据逐步重建，因为视频帧是连续的并且信息都建立在前一帧的基础上。\n\n视频测量对比摄影测量的一个优点是重建过程中较少的人工干预，因为可以通过测量或跟踪连续的视频帧之间的有趣特征来实现不同图像中的目标点的搜索。\n\n\n\n4.**RGB-D相机**：\n\n由RGB相机和深度传感器组成，RGB相机采用RGB图像，深度传感器以每像素为基础找到深度信息。最终，通过用深度信息映射RGB图像来生成彩色点云（包含XYZ坐标和RGB颜色）。\n\n\n\n5.**立体相机**：\n\n立体相机是一种相机系统，具有两个或多个具有单独图像传感器的镜头。由于一个镜头相对于另一个镜头的相对位置和方向已知，因此可以基于所获取的2D图像获得3D点云数据。\n\n\n\n---\n\n\n\n### 三、点云数据处理过程\n\n1.**数据清洗**：\n\n由于实际施工现场环境的复杂性，所获取的点云数据始终包含各种类型的噪声数据，这对于预期目的而言是无用的。此外，由于特定传感器的局限性，也发生各种类型的错误数据。因此，需要用于滤除噪声的算法来滤除无用数据并仅保留感兴趣的数据。\n\n混合像素：一种错误的激光扫描点，它发生在激光束正好落在物体边缘并一分为二的时候。激光束的两个部分落在两个不同的物体上，产生两种不同的反射激光信号。最后，激光扫描仪接收到两个反射信号并产生混合像素。\n\n传感器环绕噪声：激光扫描数据中另一种类型的噪声数据，当距离扫描仪到目标对象的实际距离超过激光扫描仪的非模糊距离时发生。\n\n幽灵几何：在激光扫描数据中捕获人或设备是不可避免的，这种移动物体只出现在一些扫描中， 并导致多次扫描数据不一致。\n\n\n\n2.**数据配准**：\n\n对准从公共坐标系中的不同位置收集的多个点云。由于大尺寸对象和遮挡物体，始终需要在不同位置进行数据采集（特别是激光扫描）以捕获目标对象的不同部分。在共享坐标系中对齐这些点云的过程称为数据配准，数据配准可以分为粗配准和精细配准。\n\n粗配准：包括点描述符定义，关键点检测，粗配准。首先定义点描述符描述每个点，突出重要特征，然后从点云检测关键点，原始点云减少到稀疏的关键点集。最后，通过两个点云重叠区域上检测到的关键点提取变换矩阵并配准两个点云。\n\n精细配准：最常用的方法是迭代最接近点（ICP）算法。\n\n\n\n3.**数据分割**：\n\n将点云数据分段为多个有意义的段或群集。这些段可以代表不同的对象或者代表可以促进点云数据的进一步处理的不同几何基元。所有方法都分为六个类别，包括基于聚类、基于边缘、基于区域、基于图形、基于模型拟合、混合的。\n\n**基于聚类**：根据点的某些特征使用聚类算法进行分段点云数据。\n\n**基于边缘**：基于边缘的分割算法检测3D点云数据中区域的边界以获得分段区域。\n\n**基于区域**：通常从一个或多个种子点开始一个区域 ，然后迭代地生长区域以包括根据某些标准的相邻点。但也存在一些不需要种子点的方法。这种类别的方法称为未特性区域分割方法。\n\n**基于图形**：在图形模型中，每个顶点对应于点云数据中的点，而图形的边缘用于连接相邻点。\n\n**基于模型拟合的分段方法**：基于模型拟合的分段方法起源于人造物体通常可以分解成简单的几何基元，例如平面、球形、圆柱体和其他基元。因此 ，原始形状装配到点云数据中，具有相同数学表示的点被标记为一个段。在现有的基于模型拟合的分段方法中，Hough 变换（HT）和随机样本共识（RANSAC）方法是最广泛的采用。\n\n**混合**：在混合技术中，组合两个或多于两种方法以从点云数据中检测。\n\n\n\n**优缺点**：\n\n基于聚类：优点：易于理解和实现。缺点：准确性问题，对数据中的噪声敏感，受邻域定义的影响。\n\n基于边缘：优点：快速分割。缺点：精度问题，对噪声敏感，对不均匀密度的点云敏感。\n\n基于区域：优点：处理噪音更准确。缺点：在分割和确定区域边界的准确性上有问题。\n\n基于图形：优点：处理不均匀密度或噪音复杂点云数据有更好的性能。缺点：无法实时处理，并且需要培训或其他系统来协助。\n\n基于模型拟合的分段方法：\n\n1.Hough变换（HT）：优点：快速且稳健地对抗异常值。缺点：较慢，对分段参数更敏感；\n\n2.随机样本共识（RANSAC）：优点：快速且稳健地对抗异常值，能够在合理短的时间段内处理大量点云数据。缺点：在处理不同点云源时的数据准确性。\n\n混合：优点：多种方法的优点使结果更准确。缺点：包含所选方法的所有缺点\n\n\n\n4.**对象识别**：\n\n识别点云数据中的某些对象。例如，要从点云数据中创建语义丰富的建筑物，建筑元素，如墙壁，窗口和门，必须从点云数据中识别。\n\n**几何形状描述符**：不同的对象实例或对象类通常具有不同的几何形状。因此，几何形状描述符描述了基于某些几何特征的对象形状，通常用于识别某个对象实例或对象类。通常以三个步骤执行：离线库生成，在线搜索，最终验证。\n\n**硬编码知识**：对于墙壁、屋顶和地板等主要建筑部件，它们通常具有不同的几何特性，使用硬编码知识将这些段分类为对象类法是一种简单有效的识别算法。但是，它仅适用于在硬编码知识中定义的约束情况，难以将该方法扩展到具有更复杂几何形状的其他物体类别。\n\n**监督学习**：使用机器学习算法来训练可以将点云数据分类为对象类的分类器。基于学习的物体识别有两种策略，基于点的分类，每个点使用点的本地特征分别分类为对象类。对于基于段的分类，点云数据通常使用数据分段算法划分为有意义的段，并且每个数据段都使用每个段的特征分类为对象类。\n\n**BIM‑vs‑Scan**：当整个结构建筑信息模型（Building Information Modeling）可用时，普遍采用更简单的基于BIM‑vs‑Scan的对象识别方法。\n\n\n\n\n\n---\n\n\n\n### 四、参考文献（前20）\n\n1.Bradley C, Vickers G, Milroy M (1994) Reverse engineering of  quadric surfaces employing threedimensional laser scanning.  Proc Inst Mech Eng Part B J Eng Manuf 208(1):21–28\n\n2.Son S, Park H, Lee KH (2002) Automated laser scanning system for reverse engineering and inspection. Int J Mach Tools  Manuf 42(8):889–897\n\n3.Varady T, Martin RR, Cox J (1997) Reverse engineering  of geometric models—an introduction. Comput Aided Des  29(4):255–268\n\n4.Yu X, Hyyppä J, Kaartinen H, Maltamo M (2004) Automatic detection of harvested trees and determination of forest  growth using airborne laser scanning. Remote Sens Environ  90(4):451–462\n\n5.Gaveau DL, Hill RA (2003) Quantifying canopy height underestimation by laser pulse penetration in small-footprint airborne laser scanning data. Can J Remote Sens 29(5):650–657\n\n6.Hollaus M, Wagner W, Maier B, Schadauer K (2007) Airborne  laser scanning of forest stem volume in a mountainous environment. Sensors 7(8):1559–1577\n\n7.Rosser N, Petley D, Lim M, Dunning S, Allison R (2005) Terrestrial laser scanning for monitoring the process of hard rock  coastal clif erosion. Q J Eng Geol Hydrogeol 38(4):363–375\n\n8.Heritage GL, Milan DJ (2009) Terrestrial laser scanning  of grain roughness in a gravel-bed river. Geomorphology  113(1–2):4–11\n\n9.Liu X (2008) Airborne LiDAR for DEM generation: some critical issues. Prog Phys Geogr 32(1):31–49\n\n10.Fröhlich C, Mettenleiter M (2004) Terrestrial laser scanning— new perspectives in 3D surveying. Int Arch Photogramm  Remote Sens Spat Inf Sci 36(Part 8):W2\n\n11.Olsen MJ, Kuester F, Chang BJ, Hutchinson TC (2009) Terrestrial laser scanning-based structural damage assessment. J  Comput Civ Eng 24(3):264–272\n\n12.Zhang C, Arditi D (2013) Automated progress control using  laser scanning technology. Autom Constr 36:108–116\n\n13.Leite F, Cho Y, Behzadan AH, Lee S, Choe S, Fang Y, Akhavian R, Hwang S (2016) Visualization, information modeling,  and simulation: grand challenges in the construction industry.  J Comput Civ Eng 30(6):04016035\n\n14.Kwon S, Lee M, Lee M, Lee S, Lee J (2013) Development of  optimized point cloud merging algorithms for accurate processing to create earthwork site models. Autom Constr 35:618–624\n\n15.Bosche F, Haas CT, Akinci B (2009) Automated recognition  of 3D CAD objects in site laser scans for project 3D status  visualization and performance control. J Comput Civ Eng  23(6):311–318\n\n16.Wang C, Cho YK (2015) Smart scanning and near real-time  3D surface modeling of dynamic construction equipment from  a point cloud. Autom Constr 49:239–249\n\n17.Tang P, Huber D, Akinci B, Lipman R, Lytle A (2010) Automatic reconstruction of as-built building information models  from laser-scanned point clouds: a review of related techniques. Autom Constr 19(7):829–843\n\n18.Wang Q, Kim M-K, Cheng JC, Sohn H (2016) Automated quality  assessment of precast concrete elements with geometry irregularities using terrestrial laser scanning. Autom Constr 68:170–182\n\n19.Volk R, Stengel J, Schultmann F (2014) Building information  modeling (BIM) for existing buildings—literature review and  future needs. Autom Constr 38:109–127\n\n20.Kim M-K, Cheng JC, Sohn H, Chang C-C (2015) A framework for dimensional and surface quality assessment of precast  concrete elements using BIM and 3D laser scanning. Autom  Constr 49:225-238\n\n","slug":"2021-10-30-《Computational Methods of Acquisition and Processing of 3D Point Cloud Data for Construction Applications》阅读笔记","published":1,"updated":"2022-01-23T05:35:24.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71ia002w1ou060vq6e48","content":"<h3 id=\"一、信息\"><a href=\"#一、信息\" class=\"headerlink\" title=\"一、信息\"></a>一、信息</h3><p>Qian Wang1 · Yi Tan2,3  · Zhongya Mei4<br>Received: 12 August 2018 / Accepted: 18 February 2019<br>© CIMNE, Barcelona, Spain 2019</p>\n<p>Archives of Computational Methods in Engineering </p>\n<p><a href=\"https://doi.org/10.1007/s11831-019-09320-4\">https://doi.org/10.1007/s11831-019-09320-4</a></p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"二、点云数据采集方法\"><a href=\"#二、点云数据采集方法\" class=\"headerlink\" title=\"二、点云数据采集方法\"></a>二、点云数据采集方法</h3><p>1.<strong>3D激光扫描</strong>：</p>\n<p>激光扫描仪通过发射激光束来测量与目标的距离并从目标中检测反射信号。主要有两种不同的测量方法，飞行时间技术和相移技术。</p>\n<p>飞行时间技术：使用飞行时间技术的扫描仪发射激光脉冲并测量反射脉冲的行 进时间t。由于激光的速度是已知的，因此可以从行进时间推断距离测量T。</p>\n<p>相移技术：使用相移技术的扫描仪发出幅度调制的连续波（AMCW）并测量发射和反射信号之间的相移。可以基于相位获得距离测量转换和调制连续波的波长。</p>\n<p>使用相移原理的扫描仪比使用飞行时间技术的扫描仪的测距精度和测量速度更高 ，使用飞行时间技术的扫描仪有更大的测量范围。</p>\n<p>2.<strong>摄影测量</strong>：</p>\n<p>摄影测量定义为获得有关物理对象和环境的可靠信息的艺术、科学和技术，是一种通过记录、测量和解释摄影图像和记录的辐射图案、电磁能量和其他现象的过程。</p>\n<p>这些图像仅使用来自不同位置的相机拍摄，从而捕获目标对象的不同部分。然后，算法将估计这些图像的相对位置，并最终将这些图像转换为3D点云。</p>\n<p>3.<strong>视频测量</strong>：</p>\n<p>类似于摄影测量，但将视频流作为输入数据而不是图像集合。视频测量可以使点云数据逐步重建，因为视频帧是连续的并且信息都建立在前一帧的基础上。</p>\n<p>视频测量对比摄影测量的一个优点是重建过程中较少的人工干预，因为可以通过测量或跟踪连续的视频帧之间的有趣特征来实现不同图像中的目标点的搜索。</p>\n<p>4.<strong>RGB-D相机</strong>：</p>\n<p>由RGB相机和深度传感器组成，RGB相机采用RGB图像，深度传感器以每像素为基础找到深度信息。最终，通过用深度信息映射RGB图像来生成彩色点云（包含XYZ坐标和RGB颜色）。</p>\n<p>5.<strong>立体相机</strong>：</p>\n<p>立体相机是一种相机系统，具有两个或多个具有单独图像传感器的镜头。由于一个镜头相对于另一个镜头的相对位置和方向已知，因此可以基于所获取的2D图像获得3D点云数据。</p>\n<hr>\n<h3 id=\"三、点云数据处理过程\"><a href=\"#三、点云数据处理过程\" class=\"headerlink\" title=\"三、点云数据处理过程\"></a>三、点云数据处理过程</h3><p>1.<strong>数据清洗</strong>：</p>\n<p>由于实际施工现场环境的复杂性，所获取的点云数据始终包含各种类型的噪声数据，这对于预期目的而言是无用的。此外，由于特定传感器的局限性，也发生各种类型的错误数据。因此，需要用于滤除噪声的算法来滤除无用数据并仅保留感兴趣的数据。</p>\n<p>混合像素：一种错误的激光扫描点，它发生在激光束正好落在物体边缘并一分为二的时候。激光束的两个部分落在两个不同的物体上，产生两种不同的反射激光信号。最后，激光扫描仪接收到两个反射信号并产生混合像素。</p>\n<p>传感器环绕噪声：激光扫描数据中另一种类型的噪声数据，当距离扫描仪到目标对象的实际距离超过激光扫描仪的非模糊距离时发生。</p>\n<p>幽灵几何：在激光扫描数据中捕获人或设备是不可避免的，这种移动物体只出现在一些扫描中， 并导致多次扫描数据不一致。</p>\n<p>2.<strong>数据配准</strong>：</p>\n<p>对准从公共坐标系中的不同位置收集的多个点云。由于大尺寸对象和遮挡物体，始终需要在不同位置进行数据采集（特别是激光扫描）以捕获目标对象的不同部分。在共享坐标系中对齐这些点云的过程称为数据配准，数据配准可以分为粗配准和精细配准。</p>\n<p>粗配准：包括点描述符定义，关键点检测，粗配准。首先定义点描述符描述每个点，突出重要特征，然后从点云检测关键点，原始点云减少到稀疏的关键点集。最后，通过两个点云重叠区域上检测到的关键点提取变换矩阵并配准两个点云。</p>\n<p>精细配准：最常用的方法是迭代最接近点（ICP）算法。</p>\n<p>3.<strong>数据分割</strong>：</p>\n<p>将点云数据分段为多个有意义的段或群集。这些段可以代表不同的对象或者代表可以促进点云数据的进一步处理的不同几何基元。所有方法都分为六个类别，包括基于聚类、基于边缘、基于区域、基于图形、基于模型拟合、混合的。</p>\n<p><strong>基于聚类</strong>：根据点的某些特征使用聚类算法进行分段点云数据。</p>\n<p><strong>基于边缘</strong>：基于边缘的分割算法检测3D点云数据中区域的边界以获得分段区域。</p>\n<p><strong>基于区域</strong>：通常从一个或多个种子点开始一个区域 ，然后迭代地生长区域以包括根据某些标准的相邻点。但也存在一些不需要种子点的方法。这种类别的方法称为未特性区域分割方法。</p>\n<p><strong>基于图形</strong>：在图形模型中，每个顶点对应于点云数据中的点，而图形的边缘用于连接相邻点。</p>\n<p><strong>基于模型拟合的分段方法</strong>：基于模型拟合的分段方法起源于人造物体通常可以分解成简单的几何基元，例如平面、球形、圆柱体和其他基元。因此 ，原始形状装配到点云数据中，具有相同数学表示的点被标记为一个段。在现有的基于模型拟合的分段方法中，Hough 变换（HT）和随机样本共识（RANSAC）方法是最广泛的采用。</p>\n<p><strong>混合</strong>：在混合技术中，组合两个或多于两种方法以从点云数据中检测。</p>\n<p><strong>优缺点</strong>：</p>\n<p>基于聚类：优点：易于理解和实现。缺点：准确性问题，对数据中的噪声敏感，受邻域定义的影响。</p>\n<p>基于边缘：优点：快速分割。缺点：精度问题，对噪声敏感，对不均匀密度的点云敏感。</p>\n<p>基于区域：优点：处理噪音更准确。缺点：在分割和确定区域边界的准确性上有问题。</p>\n<p>基于图形：优点：处理不均匀密度或噪音复杂点云数据有更好的性能。缺点：无法实时处理，并且需要培训或其他系统来协助。</p>\n<p>基于模型拟合的分段方法：</p>\n<p>1.Hough变换（HT）：优点：快速且稳健地对抗异常值。缺点：较慢，对分段参数更敏感；</p>\n<p>2.随机样本共识（RANSAC）：优点：快速且稳健地对抗异常值，能够在合理短的时间段内处理大量点云数据。缺点：在处理不同点云源时的数据准确性。</p>\n<p>混合：优点：多种方法的优点使结果更准确。缺点：包含所选方法的所有缺点</p>\n<p>4.<strong>对象识别</strong>：</p>\n<p>识别点云数据中的某些对象。例如，要从点云数据中创建语义丰富的建筑物，建筑元素，如墙壁，窗口和门，必须从点云数据中识别。</p>\n<p><strong>几何形状描述符</strong>：不同的对象实例或对象类通常具有不同的几何形状。因此，几何形状描述符描述了基于某些几何特征的对象形状，通常用于识别某个对象实例或对象类。通常以三个步骤执行：离线库生成，在线搜索，最终验证。</p>\n<p><strong>硬编码知识</strong>：对于墙壁、屋顶和地板等主要建筑部件，它们通常具有不同的几何特性，使用硬编码知识将这些段分类为对象类法是一种简单有效的识别算法。但是，它仅适用于在硬编码知识中定义的约束情况，难以将该方法扩展到具有更复杂几何形状的其他物体类别。</p>\n<p><strong>监督学习</strong>：使用机器学习算法来训练可以将点云数据分类为对象类的分类器。基于学习的物体识别有两种策略，基于点的分类，每个点使用点的本地特征分别分类为对象类。对于基于段的分类，点云数据通常使用数据分段算法划分为有意义的段，并且每个数据段都使用每个段的特征分类为对象类。</p>\n<p><strong>BIM‑vs‑Scan</strong>：当整个结构建筑信息模型（Building Information Modeling）可用时，普遍采用更简单的基于BIM‑vs‑Scan的对象识别方法。</p>\n<hr>\n<h3 id=\"四、参考文献（前20）\"><a href=\"#四、参考文献（前20）\" class=\"headerlink\" title=\"四、参考文献（前20）\"></a>四、参考文献（前20）</h3><p>1.Bradley C, Vickers G, Milroy M (1994) Reverse engineering of  quadric surfaces employing threedimensional laser scanning.  Proc Inst Mech Eng Part B J Eng Manuf 208(1):21–28</p>\n<p>2.Son S, Park H, Lee KH (2002) Automated laser scanning system for reverse engineering and inspection. Int J Mach Tools  Manuf 42(8):889–897</p>\n<p>3.Varady T, Martin RR, Cox J (1997) Reverse engineering  of geometric models—an introduction. Comput Aided Des  29(4):255–268</p>\n<p>4.Yu X, Hyyppä J, Kaartinen H, Maltamo M (2004) Automatic detection of harvested trees and determination of forest  growth using airborne laser scanning. Remote Sens Environ  90(4):451–462</p>\n<p>5.Gaveau DL, Hill RA (2003) Quantifying canopy height underestimation by laser pulse penetration in small-footprint airborne laser scanning data. Can J Remote Sens 29(5):650–657</p>\n<p>6.Hollaus M, Wagner W, Maier B, Schadauer K (2007) Airborne  laser scanning of forest stem volume in a mountainous environment. Sensors 7(8):1559–1577</p>\n<p>7.Rosser N, Petley D, Lim M, Dunning S, Allison R (2005) Terrestrial laser scanning for monitoring the process of hard rock  coastal clif erosion. Q J Eng Geol Hydrogeol 38(4):363–375</p>\n<p>8.Heritage GL, Milan DJ (2009) Terrestrial laser scanning  of grain roughness in a gravel-bed river. Geomorphology  113(1–2):4–11</p>\n<p>9.Liu X (2008) Airborne LiDAR for DEM generation: some critical issues. Prog Phys Geogr 32(1):31–49</p>\n<p>10.Fröhlich C, Mettenleiter M (2004) Terrestrial laser scanning— new perspectives in 3D surveying. Int Arch Photogramm  Remote Sens Spat Inf Sci 36(Part 8):W2</p>\n<p>11.Olsen MJ, Kuester F, Chang BJ, Hutchinson TC (2009) Terrestrial laser scanning-based structural damage assessment. J  Comput Civ Eng 24(3):264–272</p>\n<p>12.Zhang C, Arditi D (2013) Automated progress control using  laser scanning technology. Autom Constr 36:108–116</p>\n<p>13.Leite F, Cho Y, Behzadan AH, Lee S, Choe S, Fang Y, Akhavian R, Hwang S (2016) Visualization, information modeling,  and simulation: grand challenges in the construction industry.  J Comput Civ Eng 30(6):04016035</p>\n<p>14.Kwon S, Lee M, Lee M, Lee S, Lee J (2013) Development of  optimized point cloud merging algorithms for accurate processing to create earthwork site models. Autom Constr 35:618–624</p>\n<p>15.Bosche F, Haas CT, Akinci B (2009) Automated recognition  of 3D CAD objects in site laser scans for project 3D status  visualization and performance control. J Comput Civ Eng  23(6):311–318</p>\n<p>16.Wang C, Cho YK (2015) Smart scanning and near real-time  3D surface modeling of dynamic construction equipment from  a point cloud. Autom Constr 49:239–249</p>\n<p>17.Tang P, Huber D, Akinci B, Lipman R, Lytle A (2010) Automatic reconstruction of as-built building information models  from laser-scanned point clouds: a review of related techniques. Autom Constr 19(7):829–843</p>\n<p>18.Wang Q, Kim M-K, Cheng JC, Sohn H (2016) Automated quality  assessment of precast concrete elements with geometry irregularities using terrestrial laser scanning. Autom Constr 68:170–182</p>\n<p>19.Volk R, Stengel J, Schultmann F (2014) Building information  modeling (BIM) for existing buildings—literature review and  future needs. Autom Constr 38:109–127</p>\n<p>20.Kim M-K, Cheng JC, Sohn H, Chang C-C (2015) A framework for dimensional and surface quality assessment of precast  concrete elements using BIM and 3D laser scanning. Autom  Constr 49:225-238</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"一、信息\"><a href=\"#一、信息\" class=\"headerlink\" title=\"一、信息\"></a>一、信息</h3><p>Qian Wang1 · Yi Tan2,3  · Zhongya Mei4<br>Received: 12 August 2018 / Accepted: 18 February 2019<br>© CIMNE, Barcelona, Spain 2019</p>\n<p>Archives of Computational Methods in Engineering </p>\n<p><a href=\"https://doi.org/10.1007/s11831-019-09320-4\">https://doi.org/10.1007/s11831-019-09320-4</a></p>","more":"<hr>\n<h3 id=\"二、点云数据采集方法\"><a href=\"#二、点云数据采集方法\" class=\"headerlink\" title=\"二、点云数据采集方法\"></a>二、点云数据采集方法</h3><p>1.<strong>3D激光扫描</strong>：</p>\n<p>激光扫描仪通过发射激光束来测量与目标的距离并从目标中检测反射信号。主要有两种不同的测量方法，飞行时间技术和相移技术。</p>\n<p>飞行时间技术：使用飞行时间技术的扫描仪发射激光脉冲并测量反射脉冲的行 进时间t。由于激光的速度是已知的，因此可以从行进时间推断距离测量T。</p>\n<p>相移技术：使用相移技术的扫描仪发出幅度调制的连续波（AMCW）并测量发射和反射信号之间的相移。可以基于相位获得距离测量转换和调制连续波的波长。</p>\n<p>使用相移原理的扫描仪比使用飞行时间技术的扫描仪的测距精度和测量速度更高 ，使用飞行时间技术的扫描仪有更大的测量范围。</p>\n<p>2.<strong>摄影测量</strong>：</p>\n<p>摄影测量定义为获得有关物理对象和环境的可靠信息的艺术、科学和技术，是一种通过记录、测量和解释摄影图像和记录的辐射图案、电磁能量和其他现象的过程。</p>\n<p>这些图像仅使用来自不同位置的相机拍摄，从而捕获目标对象的不同部分。然后，算法将估计这些图像的相对位置，并最终将这些图像转换为3D点云。</p>\n<p>3.<strong>视频测量</strong>：</p>\n<p>类似于摄影测量，但将视频流作为输入数据而不是图像集合。视频测量可以使点云数据逐步重建，因为视频帧是连续的并且信息都建立在前一帧的基础上。</p>\n<p>视频测量对比摄影测量的一个优点是重建过程中较少的人工干预，因为可以通过测量或跟踪连续的视频帧之间的有趣特征来实现不同图像中的目标点的搜索。</p>\n<p>4.<strong>RGB-D相机</strong>：</p>\n<p>由RGB相机和深度传感器组成，RGB相机采用RGB图像，深度传感器以每像素为基础找到深度信息。最终，通过用深度信息映射RGB图像来生成彩色点云（包含XYZ坐标和RGB颜色）。</p>\n<p>5.<strong>立体相机</strong>：</p>\n<p>立体相机是一种相机系统，具有两个或多个具有单独图像传感器的镜头。由于一个镜头相对于另一个镜头的相对位置和方向已知，因此可以基于所获取的2D图像获得3D点云数据。</p>\n<hr>\n<h3 id=\"三、点云数据处理过程\"><a href=\"#三、点云数据处理过程\" class=\"headerlink\" title=\"三、点云数据处理过程\"></a>三、点云数据处理过程</h3><p>1.<strong>数据清洗</strong>：</p>\n<p>由于实际施工现场环境的复杂性，所获取的点云数据始终包含各种类型的噪声数据，这对于预期目的而言是无用的。此外，由于特定传感器的局限性，也发生各种类型的错误数据。因此，需要用于滤除噪声的算法来滤除无用数据并仅保留感兴趣的数据。</p>\n<p>混合像素：一种错误的激光扫描点，它发生在激光束正好落在物体边缘并一分为二的时候。激光束的两个部分落在两个不同的物体上，产生两种不同的反射激光信号。最后，激光扫描仪接收到两个反射信号并产生混合像素。</p>\n<p>传感器环绕噪声：激光扫描数据中另一种类型的噪声数据，当距离扫描仪到目标对象的实际距离超过激光扫描仪的非模糊距离时发生。</p>\n<p>幽灵几何：在激光扫描数据中捕获人或设备是不可避免的，这种移动物体只出现在一些扫描中， 并导致多次扫描数据不一致。</p>\n<p>2.<strong>数据配准</strong>：</p>\n<p>对准从公共坐标系中的不同位置收集的多个点云。由于大尺寸对象和遮挡物体，始终需要在不同位置进行数据采集（特别是激光扫描）以捕获目标对象的不同部分。在共享坐标系中对齐这些点云的过程称为数据配准，数据配准可以分为粗配准和精细配准。</p>\n<p>粗配准：包括点描述符定义，关键点检测，粗配准。首先定义点描述符描述每个点，突出重要特征，然后从点云检测关键点，原始点云减少到稀疏的关键点集。最后，通过两个点云重叠区域上检测到的关键点提取变换矩阵并配准两个点云。</p>\n<p>精细配准：最常用的方法是迭代最接近点（ICP）算法。</p>\n<p>3.<strong>数据分割</strong>：</p>\n<p>将点云数据分段为多个有意义的段或群集。这些段可以代表不同的对象或者代表可以促进点云数据的进一步处理的不同几何基元。所有方法都分为六个类别，包括基于聚类、基于边缘、基于区域、基于图形、基于模型拟合、混合的。</p>\n<p><strong>基于聚类</strong>：根据点的某些特征使用聚类算法进行分段点云数据。</p>\n<p><strong>基于边缘</strong>：基于边缘的分割算法检测3D点云数据中区域的边界以获得分段区域。</p>\n<p><strong>基于区域</strong>：通常从一个或多个种子点开始一个区域 ，然后迭代地生长区域以包括根据某些标准的相邻点。但也存在一些不需要种子点的方法。这种类别的方法称为未特性区域分割方法。</p>\n<p><strong>基于图形</strong>：在图形模型中，每个顶点对应于点云数据中的点，而图形的边缘用于连接相邻点。</p>\n<p><strong>基于模型拟合的分段方法</strong>：基于模型拟合的分段方法起源于人造物体通常可以分解成简单的几何基元，例如平面、球形、圆柱体和其他基元。因此 ，原始形状装配到点云数据中，具有相同数学表示的点被标记为一个段。在现有的基于模型拟合的分段方法中，Hough 变换（HT）和随机样本共识（RANSAC）方法是最广泛的采用。</p>\n<p><strong>混合</strong>：在混合技术中，组合两个或多于两种方法以从点云数据中检测。</p>\n<p><strong>优缺点</strong>：</p>\n<p>基于聚类：优点：易于理解和实现。缺点：准确性问题，对数据中的噪声敏感，受邻域定义的影响。</p>\n<p>基于边缘：优点：快速分割。缺点：精度问题，对噪声敏感，对不均匀密度的点云敏感。</p>\n<p>基于区域：优点：处理噪音更准确。缺点：在分割和确定区域边界的准确性上有问题。</p>\n<p>基于图形：优点：处理不均匀密度或噪音复杂点云数据有更好的性能。缺点：无法实时处理，并且需要培训或其他系统来协助。</p>\n<p>基于模型拟合的分段方法：</p>\n<p>1.Hough变换（HT）：优点：快速且稳健地对抗异常值。缺点：较慢，对分段参数更敏感；</p>\n<p>2.随机样本共识（RANSAC）：优点：快速且稳健地对抗异常值，能够在合理短的时间段内处理大量点云数据。缺点：在处理不同点云源时的数据准确性。</p>\n<p>混合：优点：多种方法的优点使结果更准确。缺点：包含所选方法的所有缺点</p>\n<p>4.<strong>对象识别</strong>：</p>\n<p>识别点云数据中的某些对象。例如，要从点云数据中创建语义丰富的建筑物，建筑元素，如墙壁，窗口和门，必须从点云数据中识别。</p>\n<p><strong>几何形状描述符</strong>：不同的对象实例或对象类通常具有不同的几何形状。因此，几何形状描述符描述了基于某些几何特征的对象形状，通常用于识别某个对象实例或对象类。通常以三个步骤执行：离线库生成，在线搜索，最终验证。</p>\n<p><strong>硬编码知识</strong>：对于墙壁、屋顶和地板等主要建筑部件，它们通常具有不同的几何特性，使用硬编码知识将这些段分类为对象类法是一种简单有效的识别算法。但是，它仅适用于在硬编码知识中定义的约束情况，难以将该方法扩展到具有更复杂几何形状的其他物体类别。</p>\n<p><strong>监督学习</strong>：使用机器学习算法来训练可以将点云数据分类为对象类的分类器。基于学习的物体识别有两种策略，基于点的分类，每个点使用点的本地特征分别分类为对象类。对于基于段的分类，点云数据通常使用数据分段算法划分为有意义的段，并且每个数据段都使用每个段的特征分类为对象类。</p>\n<p><strong>BIM‑vs‑Scan</strong>：当整个结构建筑信息模型（Building Information Modeling）可用时，普遍采用更简单的基于BIM‑vs‑Scan的对象识别方法。</p>\n<hr>\n<h3 id=\"四、参考文献（前20）\"><a href=\"#四、参考文献（前20）\" class=\"headerlink\" title=\"四、参考文献（前20）\"></a>四、参考文献（前20）</h3><p>1.Bradley C, Vickers G, Milroy M (1994) Reverse engineering of  quadric surfaces employing threedimensional laser scanning.  Proc Inst Mech Eng Part B J Eng Manuf 208(1):21–28</p>\n<p>2.Son S, Park H, Lee KH (2002) Automated laser scanning system for reverse engineering and inspection. Int J Mach Tools  Manuf 42(8):889–897</p>\n<p>3.Varady T, Martin RR, Cox J (1997) Reverse engineering  of geometric models—an introduction. Comput Aided Des  29(4):255–268</p>\n<p>4.Yu X, Hyyppä J, Kaartinen H, Maltamo M (2004) Automatic detection of harvested trees and determination of forest  growth using airborne laser scanning. Remote Sens Environ  90(4):451–462</p>\n<p>5.Gaveau DL, Hill RA (2003) Quantifying canopy height underestimation by laser pulse penetration in small-footprint airborne laser scanning data. Can J Remote Sens 29(5):650–657</p>\n<p>6.Hollaus M, Wagner W, Maier B, Schadauer K (2007) Airborne  laser scanning of forest stem volume in a mountainous environment. Sensors 7(8):1559–1577</p>\n<p>7.Rosser N, Petley D, Lim M, Dunning S, Allison R (2005) Terrestrial laser scanning for monitoring the process of hard rock  coastal clif erosion. Q J Eng Geol Hydrogeol 38(4):363–375</p>\n<p>8.Heritage GL, Milan DJ (2009) Terrestrial laser scanning  of grain roughness in a gravel-bed river. Geomorphology  113(1–2):4–11</p>\n<p>9.Liu X (2008) Airborne LiDAR for DEM generation: some critical issues. Prog Phys Geogr 32(1):31–49</p>\n<p>10.Fröhlich C, Mettenleiter M (2004) Terrestrial laser scanning— new perspectives in 3D surveying. Int Arch Photogramm  Remote Sens Spat Inf Sci 36(Part 8):W2</p>\n<p>11.Olsen MJ, Kuester F, Chang BJ, Hutchinson TC (2009) Terrestrial laser scanning-based structural damage assessment. J  Comput Civ Eng 24(3):264–272</p>\n<p>12.Zhang C, Arditi D (2013) Automated progress control using  laser scanning technology. Autom Constr 36:108–116</p>\n<p>13.Leite F, Cho Y, Behzadan AH, Lee S, Choe S, Fang Y, Akhavian R, Hwang S (2016) Visualization, information modeling,  and simulation: grand challenges in the construction industry.  J Comput Civ Eng 30(6):04016035</p>\n<p>14.Kwon S, Lee M, Lee M, Lee S, Lee J (2013) Development of  optimized point cloud merging algorithms for accurate processing to create earthwork site models. Autom Constr 35:618–624</p>\n<p>15.Bosche F, Haas CT, Akinci B (2009) Automated recognition  of 3D CAD objects in site laser scans for project 3D status  visualization and performance control. J Comput Civ Eng  23(6):311–318</p>\n<p>16.Wang C, Cho YK (2015) Smart scanning and near real-time  3D surface modeling of dynamic construction equipment from  a point cloud. Autom Constr 49:239–249</p>\n<p>17.Tang P, Huber D, Akinci B, Lipman R, Lytle A (2010) Automatic reconstruction of as-built building information models  from laser-scanned point clouds: a review of related techniques. Autom Constr 19(7):829–843</p>\n<p>18.Wang Q, Kim M-K, Cheng JC, Sohn H (2016) Automated quality  assessment of precast concrete elements with geometry irregularities using terrestrial laser scanning. Autom Constr 68:170–182</p>\n<p>19.Volk R, Stengel J, Schultmann F (2014) Building information  modeling (BIM) for existing buildings—literature review and  future needs. Autom Constr 38:109–127</p>\n<p>20.Kim M-K, Cheng JC, Sohn H, Chang C-C (2015) A framework for dimensional and surface quality assessment of precast  concrete elements using BIM and 3D laser scanning. Autom  Constr 49:225-238</p>"},{"title":"算法题方法总结（数组基础）","date":"2022-01-21T06:18:03.000Z","_content":"\n\n\n### \t始、前言\n\n有时候碰到一些以前做过的算法题，还是会忘记经典解法。\n\n是不是在记录题目的同时，也应该记录一下不同的解法呢？\n\n\n\n<!--more-->\n\n---\n\n### \t一、二分查找\n\n场景：遍历有序数组\n\n效果：使时间复杂度O(n)的遍历操作降低为O(logn)\n\n注意“循环不变量”规则，是左闭右闭`[left,  right]`还是左闭右开`[left, right)`，每一轮循环结束都要处理好边界，循环的判断条件也需要对应调整。\n\n求`mid`时为了防止计算过程中的数值溢出，要使用`mid = left + (right - left) / 2`而不是~~`mid = (left + right) / 2`~~\n\n\n\n### 二、双指针法（快慢指针法）\n\n场景：双层循环\n\n效果：一个循环内完成两个循环的工作，使时间复杂度O(n2)的遍历操作降低为O(n)\n\n注意指针在不同情况下的不同跳转位置，以及两个指针之间的差异\n\n\n\n### 三、滑动窗口\n\n场景：双层循环\n\n效果：不断调节窗口的起始位置和终止位置，使时间复杂度O(n2)的遍历操作降低为O(n)\n\n滑动窗口也可以理解为双指针法的一种，但是需要指针之间的数据，所以称之为窗口。\n\n重点是找到移动窗口起始位置和终止位置的条件\n\n\n\n\n","source":"_posts/2022-01-21-算法题方法总结（数组基础）.md","raw":"---\ntitle: 算法题方法总结（数组基础）\ndate: 2022-01-21 14:18:03\ncategories:\t算法\ntags:\n  - 数组\n\n---\n\n\n\n### \t始、前言\n\n有时候碰到一些以前做过的算法题，还是会忘记经典解法。\n\n是不是在记录题目的同时，也应该记录一下不同的解法呢？\n\n\n\n<!--more-->\n\n---\n\n### \t一、二分查找\n\n场景：遍历有序数组\n\n效果：使时间复杂度O(n)的遍历操作降低为O(logn)\n\n注意“循环不变量”规则，是左闭右闭`[left,  right]`还是左闭右开`[left, right)`，每一轮循环结束都要处理好边界，循环的判断条件也需要对应调整。\n\n求`mid`时为了防止计算过程中的数值溢出，要使用`mid = left + (right - left) / 2`而不是~~`mid = (left + right) / 2`~~\n\n\n\n### 二、双指针法（快慢指针法）\n\n场景：双层循环\n\n效果：一个循环内完成两个循环的工作，使时间复杂度O(n2)的遍历操作降低为O(n)\n\n注意指针在不同情况下的不同跳转位置，以及两个指针之间的差异\n\n\n\n### 三、滑动窗口\n\n场景：双层循环\n\n效果：不断调节窗口的起始位置和终止位置，使时间复杂度O(n2)的遍历操作降低为O(n)\n\n滑动窗口也可以理解为双指针法的一种，但是需要指针之间的数据，所以称之为窗口。\n\n重点是找到移动窗口起始位置和终止位置的条件\n\n\n\n\n","slug":"2022-01-21-算法题方法总结（数组基础）","published":1,"updated":"2022-02-03T08:20:40.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71ie00301ou0cy9t0kdb","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>有时候碰到一些以前做过的算法题，还是会忘记经典解法。</p>\n<p>是不是在记录题目的同时，也应该记录一下不同的解法呢？</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、二分查找\"><a href=\"#一、二分查找\" class=\"headerlink\" title=\"一、二分查找\"></a>一、二分查找</h3><p>场景：遍历有序数组</p>\n<p>效果：使时间复杂度O(n)的遍历操作降低为O(logn)</p>\n<p>注意“循环不变量”规则，是左闭右闭<code>[left,  right]</code>还是左闭右开<code>[left, right)</code>，每一轮循环结束都要处理好边界，循环的判断条件也需要对应调整。</p>\n<p>求<code>mid</code>时为了防止计算过程中的数值溢出，要使用<code>mid = left + (right - left) / 2</code>而不是<del><code>mid = (left + right) / 2</code></del></p>\n<h3 id=\"二、双指针法（快慢指针法）\"><a href=\"#二、双指针法（快慢指针法）\" class=\"headerlink\" title=\"二、双指针法（快慢指针法）\"></a>二、双指针法（快慢指针法）</h3><p>场景：双层循环</p>\n<p>效果：一个循环内完成两个循环的工作，使时间复杂度O(n2)的遍历操作降低为O(n)</p>\n<p>注意指针在不同情况下的不同跳转位置，以及两个指针之间的差异</p>\n<h3 id=\"三、滑动窗口\"><a href=\"#三、滑动窗口\" class=\"headerlink\" title=\"三、滑动窗口\"></a>三、滑动窗口</h3><p>场景：双层循环</p>\n<p>效果：不断调节窗口的起始位置和终止位置，使时间复杂度O(n2)的遍历操作降低为O(n)</p>\n<p>滑动窗口也可以理解为双指针法的一种，但是需要指针之间的数据，所以称之为窗口。</p>\n<p>重点是找到移动窗口起始位置和终止位置的条件</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>有时候碰到一些以前做过的算法题，还是会忘记经典解法。</p>\n<p>是不是在记录题目的同时，也应该记录一下不同的解法呢？</p>","more":"<hr>\n<h3 id=\"一、二分查找\"><a href=\"#一、二分查找\" class=\"headerlink\" title=\"一、二分查找\"></a>一、二分查找</h3><p>场景：遍历有序数组</p>\n<p>效果：使时间复杂度O(n)的遍历操作降低为O(logn)</p>\n<p>注意“循环不变量”规则，是左闭右闭<code>[left,  right]</code>还是左闭右开<code>[left, right)</code>，每一轮循环结束都要处理好边界，循环的判断条件也需要对应调整。</p>\n<p>求<code>mid</code>时为了防止计算过程中的数值溢出，要使用<code>mid = left + (right - left) / 2</code>而不是<del><code>mid = (left + right) / 2</code></del></p>\n<h3 id=\"二、双指针法（快慢指针法）\"><a href=\"#二、双指针法（快慢指针法）\" class=\"headerlink\" title=\"二、双指针法（快慢指针法）\"></a>二、双指针法（快慢指针法）</h3><p>场景：双层循环</p>\n<p>效果：一个循环内完成两个循环的工作，使时间复杂度O(n2)的遍历操作降低为O(n)</p>\n<p>注意指针在不同情况下的不同跳转位置，以及两个指针之间的差异</p>\n<h3 id=\"三、滑动窗口\"><a href=\"#三、滑动窗口\" class=\"headerlink\" title=\"三、滑动窗口\"></a>三、滑动窗口</h3><p>场景：双层循环</p>\n<p>效果：不断调节窗口的起始位置和终止位置，使时间复杂度O(n2)的遍历操作降低为O(n)</p>\n<p>滑动窗口也可以理解为双指针法的一种，但是需要指针之间的数据，所以称之为窗口。</p>\n<p>重点是找到移动窗口起始位置和终止位置的条件</p>"},{"title":"Ubuntu锐捷认证校园网并设置开机自启动","date":"2022-04-03T05:36:27.000Z","_content":"\n\n\n### \t始、前言\n\n深度学习离不开Linux系统，装好系统第一时间必须得是联网，这里总结一下我成功联网并实现开机自启动的过程，感叹一下这个锐捷校园网也是够复杂的。\n\n\n\n适用于台式机有线连接。\n\n如果过程中提示缺了什么就安装什么，基础功能的安装一般都只要一个命令，可以百度一下。\n\n\n\n<!--more-->\n\n---\n\n\n\n### 一、下载校园网官网提供的锐捷安装包Linux版并联网\n\n下载解压后是一个名为rjsupplicant的文件，将它放到你的home文件夹下，比如我的路径是 /home/xiong/Mywork/Tool/rjsupplicant\n\n\n\n我们只需要写一个脚本调用文件中的rjsupplicant.sh（也是一个脚本）。我在rjsupplicant同级的文件夹下打开终端（ctrl+alt+t），输入`touch rjzdrz.sh`，打开这个新建的脚本文件，可以在文件夹中双击，也可以继续在终端中输入`gedit rjzdrz.sh`。在脚本中编写如下内容：\n\n```\n#!/bin/bash\nsudo /home/xiong/Mywork/Tool/rjsupplicant/rjsupplicant.sh -u 123456789 -p 123456789 -d 1 -a 1\n```\n\n**注：**\n\n**1、sudo后面的路径要改成你放锐捷文件的路径**\n\n**2、-u 后面是学号，-p 后面是密码，我都用123456789代替了**\n\n**3、ubuntu中#表示注释，但这里的第一行不能省略**\n\n\n\n给脚本添加可执行权限`chmod +x rjzdrz.sh`，`chmod +x rjsupplicant.sh`\n\n\n\n这样一来我们就用了一个脚本来调用锐捷的联网认证了，可能由于不同学校或者软件更新导致认证需要填入的参数不同，可以打开锐捷的说明文档来差看相应的规则，需要联网时只要调用这个脚本就行，打开终端输入`bash rjzdrz.sh`，成功上网\n\n\n\n至此我们已经完成了：下载安装锐捷→编写脚本调用锐捷认证→调用脚本实现联网\n\n---\n\n### 二、图形方法实现开机自启动\n\n现在我们需要设置开机自动认证联网，毕竟除了特殊情况外谁也不希望每次开机都要找到文件夹打开终端手动输入一次`bash rjzdrz.sh`\n\n在ubuntu中搜索启动应用程序，在弹出的窗口中添加额外的启动程序，在“命令”一行写入`gnome-terminal -x bash \"/home/xiong/Mywork/Tool/rjzdrz.sh\"`，同样是改成自己相应的脚本存放位置\n\n![img](file:///C:\\Users\\Nobita\\Documents\\Tencent Files\\1448900840\\Image\\C2C\\90A8346D64723AC7C5A1952956E2E408.jpg)\n\n\n\n由于我们执行sudo之类的命令时要输入密码，开机自启动脚本就会失效，所以要给脚本添加不需要密码的权限\n\n终端中输入`sudo gedit /etc/sudoers`，在打开的文件中末尾添加一行：\n\n```\nxiong\tAll = NOPASSWD: /home/xiong/Mywork/Tool/rjsupplicant/rjsupplicant.sh\n```\n\n这里xiong是我的用户名，请替换自己的用户名和锐捷文件存放路径。\n\n\n\n重启电脑，开机自动弹出终端认证，自动联网\n","source":"_posts/2022-04-03-Ubuntu锐捷认证校园网并设置开机自启动.md","raw":"---\ntitle: Ubuntu锐捷认证校园网并设置开机自启动\ndate: 2022-04-03 13:36:27\ncategories: linux\ntags:\n  - linux\n  - ubuntu\n\n---\n\n\n\n### \t始、前言\n\n深度学习离不开Linux系统，装好系统第一时间必须得是联网，这里总结一下我成功联网并实现开机自启动的过程，感叹一下这个锐捷校园网也是够复杂的。\n\n\n\n适用于台式机有线连接。\n\n如果过程中提示缺了什么就安装什么，基础功能的安装一般都只要一个命令，可以百度一下。\n\n\n\n<!--more-->\n\n---\n\n\n\n### 一、下载校园网官网提供的锐捷安装包Linux版并联网\n\n下载解压后是一个名为rjsupplicant的文件，将它放到你的home文件夹下，比如我的路径是 /home/xiong/Mywork/Tool/rjsupplicant\n\n\n\n我们只需要写一个脚本调用文件中的rjsupplicant.sh（也是一个脚本）。我在rjsupplicant同级的文件夹下打开终端（ctrl+alt+t），输入`touch rjzdrz.sh`，打开这个新建的脚本文件，可以在文件夹中双击，也可以继续在终端中输入`gedit rjzdrz.sh`。在脚本中编写如下内容：\n\n```\n#!/bin/bash\nsudo /home/xiong/Mywork/Tool/rjsupplicant/rjsupplicant.sh -u 123456789 -p 123456789 -d 1 -a 1\n```\n\n**注：**\n\n**1、sudo后面的路径要改成你放锐捷文件的路径**\n\n**2、-u 后面是学号，-p 后面是密码，我都用123456789代替了**\n\n**3、ubuntu中#表示注释，但这里的第一行不能省略**\n\n\n\n给脚本添加可执行权限`chmod +x rjzdrz.sh`，`chmod +x rjsupplicant.sh`\n\n\n\n这样一来我们就用了一个脚本来调用锐捷的联网认证了，可能由于不同学校或者软件更新导致认证需要填入的参数不同，可以打开锐捷的说明文档来差看相应的规则，需要联网时只要调用这个脚本就行，打开终端输入`bash rjzdrz.sh`，成功上网\n\n\n\n至此我们已经完成了：下载安装锐捷→编写脚本调用锐捷认证→调用脚本实现联网\n\n---\n\n### 二、图形方法实现开机自启动\n\n现在我们需要设置开机自动认证联网，毕竟除了特殊情况外谁也不希望每次开机都要找到文件夹打开终端手动输入一次`bash rjzdrz.sh`\n\n在ubuntu中搜索启动应用程序，在弹出的窗口中添加额外的启动程序，在“命令”一行写入`gnome-terminal -x bash \"/home/xiong/Mywork/Tool/rjzdrz.sh\"`，同样是改成自己相应的脚本存放位置\n\n![img](file:///C:\\Users\\Nobita\\Documents\\Tencent Files\\1448900840\\Image\\C2C\\90A8346D64723AC7C5A1952956E2E408.jpg)\n\n\n\n由于我们执行sudo之类的命令时要输入密码，开机自启动脚本就会失效，所以要给脚本添加不需要密码的权限\n\n终端中输入`sudo gedit /etc/sudoers`，在打开的文件中末尾添加一行：\n\n```\nxiong\tAll = NOPASSWD: /home/xiong/Mywork/Tool/rjsupplicant/rjsupplicant.sh\n```\n\n这里xiong是我的用户名，请替换自己的用户名和锐捷文件存放路径。\n\n\n\n重启电脑，开机自动弹出终端认证，自动联网\n","slug":"2022-04-03-Ubuntu锐捷认证校园网并设置开机自启动","published":1,"updated":"2022-04-03T06:59:33.249Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71ig00321ou010le1cn9","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>深度学习离不开Linux系统，装好系统第一时间必须得是联网，这里总结一下我成功联网并实现开机自启动的过程，感叹一下这个锐捷校园网也是够复杂的。</p>\n<p>适用于台式机有线连接。</p>\n<p>如果过程中提示缺了什么就安装什么，基础功能的安装一般都只要一个命令，可以百度一下。</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、下载校园网官网提供的锐捷安装包Linux版并联网\"><a href=\"#一、下载校园网官网提供的锐捷安装包Linux版并联网\" class=\"headerlink\" title=\"一、下载校园网官网提供的锐捷安装包Linux版并联网\"></a>一、下载校园网官网提供的锐捷安装包Linux版并联网</h3><p>下载解压后是一个名为rjsupplicant的文件，将它放到你的home文件夹下，比如我的路径是 /home/xiong/Mywork/Tool/rjsupplicant</p>\n<p>我们只需要写一个脚本调用文件中的rjsupplicant.sh（也是一个脚本）。我在rjsupplicant同级的文件夹下打开终端（ctrl+alt+t），输入<code>touch rjzdrz.sh</code>，打开这个新建的脚本文件，可以在文件夹中双击，也可以继续在终端中输入<code>gedit rjzdrz.sh</code>。在脚本中编写如下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">sudo /home/xiong/Mywork/Tool/rjsupplicant/rjsupplicant.sh -u 123456789 -p 123456789 -d 1 -a 1</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：</strong></p>\n<p><strong>1、sudo后面的路径要改成你放锐捷文件的路径</strong></p>\n<p><strong>2、-u 后面是学号，-p 后面是密码，我都用123456789代替了</strong></p>\n<p><strong>3、ubuntu中#表示注释，但这里的第一行不能省略</strong></p>\n<p>给脚本添加可执行权限<code>chmod +x rjzdrz.sh</code>，<code>chmod +x rjsupplicant.sh</code></p>\n<p>这样一来我们就用了一个脚本来调用锐捷的联网认证了，可能由于不同学校或者软件更新导致认证需要填入的参数不同，可以打开锐捷的说明文档来差看相应的规则，需要联网时只要调用这个脚本就行，打开终端输入<code>bash rjzdrz.sh</code>，成功上网</p>\n<p>至此我们已经完成了：下载安装锐捷→编写脚本调用锐捷认证→调用脚本实现联网</p>\n<hr>\n<h3 id=\"二、图形方法实现开机自启动\"><a href=\"#二、图形方法实现开机自启动\" class=\"headerlink\" title=\"二、图形方法实现开机自启动\"></a>二、图形方法实现开机自启动</h3><p>现在我们需要设置开机自动认证联网，毕竟除了特殊情况外谁也不希望每次开机都要找到文件夹打开终端手动输入一次<code>bash rjzdrz.sh</code></p>\n<p>在ubuntu中搜索启动应用程序，在弹出的窗口中添加额外的启动程序，在“命令”一行写入<code>gnome-terminal -x bash &quot;/home/xiong/Mywork/Tool/rjzdrz.sh&quot;</code>，同样是改成自己相应的脚本存放位置</p>\n<p>![img](file:///C:\\Users\\Nobita\\Documents\\Tencent Files\\1448900840\\Image\\C2C\\90A8346D64723AC7C5A1952956E2E408.jpg)</p>\n<p>由于我们执行sudo之类的命令时要输入密码，开机自启动脚本就会失效，所以要给脚本添加不需要密码的权限</p>\n<p>终端中输入<code>sudo gedit /etc/sudoers</code>，在打开的文件中末尾添加一行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xiong\tAll = NOPASSWD: /home/xiong/Mywork/Tool/rjsupplicant/rjsupplicant.sh</span><br></pre></td></tr></table></figure>\n\n<p>这里xiong是我的用户名，请替换自己的用户名和锐捷文件存放路径。</p>\n<p>重启电脑，开机自动弹出终端认证，自动联网</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>深度学习离不开Linux系统，装好系统第一时间必须得是联网，这里总结一下我成功联网并实现开机自启动的过程，感叹一下这个锐捷校园网也是够复杂的。</p>\n<p>适用于台式机有线连接。</p>\n<p>如果过程中提示缺了什么就安装什么，基础功能的安装一般都只要一个命令，可以百度一下。</p>","more":"<hr>\n<h3 id=\"一、下载校园网官网提供的锐捷安装包Linux版并联网\"><a href=\"#一、下载校园网官网提供的锐捷安装包Linux版并联网\" class=\"headerlink\" title=\"一、下载校园网官网提供的锐捷安装包Linux版并联网\"></a>一、下载校园网官网提供的锐捷安装包Linux版并联网</h3><p>下载解压后是一个名为rjsupplicant的文件，将它放到你的home文件夹下，比如我的路径是 /home/xiong/Mywork/Tool/rjsupplicant</p>\n<p>我们只需要写一个脚本调用文件中的rjsupplicant.sh（也是一个脚本）。我在rjsupplicant同级的文件夹下打开终端（ctrl+alt+t），输入<code>touch rjzdrz.sh</code>，打开这个新建的脚本文件，可以在文件夹中双击，也可以继续在终端中输入<code>gedit rjzdrz.sh</code>。在脚本中编写如下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">sudo /home/xiong/Mywork/Tool/rjsupplicant/rjsupplicant.sh -u 123456789 -p 123456789 -d 1 -a 1</span><br></pre></td></tr></table></figure>\n\n<p><strong>注：</strong></p>\n<p><strong>1、sudo后面的路径要改成你放锐捷文件的路径</strong></p>\n<p><strong>2、-u 后面是学号，-p 后面是密码，我都用123456789代替了</strong></p>\n<p><strong>3、ubuntu中#表示注释，但这里的第一行不能省略</strong></p>\n<p>给脚本添加可执行权限<code>chmod +x rjzdrz.sh</code>，<code>chmod +x rjsupplicant.sh</code></p>\n<p>这样一来我们就用了一个脚本来调用锐捷的联网认证了，可能由于不同学校或者软件更新导致认证需要填入的参数不同，可以打开锐捷的说明文档来差看相应的规则，需要联网时只要调用这个脚本就行，打开终端输入<code>bash rjzdrz.sh</code>，成功上网</p>\n<p>至此我们已经完成了：下载安装锐捷→编写脚本调用锐捷认证→调用脚本实现联网</p>\n<hr>\n<h3 id=\"二、图形方法实现开机自启动\"><a href=\"#二、图形方法实现开机自启动\" class=\"headerlink\" title=\"二、图形方法实现开机自启动\"></a>二、图形方法实现开机自启动</h3><p>现在我们需要设置开机自动认证联网，毕竟除了特殊情况外谁也不希望每次开机都要找到文件夹打开终端手动输入一次<code>bash rjzdrz.sh</code></p>\n<p>在ubuntu中搜索启动应用程序，在弹出的窗口中添加额外的启动程序，在“命令”一行写入<code>gnome-terminal -x bash &quot;/home/xiong/Mywork/Tool/rjzdrz.sh&quot;</code>，同样是改成自己相应的脚本存放位置</p>\n<p>![img](file:///C:\\Users\\Nobita\\Documents\\Tencent Files\\1448900840\\Image\\C2C\\90A8346D64723AC7C5A1952956E2E408.jpg)</p>\n<p>由于我们执行sudo之类的命令时要输入密码，开机自启动脚本就会失效，所以要给脚本添加不需要密码的权限</p>\n<p>终端中输入<code>sudo gedit /etc/sudoers</code>，在打开的文件中末尾添加一行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xiong\tAll = NOPASSWD: /home/xiong/Mywork/Tool/rjsupplicant/rjsupplicant.sh</span><br></pre></td></tr></table></figure>\n\n<p>这里xiong是我的用户名，请替换自己的用户名和锐捷文件存放路径。</p>\n<p>重启电脑，开机自动弹出终端认证，自动联网</p>"},{"title":"C++STL","date":"2021-07-09T12:53:36.000Z","_content":"\n\n\n### \t始、STL初识\n\nSTL(standard template library)标准模板库\n\n广义上分为容器、算法、迭代器（容器和算法之间通过迭代器无缝连接）\n\n六大组件：容器、算法、迭代器、仿函数、适配器、空间配置器\n\n**主要学习以下四个：**\n\n​\t**容器**：vector、list、deque、set、map等\n\n​\t**算法(Algorithms)**：sort、find、copy、for_each等\n\n​\t**迭代器**：扮演容器与算法之间的胶合剂（每个容器都有自己专属的迭代器），迭代器可以理解成**指针**\n\n​\t**仿函数**：类似函数，可作为算法的某种策略\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t\t一、vector容器\n\nvector容器可以理解成**数组**\n\n\n\n初始化：`vector<数据类型> 容器名 (容器大小)`\n\n容器输入：`容器名. push_back(数据)`，尾插法插入数据\n\n起始迭代器：`容器名. begin()`，指向第一个元素\n\n结束迭代器：`容器名. end()`，指向最后一个元素的下一个位置\n\n自定义专属迭代器：`vector<数据类型> : : iterator 迭代器名`\n\n\n\n---\n\n\n\n### \t二、遍历算法：`for_each`\n\n```\nfor_each(InputIterator beg, InputIterator end, Function f) {\n  while(beg != end) \n    f(*beg++);\n}\n```\n\n\n\n\n\n---\n\n\n\n### \t\t三、map/multimap容器\n\nmap容器可以理解成**哈希表**（第三常用）\n\n\n\n**map中每个元素都是pair(对组元素)**\n\npair中第一个元素为key(键值)，第二个元素为value(实值)\n\n所有元素会根据键值自动排序\n\nmap不允许容器中有重复的key值，multimap允许容器中有重复的key值\n\n\n\n默认构造：`map<key类型, value类型> 容器名`\n\n拷贝构造：`map<key类型, value类型> 容器名 (拷贝容器名)`\n\n赋值：`容器名 = 目标容器名`\n\n插入数据：`容器名. insert(pair<key类型, value类型>(key, value))`\n\n\n\n---\n\n\n\n### 四、stack容器\n\nstack容器可以理解成**栈**\n\n栈是一种**先进后出(FILO)**的数据结构，只有一个出入口\n\n栈不允许有遍历行为，但可以判断是否为空、可以获取元素个数\n\n默认构造：`stack<数据类型> 容器名`\n\n拷贝构造：`stack<数据类型> 容器名 (拷贝容器名)`\n\n赋值操作：`容器名 = 目标容器名`\n\n入栈：`push(elem)`\n\n出栈：`pop()`\n\n栈顶：`top()`\n\n判空：`empty()`\n\n获取大小：`size()`\n\n\n\n---\n\n","source":"_posts/更2021-07-09-C++STL.md","raw":"---\ntitle: C++STL\ndate: 2021-07-09 20:53:36\ncategories: c++\ntags:\n  - c++\n  - map\n  - vector\n  - stack\n---\n\n\n\n### \t始、STL初识\n\nSTL(standard template library)标准模板库\n\n广义上分为容器、算法、迭代器（容器和算法之间通过迭代器无缝连接）\n\n六大组件：容器、算法、迭代器、仿函数、适配器、空间配置器\n\n**主要学习以下四个：**\n\n​\t**容器**：vector、list、deque、set、map等\n\n​\t**算法(Algorithms)**：sort、find、copy、for_each等\n\n​\t**迭代器**：扮演容器与算法之间的胶合剂（每个容器都有自己专属的迭代器），迭代器可以理解成**指针**\n\n​\t**仿函数**：类似函数，可作为算法的某种策略\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t\t一、vector容器\n\nvector容器可以理解成**数组**\n\n\n\n初始化：`vector<数据类型> 容器名 (容器大小)`\n\n容器输入：`容器名. push_back(数据)`，尾插法插入数据\n\n起始迭代器：`容器名. begin()`，指向第一个元素\n\n结束迭代器：`容器名. end()`，指向最后一个元素的下一个位置\n\n自定义专属迭代器：`vector<数据类型> : : iterator 迭代器名`\n\n\n\n---\n\n\n\n### \t二、遍历算法：`for_each`\n\n```\nfor_each(InputIterator beg, InputIterator end, Function f) {\n  while(beg != end) \n    f(*beg++);\n}\n```\n\n\n\n\n\n---\n\n\n\n### \t\t三、map/multimap容器\n\nmap容器可以理解成**哈希表**（第三常用）\n\n\n\n**map中每个元素都是pair(对组元素)**\n\npair中第一个元素为key(键值)，第二个元素为value(实值)\n\n所有元素会根据键值自动排序\n\nmap不允许容器中有重复的key值，multimap允许容器中有重复的key值\n\n\n\n默认构造：`map<key类型, value类型> 容器名`\n\n拷贝构造：`map<key类型, value类型> 容器名 (拷贝容器名)`\n\n赋值：`容器名 = 目标容器名`\n\n插入数据：`容器名. insert(pair<key类型, value类型>(key, value))`\n\n\n\n---\n\n\n\n### 四、stack容器\n\nstack容器可以理解成**栈**\n\n栈是一种**先进后出(FILO)**的数据结构，只有一个出入口\n\n栈不允许有遍历行为，但可以判断是否为空、可以获取元素个数\n\n默认构造：`stack<数据类型> 容器名`\n\n拷贝构造：`stack<数据类型> 容器名 (拷贝容器名)`\n\n赋值操作：`容器名 = 目标容器名`\n\n入栈：`push(elem)`\n\n出栈：`pop()`\n\n栈顶：`top()`\n\n判空：`empty()`\n\n获取大小：`size()`\n\n\n\n---\n\n","slug":"更2021-07-09-C++STL","published":1,"updated":"2021-08-19T11:07:32.470Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71in00361ou0cyhde4ks","content":"<h3 id=\"始、STL初识\"><a href=\"#始、STL初识\" class=\"headerlink\" title=\"始、STL初识\"></a>始、STL初识</h3><p>STL(standard template library)标准模板库</p>\n<p>广义上分为容器、算法、迭代器（容器和算法之间通过迭代器无缝连接）</p>\n<p>六大组件：容器、算法、迭代器、仿函数、适配器、空间配置器</p>\n<p><strong>主要学习以下四个：</strong></p>\n<p>​    <strong>容器</strong>：vector、list、deque、set、map等</p>\n<p>​    **算法(Algorithms)**：sort、find、copy、for_each等</p>\n<p>​    <strong>迭代器</strong>：扮演容器与算法之间的胶合剂（每个容器都有自己专属的迭代器），迭代器可以理解成<strong>指针</strong></p>\n<p>​    <strong>仿函数</strong>：类似函数，可作为算法的某种策略</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、vector容器\"><a href=\"#一、vector容器\" class=\"headerlink\" title=\"一、vector容器\"></a>一、vector容器</h3><p>vector容器可以理解成<strong>数组</strong></p>\n<p>初始化：<code>vector&lt;数据类型&gt; 容器名 (容器大小)</code></p>\n<p>容器输入：<code>容器名. push_back(数据)</code>，尾插法插入数据</p>\n<p>起始迭代器：<code>容器名. begin()</code>，指向第一个元素</p>\n<p>结束迭代器：<code>容器名. end()</code>，指向最后一个元素的下一个位置</p>\n<p>自定义专属迭代器：<code>vector&lt;数据类型&gt; : : iterator 迭代器名</code></p>\n<hr>\n<h3 id=\"二、遍历算法：for-each\"><a href=\"#二、遍历算法：for-each\" class=\"headerlink\" title=\"二、遍历算法：for_each\"></a>二、遍历算法：<code>for_each</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for_each(InputIterator beg, InputIterator end, Function f) &#123;</span><br><span class=\"line\">  while(beg != end) </span><br><span class=\"line\">    f(*beg++);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<hr>\n<h3 id=\"三、map-multimap容器\"><a href=\"#三、map-multimap容器\" class=\"headerlink\" title=\"三、map/multimap容器\"></a>三、map/multimap容器</h3><p>map容器可以理解成<strong>哈希表</strong>（第三常用）</p>\n<p><strong>map中每个元素都是pair(对组元素)</strong></p>\n<p>pair中第一个元素为key(键值)，第二个元素为value(实值)</p>\n<p>所有元素会根据键值自动排序</p>\n<p>map不允许容器中有重复的key值，multimap允许容器中有重复的key值</p>\n<p>默认构造：<code>map&lt;key类型, value类型&gt; 容器名</code></p>\n<p>拷贝构造：<code>map&lt;key类型, value类型&gt; 容器名 (拷贝容器名)</code></p>\n<p>赋值：<code>容器名 = 目标容器名</code></p>\n<p>插入数据：<code>容器名. insert(pair&lt;key类型, value类型&gt;(key, value))</code></p>\n<hr>\n<h3 id=\"四、stack容器\"><a href=\"#四、stack容器\" class=\"headerlink\" title=\"四、stack容器\"></a>四、stack容器</h3><p>stack容器可以理解成<strong>栈</strong></p>\n<p>栈是一种**先进后出(FILO)**的数据结构，只有一个出入口</p>\n<p>栈不允许有遍历行为，但可以判断是否为空、可以获取元素个数</p>\n<p>默认构造：<code>stack&lt;数据类型&gt; 容器名</code></p>\n<p>拷贝构造：<code>stack&lt;数据类型&gt; 容器名 (拷贝容器名)</code></p>\n<p>赋值操作：<code>容器名 = 目标容器名</code></p>\n<p>入栈：<code>push(elem)</code></p>\n<p>出栈：<code>pop()</code></p>\n<p>栈顶：<code>top()</code></p>\n<p>判空：<code>empty()</code></p>\n<p>获取大小：<code>size()</code></p>\n<hr>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、STL初识\"><a href=\"#始、STL初识\" class=\"headerlink\" title=\"始、STL初识\"></a>始、STL初识</h3><p>STL(standard template library)标准模板库</p>\n<p>广义上分为容器、算法、迭代器（容器和算法之间通过迭代器无缝连接）</p>\n<p>六大组件：容器、算法、迭代器、仿函数、适配器、空间配置器</p>\n<p><strong>主要学习以下四个：</strong></p>\n<p>​    <strong>容器</strong>：vector、list、deque、set、map等</p>\n<p>​    **算法(Algorithms)**：sort、find、copy、for_each等</p>\n<p>​    <strong>迭代器</strong>：扮演容器与算法之间的胶合剂（每个容器都有自己专属的迭代器），迭代器可以理解成<strong>指针</strong></p>\n<p>​    <strong>仿函数</strong>：类似函数，可作为算法的某种策略</p>","more":"<hr>\n<h3 id=\"一、vector容器\"><a href=\"#一、vector容器\" class=\"headerlink\" title=\"一、vector容器\"></a>一、vector容器</h3><p>vector容器可以理解成<strong>数组</strong></p>\n<p>初始化：<code>vector&lt;数据类型&gt; 容器名 (容器大小)</code></p>\n<p>容器输入：<code>容器名. push_back(数据)</code>，尾插法插入数据</p>\n<p>起始迭代器：<code>容器名. begin()</code>，指向第一个元素</p>\n<p>结束迭代器：<code>容器名. end()</code>，指向最后一个元素的下一个位置</p>\n<p>自定义专属迭代器：<code>vector&lt;数据类型&gt; : : iterator 迭代器名</code></p>\n<hr>\n<h3 id=\"二、遍历算法：for-each\"><a href=\"#二、遍历算法：for-each\" class=\"headerlink\" title=\"二、遍历算法：for_each\"></a>二、遍历算法：<code>for_each</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for_each(InputIterator beg, InputIterator end, Function f) &#123;</span><br><span class=\"line\">  while(beg != end) </span><br><span class=\"line\">    f(*beg++);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<hr>\n<h3 id=\"三、map-multimap容器\"><a href=\"#三、map-multimap容器\" class=\"headerlink\" title=\"三、map/multimap容器\"></a>三、map/multimap容器</h3><p>map容器可以理解成<strong>哈希表</strong>（第三常用）</p>\n<p><strong>map中每个元素都是pair(对组元素)</strong></p>\n<p>pair中第一个元素为key(键值)，第二个元素为value(实值)</p>\n<p>所有元素会根据键值自动排序</p>\n<p>map不允许容器中有重复的key值，multimap允许容器中有重复的key值</p>\n<p>默认构造：<code>map&lt;key类型, value类型&gt; 容器名</code></p>\n<p>拷贝构造：<code>map&lt;key类型, value类型&gt; 容器名 (拷贝容器名)</code></p>\n<p>赋值：<code>容器名 = 目标容器名</code></p>\n<p>插入数据：<code>容器名. insert(pair&lt;key类型, value类型&gt;(key, value))</code></p>\n<hr>\n<h3 id=\"四、stack容器\"><a href=\"#四、stack容器\" class=\"headerlink\" title=\"四、stack容器\"></a>四、stack容器</h3><p>stack容器可以理解成<strong>栈</strong></p>\n<p>栈是一种**先进后出(FILO)**的数据结构，只有一个出入口</p>\n<p>栈不允许有遍历行为，但可以判断是否为空、可以获取元素个数</p>\n<p>默认构造：<code>stack&lt;数据类型&gt; 容器名</code></p>\n<p>拷贝构造：<code>stack&lt;数据类型&gt; 容器名 (拷贝容器名)</code></p>\n<p>赋值操作：<code>容器名 = 目标容器名</code></p>\n<p>入栈：<code>push(elem)</code></p>\n<p>出栈：<code>pop()</code></p>\n<p>栈顶：<code>top()</code></p>\n<p>判空：<code>empty()</code></p>\n<p>获取大小：<code>size()</code></p>\n<hr>"},{"title":"《Robbie Swifthand》Unity2d独立游戏学习（八）","date":"2021-09-13T02:08:28.000Z","_content":"\n\n\n### \t始、前言\n\n先解决之前遗留下来的问题：场景重置时重复生成Audio Manager，导致声音重复并且游戏卡顿。\n\n<!--more-->\n\n修改Audio Manager脚本：\n\n```\n    private void Awake()\n    {\n        if(current != null)\n        {\n            Destroy(gameObject);\n            return;\n        }\n        current = this;\n        //切换场景也不会销毁这个物体\n        DontDestroyOnLoad(gameObject);\n    }\n```\n\n在场景初始化时添加判断`if(current != null)`，当场景中已经存在此类物体时摧毁刚生成的新物体并且不再执行以下代码\n\n\n\n---\n\n\n\n### \t一、GameManager\n\n1.新建物体GameManager\n\n1.新建脚本GameManager（注意拼写，拼写正确时脚本图标会变成齿轮），挂载到GameManager物体下：\n\n```\nusing UnityEngine.SceneManagement;\n\npublic class GameManager : MonoBehaviour\n{\n    static GameManager instance;\n\n    private void Awake()\n    {\n        if(instance != null)\n        {\n            Destroy(gameObject);\n            return;\n        }\n        instance = this;\n\n        DontDestroyOnLoad(this);\n    }\n\n    public static void PlayerDied()\n    {\n        //经过1.5s后重新加载场景\n        instance.Invoke(\"RestartScene\", 1.5f);\n    }\n\n    void RestartScene()\n    {\n        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);\n    }\n\n}\n```\n\n完成角色死亡时重新加载场景的代码\n\n\n\n3.然后在PalyerHealth脚本中调用GameManager.PlayerDied();\n\n```\n   private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if(collision.gameObject.layer == trapsLayer)\n        {\n            Instantiate(deathVFXPrefab, transform.position, transform.rotation);\n            gameObject.SetActive(false);\n\n            AudioManager.PlayDeathAudio();\n\n           /* SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);*/\n           //调用GameManager中的方法来实现场景重置\n            GameManager.PlayerDied();\n        }\n    }\n\n```\n\n\n\n4.添加重启场景的动画效果\n\n","source":"_posts/更2021-09-13-《Robbie Swifthand》Unity2d独立游戏学习（八）.md","raw":"---\ntitle: 《Robbie Swifthand》Unity2d独立游戏学习（八）\ndate: 2021-09-13 10:08:28\ncategories:\tunity\ntags:\n  - unity\n  - c#\n---\n\n\n\n### \t始、前言\n\n先解决之前遗留下来的问题：场景重置时重复生成Audio Manager，导致声音重复并且游戏卡顿。\n\n<!--more-->\n\n修改Audio Manager脚本：\n\n```\n    private void Awake()\n    {\n        if(current != null)\n        {\n            Destroy(gameObject);\n            return;\n        }\n        current = this;\n        //切换场景也不会销毁这个物体\n        DontDestroyOnLoad(gameObject);\n    }\n```\n\n在场景初始化时添加判断`if(current != null)`，当场景中已经存在此类物体时摧毁刚生成的新物体并且不再执行以下代码\n\n\n\n---\n\n\n\n### \t一、GameManager\n\n1.新建物体GameManager\n\n1.新建脚本GameManager（注意拼写，拼写正确时脚本图标会变成齿轮），挂载到GameManager物体下：\n\n```\nusing UnityEngine.SceneManagement;\n\npublic class GameManager : MonoBehaviour\n{\n    static GameManager instance;\n\n    private void Awake()\n    {\n        if(instance != null)\n        {\n            Destroy(gameObject);\n            return;\n        }\n        instance = this;\n\n        DontDestroyOnLoad(this);\n    }\n\n    public static void PlayerDied()\n    {\n        //经过1.5s后重新加载场景\n        instance.Invoke(\"RestartScene\", 1.5f);\n    }\n\n    void RestartScene()\n    {\n        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);\n    }\n\n}\n```\n\n完成角色死亡时重新加载场景的代码\n\n\n\n3.然后在PalyerHealth脚本中调用GameManager.PlayerDied();\n\n```\n   private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if(collision.gameObject.layer == trapsLayer)\n        {\n            Instantiate(deathVFXPrefab, transform.position, transform.rotation);\n            gameObject.SetActive(false);\n\n            AudioManager.PlayDeathAudio();\n\n           /* SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);*/\n           //调用GameManager中的方法来实现场景重置\n            GameManager.PlayerDied();\n        }\n    }\n\n```\n\n\n\n4.添加重启场景的动画效果\n\n","slug":"更2021-09-13-《Robbie Swifthand》Unity2d独立游戏学习（八）","published":1,"updated":"2021-09-19T09:49:31.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71ip00391ou036qt9odd","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>先解决之前遗留下来的问题：场景重置时重复生成Audio Manager，导致声音重复并且游戏卡顿。</p>\n<span id=\"more\"></span>\n\n<p>修改Audio Manager脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void Awake()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(current != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Destroy(gameObject);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    current = this;</span><br><span class=\"line\">    //切换场景也不会销毁这个物体</span><br><span class=\"line\">    DontDestroyOnLoad(gameObject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在场景初始化时添加判断<code>if(current != null)</code>，当场景中已经存在此类物体时摧毁刚生成的新物体并且不再执行以下代码</p>\n<hr>\n<h3 id=\"一、GameManager\"><a href=\"#一、GameManager\" class=\"headerlink\" title=\"一、GameManager\"></a>一、GameManager</h3><p>1.新建物体GameManager</p>\n<p>1.新建脚本GameManager（注意拼写，拼写正确时脚本图标会变成齿轮），挂载到GameManager物体下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using UnityEngine.SceneManagement;</span><br><span class=\"line\"></span><br><span class=\"line\">public class GameManager : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static GameManager instance;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void Awake()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(instance != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        instance = this;</span><br><span class=\"line\"></span><br><span class=\"line\">        DontDestroyOnLoad(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void PlayerDied()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //经过1.5s后重新加载场景</span><br><span class=\"line\">        instance.Invoke(&quot;RestartScene&quot;, 1.5f);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void RestartScene()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完成角色死亡时重新加载场景的代码</p>\n<p>3.然后在PalyerHealth脚本中调用GameManager.PlayerDied();</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     if(collision.gameObject.layer == trapsLayer)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         Instantiate(deathVFXPrefab, transform.position, transform.rotation);</span><br><span class=\"line\">         gameObject.SetActive(false);</span><br><span class=\"line\"></span><br><span class=\"line\">         AudioManager.PlayDeathAudio();</span><br><span class=\"line\"></span><br><span class=\"line\">        /* SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);*/</span><br><span class=\"line\">        //调用GameManager中的方法来实现场景重置</span><br><span class=\"line\">         GameManager.PlayerDied();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>4.添加重启场景的动画效果</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>先解决之前遗留下来的问题：场景重置时重复生成Audio Manager，导致声音重复并且游戏卡顿。</p>","more":"<p>修改Audio Manager脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void Awake()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(current != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Destroy(gameObject);</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    current = this;</span><br><span class=\"line\">    //切换场景也不会销毁这个物体</span><br><span class=\"line\">    DontDestroyOnLoad(gameObject);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在场景初始化时添加判断<code>if(current != null)</code>，当场景中已经存在此类物体时摧毁刚生成的新物体并且不再执行以下代码</p>\n<hr>\n<h3 id=\"一、GameManager\"><a href=\"#一、GameManager\" class=\"headerlink\" title=\"一、GameManager\"></a>一、GameManager</h3><p>1.新建物体GameManager</p>\n<p>1.新建脚本GameManager（注意拼写，拼写正确时脚本图标会变成齿轮），挂载到GameManager物体下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using UnityEngine.SceneManagement;</span><br><span class=\"line\"></span><br><span class=\"line\">public class GameManager : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static GameManager instance;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void Awake()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(instance != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        instance = this;</span><br><span class=\"line\"></span><br><span class=\"line\">        DontDestroyOnLoad(this);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void PlayerDied()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //经过1.5s后重新加载场景</span><br><span class=\"line\">        instance.Invoke(&quot;RestartScene&quot;, 1.5f);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void RestartScene()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完成角色死亡时重新加载场景的代码</p>\n<p>3.然后在PalyerHealth脚本中调用GameManager.PlayerDied();</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     if(collision.gameObject.layer == trapsLayer)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         Instantiate(deathVFXPrefab, transform.position, transform.rotation);</span><br><span class=\"line\">         gameObject.SetActive(false);</span><br><span class=\"line\"></span><br><span class=\"line\">         AudioManager.PlayDeathAudio();</span><br><span class=\"line\"></span><br><span class=\"line\">        /* SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);*/</span><br><span class=\"line\">        //调用GameManager中的方法来实现场景重置</span><br><span class=\"line\">         GameManager.PlayerDied();</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>4.添加重启场景的动画效果</p>"},{"title":"算法题方法总结（链表基础）","date":"2022-02-03T12:51:36.000Z","_content":"\n\n\n### \t始、\n","source":"_posts/更2022-02-03-算法题方法总结（链表基础）.md","raw":"---\ntitle: 算法题方法总结（链表基础）\ndate: 2022-02-03 20:51:36\ncategories:\t算法\ntags:\n  - 链表\n\n---\n\n\n\n### \t始、\n","slug":"更2022-02-03-算法题方法总结（链表基础）","published":1,"updated":"2022-02-06T05:56:54.133Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71it003c1ou09mma7ic3","content":"<h3 id=\"始、\"><a href=\"#始、\" class=\"headerlink\" title=\"始、\"></a>始、</h3>","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"","more":"<h3 id=\"始、\"><a href=\"#始、\" class=\"headerlink\" title=\"始、\"></a>始、</h3>"},{"top":true,"title":"Top","date":"2021-07-09T15:38:24.000Z","_content":"\n\n\n# <center>备忘</center>\n\n​\t<!--more-->\n\n### <center>大坏蛋，爱偷看</center>\n\n\n\n### 版本：\n\n`hexo 5.4`\n\n`next 7.8`\n\n\n\n### \thexo + github 常用指令及个性化步骤：\n\n新建文章：`hexo n 文章名`\n\n发布到本地：`hexo s`\n\n部署到github：`hexo clean` ， `hexo g -d`\n\n备份源文件到github：`git add .` ， `git commit -m 备注` ，  `git push origin hexo`\n\n\n\n更改背景图案：将图片放入`Blog → blog → themes → next → source → assets`，在`Blog → blog → source → _data`中调整图片\n","source":"_posts/置顶页面Top.md","raw":"---\ntop: true\ntitle: Top\ndate: 2021-07-09 23:38:24\ncategories: 琐碎\ntags:\n---\n\n\n\n# <center>备忘</center>\n\n​\t<!--more-->\n\n### <center>大坏蛋，爱偷看</center>\n\n\n\n### 版本：\n\n`hexo 5.4`\n\n`next 7.8`\n\n\n\n### \thexo + github 常用指令及个性化步骤：\n\n新建文章：`hexo n 文章名`\n\n发布到本地：`hexo s`\n\n部署到github：`hexo clean` ， `hexo g -d`\n\n备份源文件到github：`git add .` ， `git commit -m 备注` ，  `git push origin hexo`\n\n\n\n更改背景图案：将图片放入`Blog → blog → themes → next → source → assets`，在`Blog → blog → source → _data`中调整图片\n","slug":"置顶页面Top","published":1,"updated":"2021-10-06T07:20:10.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71iv003f1ou0416o1j06","content":"<h1 id=\"备忘\"><a href=\"#备忘\" class=\"headerlink\" title=\"备忘\"></a><center>备忘</center></h1><p>​    <span id=\"more\"></span></p>\n<h3 id=\"大坏蛋，爱偷看\"><a href=\"#大坏蛋，爱偷看\" class=\"headerlink\" title=\"大坏蛋，爱偷看\"></a><center>大坏蛋，爱偷看</center></h3><h3 id=\"版本：\"><a href=\"#版本：\" class=\"headerlink\" title=\"版本：\"></a>版本：</h3><p><code>hexo 5.4</code></p>\n<p><code>next 7.8</code></p>\n<h3 id=\"hexo-github-常用指令及个性化步骤：\"><a href=\"#hexo-github-常用指令及个性化步骤：\" class=\"headerlink\" title=\"hexo + github 常用指令及个性化步骤：\"></a>hexo + github 常用指令及个性化步骤：</h3><p>新建文章：<code>hexo n 文章名</code></p>\n<p>发布到本地：<code>hexo s</code></p>\n<p>部署到github：<code>hexo clean</code> ， <code>hexo g -d</code></p>\n<p>备份源文件到github：<code>git add .</code> ， <code>git commit -m 备注</code> ，  <code>git push origin hexo</code></p>\n<p>更改背景图案：将图片放入<code>Blog → blog → themes → next → source → assets</code>，在<code>Blog → blog → source → _data</code>中调整图片</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h1 id=\"备忘\"><a href=\"#备忘\" class=\"headerlink\" title=\"备忘\"></a><center>备忘</center></h1><p>​","more":"</p>\n<h3 id=\"大坏蛋，爱偷看\"><a href=\"#大坏蛋，爱偷看\" class=\"headerlink\" title=\"大坏蛋，爱偷看\"></a><center>大坏蛋，爱偷看</center></h3><h3 id=\"版本：\"><a href=\"#版本：\" class=\"headerlink\" title=\"版本：\"></a>版本：</h3><p><code>hexo 5.4</code></p>\n<p><code>next 7.8</code></p>\n<h3 id=\"hexo-github-常用指令及个性化步骤：\"><a href=\"#hexo-github-常用指令及个性化步骤：\" class=\"headerlink\" title=\"hexo + github 常用指令及个性化步骤：\"></a>hexo + github 常用指令及个性化步骤：</h3><p>新建文章：<code>hexo n 文章名</code></p>\n<p>发布到本地：<code>hexo s</code></p>\n<p>部署到github：<code>hexo clean</code> ， <code>hexo g -d</code></p>\n<p>备份源文件到github：<code>git add .</code> ， <code>git commit -m 备注</code> ，  <code>git push origin hexo</code></p>\n<p>更改背景图案：将图片放入<code>Blog → blog → themes → next → source → assets</code>，在<code>Blog → blog → source → _data</code>中调整图片</p>"},{"title":"三维重建综述","date":"2022-01-31T14:13:34.000Z","_content":"\n\n\n### \t始、前言\n\n\n\n<!--more-->\n\n---\n\n\n\n### 一、\n\n\n\n**一、KinectFusion**\n\n帝国理工的Newcombe等人在2011年提出的**KinectFusion，**可在不需要RGB图而只用[深度图](https://www.zhihu.com/search?q=深度图&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A918009389})的情况下就能实时地建立三维模型。KinectFusion算法首次实现了基于廉价消费类相机的实时刚体重建，在当时是非常有影响力的工作，它极大的推动了实时稠密三维重建的商业化进程。\n\n![img](https://pica.zhimg.com/50/v2-7a5d423eaf4f7ec313672500c40739d7_720w.jpg?source=1940ef5c)![img](https://pica.zhimg.com/80/v2-7a5d423eaf4f7ec313672500c40739d7_1440w.jpg?source=1940ef5c)KinectFusion重建效果\n\n在他们的论文中没有开源代码，最初的代码是由PCL团队实现的：[kinectfusion-open-source](https://link.zhihu.com/?target=http%3A//pointclouds.org/news/kinectfusion-open-source.html)\n\nKinectFusion的重建效果可以看这个视频：\n\n<iframe title=\"video\" src=\"https://video.zhihu.com/video/1184501699569471488?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe>\n\nKinectFusion重建效果\n\n\n\nKinectFusion之后，陆续出现了**Kintinuous，ElasticFusion，ElasticReconstruction，DynamicFusion，InfiniTAM，BundleFusion**等非常优秀的工作。其中2017年斯坦福大学提出的**BundleFusion**算法，据说是目前基于RGB-D相机进行稠密三维重建效果最好的方法。\n\n**二、Kintinuous和ElasticFusion**\n\n这两个工作都是同一个人做出来的，这个人就是**Thomas Whelan。**这两个工作应该算KinectFusion之后影响力比较大的。\n\nKintinuous GitHub代码：[mp3guy/Kintinuous](https://link.zhihu.com/?target=https%3A//github.com/mp3guy/Kintinuous)\n\nElasticFusion GitHub代码：[mp3guy/ElasticFusion](https://link.zhihu.com/?target=https%3A//github.com/mp3guy/ElasticFusion)\n\nKintinuous2.0重建效果：\n\n![img](https://pic1.zhimg.com/50/v2-02a3ce9419137e658c6c9a25237c6a3f_720w.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-02a3ce9419137e658c6c9a25237c6a3f_1440w.jpg?source=1940ef5c)Kintinuous2.0重建效果\n\nElasticFusion 重建效果：\n\n![img](https://pic1.zhimg.com/50/v2-e50cdaf0f90316a13376b8089f090bae_720w.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-e50cdaf0f90316a13376b8089f090bae_1440w.jpg?source=1940ef5c)ElasticFusion 重建效果\n\n**三、ElasticReconstruction**\n\n项目官网：[http://qianyi.info/scene.html](https://link.zhihu.com/?target=http%3A//qianyi.info/scene.html)\n\nGitHub代码：[qianyizh/ElasticReconstruction](https://link.zhihu.com/?target=https%3A//github.com/qianyizh/ElasticReconstruction)\n\n重建效果：\n\n![img](https://pic3.zhimg.com/50/v2-1baa9a7ad7d37384c7d967fe0f311000_720w.jpg?source=1940ef5c)![img](https://pic3.zhimg.com/80/v2-1baa9a7ad7d37384c7d967fe0f311000_1440w.jpg?source=1940ef5c)ElasticReconstruction重建效果\n\n**四、InfiniTAM**\n\nInfiniTAM提供**Linux，iOS，Android平台版本，CPU可以实时重建**。\n\n官网**：**[InfiniTAM v3](https://link.zhihu.com/?target=http%3A//www.robots.ox.ac.uk/~victor/infinitam/)\n\nGitHub代码：[victorprad/InfiniTAM](https://link.zhihu.com/?target=https%3A//github.com/victorprad/InfiniTAM)\n\n重建效果：\n\n![img](https://pic2.zhimg.com/50/v2-a40ba476c7384e576feedaba697f8a63_720w.jpg?source=1940ef5c)![img](https://pic2.zhimg.com/80/v2-a40ba476c7384e576feedaba697f8a63_1440w.jpg?source=1940ef5c)\n\n**五、DynamicFusion**\n\n**官网：**[DynamicFusion Project Page](https://link.zhihu.com/?target=https%3A//grail.cs.washington.edu/projects/dynamicfusion/)\n\n**代码：**[https://github.com/mihaibujanca/dynamicfusion](https://link.zhihu.com/?target=https%3A//github.com/mihaibujanca/dynamicfusion)\n\n重建效果：\n\n![img](https://pica.zhimg.com/50/v2-a57742d62c96a7dc69939b3a8e6fbe44_720w.jpg?source=1940ef5c)![img](https://pica.zhimg.com/80/v2-a57742d62c96a7dc69939b3a8e6fbe44_1440w.jpg?source=1940ef5c)\n\nDynamicFusion重建效果\n\n**六、BundleFusion**\n\n**据说是现在重建效果最好的工作！**\n\n**官网：**[BundleFusion](https://link.zhihu.com/?target=http%3A//graphics.stanford.edu/projects/bundlefusion/)\n\n论文：[https://arxiv.org/pdf/1604.01093.pdf](https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1604.01093.pdf)\n\n代码：[niessner/BundleFusion](https://link.zhihu.com/?target=https%3A//github.com/niessner/BundleFusion)\n\n算法解读：[计算机视觉方向简介 | 深度相机室内实时稠密三维重建](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzIxOTczOTM4NA%3D%3D%26mid%3D2247485487%26idx%3D1%26sn%3D068e04d652578deb55e93b1a32fa9a21%26chksm%3D97d7edb8a0a064ae265e9beb0f337f36fd3470a14ce97701cb16710608e0f1899c3d03b196ff%26scene%3D21%23wechat_redirect)\n\n重建效果：\n\n<iframe title=\"video\" src=\"https://video.zhihu.com/video/1184509281717673984?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe><iframe title=\"video\" src=\"https://video.zhihu.com/video/1184509281717673984?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe><iframe title=\"video\" src=\"https://video.zhihu.com/video/1184509281717673984?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe><iframe title=\"video\" src=\"https://video.zhihu.com/video/1184509281717673984?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe>\n\nBundleFusion：最好的三维重建\n\n\n\n最近[国防科大](https://www.zhihu.com/search?q=国防科大&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A918009389})张博士也发表了一篇稠密三维重建的文章 (ROSEFusion)。仅依靠深度图作为输入，利用随机优化实现了快速相机下的稠密重建。代码已经开源[https://github.com/jzhzhang/ROSEFusion](https://link.zhihu.com/?target=https%3A//github.com/jzhzhang/ROSEFusion)\n\n![img](https://pic2.zhimg.com/50/v2-db22a7f37930746c9df8e90ba7674e2f_720w.jpg?source=1940ef5c)\n\n<video class=\"ztext-gif GifPlayer-gif2mp4\" src=\"https://vdn.vzuu.com/SD/ac7d8ca0-15c8-11ec-8326-b63668e58176.mp4?disable_local_cache=1&amp;auth_key=1644047986-0-0-746329fe8f8f0ca37018fe44c81d28a2&amp;f=mp4&amp;bu=pico&amp;expiration=1644047986&amp;v=ali\" data-thumbnail=\"https://pic2.zhimg.com/50/v2-db22a7f37930746c9df8e90ba7674e2f_720w.jpg?source=1940ef5c\" poster=\"https://pic2.zhimg.com/50/v2-db22a7f37930746c9df8e90ba7674e2f_720w.jpg?source=1940ef5c\" data-size=\"normal\" preload=\"metadata\" loop=\"\" playsinline=\"\"></video>\n\n\n\nROSEFusion效果\n\n![img](https://pic3.zhimg.com/50/v2-6ebb19ebe17f2f577e9bb42b3676d075_720w.jpg?source=1940ef5c)![img](https://pic3.zhimg.com/80/v2-6ebb19ebe17f2f577e9bb42b3676d075_1440w.jpg?source=1940ef5c)\n\nROSEFusion 能够在仅考虑深度图作为输入的条件下，利用随机优化求解相机位姿，实现了在快速相机移动下的室内场景稠密重建。同时该工作仅依赖深度信息，因此也可以在无光照，和变化光照的条件下使用。  该工作的主要特点是：(a) 利用深度图和TSDF相容性作为代价函数，不需要提取特征点，仅依赖于深度图；(b) 提出了Particle Swarm Template（PST），利用PST可以高效的对相机位姿空间进行采样，并利用随机优化求解出相机的位姿。\n\n\n\n\n\n---\n\n\n\n收藏这个问题很久，楼上各位大佬已经总结的很好，大部分回答介绍了对[刚体](https://www.zhihu.com/search?q=刚体&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A1242628310})的三维重建工作，但对非刚体三维重建的工作介绍还比较少。刚好读研时做过这方面的调研和学习，来做一点点补充吧。高赞 [@曹力科](http://www.zhihu.com/people/5df6b1e2e74ebe45983a5c8eeb489e84) 博士的回答介绍了基于RGBD的实时三维重建工作，各种XXXFusion效果很是惊艳，而且可以实时重建出动态物体的三维模型。但是也有个问题，要是RGBD相机我也觉得贵怎么办，我就想用普通的RGB相机去进行动态三维，还想只用一个RGB相机去完成重建。\n\n\n\n学术界那帮大佬也这么想，想用最最最简单的设备去解决某个复杂的问题，即采用单目的RGB相机去进行动态三维重建。大道至简嘛，不然怎么体现出大佬的水平，手动狗头。\n\n同时问题也来了，单目RGB相机在投影时已经失去了深度信息，如何恢复深度和重建呢？有这么几类方案。\n\n**一、NRSfM(NonRigid Structure from Motion)**\n\nBregler等人[1]首先提出了NRSfM的思想，他们提出将目标物体在每一帧上的三维变形形状表示为K个形状基的线性加权组合，然后通过分解刚性系数矩阵来得到随时间序列变化的形状基、组合系数和摄像机运动参数。基于低秩形状的约束是一个强大的约束，但是它的求解是一个病态不定问题。\n\n这类重建方案我不是很熟，只介绍个做的比较好的。\n\nRavi Garg等人CVPR2013的工作，论文地址：\n\n[Dense Variational Reconstruction of Non-Rigid Surfaces from Monocular Video∗](https://link.zhihu.com/?target=https%3A//www.cv-foundation.org/openaccess/content_cvpr_2013/papers/Garg_Dense_Variational_Reconstruction_2013_CVPR_paper.pdf)\n\n重建可以得到稠密的结果，效果还是很不错的，就是需要得到完整的视频后才能重建。\n\n重建结果：\n\n![img](https://pic2.zhimg.com/50/v2-45df925a2c26567962c6027d1cf1acb6_720w.jpg?source=1940ef5c)![img](https://pic2.zhimg.com/80/v2-45df925a2c26567962c6027d1cf1acb6_1440w.jpg?source=1940ef5c)\n\n**二、SfT(Shape from Template)**\n\n另外一种方法是SfT。这种重建方法需要预先得到目标物体在刚性状态下的三维模型来作为模板，后面模型去追踪单目视频里目标物体的变化，得到每一帧图像对应的形变三维模型。这种方法具有实时重建的可能。\n\n重建的时候一般使用网格来表示三维模型，大佬们发现物体在发生形变时对应的网格模型是存在着约束的：等距约束(相邻网格顶点之间的距离在变形过程中保持不变)、平滑先验(相邻顶点的变形应该相似)和尽可能的刚性先验(变形可以用局部刚体运动近似)。打个比方，吹气球气球变大的过程中，气球上的某个点和它附件的点变化的趋势是相似的，但是这些点变大时又保持着最开始的拓扑结构。\n\n**1.Adrien Bartoli团队的工作**\n\nSfT的理论由Adrien Bartoli等人总结提出，对平面进行了稀疏重建。论文地址：[Bartoli_etal_SfT](https://link.zhihu.com/?target=http%3A//igt.ip.uca.fr/~ab/Publications/Bartoli_etal_PAMI15.pdf)\n\nBartoli主页：[http://igt.ip.uca.fr/~ab/index.html](https://link.zhihu.com/?target=http%3A//igt.ip.uca.fr/~ab/)\n\n重建结果：\n\n![img](https://pic2.zhimg.com/50/v2-f52d5d65cb8151f85ee17a23a6b9f817_720w.jpg?source=1940ef5c)![img](https://pic2.zhimg.com/80/v2-f52d5d65cb8151f85ee17a23a6b9f817_1440w.jpg?source=1940ef5c)\n\n后面他们团队拓展了这个方法，对稠密完整的物体进行了重建，而且给出了一个Demo。\n\n论文地址：[http://igt.ip.uca.fr/~ab/Publications/Collins_Bartoli_ISMAR15.pdf](https://link.zhihu.com/?target=http%3A//igt.ip.uca.fr/~ab/Publications/Collins_Bartoli_ISMAR15.pdf)\n\n论文中说好的会公开源码，但是我没找到。\n\n重建结果：\n\n![img](https://pic2.zhimg.com/50/v2-3fdf7bc372fbf90f752aa1229568db5a_720w.jpg?source=1940ef5c)![img](https://pic2.zhimg.com/80/v2-3fdf7bc372fbf90f752aa1229568db5a_1440w.jpg?source=1940ef5c)\n\n演示视频：\n\nRealtime SfT\n\n他们组后续还有一些相关工作，都是对这个方法的改进：[http://igt.ip.uca.fr/~ab/Publications/Parashar_etal_ICCV15.pdf](https://link.zhihu.com/?target=http%3A//igt.ip.uca.fr/~ab/Publications/Parashar_etal_ICCV15.pdf)\n\n此外这个组在arxiv上挂了一篇用深度学习方法做的SfT，但是现在还没正式发表，实验结果并不能重建得到完整的动态三维模型，只针物体的一个面完成了重建。\n\n[https://arxiv.org/pdf/1811.07791.pdf](https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1811.07791.pdf)\n\n**2.Lourdes Agapito团队的工作**\n\n这方面的工作主要由\n\n[@余瑞](http://www.zhihu.com/people/d2cf5bfec952c05516618be8f62b2f66)\n\n 博士做的，并且开源了源码。论文地址：[http://www0.cs.ucl.ac.uk/staff/R.Yu/direct_nrsfm/direct_nrsfm.pdf](https://link.zhihu.com/?target=http%3A//www0.cs.ucl.ac.uk/staff/R.Yu/direct_nrsfm/direct_nrsfm.pdf)\n\n\n\n项目主页：[http://www0.cs.ucl.ac.uk/staff/R.Yu/direct_nrsfm/direct_nrsfm.html](https://link.zhihu.com/?target=http%3A//www0.cs.ucl.ac.uk/staff/R.Yu/direct_nrsfm/direct_nrsfm.html)\n\n代码：[https://github.com/cvfish/PangaeaTracking](https://link.zhihu.com/?target=https%3A//github.com/cvfish/PangaeaTracking)\n\n重建结果：\n\n![img](https://pic2.zhimg.com/50/v2-3ce62e74607e88ef852e29977f72695c_720w.jpg?source=1940ef5c)![img](https://pic2.zhimg.com/80/v2-3ce62e74607e88ef852e29977f72695c_1440w.jpg?source=1940ef5c)\n\n演示视频：\n\n单目RGB动态三维重建\n\n一年后在这个基础上又做出了改进，把shape-from-shading的方法加入到整个系统中，提高了重建的质量和精度。可以发现下图重建的结果更好了，多了很多细节。\n\n论文地址：[http://www0.cs.ucl.ac.uk/staff/Qi.Liu/bmvc16/better_together.pdf](https://link.zhihu.com/?target=http%3A//www0.cs.ucl.ac.uk/staff/Qi.Liu/bmvc16/better_together.pdf)\n\n项目主页：[http://www0.cs.ucl.ac.uk/staff/Qi.Liu/bmvc16/better_together.html](https://link.zhihu.com/?target=http%3A//www0.cs.ucl.ac.uk/staff/Qi.Liu/bmvc16/better_together.html)\n\n代码：[https://github.com/qilon/PangaeaTracking](https://link.zhihu.com/?target=https%3A//github.com/qilon/PangaeaTracking)\n\n重建结果\n\n![img](https://pic2.zhimg.com/50/v2-413641049fd99de9e4092e1daa8f7642_720w.jpg?source=1940ef5c)![img](https://pic2.zhimg.com/80/v2-413641049fd99de9e4092e1daa8f7642_1440w.jpg?source=1940ef5c)\n\n**3.马普所团队的工作**\n\n马普所的Marc Habermann等人把\n\n[@余瑞](http://www.zhihu.com/people/d2cf5bfec952c05516618be8f62b2f66)\n\n 博士的工作改进应用到了人体动态三维重建方面。\n\n\n\n论文地址：[https://gvv.mpi-inf.mpg.de/projects/LiveCap/data/livecap.pdf](https://link.zhihu.com/?target=https%3A//gvv.mpi-inf.mpg.de/projects/LiveCap/data/livecap.pdf)\n\n项目地址：[https://gvv.mpi-inf.mpg.de/projects/LiveCap/](https://link.zhihu.com/?target=https%3A//gvv.mpi-inf.mpg.de/projects/LiveCap/)\n\n重建结果：\n\n![img](https://pic1.zhimg.com/50/v2-da3a17671749373c853da4c72d9911d1_720w.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-da3a17671749373c853da4c72d9911d1_1440w.jpg?source=1940ef5c)\n\n**三、基于模型的方法 (Model-based methods)**\n\n这一类方法主要代表是HMR等，主要针对于人体和动物，作者建立了两个模型库SMPL和SMAL，然后把人或动物的姿态给模型参数化了。这几个项目用到深度学习的方法。\n\n作者Angjoo Kanazawa主页：[https://people.eecs.berkeley.edu/~kanazawa/](https://link.zhihu.com/?target=https%3A//people.eecs.berkeley.edu/~kanazawa/)\n\nGithub：[https://github.com/akanazawa](https://link.zhihu.com/?target=https%3A//github.com/akanazawa)\n\n演示视频：\n\n<iframe title=\"video\" src=\"https://video.zhihu.com/video/1247867048929185792?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe>\n\n<iframe title=\"video\" src=\"https://video.zhihu.com/video/1247867124434636800?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe>\n\n**四、其他**\n\n除此之外还有一些对于人脸的重建，如Face2Face等。也是输入单目视频得到重建结果，这块我没去了解过，就不多介绍了。\n\n做单目动态三维重建的团队还有Mathieu Salzmann等人和 \n\n[@戴玉超](http://www.zhihu.com/people/99407a07afd17db138c3990746a55886)\n\n 老师在的团队，但是成果都是偏向稀疏的重建，而且近几年没有看到新的成果，感兴趣的小伙伴可以去找找相关资料。\n\n\n\n国内[西安交通大学](https://www.zhihu.com/search?q=西安交通大学&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A1242628310})的Wang Xuan博士在这个方向也做了部分工作，他在Mathieu Salzmann组做过访问学生。论文链接：\n\n[https://link.springer.com/chapter/10.1007/978-3-319-46478-7_40link.springer.com/chapter/10.1007/978-3-319-46478-7_40](https://link.zhihu.com/?target=https%3A//link.springer.com/chapter/10.1007/978-3-319-46478-7_40)\n\n戴老师的工作，论文链接：\n\n[http://users.cecs.anu.edu.au/~hongdong/CVPR12_Nonrigid_CRC_17_postprint.pdfusers.cecs.anu.edu.au/~hongdong/CVPR12_Nonrigid_CRC_17_postprint.pdf](https://link.zhihu.com/?target=http%3A//users.cecs.anu.edu.au/~hongdong/CVPR12_Nonrigid_CRC_17_postprint.pdf)\n\n这篇回答主要介绍了几个稠密的重建方案，采用的方法也比较传统，大多是基于优化的方式进行的重建，目前深度学习的方法应用在这个领域的方案还比较少，没看到什么令人惊艳的成果。\n\n由于水平有限，这篇回答仅抛砖引玉一下。肯定存在着很多纰漏和错误，请小伙伴们多多补充和指正。\n\n**五、引用**\n\n[1]Recovering Non-Rigid 3D Shape from Image Streams.Christoph Bregler, Aaron Hertzmann and Henning Biermann.*Proc. IEEE CVPR 2000*\n","source":"_posts/更2022-01-31-三维重建综述.md","raw":"---\ntitle: 三维重建综述\ndate: 2022-01-31 22:13:34\ncategories:\ntags:\n\n---\n\n\n\n### \t始、前言\n\n\n\n<!--more-->\n\n---\n\n\n\n### 一、\n\n\n\n**一、KinectFusion**\n\n帝国理工的Newcombe等人在2011年提出的**KinectFusion，**可在不需要RGB图而只用[深度图](https://www.zhihu.com/search?q=深度图&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A918009389})的情况下就能实时地建立三维模型。KinectFusion算法首次实现了基于廉价消费类相机的实时刚体重建，在当时是非常有影响力的工作，它极大的推动了实时稠密三维重建的商业化进程。\n\n![img](https://pica.zhimg.com/50/v2-7a5d423eaf4f7ec313672500c40739d7_720w.jpg?source=1940ef5c)![img](https://pica.zhimg.com/80/v2-7a5d423eaf4f7ec313672500c40739d7_1440w.jpg?source=1940ef5c)KinectFusion重建效果\n\n在他们的论文中没有开源代码，最初的代码是由PCL团队实现的：[kinectfusion-open-source](https://link.zhihu.com/?target=http%3A//pointclouds.org/news/kinectfusion-open-source.html)\n\nKinectFusion的重建效果可以看这个视频：\n\n<iframe title=\"video\" src=\"https://video.zhihu.com/video/1184501699569471488?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe>\n\nKinectFusion重建效果\n\n\n\nKinectFusion之后，陆续出现了**Kintinuous，ElasticFusion，ElasticReconstruction，DynamicFusion，InfiniTAM，BundleFusion**等非常优秀的工作。其中2017年斯坦福大学提出的**BundleFusion**算法，据说是目前基于RGB-D相机进行稠密三维重建效果最好的方法。\n\n**二、Kintinuous和ElasticFusion**\n\n这两个工作都是同一个人做出来的，这个人就是**Thomas Whelan。**这两个工作应该算KinectFusion之后影响力比较大的。\n\nKintinuous GitHub代码：[mp3guy/Kintinuous](https://link.zhihu.com/?target=https%3A//github.com/mp3guy/Kintinuous)\n\nElasticFusion GitHub代码：[mp3guy/ElasticFusion](https://link.zhihu.com/?target=https%3A//github.com/mp3guy/ElasticFusion)\n\nKintinuous2.0重建效果：\n\n![img](https://pic1.zhimg.com/50/v2-02a3ce9419137e658c6c9a25237c6a3f_720w.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-02a3ce9419137e658c6c9a25237c6a3f_1440w.jpg?source=1940ef5c)Kintinuous2.0重建效果\n\nElasticFusion 重建效果：\n\n![img](https://pic1.zhimg.com/50/v2-e50cdaf0f90316a13376b8089f090bae_720w.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-e50cdaf0f90316a13376b8089f090bae_1440w.jpg?source=1940ef5c)ElasticFusion 重建效果\n\n**三、ElasticReconstruction**\n\n项目官网：[http://qianyi.info/scene.html](https://link.zhihu.com/?target=http%3A//qianyi.info/scene.html)\n\nGitHub代码：[qianyizh/ElasticReconstruction](https://link.zhihu.com/?target=https%3A//github.com/qianyizh/ElasticReconstruction)\n\n重建效果：\n\n![img](https://pic3.zhimg.com/50/v2-1baa9a7ad7d37384c7d967fe0f311000_720w.jpg?source=1940ef5c)![img](https://pic3.zhimg.com/80/v2-1baa9a7ad7d37384c7d967fe0f311000_1440w.jpg?source=1940ef5c)ElasticReconstruction重建效果\n\n**四、InfiniTAM**\n\nInfiniTAM提供**Linux，iOS，Android平台版本，CPU可以实时重建**。\n\n官网**：**[InfiniTAM v3](https://link.zhihu.com/?target=http%3A//www.robots.ox.ac.uk/~victor/infinitam/)\n\nGitHub代码：[victorprad/InfiniTAM](https://link.zhihu.com/?target=https%3A//github.com/victorprad/InfiniTAM)\n\n重建效果：\n\n![img](https://pic2.zhimg.com/50/v2-a40ba476c7384e576feedaba697f8a63_720w.jpg?source=1940ef5c)![img](https://pic2.zhimg.com/80/v2-a40ba476c7384e576feedaba697f8a63_1440w.jpg?source=1940ef5c)\n\n**五、DynamicFusion**\n\n**官网：**[DynamicFusion Project Page](https://link.zhihu.com/?target=https%3A//grail.cs.washington.edu/projects/dynamicfusion/)\n\n**代码：**[https://github.com/mihaibujanca/dynamicfusion](https://link.zhihu.com/?target=https%3A//github.com/mihaibujanca/dynamicfusion)\n\n重建效果：\n\n![img](https://pica.zhimg.com/50/v2-a57742d62c96a7dc69939b3a8e6fbe44_720w.jpg?source=1940ef5c)![img](https://pica.zhimg.com/80/v2-a57742d62c96a7dc69939b3a8e6fbe44_1440w.jpg?source=1940ef5c)\n\nDynamicFusion重建效果\n\n**六、BundleFusion**\n\n**据说是现在重建效果最好的工作！**\n\n**官网：**[BundleFusion](https://link.zhihu.com/?target=http%3A//graphics.stanford.edu/projects/bundlefusion/)\n\n论文：[https://arxiv.org/pdf/1604.01093.pdf](https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1604.01093.pdf)\n\n代码：[niessner/BundleFusion](https://link.zhihu.com/?target=https%3A//github.com/niessner/BundleFusion)\n\n算法解读：[计算机视觉方向简介 | 深度相机室内实时稠密三维重建](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzIxOTczOTM4NA%3D%3D%26mid%3D2247485487%26idx%3D1%26sn%3D068e04d652578deb55e93b1a32fa9a21%26chksm%3D97d7edb8a0a064ae265e9beb0f337f36fd3470a14ce97701cb16710608e0f1899c3d03b196ff%26scene%3D21%23wechat_redirect)\n\n重建效果：\n\n<iframe title=\"video\" src=\"https://video.zhihu.com/video/1184509281717673984?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe><iframe title=\"video\" src=\"https://video.zhihu.com/video/1184509281717673984?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe><iframe title=\"video\" src=\"https://video.zhihu.com/video/1184509281717673984?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe><iframe title=\"video\" src=\"https://video.zhihu.com/video/1184509281717673984?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe>\n\nBundleFusion：最好的三维重建\n\n\n\n最近[国防科大](https://www.zhihu.com/search?q=国防科大&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A918009389})张博士也发表了一篇稠密三维重建的文章 (ROSEFusion)。仅依靠深度图作为输入，利用随机优化实现了快速相机下的稠密重建。代码已经开源[https://github.com/jzhzhang/ROSEFusion](https://link.zhihu.com/?target=https%3A//github.com/jzhzhang/ROSEFusion)\n\n![img](https://pic2.zhimg.com/50/v2-db22a7f37930746c9df8e90ba7674e2f_720w.jpg?source=1940ef5c)\n\n<video class=\"ztext-gif GifPlayer-gif2mp4\" src=\"https://vdn.vzuu.com/SD/ac7d8ca0-15c8-11ec-8326-b63668e58176.mp4?disable_local_cache=1&amp;auth_key=1644047986-0-0-746329fe8f8f0ca37018fe44c81d28a2&amp;f=mp4&amp;bu=pico&amp;expiration=1644047986&amp;v=ali\" data-thumbnail=\"https://pic2.zhimg.com/50/v2-db22a7f37930746c9df8e90ba7674e2f_720w.jpg?source=1940ef5c\" poster=\"https://pic2.zhimg.com/50/v2-db22a7f37930746c9df8e90ba7674e2f_720w.jpg?source=1940ef5c\" data-size=\"normal\" preload=\"metadata\" loop=\"\" playsinline=\"\"></video>\n\n\n\nROSEFusion效果\n\n![img](https://pic3.zhimg.com/50/v2-6ebb19ebe17f2f577e9bb42b3676d075_720w.jpg?source=1940ef5c)![img](https://pic3.zhimg.com/80/v2-6ebb19ebe17f2f577e9bb42b3676d075_1440w.jpg?source=1940ef5c)\n\nROSEFusion 能够在仅考虑深度图作为输入的条件下，利用随机优化求解相机位姿，实现了在快速相机移动下的室内场景稠密重建。同时该工作仅依赖深度信息，因此也可以在无光照，和变化光照的条件下使用。  该工作的主要特点是：(a) 利用深度图和TSDF相容性作为代价函数，不需要提取特征点，仅依赖于深度图；(b) 提出了Particle Swarm Template（PST），利用PST可以高效的对相机位姿空间进行采样，并利用随机优化求解出相机的位姿。\n\n\n\n\n\n---\n\n\n\n收藏这个问题很久，楼上各位大佬已经总结的很好，大部分回答介绍了对[刚体](https://www.zhihu.com/search?q=刚体&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A1242628310})的三维重建工作，但对非刚体三维重建的工作介绍还比较少。刚好读研时做过这方面的调研和学习，来做一点点补充吧。高赞 [@曹力科](http://www.zhihu.com/people/5df6b1e2e74ebe45983a5c8eeb489e84) 博士的回答介绍了基于RGBD的实时三维重建工作，各种XXXFusion效果很是惊艳，而且可以实时重建出动态物体的三维模型。但是也有个问题，要是RGBD相机我也觉得贵怎么办，我就想用普通的RGB相机去进行动态三维，还想只用一个RGB相机去完成重建。\n\n\n\n学术界那帮大佬也这么想，想用最最最简单的设备去解决某个复杂的问题，即采用单目的RGB相机去进行动态三维重建。大道至简嘛，不然怎么体现出大佬的水平，手动狗头。\n\n同时问题也来了，单目RGB相机在投影时已经失去了深度信息，如何恢复深度和重建呢？有这么几类方案。\n\n**一、NRSfM(NonRigid Structure from Motion)**\n\nBregler等人[1]首先提出了NRSfM的思想，他们提出将目标物体在每一帧上的三维变形形状表示为K个形状基的线性加权组合，然后通过分解刚性系数矩阵来得到随时间序列变化的形状基、组合系数和摄像机运动参数。基于低秩形状的约束是一个强大的约束，但是它的求解是一个病态不定问题。\n\n这类重建方案我不是很熟，只介绍个做的比较好的。\n\nRavi Garg等人CVPR2013的工作，论文地址：\n\n[Dense Variational Reconstruction of Non-Rigid Surfaces from Monocular Video∗](https://link.zhihu.com/?target=https%3A//www.cv-foundation.org/openaccess/content_cvpr_2013/papers/Garg_Dense_Variational_Reconstruction_2013_CVPR_paper.pdf)\n\n重建可以得到稠密的结果，效果还是很不错的，就是需要得到完整的视频后才能重建。\n\n重建结果：\n\n![img](https://pic2.zhimg.com/50/v2-45df925a2c26567962c6027d1cf1acb6_720w.jpg?source=1940ef5c)![img](https://pic2.zhimg.com/80/v2-45df925a2c26567962c6027d1cf1acb6_1440w.jpg?source=1940ef5c)\n\n**二、SfT(Shape from Template)**\n\n另外一种方法是SfT。这种重建方法需要预先得到目标物体在刚性状态下的三维模型来作为模板，后面模型去追踪单目视频里目标物体的变化，得到每一帧图像对应的形变三维模型。这种方法具有实时重建的可能。\n\n重建的时候一般使用网格来表示三维模型，大佬们发现物体在发生形变时对应的网格模型是存在着约束的：等距约束(相邻网格顶点之间的距离在变形过程中保持不变)、平滑先验(相邻顶点的变形应该相似)和尽可能的刚性先验(变形可以用局部刚体运动近似)。打个比方，吹气球气球变大的过程中，气球上的某个点和它附件的点变化的趋势是相似的，但是这些点变大时又保持着最开始的拓扑结构。\n\n**1.Adrien Bartoli团队的工作**\n\nSfT的理论由Adrien Bartoli等人总结提出，对平面进行了稀疏重建。论文地址：[Bartoli_etal_SfT](https://link.zhihu.com/?target=http%3A//igt.ip.uca.fr/~ab/Publications/Bartoli_etal_PAMI15.pdf)\n\nBartoli主页：[http://igt.ip.uca.fr/~ab/index.html](https://link.zhihu.com/?target=http%3A//igt.ip.uca.fr/~ab/)\n\n重建结果：\n\n![img](https://pic2.zhimg.com/50/v2-f52d5d65cb8151f85ee17a23a6b9f817_720w.jpg?source=1940ef5c)![img](https://pic2.zhimg.com/80/v2-f52d5d65cb8151f85ee17a23a6b9f817_1440w.jpg?source=1940ef5c)\n\n后面他们团队拓展了这个方法，对稠密完整的物体进行了重建，而且给出了一个Demo。\n\n论文地址：[http://igt.ip.uca.fr/~ab/Publications/Collins_Bartoli_ISMAR15.pdf](https://link.zhihu.com/?target=http%3A//igt.ip.uca.fr/~ab/Publications/Collins_Bartoli_ISMAR15.pdf)\n\n论文中说好的会公开源码，但是我没找到。\n\n重建结果：\n\n![img](https://pic2.zhimg.com/50/v2-3fdf7bc372fbf90f752aa1229568db5a_720w.jpg?source=1940ef5c)![img](https://pic2.zhimg.com/80/v2-3fdf7bc372fbf90f752aa1229568db5a_1440w.jpg?source=1940ef5c)\n\n演示视频：\n\nRealtime SfT\n\n他们组后续还有一些相关工作，都是对这个方法的改进：[http://igt.ip.uca.fr/~ab/Publications/Parashar_etal_ICCV15.pdf](https://link.zhihu.com/?target=http%3A//igt.ip.uca.fr/~ab/Publications/Parashar_etal_ICCV15.pdf)\n\n此外这个组在arxiv上挂了一篇用深度学习方法做的SfT，但是现在还没正式发表，实验结果并不能重建得到完整的动态三维模型，只针物体的一个面完成了重建。\n\n[https://arxiv.org/pdf/1811.07791.pdf](https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1811.07791.pdf)\n\n**2.Lourdes Agapito团队的工作**\n\n这方面的工作主要由\n\n[@余瑞](http://www.zhihu.com/people/d2cf5bfec952c05516618be8f62b2f66)\n\n 博士做的，并且开源了源码。论文地址：[http://www0.cs.ucl.ac.uk/staff/R.Yu/direct_nrsfm/direct_nrsfm.pdf](https://link.zhihu.com/?target=http%3A//www0.cs.ucl.ac.uk/staff/R.Yu/direct_nrsfm/direct_nrsfm.pdf)\n\n\n\n项目主页：[http://www0.cs.ucl.ac.uk/staff/R.Yu/direct_nrsfm/direct_nrsfm.html](https://link.zhihu.com/?target=http%3A//www0.cs.ucl.ac.uk/staff/R.Yu/direct_nrsfm/direct_nrsfm.html)\n\n代码：[https://github.com/cvfish/PangaeaTracking](https://link.zhihu.com/?target=https%3A//github.com/cvfish/PangaeaTracking)\n\n重建结果：\n\n![img](https://pic2.zhimg.com/50/v2-3ce62e74607e88ef852e29977f72695c_720w.jpg?source=1940ef5c)![img](https://pic2.zhimg.com/80/v2-3ce62e74607e88ef852e29977f72695c_1440w.jpg?source=1940ef5c)\n\n演示视频：\n\n单目RGB动态三维重建\n\n一年后在这个基础上又做出了改进，把shape-from-shading的方法加入到整个系统中，提高了重建的质量和精度。可以发现下图重建的结果更好了，多了很多细节。\n\n论文地址：[http://www0.cs.ucl.ac.uk/staff/Qi.Liu/bmvc16/better_together.pdf](https://link.zhihu.com/?target=http%3A//www0.cs.ucl.ac.uk/staff/Qi.Liu/bmvc16/better_together.pdf)\n\n项目主页：[http://www0.cs.ucl.ac.uk/staff/Qi.Liu/bmvc16/better_together.html](https://link.zhihu.com/?target=http%3A//www0.cs.ucl.ac.uk/staff/Qi.Liu/bmvc16/better_together.html)\n\n代码：[https://github.com/qilon/PangaeaTracking](https://link.zhihu.com/?target=https%3A//github.com/qilon/PangaeaTracking)\n\n重建结果\n\n![img](https://pic2.zhimg.com/50/v2-413641049fd99de9e4092e1daa8f7642_720w.jpg?source=1940ef5c)![img](https://pic2.zhimg.com/80/v2-413641049fd99de9e4092e1daa8f7642_1440w.jpg?source=1940ef5c)\n\n**3.马普所团队的工作**\n\n马普所的Marc Habermann等人把\n\n[@余瑞](http://www.zhihu.com/people/d2cf5bfec952c05516618be8f62b2f66)\n\n 博士的工作改进应用到了人体动态三维重建方面。\n\n\n\n论文地址：[https://gvv.mpi-inf.mpg.de/projects/LiveCap/data/livecap.pdf](https://link.zhihu.com/?target=https%3A//gvv.mpi-inf.mpg.de/projects/LiveCap/data/livecap.pdf)\n\n项目地址：[https://gvv.mpi-inf.mpg.de/projects/LiveCap/](https://link.zhihu.com/?target=https%3A//gvv.mpi-inf.mpg.de/projects/LiveCap/)\n\n重建结果：\n\n![img](https://pic1.zhimg.com/50/v2-da3a17671749373c853da4c72d9911d1_720w.jpg?source=1940ef5c)![img](https://pic1.zhimg.com/80/v2-da3a17671749373c853da4c72d9911d1_1440w.jpg?source=1940ef5c)\n\n**三、基于模型的方法 (Model-based methods)**\n\n这一类方法主要代表是HMR等，主要针对于人体和动物，作者建立了两个模型库SMPL和SMAL，然后把人或动物的姿态给模型参数化了。这几个项目用到深度学习的方法。\n\n作者Angjoo Kanazawa主页：[https://people.eecs.berkeley.edu/~kanazawa/](https://link.zhihu.com/?target=https%3A//people.eecs.berkeley.edu/~kanazawa/)\n\nGithub：[https://github.com/akanazawa](https://link.zhihu.com/?target=https%3A//github.com/akanazawa)\n\n演示视频：\n\n<iframe title=\"video\" src=\"https://video.zhihu.com/video/1247867048929185792?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe>\n\n<iframe title=\"video\" src=\"https://video.zhihu.com/video/1247867124434636800?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe>\n\n**四、其他**\n\n除此之外还有一些对于人脸的重建，如Face2Face等。也是输入单目视频得到重建结果，这块我没去了解过，就不多介绍了。\n\n做单目动态三维重建的团队还有Mathieu Salzmann等人和 \n\n[@戴玉超](http://www.zhihu.com/people/99407a07afd17db138c3990746a55886)\n\n 老师在的团队，但是成果都是偏向稀疏的重建，而且近几年没有看到新的成果，感兴趣的小伙伴可以去找找相关资料。\n\n\n\n国内[西安交通大学](https://www.zhihu.com/search?q=西安交通大学&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A1242628310})的Wang Xuan博士在这个方向也做了部分工作，他在Mathieu Salzmann组做过访问学生。论文链接：\n\n[https://link.springer.com/chapter/10.1007/978-3-319-46478-7_40link.springer.com/chapter/10.1007/978-3-319-46478-7_40](https://link.zhihu.com/?target=https%3A//link.springer.com/chapter/10.1007/978-3-319-46478-7_40)\n\n戴老师的工作，论文链接：\n\n[http://users.cecs.anu.edu.au/~hongdong/CVPR12_Nonrigid_CRC_17_postprint.pdfusers.cecs.anu.edu.au/~hongdong/CVPR12_Nonrigid_CRC_17_postprint.pdf](https://link.zhihu.com/?target=http%3A//users.cecs.anu.edu.au/~hongdong/CVPR12_Nonrigid_CRC_17_postprint.pdf)\n\n这篇回答主要介绍了几个稠密的重建方案，采用的方法也比较传统，大多是基于优化的方式进行的重建，目前深度学习的方法应用在这个领域的方案还比较少，没看到什么令人惊艳的成果。\n\n由于水平有限，这篇回答仅抛砖引玉一下。肯定存在着很多纰漏和错误，请小伙伴们多多补充和指正。\n\n**五、引用**\n\n[1]Recovering Non-Rigid 3D Shape from Image Streams.Christoph Bregler, Aaron Hertzmann and Henning Biermann.*Proc. IEEE CVPR 2000*\n","slug":"更2022-01-31-三维重建综述","published":1,"updated":"2022-02-21T14:17:48.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl1iy71kp008q1ou0emv1dx52","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、\"><a href=\"#一、\" class=\"headerlink\" title=\"一、\"></a>一、</h3><p><strong>一、KinectFusion</strong></p>\n<p>帝国理工的Newcombe等人在2011年提出的<strong>KinectFusion，</strong>可在不需要RGB图而只用<a href=\"https://www.zhihu.com/search?q=%E6%B7%B1%E5%BA%A6%E5%9B%BE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:918009389%7D\">深度图</a>的情况下就能实时地建立三维模型。KinectFusion算法首次实现了基于廉价消费类相机的实时刚体重建，在当时是非常有影响力的工作，它极大的推动了实时稠密三维重建的商业化进程。</p>\n<p><img data-src=\"https://pica.zhimg.com/50/v2-7a5d423eaf4f7ec313672500c40739d7_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pica.zhimg.com/80/v2-7a5d423eaf4f7ec313672500c40739d7_1440w.jpg?source=1940ef5c\" alt=\"img\">KinectFusion重建效果</p>\n<p>在他们的论文中没有开源代码，最初的代码是由PCL团队实现的：<a href=\"https://link.zhihu.com/?target=http://pointclouds.org/news/kinectfusion-open-source.html\">kinectfusion-open-source</a></p>\n<p>KinectFusion的重建效果可以看这个视频：</p>\n<iframe title=\"video\" src=\"https://video.zhihu.com/video/1184501699569471488?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe>\n\n<p>KinectFusion重建效果</p>\n<p>KinectFusion之后，陆续出现了<strong>Kintinuous，ElasticFusion，ElasticReconstruction，DynamicFusion，InfiniTAM，BundleFusion</strong>等非常优秀的工作。其中2017年斯坦福大学提出的<strong>BundleFusion</strong>算法，据说是目前基于RGB-D相机进行稠密三维重建效果最好的方法。</p>\n<p><strong>二、Kintinuous和ElasticFusion</strong></p>\n<p>这两个工作都是同一个人做出来的，这个人就是<strong>Thomas Whelan。</strong>这两个工作应该算KinectFusion之后影响力比较大的。</p>\n<p>Kintinuous GitHub代码：<a href=\"https://link.zhihu.com/?target=https://github.com/mp3guy/Kintinuous\">mp3guy/Kintinuous</a></p>\n<p>ElasticFusion GitHub代码：<a href=\"https://link.zhihu.com/?target=https://github.com/mp3guy/ElasticFusion\">mp3guy/ElasticFusion</a></p>\n<p>Kintinuous2.0重建效果：</p>\n<p><img data-src=\"https://pic1.zhimg.com/50/v2-02a3ce9419137e658c6c9a25237c6a3f_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic1.zhimg.com/80/v2-02a3ce9419137e658c6c9a25237c6a3f_1440w.jpg?source=1940ef5c\" alt=\"img\">Kintinuous2.0重建效果</p>\n<p>ElasticFusion 重建效果：</p>\n<p><img data-src=\"https://pic1.zhimg.com/50/v2-e50cdaf0f90316a13376b8089f090bae_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic1.zhimg.com/80/v2-e50cdaf0f90316a13376b8089f090bae_1440w.jpg?source=1940ef5c\" alt=\"img\">ElasticFusion 重建效果</p>\n<p><strong>三、ElasticReconstruction</strong></p>\n<p>项目官网：<a href=\"https://link.zhihu.com/?target=http://qianyi.info/scene.html\">http://qianyi.info/scene.html</a></p>\n<p>GitHub代码：<a href=\"https://link.zhihu.com/?target=https://github.com/qianyizh/ElasticReconstruction\">qianyizh/ElasticReconstruction</a></p>\n<p>重建效果：</p>\n<p><img data-src=\"https://pic3.zhimg.com/50/v2-1baa9a7ad7d37384c7d967fe0f311000_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic3.zhimg.com/80/v2-1baa9a7ad7d37384c7d967fe0f311000_1440w.jpg?source=1940ef5c\" alt=\"img\">ElasticReconstruction重建效果</p>\n<p><strong>四、InfiniTAM</strong></p>\n<p>InfiniTAM提供<strong>Linux，iOS，Android平台版本，CPU可以实时重建</strong>。</p>\n<p>官网<strong>：</strong><a href=\"https://link.zhihu.com/?target=http://www.robots.ox.ac.uk/~victor/infinitam/\">InfiniTAM v3</a></p>\n<p>GitHub代码：<a href=\"https://link.zhihu.com/?target=https://github.com/victorprad/InfiniTAM\">victorprad/InfiniTAM</a></p>\n<p>重建效果：</p>\n<p><img data-src=\"https://pic2.zhimg.com/50/v2-a40ba476c7384e576feedaba697f8a63_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic2.zhimg.com/80/v2-a40ba476c7384e576feedaba697f8a63_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p><strong>五、DynamicFusion</strong></p>\n<p><strong>官网：</strong><a href=\"https://link.zhihu.com/?target=https://grail.cs.washington.edu/projects/dynamicfusion/\">DynamicFusion Project Page</a></p>\n<p><strong>代码：</strong><a href=\"https://link.zhihu.com/?target=https://github.com/mihaibujanca/dynamicfusion\">https://github.com/mihaibujanca/dynamicfusion</a></p>\n<p>重建效果：</p>\n<p><img data-src=\"https://pica.zhimg.com/50/v2-a57742d62c96a7dc69939b3a8e6fbe44_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pica.zhimg.com/80/v2-a57742d62c96a7dc69939b3a8e6fbe44_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p>DynamicFusion重建效果</p>\n<p><strong>六、BundleFusion</strong></p>\n<p><strong>据说是现在重建效果最好的工作！</strong></p>\n<p><strong>官网：</strong><a href=\"https://link.zhihu.com/?target=http://graphics.stanford.edu/projects/bundlefusion/\">BundleFusion</a></p>\n<p>论文：<a href=\"https://link.zhihu.com/?target=https://arxiv.org/pdf/1604.01093.pdf\">https://arxiv.org/pdf/1604.01093.pdf</a></p>\n<p>代码：<a href=\"https://link.zhihu.com/?target=https://github.com/niessner/BundleFusion\">niessner/BundleFusion</a></p>\n<p>算法解读：<a href=\"https://link.zhihu.com/?target=https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&mid=2247485487&idx=1&sn=068e04d652578deb55e93b1a32fa9a21&chksm=97d7edb8a0a064ae265e9beb0f337f36fd3470a14ce97701cb16710608e0f1899c3d03b196ff&scene=21%23wechat_redirect\">计算机视觉方向简介 | 深度相机室内实时稠密三维重建</a></p>\n<p>重建效果：</p>\n<iframe title=\"video\" src=\"https://video.zhihu.com/video/1184509281717673984?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe><iframe title=\"video\" src=\"https://video.zhihu.com/video/1184509281717673984?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe><iframe title=\"video\" src=\"https://video.zhihu.com/video/1184509281717673984?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe><iframe title=\"video\" src=\"https://video.zhihu.com/video/1184509281717673984?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe>\n\n<p>BundleFusion：最好的三维重建</p>\n<p>最近<a href=\"https://www.zhihu.com/search?q=%E5%9B%BD%E9%98%B2%E7%A7%91%E5%A4%A7&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:918009389%7D\">国防科大</a>张博士也发表了一篇稠密三维重建的文章 (ROSEFusion)。仅依靠深度图作为输入，利用随机优化实现了快速相机下的稠密重建。代码已经开源<a href=\"https://link.zhihu.com/?target=https://github.com/jzhzhang/ROSEFusion\">https://github.com/jzhzhang/ROSEFusion</a></p>\n<p><img data-src=\"https://pic2.zhimg.com/50/v2-db22a7f37930746c9df8e90ba7674e2f_720w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p><video class=\"ztext-gif GifPlayer-gif2mp4\" src=\"https://vdn.vzuu.com/SD/ac7d8ca0-15c8-11ec-8326-b63668e58176.mp4?disable_local_cache=1&amp;auth_key=1644047986-0-0-746329fe8f8f0ca37018fe44c81d28a2&amp;f=mp4&amp;bu=pico&amp;expiration=1644047986&amp;v=ali\" data-thumbnail=\"https://pic2.zhimg.com/50/v2-db22a7f37930746c9df8e90ba7674e2f_720w.jpg?source=1940ef5c\" poster=\"https://pic2.zhimg.com/50/v2-db22a7f37930746c9df8e90ba7674e2f_720w.jpg?source=1940ef5c\" data-size=\"normal\" preload=\"metadata\" loop=\"\" playsinline=\"\"></video></p>\n<p>ROSEFusion效果</p>\n<p><img data-src=\"https://pic3.zhimg.com/50/v2-6ebb19ebe17f2f577e9bb42b3676d075_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic3.zhimg.com/80/v2-6ebb19ebe17f2f577e9bb42b3676d075_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p>ROSEFusion 能够在仅考虑深度图作为输入的条件下，利用随机优化求解相机位姿，实现了在快速相机移动下的室内场景稠密重建。同时该工作仅依赖深度信息，因此也可以在无光照，和变化光照的条件下使用。  该工作的主要特点是：(a) 利用深度图和TSDF相容性作为代价函数，不需要提取特征点，仅依赖于深度图；(b) 提出了Particle Swarm Template（PST），利用PST可以高效的对相机位姿空间进行采样，并利用随机优化求解出相机的位姿。</p>\n<hr>\n<p>收藏这个问题很久，楼上各位大佬已经总结的很好，大部分回答介绍了对<a href=\"https://www.zhihu.com/search?q=%E5%88%9A%E4%BD%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1242628310%7D\">刚体</a>的三维重建工作，但对非刚体三维重建的工作介绍还比较少。刚好读研时做过这方面的调研和学习，来做一点点补充吧。高赞 <a href=\"http://www.zhihu.com/people/5df6b1e2e74ebe45983a5c8eeb489e84\">@曹力科</a> 博士的回答介绍了基于RGBD的实时三维重建工作，各种XXXFusion效果很是惊艳，而且可以实时重建出动态物体的三维模型。但是也有个问题，要是RGBD相机我也觉得贵怎么办，我就想用普通的RGB相机去进行动态三维，还想只用一个RGB相机去完成重建。</p>\n<p>学术界那帮大佬也这么想，想用最最最简单的设备去解决某个复杂的问题，即采用单目的RGB相机去进行动态三维重建。大道至简嘛，不然怎么体现出大佬的水平，手动狗头。</p>\n<p>同时问题也来了，单目RGB相机在投影时已经失去了深度信息，如何恢复深度和重建呢？有这么几类方案。</p>\n<p><strong>一、NRSfM(NonRigid Structure from Motion)</strong></p>\n<p>Bregler等人[1]首先提出了NRSfM的思想，他们提出将目标物体在每一帧上的三维变形形状表示为K个形状基的线性加权组合，然后通过分解刚性系数矩阵来得到随时间序列变化的形状基、组合系数和摄像机运动参数。基于低秩形状的约束是一个强大的约束，但是它的求解是一个病态不定问题。</p>\n<p>这类重建方案我不是很熟，只介绍个做的比较好的。</p>\n<p>Ravi Garg等人CVPR2013的工作，论文地址：</p>\n<p><a href=\"https://link.zhihu.com/?target=https://www.cv-foundation.org/openaccess/content_cvpr_2013/papers/Garg_Dense_Variational_Reconstruction_2013_CVPR_paper.pdf\">Dense Variational Reconstruction of Non-Rigid Surfaces from Monocular Video∗</a></p>\n<p>重建可以得到稠密的结果，效果还是很不错的，就是需要得到完整的视频后才能重建。</p>\n<p>重建结果：</p>\n<p><img data-src=\"https://pic2.zhimg.com/50/v2-45df925a2c26567962c6027d1cf1acb6_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic2.zhimg.com/80/v2-45df925a2c26567962c6027d1cf1acb6_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p><strong>二、SfT(Shape from Template)</strong></p>\n<p>另外一种方法是SfT。这种重建方法需要预先得到目标物体在刚性状态下的三维模型来作为模板，后面模型去追踪单目视频里目标物体的变化，得到每一帧图像对应的形变三维模型。这种方法具有实时重建的可能。</p>\n<p>重建的时候一般使用网格来表示三维模型，大佬们发现物体在发生形变时对应的网格模型是存在着约束的：等距约束(相邻网格顶点之间的距离在变形过程中保持不变)、平滑先验(相邻顶点的变形应该相似)和尽可能的刚性先验(变形可以用局部刚体运动近似)。打个比方，吹气球气球变大的过程中，气球上的某个点和它附件的点变化的趋势是相似的，但是这些点变大时又保持着最开始的拓扑结构。</p>\n<p><strong>1.Adrien Bartoli团队的工作</strong></p>\n<p>SfT的理论由Adrien Bartoli等人总结提出，对平面进行了稀疏重建。论文地址：<a href=\"https://link.zhihu.com/?target=http://igt.ip.uca.fr/~ab/Publications/Bartoli_etal_PAMI15.pdf\">Bartoli_etal_SfT</a></p>\n<p>Bartoli主页：<a href=\"https://link.zhihu.com/?target=http://igt.ip.uca.fr/~ab/\">http://igt.ip.uca.fr/~ab/index.html</a></p>\n<p>重建结果：</p>\n<p><img data-src=\"https://pic2.zhimg.com/50/v2-f52d5d65cb8151f85ee17a23a6b9f817_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic2.zhimg.com/80/v2-f52d5d65cb8151f85ee17a23a6b9f817_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p>后面他们团队拓展了这个方法，对稠密完整的物体进行了重建，而且给出了一个Demo。</p>\n<p>论文地址：<a href=\"https://link.zhihu.com/?target=http://igt.ip.uca.fr/~ab/Publications/Collins_Bartoli_ISMAR15.pdf\">http://igt.ip.uca.fr/~ab/Publications/Collins_Bartoli_ISMAR15.pdf</a></p>\n<p>论文中说好的会公开源码，但是我没找到。</p>\n<p>重建结果：</p>\n<p><img data-src=\"https://pic2.zhimg.com/50/v2-3fdf7bc372fbf90f752aa1229568db5a_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic2.zhimg.com/80/v2-3fdf7bc372fbf90f752aa1229568db5a_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p>演示视频：</p>\n<p>Realtime SfT</p>\n<p>他们组后续还有一些相关工作，都是对这个方法的改进：<a href=\"https://link.zhihu.com/?target=http://igt.ip.uca.fr/~ab/Publications/Parashar_etal_ICCV15.pdf\">http://igt.ip.uca.fr/~ab/Publications/Parashar_etal_ICCV15.pdf</a></p>\n<p>此外这个组在arxiv上挂了一篇用深度学习方法做的SfT，但是现在还没正式发表，实验结果并不能重建得到完整的动态三维模型，只针物体的一个面完成了重建。</p>\n<p><a href=\"https://link.zhihu.com/?target=https://arxiv.org/pdf/1811.07791.pdf\">https://arxiv.org/pdf/1811.07791.pdf</a></p>\n<p><strong>2.Lourdes Agapito团队的工作</strong></p>\n<p>这方面的工作主要由</p>\n<p><a href=\"http://www.zhihu.com/people/d2cf5bfec952c05516618be8f62b2f66\">@余瑞</a></p>\n<p> 博士做的，并且开源了源码。论文地址：<a href=\"https://link.zhihu.com/?target=http://www0.cs.ucl.ac.uk/staff/R.Yu/direct_nrsfm/direct_nrsfm.pdf\">http://www0.cs.ucl.ac.uk/staff/R.Yu/direct_nrsfm/direct_nrsfm.pdf</a></p>\n<p>项目主页：<a href=\"https://link.zhihu.com/?target=http://www0.cs.ucl.ac.uk/staff/R.Yu/direct_nrsfm/direct_nrsfm.html\">http://www0.cs.ucl.ac.uk/staff/R.Yu/direct_nrsfm/direct_nrsfm.html</a></p>\n<p>代码：<a href=\"https://link.zhihu.com/?target=https://github.com/cvfish/PangaeaTracking\">https://github.com/cvfish/PangaeaTracking</a></p>\n<p>重建结果：</p>\n<p><img data-src=\"https://pic2.zhimg.com/50/v2-3ce62e74607e88ef852e29977f72695c_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic2.zhimg.com/80/v2-3ce62e74607e88ef852e29977f72695c_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p>演示视频：</p>\n<p>单目RGB动态三维重建</p>\n<p>一年后在这个基础上又做出了改进，把shape-from-shading的方法加入到整个系统中，提高了重建的质量和精度。可以发现下图重建的结果更好了，多了很多细节。</p>\n<p>论文地址：<a href=\"https://link.zhihu.com/?target=http://www0.cs.ucl.ac.uk/staff/Qi.Liu/bmvc16/better_together.pdf\">http://www0.cs.ucl.ac.uk/staff/Qi.Liu/bmvc16/better_together.pdf</a></p>\n<p>项目主页：<a href=\"https://link.zhihu.com/?target=http://www0.cs.ucl.ac.uk/staff/Qi.Liu/bmvc16/better_together.html\">http://www0.cs.ucl.ac.uk/staff/Qi.Liu/bmvc16/better_together.html</a></p>\n<p>代码：<a href=\"https://link.zhihu.com/?target=https://github.com/qilon/PangaeaTracking\">https://github.com/qilon/PangaeaTracking</a></p>\n<p>重建结果</p>\n<p><img data-src=\"https://pic2.zhimg.com/50/v2-413641049fd99de9e4092e1daa8f7642_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic2.zhimg.com/80/v2-413641049fd99de9e4092e1daa8f7642_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p><strong>3.马普所团队的工作</strong></p>\n<p>马普所的Marc Habermann等人把</p>\n<p><a href=\"http://www.zhihu.com/people/d2cf5bfec952c05516618be8f62b2f66\">@余瑞</a></p>\n<p> 博士的工作改进应用到了人体动态三维重建方面。</p>\n<p>论文地址：<a href=\"https://link.zhihu.com/?target=https://gvv.mpi-inf.mpg.de/projects/LiveCap/data/livecap.pdf\">https://gvv.mpi-inf.mpg.de/projects/LiveCap/data/livecap.pdf</a></p>\n<p>项目地址：<a href=\"https://link.zhihu.com/?target=https://gvv.mpi-inf.mpg.de/projects/LiveCap/\">https://gvv.mpi-inf.mpg.de/projects/LiveCap/</a></p>\n<p>重建结果：</p>\n<p><img data-src=\"https://pic1.zhimg.com/50/v2-da3a17671749373c853da4c72d9911d1_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic1.zhimg.com/80/v2-da3a17671749373c853da4c72d9911d1_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p><strong>三、基于模型的方法 (Model-based methods)</strong></p>\n<p>这一类方法主要代表是HMR等，主要针对于人体和动物，作者建立了两个模型库SMPL和SMAL，然后把人或动物的姿态给模型参数化了。这几个项目用到深度学习的方法。</p>\n<p>作者Angjoo Kanazawa主页：<a href=\"https://link.zhihu.com/?target=https://people.eecs.berkeley.edu/~kanazawa/\">https://people.eecs.berkeley.edu/~kanazawa/</a></p>\n<p>Github：<a href=\"https://link.zhihu.com/?target=https://github.com/akanazawa\">https://github.com/akanazawa</a></p>\n<p>演示视频：</p>\n<iframe title=\"video\" src=\"https://video.zhihu.com/video/1247867048929185792?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe>\n\n<iframe title=\"video\" src=\"https://video.zhihu.com/video/1247867124434636800?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe>\n\n<p><strong>四、其他</strong></p>\n<p>除此之外还有一些对于人脸的重建，如Face2Face等。也是输入单目视频得到重建结果，这块我没去了解过，就不多介绍了。</p>\n<p>做单目动态三维重建的团队还有Mathieu Salzmann等人和 </p>\n<p><a href=\"http://www.zhihu.com/people/99407a07afd17db138c3990746a55886\">@戴玉超</a></p>\n<p> 老师在的团队，但是成果都是偏向稀疏的重建，而且近几年没有看到新的成果，感兴趣的小伙伴可以去找找相关资料。</p>\n<p>国内<a href=\"https://www.zhihu.com/search?q=%E8%A5%BF%E5%AE%89%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1242628310%7D\">西安交通大学</a>的Wang Xuan博士在这个方向也做了部分工作，他在Mathieu Salzmann组做过访问学生。论文链接：</p>\n<p><a href=\"https://link.zhihu.com/?target=https://link.springer.com/chapter/10.1007/978-3-319-46478-7_40\">https://link.springer.com/chapter/10.1007/978-3-319-46478-7_40link.springer.com/chapter/10.1007/978-3-319-46478-7_40</a></p>\n<p>戴老师的工作，论文链接：</p>\n<p><a href=\"https://link.zhihu.com/?target=http://users.cecs.anu.edu.au/~hongdong/CVPR12_Nonrigid_CRC_17_postprint.pdf\">http://users.cecs.anu.edu.au/<del>hongdong/CVPR12_Nonrigid_CRC_17_postprint.pdfusers.cecs.anu.edu.au/</del>hongdong/CVPR12_Nonrigid_CRC_17_postprint.pdf</a></p>\n<p>这篇回答主要介绍了几个稠密的重建方案，采用的方法也比较传统，大多是基于优化的方式进行的重建，目前深度学习的方法应用在这个领域的方案还比较少，没看到什么令人惊艳的成果。</p>\n<p>由于水平有限，这篇回答仅抛砖引玉一下。肯定存在着很多纰漏和错误，请小伙伴们多多补充和指正。</p>\n<p><strong>五、引用</strong></p>\n<p>[1]Recovering Non-Rigid 3D Shape from Image Streams.Christoph Bregler, Aaron Hertzmann and Henning Biermann.<em>Proc. IEEE CVPR 2000</em></p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.jfif\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 80%;\n  background-size: 100%;\n  opacity: 88%;\nmobile()\n}\n.post {\n  margin-top: 0px;\n  margin-bottom: 600px;\n  padding: 10px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3>","more":"<hr>\n<h3 id=\"一、\"><a href=\"#一、\" class=\"headerlink\" title=\"一、\"></a>一、</h3><p><strong>一、KinectFusion</strong></p>\n<p>帝国理工的Newcombe等人在2011年提出的<strong>KinectFusion，</strong>可在不需要RGB图而只用<a href=\"https://www.zhihu.com/search?q=%E6%B7%B1%E5%BA%A6%E5%9B%BE&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:918009389%7D\">深度图</a>的情况下就能实时地建立三维模型。KinectFusion算法首次实现了基于廉价消费类相机的实时刚体重建，在当时是非常有影响力的工作，它极大的推动了实时稠密三维重建的商业化进程。</p>\n<p><img data-src=\"https://pica.zhimg.com/50/v2-7a5d423eaf4f7ec313672500c40739d7_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pica.zhimg.com/80/v2-7a5d423eaf4f7ec313672500c40739d7_1440w.jpg?source=1940ef5c\" alt=\"img\">KinectFusion重建效果</p>\n<p>在他们的论文中没有开源代码，最初的代码是由PCL团队实现的：<a href=\"https://link.zhihu.com/?target=http://pointclouds.org/news/kinectfusion-open-source.html\">kinectfusion-open-source</a></p>\n<p>KinectFusion的重建效果可以看这个视频：</p>\n<iframe title=\"video\" src=\"https://video.zhihu.com/video/1184501699569471488?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe>\n\n<p>KinectFusion重建效果</p>\n<p>KinectFusion之后，陆续出现了<strong>Kintinuous，ElasticFusion，ElasticReconstruction，DynamicFusion，InfiniTAM，BundleFusion</strong>等非常优秀的工作。其中2017年斯坦福大学提出的<strong>BundleFusion</strong>算法，据说是目前基于RGB-D相机进行稠密三维重建效果最好的方法。</p>\n<p><strong>二、Kintinuous和ElasticFusion</strong></p>\n<p>这两个工作都是同一个人做出来的，这个人就是<strong>Thomas Whelan。</strong>这两个工作应该算KinectFusion之后影响力比较大的。</p>\n<p>Kintinuous GitHub代码：<a href=\"https://link.zhihu.com/?target=https://github.com/mp3guy/Kintinuous\">mp3guy/Kintinuous</a></p>\n<p>ElasticFusion GitHub代码：<a href=\"https://link.zhihu.com/?target=https://github.com/mp3guy/ElasticFusion\">mp3guy/ElasticFusion</a></p>\n<p>Kintinuous2.0重建效果：</p>\n<p><img data-src=\"https://pic1.zhimg.com/50/v2-02a3ce9419137e658c6c9a25237c6a3f_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic1.zhimg.com/80/v2-02a3ce9419137e658c6c9a25237c6a3f_1440w.jpg?source=1940ef5c\" alt=\"img\">Kintinuous2.0重建效果</p>\n<p>ElasticFusion 重建效果：</p>\n<p><img data-src=\"https://pic1.zhimg.com/50/v2-e50cdaf0f90316a13376b8089f090bae_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic1.zhimg.com/80/v2-e50cdaf0f90316a13376b8089f090bae_1440w.jpg?source=1940ef5c\" alt=\"img\">ElasticFusion 重建效果</p>\n<p><strong>三、ElasticReconstruction</strong></p>\n<p>项目官网：<a href=\"https://link.zhihu.com/?target=http://qianyi.info/scene.html\">http://qianyi.info/scene.html</a></p>\n<p>GitHub代码：<a href=\"https://link.zhihu.com/?target=https://github.com/qianyizh/ElasticReconstruction\">qianyizh/ElasticReconstruction</a></p>\n<p>重建效果：</p>\n<p><img data-src=\"https://pic3.zhimg.com/50/v2-1baa9a7ad7d37384c7d967fe0f311000_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic3.zhimg.com/80/v2-1baa9a7ad7d37384c7d967fe0f311000_1440w.jpg?source=1940ef5c\" alt=\"img\">ElasticReconstruction重建效果</p>\n<p><strong>四、InfiniTAM</strong></p>\n<p>InfiniTAM提供<strong>Linux，iOS，Android平台版本，CPU可以实时重建</strong>。</p>\n<p>官网<strong>：</strong><a href=\"https://link.zhihu.com/?target=http://www.robots.ox.ac.uk/~victor/infinitam/\">InfiniTAM v3</a></p>\n<p>GitHub代码：<a href=\"https://link.zhihu.com/?target=https://github.com/victorprad/InfiniTAM\">victorprad/InfiniTAM</a></p>\n<p>重建效果：</p>\n<p><img data-src=\"https://pic2.zhimg.com/50/v2-a40ba476c7384e576feedaba697f8a63_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic2.zhimg.com/80/v2-a40ba476c7384e576feedaba697f8a63_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p><strong>五、DynamicFusion</strong></p>\n<p><strong>官网：</strong><a href=\"https://link.zhihu.com/?target=https://grail.cs.washington.edu/projects/dynamicfusion/\">DynamicFusion Project Page</a></p>\n<p><strong>代码：</strong><a href=\"https://link.zhihu.com/?target=https://github.com/mihaibujanca/dynamicfusion\">https://github.com/mihaibujanca/dynamicfusion</a></p>\n<p>重建效果：</p>\n<p><img data-src=\"https://pica.zhimg.com/50/v2-a57742d62c96a7dc69939b3a8e6fbe44_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pica.zhimg.com/80/v2-a57742d62c96a7dc69939b3a8e6fbe44_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p>DynamicFusion重建效果</p>\n<p><strong>六、BundleFusion</strong></p>\n<p><strong>据说是现在重建效果最好的工作！</strong></p>\n<p><strong>官网：</strong><a href=\"https://link.zhihu.com/?target=http://graphics.stanford.edu/projects/bundlefusion/\">BundleFusion</a></p>\n<p>论文：<a href=\"https://link.zhihu.com/?target=https://arxiv.org/pdf/1604.01093.pdf\">https://arxiv.org/pdf/1604.01093.pdf</a></p>\n<p>代码：<a href=\"https://link.zhihu.com/?target=https://github.com/niessner/BundleFusion\">niessner/BundleFusion</a></p>\n<p>算法解读：<a href=\"https://link.zhihu.com/?target=https://mp.weixin.qq.com/s?__biz=MzIxOTczOTM4NA==&mid=2247485487&idx=1&sn=068e04d652578deb55e93b1a32fa9a21&chksm=97d7edb8a0a064ae265e9beb0f337f36fd3470a14ce97701cb16710608e0f1899c3d03b196ff&scene=21%23wechat_redirect\">计算机视觉方向简介 | 深度相机室内实时稠密三维重建</a></p>\n<p>重建效果：</p>\n<iframe title=\"video\" src=\"https://video.zhihu.com/video/1184509281717673984?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe><iframe title=\"video\" src=\"https://video.zhihu.com/video/1184509281717673984?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe><iframe title=\"video\" src=\"https://video.zhihu.com/video/1184509281717673984?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe><iframe title=\"video\" src=\"https://video.zhihu.com/video/1184509281717673984?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe>\n\n<p>BundleFusion：最好的三维重建</p>\n<p>最近<a href=\"https://www.zhihu.com/search?q=%E5%9B%BD%E9%98%B2%E7%A7%91%E5%A4%A7&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:918009389%7D\">国防科大</a>张博士也发表了一篇稠密三维重建的文章 (ROSEFusion)。仅依靠深度图作为输入，利用随机优化实现了快速相机下的稠密重建。代码已经开源<a href=\"https://link.zhihu.com/?target=https://github.com/jzhzhang/ROSEFusion\">https://github.com/jzhzhang/ROSEFusion</a></p>\n<p><img data-src=\"https://pic2.zhimg.com/50/v2-db22a7f37930746c9df8e90ba7674e2f_720w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p><video class=\"ztext-gif GifPlayer-gif2mp4\" src=\"https://vdn.vzuu.com/SD/ac7d8ca0-15c8-11ec-8326-b63668e58176.mp4?disable_local_cache=1&amp;auth_key=1644047986-0-0-746329fe8f8f0ca37018fe44c81d28a2&amp;f=mp4&amp;bu=pico&amp;expiration=1644047986&amp;v=ali\" data-thumbnail=\"https://pic2.zhimg.com/50/v2-db22a7f37930746c9df8e90ba7674e2f_720w.jpg?source=1940ef5c\" poster=\"https://pic2.zhimg.com/50/v2-db22a7f37930746c9df8e90ba7674e2f_720w.jpg?source=1940ef5c\" data-size=\"normal\" preload=\"metadata\" loop=\"\" playsinline=\"\"></video></p>\n<p>ROSEFusion效果</p>\n<p><img data-src=\"https://pic3.zhimg.com/50/v2-6ebb19ebe17f2f577e9bb42b3676d075_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic3.zhimg.com/80/v2-6ebb19ebe17f2f577e9bb42b3676d075_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p>ROSEFusion 能够在仅考虑深度图作为输入的条件下，利用随机优化求解相机位姿，实现了在快速相机移动下的室内场景稠密重建。同时该工作仅依赖深度信息，因此也可以在无光照，和变化光照的条件下使用。  该工作的主要特点是：(a) 利用深度图和TSDF相容性作为代价函数，不需要提取特征点，仅依赖于深度图；(b) 提出了Particle Swarm Template（PST），利用PST可以高效的对相机位姿空间进行采样，并利用随机优化求解出相机的位姿。</p>\n<hr>\n<p>收藏这个问题很久，楼上各位大佬已经总结的很好，大部分回答介绍了对<a href=\"https://www.zhihu.com/search?q=%E5%88%9A%E4%BD%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1242628310%7D\">刚体</a>的三维重建工作，但对非刚体三维重建的工作介绍还比较少。刚好读研时做过这方面的调研和学习，来做一点点补充吧。高赞 <a href=\"http://www.zhihu.com/people/5df6b1e2e74ebe45983a5c8eeb489e84\">@曹力科</a> 博士的回答介绍了基于RGBD的实时三维重建工作，各种XXXFusion效果很是惊艳，而且可以实时重建出动态物体的三维模型。但是也有个问题，要是RGBD相机我也觉得贵怎么办，我就想用普通的RGB相机去进行动态三维，还想只用一个RGB相机去完成重建。</p>\n<p>学术界那帮大佬也这么想，想用最最最简单的设备去解决某个复杂的问题，即采用单目的RGB相机去进行动态三维重建。大道至简嘛，不然怎么体现出大佬的水平，手动狗头。</p>\n<p>同时问题也来了，单目RGB相机在投影时已经失去了深度信息，如何恢复深度和重建呢？有这么几类方案。</p>\n<p><strong>一、NRSfM(NonRigid Structure from Motion)</strong></p>\n<p>Bregler等人[1]首先提出了NRSfM的思想，他们提出将目标物体在每一帧上的三维变形形状表示为K个形状基的线性加权组合，然后通过分解刚性系数矩阵来得到随时间序列变化的形状基、组合系数和摄像机运动参数。基于低秩形状的约束是一个强大的约束，但是它的求解是一个病态不定问题。</p>\n<p>这类重建方案我不是很熟，只介绍个做的比较好的。</p>\n<p>Ravi Garg等人CVPR2013的工作，论文地址：</p>\n<p><a href=\"https://link.zhihu.com/?target=https://www.cv-foundation.org/openaccess/content_cvpr_2013/papers/Garg_Dense_Variational_Reconstruction_2013_CVPR_paper.pdf\">Dense Variational Reconstruction of Non-Rigid Surfaces from Monocular Video∗</a></p>\n<p>重建可以得到稠密的结果，效果还是很不错的，就是需要得到完整的视频后才能重建。</p>\n<p>重建结果：</p>\n<p><img data-src=\"https://pic2.zhimg.com/50/v2-45df925a2c26567962c6027d1cf1acb6_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic2.zhimg.com/80/v2-45df925a2c26567962c6027d1cf1acb6_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p><strong>二、SfT(Shape from Template)</strong></p>\n<p>另外一种方法是SfT。这种重建方法需要预先得到目标物体在刚性状态下的三维模型来作为模板，后面模型去追踪单目视频里目标物体的变化，得到每一帧图像对应的形变三维模型。这种方法具有实时重建的可能。</p>\n<p>重建的时候一般使用网格来表示三维模型，大佬们发现物体在发生形变时对应的网格模型是存在着约束的：等距约束(相邻网格顶点之间的距离在变形过程中保持不变)、平滑先验(相邻顶点的变形应该相似)和尽可能的刚性先验(变形可以用局部刚体运动近似)。打个比方，吹气球气球变大的过程中，气球上的某个点和它附件的点变化的趋势是相似的，但是这些点变大时又保持着最开始的拓扑结构。</p>\n<p><strong>1.Adrien Bartoli团队的工作</strong></p>\n<p>SfT的理论由Adrien Bartoli等人总结提出，对平面进行了稀疏重建。论文地址：<a href=\"https://link.zhihu.com/?target=http://igt.ip.uca.fr/~ab/Publications/Bartoli_etal_PAMI15.pdf\">Bartoli_etal_SfT</a></p>\n<p>Bartoli主页：<a href=\"https://link.zhihu.com/?target=http://igt.ip.uca.fr/~ab/\">http://igt.ip.uca.fr/~ab/index.html</a></p>\n<p>重建结果：</p>\n<p><img data-src=\"https://pic2.zhimg.com/50/v2-f52d5d65cb8151f85ee17a23a6b9f817_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic2.zhimg.com/80/v2-f52d5d65cb8151f85ee17a23a6b9f817_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p>后面他们团队拓展了这个方法，对稠密完整的物体进行了重建，而且给出了一个Demo。</p>\n<p>论文地址：<a href=\"https://link.zhihu.com/?target=http://igt.ip.uca.fr/~ab/Publications/Collins_Bartoli_ISMAR15.pdf\">http://igt.ip.uca.fr/~ab/Publications/Collins_Bartoli_ISMAR15.pdf</a></p>\n<p>论文中说好的会公开源码，但是我没找到。</p>\n<p>重建结果：</p>\n<p><img data-src=\"https://pic2.zhimg.com/50/v2-3fdf7bc372fbf90f752aa1229568db5a_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic2.zhimg.com/80/v2-3fdf7bc372fbf90f752aa1229568db5a_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p>演示视频：</p>\n<p>Realtime SfT</p>\n<p>他们组后续还有一些相关工作，都是对这个方法的改进：<a href=\"https://link.zhihu.com/?target=http://igt.ip.uca.fr/~ab/Publications/Parashar_etal_ICCV15.pdf\">http://igt.ip.uca.fr/~ab/Publications/Parashar_etal_ICCV15.pdf</a></p>\n<p>此外这个组在arxiv上挂了一篇用深度学习方法做的SfT，但是现在还没正式发表，实验结果并不能重建得到完整的动态三维模型，只针物体的一个面完成了重建。</p>\n<p><a href=\"https://link.zhihu.com/?target=https://arxiv.org/pdf/1811.07791.pdf\">https://arxiv.org/pdf/1811.07791.pdf</a></p>\n<p><strong>2.Lourdes Agapito团队的工作</strong></p>\n<p>这方面的工作主要由</p>\n<p><a href=\"http://www.zhihu.com/people/d2cf5bfec952c05516618be8f62b2f66\">@余瑞</a></p>\n<p> 博士做的，并且开源了源码。论文地址：<a href=\"https://link.zhihu.com/?target=http://www0.cs.ucl.ac.uk/staff/R.Yu/direct_nrsfm/direct_nrsfm.pdf\">http://www0.cs.ucl.ac.uk/staff/R.Yu/direct_nrsfm/direct_nrsfm.pdf</a></p>\n<p>项目主页：<a href=\"https://link.zhihu.com/?target=http://www0.cs.ucl.ac.uk/staff/R.Yu/direct_nrsfm/direct_nrsfm.html\">http://www0.cs.ucl.ac.uk/staff/R.Yu/direct_nrsfm/direct_nrsfm.html</a></p>\n<p>代码：<a href=\"https://link.zhihu.com/?target=https://github.com/cvfish/PangaeaTracking\">https://github.com/cvfish/PangaeaTracking</a></p>\n<p>重建结果：</p>\n<p><img data-src=\"https://pic2.zhimg.com/50/v2-3ce62e74607e88ef852e29977f72695c_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic2.zhimg.com/80/v2-3ce62e74607e88ef852e29977f72695c_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p>演示视频：</p>\n<p>单目RGB动态三维重建</p>\n<p>一年后在这个基础上又做出了改进，把shape-from-shading的方法加入到整个系统中，提高了重建的质量和精度。可以发现下图重建的结果更好了，多了很多细节。</p>\n<p>论文地址：<a href=\"https://link.zhihu.com/?target=http://www0.cs.ucl.ac.uk/staff/Qi.Liu/bmvc16/better_together.pdf\">http://www0.cs.ucl.ac.uk/staff/Qi.Liu/bmvc16/better_together.pdf</a></p>\n<p>项目主页：<a href=\"https://link.zhihu.com/?target=http://www0.cs.ucl.ac.uk/staff/Qi.Liu/bmvc16/better_together.html\">http://www0.cs.ucl.ac.uk/staff/Qi.Liu/bmvc16/better_together.html</a></p>\n<p>代码：<a href=\"https://link.zhihu.com/?target=https://github.com/qilon/PangaeaTracking\">https://github.com/qilon/PangaeaTracking</a></p>\n<p>重建结果</p>\n<p><img data-src=\"https://pic2.zhimg.com/50/v2-413641049fd99de9e4092e1daa8f7642_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic2.zhimg.com/80/v2-413641049fd99de9e4092e1daa8f7642_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p><strong>3.马普所团队的工作</strong></p>\n<p>马普所的Marc Habermann等人把</p>\n<p><a href=\"http://www.zhihu.com/people/d2cf5bfec952c05516618be8f62b2f66\">@余瑞</a></p>\n<p> 博士的工作改进应用到了人体动态三维重建方面。</p>\n<p>论文地址：<a href=\"https://link.zhihu.com/?target=https://gvv.mpi-inf.mpg.de/projects/LiveCap/data/livecap.pdf\">https://gvv.mpi-inf.mpg.de/projects/LiveCap/data/livecap.pdf</a></p>\n<p>项目地址：<a href=\"https://link.zhihu.com/?target=https://gvv.mpi-inf.mpg.de/projects/LiveCap/\">https://gvv.mpi-inf.mpg.de/projects/LiveCap/</a></p>\n<p>重建结果：</p>\n<p><img data-src=\"https://pic1.zhimg.com/50/v2-da3a17671749373c853da4c72d9911d1_720w.jpg?source=1940ef5c\" alt=\"img\"><img data-src=\"https://pic1.zhimg.com/80/v2-da3a17671749373c853da4c72d9911d1_1440w.jpg?source=1940ef5c\" alt=\"img\"></p>\n<p><strong>三、基于模型的方法 (Model-based methods)</strong></p>\n<p>这一类方法主要代表是HMR等，主要针对于人体和动物，作者建立了两个模型库SMPL和SMAL，然后把人或动物的姿态给模型参数化了。这几个项目用到深度学习的方法。</p>\n<p>作者Angjoo Kanazawa主页：<a href=\"https://link.zhihu.com/?target=https://people.eecs.berkeley.edu/~kanazawa/\">https://people.eecs.berkeley.edu/~kanazawa/</a></p>\n<p>Github：<a href=\"https://link.zhihu.com/?target=https://github.com/akanazawa\">https://github.com/akanazawa</a></p>\n<p>演示视频：</p>\n<iframe title=\"video\" src=\"https://video.zhihu.com/video/1247867048929185792?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe>\n\n<iframe title=\"video\" src=\"https://video.zhihu.com/video/1247867124434636800?player=%7B%22autoplay%22%3Afalse%2C%22shouldShowPageFullScreenButton%22%3Atrue%7D\" allowfullscreen=\"\" frameborder=\"0\" class=\"css-uwwqev\"></iframe>\n\n<p><strong>四、其他</strong></p>\n<p>除此之外还有一些对于人脸的重建，如Face2Face等。也是输入单目视频得到重建结果，这块我没去了解过，就不多介绍了。</p>\n<p>做单目动态三维重建的团队还有Mathieu Salzmann等人和 </p>\n<p><a href=\"http://www.zhihu.com/people/99407a07afd17db138c3990746a55886\">@戴玉超</a></p>\n<p> 老师在的团队，但是成果都是偏向稀疏的重建，而且近几年没有看到新的成果，感兴趣的小伙伴可以去找找相关资料。</p>\n<p>国内<a href=\"https://www.zhihu.com/search?q=%E8%A5%BF%E5%AE%89%E4%BA%A4%E9%80%9A%E5%A4%A7%E5%AD%A6&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1242628310%7D\">西安交通大学</a>的Wang Xuan博士在这个方向也做了部分工作，他在Mathieu Salzmann组做过访问学生。论文链接：</p>\n<p><a href=\"https://link.zhihu.com/?target=https://link.springer.com/chapter/10.1007/978-3-319-46478-7_40\">https://link.springer.com/chapter/10.1007/978-3-319-46478-7_40link.springer.com/chapter/10.1007/978-3-319-46478-7_40</a></p>\n<p>戴老师的工作，论文链接：</p>\n<p><a href=\"https://link.zhihu.com/?target=http://users.cecs.anu.edu.au/~hongdong/CVPR12_Nonrigid_CRC_17_postprint.pdf\">http://users.cecs.anu.edu.au/<del>hongdong/CVPR12_Nonrigid_CRC_17_postprint.pdfusers.cecs.anu.edu.au/</del>hongdong/CVPR12_Nonrigid_CRC_17_postprint.pdf</a></p>\n<p>这篇回答主要介绍了几个稠密的重建方案，采用的方法也比较传统，大多是基于优化的方式进行的重建，目前深度学习的方法应用在这个领域的方案还比较少，没看到什么令人惊艳的成果。</p>\n<p>由于水平有限，这篇回答仅抛砖引玉一下。肯定存在着很多纰漏和错误，请小伙伴们多多补充和指正。</p>\n<p><strong>五、引用</strong></p>\n<p>[1]Recovering Non-Rigid 3D Shape from Image Streams.Christoph Bregler, Aaron Hertzmann and Henning Biermann.<em>Proc. IEEE CVPR 2000</em></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cl1iy71gy00011ou05hht30b8","category_id":"cl1iy71h200041ou0b11r3z3o","_id":"cl1iy71h8000d1ou0ahb9cqsu"},{"post_id":"cl1iy71h500081ou040recmue","category_id":"cl1iy71h200041ou0b11r3z3o","_id":"cl1iy71ha000h1ou0cncp76kl"},{"post_id":"cl1iy71h6000b1ou0crl8g6c2","category_id":"cl1iy71h500091ou00td50wx8","_id":"cl1iy71hb000j1ou01tfu3agk"},{"post_id":"cl1iy71h000031ou0fsls9fty","category_id":"cl1iy71h500091ou00td50wx8","_id":"cl1iy71hc000n1ou08ww254ml"},{"post_id":"cl1iy71h7000c1ou0a5y63f5h","category_id":"cl1iy71h500091ou00td50wx8","_id":"cl1iy71hd000p1ou053qnavlh"},{"post_id":"cl1iy71h9000g1ou0egxyhrdo","category_id":"cl1iy71h500091ou00td50wx8","_id":"cl1iy71he000s1ou03umz7tga"},{"post_id":"cl1iy71h300061ou01x7z0fe5","category_id":"cl1iy71h200041ou0b11r3z3o","_id":"cl1iy71hf000u1ou0exb73hlh"},{"post_id":"cl1iy71ha000i1ou0667ogl90","category_id":"cl1iy71h500091ou00td50wx8","_id":"cl1iy71hg000w1ou05x3w1fpu"},{"post_id":"cl1iy71hb000m1ou046u4ax80","category_id":"cl1iy71h500091ou00td50wx8","_id":"cl1iy71hh00101ou09w5th3wx"},{"post_id":"cl1iy71h400071ou088zv022b","category_id":"cl1iy71hb000k1ou06pxt273w","_id":"cl1iy71hi00131ou0795wbfuk"},{"post_id":"cl1iy71hd000o1ou0crtb6dbh","category_id":"cl1iy71h500091ou00td50wx8","_id":"cl1iy71hj00171ou0d6xk30hm"},{"post_id":"cl1iy71he000r1ou08rqkhpfl","category_id":"cl1iy71hb000k1ou06pxt273w","_id":"cl1iy71hk001a1ou0cp9d32we"},{"post_id":"cl1iy71hf000t1ou08ruy0cv7","category_id":"cl1iy71h500091ou00td50wx8","_id":"cl1iy71hl001e1ou05czy0fsk"},{"post_id":"cl1iy71hg000v1ou014tocspq","category_id":"cl1iy71h500091ou00td50wx8","_id":"cl1iy71ho001g1ou0f21x4c6x"},{"post_id":"cl1iy71hh000z1ou0hzoa7yvt","category_id":"cl1iy71h500091ou00td50wx8","_id":"cl1iy71hp001j1ou0czbb1tds"},{"post_id":"cl1iy71hi00121ou0bth1emna","category_id":"cl1iy71h500091ou00td50wx8","_id":"cl1iy71hq001l1ou0dnwl6e7n"},{"post_id":"cl1iy71hj00161ou0c8ivfaze","category_id":"cl1iy71hb000k1ou06pxt273w","_id":"cl1iy71hq001n1ou029jlcura"},{"post_id":"cl1iy71hk00191ou0cmax4vnj","category_id":"cl1iy71hb000k1ou06pxt273w","_id":"cl1iy71hs001r1ou0992p9j1k"},{"post_id":"cl1iy71hl001d1ou0catvh30l","category_id":"cl1iy71h500091ou00td50wx8","_id":"cl1iy71ht001v1ou04j8z8uzz"},{"post_id":"cl1iy71hm001f1ou08tn3b8xz","category_id":"cl1iy71hb000k1ou06pxt273w","_id":"cl1iy71hu001z1ou09bib42n0"},{"post_id":"cl1iy71hp001i1ou0btvw0eob","category_id":"cl1iy71hb000k1ou06pxt273w","_id":"cl1iy71hv00221ou0acwy7jdk"},{"post_id":"cl1iy71hp001k1ou0efvc37ye","category_id":"cl1iy71hb000k1ou06pxt273w","_id":"cl1iy71hx00261ou039nbd8i0"},{"post_id":"cl1iy71hr001q1ou081aa6625","category_id":"cl1iy71h500091ou00td50wx8","_id":"cl1iy71hz002a1ou09msaa4tc"},{"post_id":"cl1iy71hs001u1ou04w9r47qo","category_id":"cl1iy71h500091ou00td50wx8","_id":"cl1iy71i1002e1ou00ij9bft4"},{"post_id":"cl1iy71ht001y1ou0gtzfg822","category_id":"cl1iy71hb000k1ou06pxt273w","_id":"cl1iy71i4002h1ou07pt9gd3m"},{"post_id":"cl1iy71hq001m1ou05u855pcs","category_id":"cl1iy71hs001s1ou075qfhmsa","_id":"cl1iy71i5002l1ou075d1fo1e"},{"post_id":"cl1iy71hw00251ou0cs8hama7","category_id":"cl1iy71hb000k1ou06pxt273w","_id":"cl1iy71i6002n1ou06x2oameb"},{"post_id":"cl1iy71hy00291ou0fpkpc1xi","category_id":"cl1iy71h200041ou0b11r3z3o","_id":"cl1iy71i7002q1ou0bwns0uwh"},{"post_id":"cl1iy71hu00211ou0d5zyfhtb","category_id":"cl1iy71hx00271ou059mxc450","_id":"cl1iy71i9002u1ou05reibn33"},{"post_id":"cl1iy71i2002g1ou05ve3gacx","category_id":"cl1iy71hb000k1ou06pxt273w","_id":"cl1iy71ic002x1ou04lhj9l66"},{"post_id":"cl1iy71i6002m1ou0702ca658","category_id":"cl1iy71i4002i1ou0h8rk2t5v","_id":"cl1iy71if00311ou0f67hfry1"},{"post_id":"cl1iy71i0002d1ou06qy49h26","category_id":"cl1iy71i4002i1ou0h8rk2t5v","_id":"cl1iy71ih00331ou00rwk69ow"},{"post_id":"cl1iy71i7002o1ou0dgri1uqu","category_id":"cl1iy71h200041ou0b11r3z3o","_id":"cl1iy71io00371ou04f87f0te"},{"post_id":"cl1iy71i8002t1ou0dy0m1tgo","category_id":"cl1iy71h200041ou0b11r3z3o","_id":"cl1iy71iq003a1ou0cyn4e5b3"},{"post_id":"cl1iy71i5002k1ou07gzv7ezc","category_id":"cl1iy71i4002i1ou0h8rk2t5v","_id":"cl1iy71iu003d1ou03v4k9d0y"},{"post_id":"cl1iy71ia002w1ou060vq6e48","category_id":"cl1iy71hx00271ou059mxc450","_id":"cl1iy71iw003g1ou00y8lbhdk"},{"post_id":"cl1iy71ie00301ou0cy9t0kdb","category_id":"cl1iy71hb000k1ou06pxt273w","_id":"cl1iy71iz003j1ou0853t9f0w"},{"post_id":"cl1iy71in00361ou0cyhde4ks","category_id":"cl1iy71hs001s1ou075qfhmsa","_id":"cl1iy71j0003l1ou05dr57rr2"},{"post_id":"cl1iy71ip00391ou036qt9odd","category_id":"cl1iy71h500091ou00td50wx8","_id":"cl1iy71j1003o1ou06d48cd3s"},{"post_id":"cl1iy71it003c1ou09mma7ic3","category_id":"cl1iy71hb000k1ou06pxt273w","_id":"cl1iy71j1003q1ou052om0bng"},{"post_id":"cl1iy71ig00321ou010le1cn9","category_id":"cl1iy71io00381ou04iow1gvb","_id":"cl1iy71j2003t1ou0cba707sb"},{"post_id":"cl1iy71iv003f1ou0416o1j06","category_id":"cl1iy71h200041ou0b11r3z3o","_id":"cl1iy71j2003u1ou076op9zo0"}],"PostTag":[{"post_id":"cl1iy71gy00011ou05hht30b8","tag_id":"cl1iy71h300051ou0bp50epvo","_id":"cl1iy71hh000y1ou0fyg6g9dq"},{"post_id":"cl1iy71gy00011ou05hht30b8","tag_id":"cl1iy71h6000a1ou08sm2bjz6","_id":"cl1iy71hi00111ou04ib1aw4j"},{"post_id":"cl1iy71gy00011ou05hht30b8","tag_id":"cl1iy71h8000f1ou094b8cp9m","_id":"cl1iy71hj00151ou00e8132d3"},{"post_id":"cl1iy71gy00011ou05hht30b8","tag_id":"cl1iy71hb000l1ou0dob44mm4","_id":"cl1iy71hk00181ou0bvff4daw"},{"post_id":"cl1iy71gy00011ou05hht30b8","tag_id":"cl1iy71he000q1ou0hdimgzd6","_id":"cl1iy71hl001c1ou0gdxah1qw"},{"post_id":"cl1iy71h000031ou0fsls9fty","tag_id":"cl1iy71hg000x1ou0bxzx7cl3","_id":"cl1iy71hr001p1ou027hzhnoc"},{"post_id":"cl1iy71h000031ou0fsls9fty","tag_id":"cl1iy71hj00141ou0gxo90osy","_id":"cl1iy71hs001t1ou0hfcdexha"},{"post_id":"cl1iy71h000031ou0fsls9fty","tag_id":"cl1iy71hk001b1ou08w93djpg","_id":"cl1iy71ht001x1ou00x5m0vpd"},{"post_id":"cl1iy71h000031ou0fsls9fty","tag_id":"cl1iy71ho001h1ou0g1316xb2","_id":"cl1iy71hu00201ou024i68w5i"},{"post_id":"cl1iy71hr001q1ou081aa6625","tag_id":"cl1iy71hj00141ou0gxo90osy","_id":"cl1iy71hw00241ou036tq1t5u"},{"post_id":"cl1iy71hr001q1ou081aa6625","tag_id":"cl1iy71hg000x1ou0bxzx7cl3","_id":"cl1iy71hy00281ou0ake468qu"},{"post_id":"cl1iy71h300061ou01x7z0fe5","tag_id":"cl1iy71h8000f1ou094b8cp9m","_id":"cl1iy71i0002c1ou0fa2w0pop"},{"post_id":"cl1iy71h300061ou01x7z0fe5","tag_id":"cl1iy71ht001w1ou0g9dm5nqo","_id":"cl1iy71i2002f1ou0b6j07zwy"},{"post_id":"cl1iy71h400071ou088zv022b","tag_id":"cl1iy71hv00231ou00xj9hr5k","_id":"cl1iy71i8002s1ou01r0ka8gc"},{"post_id":"cl1iy71h400071ou088zv022b","tag_id":"cl1iy71i0002b1ou0fb6k8obb","_id":"cl1iy71ia002v1ou0dtjoa4lj"},{"post_id":"cl1iy71h400071ou088zv022b","tag_id":"cl1iy71i5002j1ou05k7ahavg","_id":"cl1iy71ie002z1ou02wk9gzrp"},{"post_id":"cl1iy71ie00301ou0cy9t0kdb","tag_id":"cl1iy71i5002j1ou05k7ahavg","_id":"cl1iy71in00351ou0glkd0d8q"},{"post_id":"cl1iy71ip00391ou036qt9odd","tag_id":"cl1iy71hg000x1ou0bxzx7cl3","_id":"cl1iy71iv003e1ou0e9a6hjzc"},{"post_id":"cl1iy71ip00391ou036qt9odd","tag_id":"cl1iy71hj00141ou0gxo90osy","_id":"cl1iy71iy003i1ou01kdb7i0y"},{"post_id":"cl1iy71h500081ou040recmue","tag_id":"cl1iy71hg000x1ou0bxzx7cl3","_id":"cl1iy71j0003k1ou0474f57ry"},{"post_id":"cl1iy71h500081ou040recmue","tag_id":"cl1iy71hj00141ou0gxo90osy","_id":"cl1iy71j0003n1ou0gzrzdebp"},{"post_id":"cl1iy71h500081ou040recmue","tag_id":"cl1iy71ih00341ou05otj9tu3","_id":"cl1iy71j1003p1ou0bm6zakg0"},{"post_id":"cl1iy71h500081ou040recmue","tag_id":"cl1iy71iq003b1ou07we5fs4p","_id":"cl1iy71j2003s1ou02rk77qnf"},{"post_id":"cl1iy71h6000b1ou0crl8g6c2","tag_id":"cl1iy71hg000x1ou0bxzx7cl3","_id":"cl1iy71j3003w1ou04f18hz35"},{"post_id":"cl1iy71h6000b1ou0crl8g6c2","tag_id":"cl1iy71hj00141ou0gxo90osy","_id":"cl1iy71j3003x1ou09we088sb"},{"post_id":"cl1iy71h6000b1ou0crl8g6c2","tag_id":"cl1iy71j1003r1ou03mfd9qk3","_id":"cl1iy71j4003z1ou02y07hms4"},{"post_id":"cl1iy71h7000c1ou0a5y63f5h","tag_id":"cl1iy71hg000x1ou0bxzx7cl3","_id":"cl1iy71j600431ou098f84pyh"},{"post_id":"cl1iy71h7000c1ou0a5y63f5h","tag_id":"cl1iy71hj00141ou0gxo90osy","_id":"cl1iy71j600441ou012h2c7xm"},{"post_id":"cl1iy71h7000c1ou0a5y63f5h","tag_id":"cl1iy71j400401ou02vwk20oj","_id":"cl1iy71j700461ou0h6mcbdkh"},{"post_id":"cl1iy71h7000c1ou0a5y63f5h","tag_id":"cl1iy71j500411ou0ax2k4j11","_id":"cl1iy71j700471ou0bqmxeb2q"},{"post_id":"cl1iy71h9000g1ou0egxyhrdo","tag_id":"cl1iy71hg000x1ou0bxzx7cl3","_id":"cl1iy71ja004c1ou04ayzbvub"},{"post_id":"cl1iy71h9000g1ou0egxyhrdo","tag_id":"cl1iy71hj00141ou0gxo90osy","_id":"cl1iy71ja004d1ou03qkhe4x3"},{"post_id":"cl1iy71h9000g1ou0egxyhrdo","tag_id":"cl1iy71j700481ou0h09we6ze","_id":"cl1iy71jb004f1ou08jny5c8x"},{"post_id":"cl1iy71h9000g1ou0egxyhrdo","tag_id":"cl1iy71j400401ou02vwk20oj","_id":"cl1iy71jb004g1ou083086fmz"},{"post_id":"cl1iy71h9000g1ou0egxyhrdo","tag_id":"cl1iy71j9004a1ou0ciml26yl","_id":"cl1iy71jc004i1ou0dmw54pzd"},{"post_id":"cl1iy71ha000i1ou0667ogl90","tag_id":"cl1iy71hg000x1ou0bxzx7cl3","_id":"cl1iy71jd004l1ou0baci3vod"},{"post_id":"cl1iy71ha000i1ou0667ogl90","tag_id":"cl1iy71hj00141ou0gxo90osy","_id":"cl1iy71jd004m1ou0bmiy0v8r"},{"post_id":"cl1iy71ha000i1ou0667ogl90","tag_id":"cl1iy71jb004h1ou019a1eh0d","_id":"cl1iy71jd004o1ou0hg3a44yo"},{"post_id":"cl1iy71ha000i1ou0667ogl90","tag_id":"cl1iy71jc004j1ou0212x37yh","_id":"cl1iy71je004p1ou07itnc6b7"},{"post_id":"cl1iy71hb000m1ou046u4ax80","tag_id":"cl1iy71hg000x1ou0bxzx7cl3","_id":"cl1iy71jf004t1ou0gv52accf"},{"post_id":"cl1iy71hb000m1ou046u4ax80","tag_id":"cl1iy71hj00141ou0gxo90osy","_id":"cl1iy71jf004u1ou03qey182s"},{"post_id":"cl1iy71hb000m1ou046u4ax80","tag_id":"cl1iy71je004q1ou09dj524d0","_id":"cl1iy71jf004w1ou04c2r8xi6"},{"post_id":"cl1iy71hb000m1ou046u4ax80","tag_id":"cl1iy71j9004a1ou0ciml26yl","_id":"cl1iy71jg004x1ou07iae1g3m"},{"post_id":"cl1iy71hd000o1ou0crtb6dbh","tag_id":"cl1iy71hg000x1ou0bxzx7cl3","_id":"cl1iy71ji00541ou04lj97s4x"},{"post_id":"cl1iy71hd000o1ou0crtb6dbh","tag_id":"cl1iy71hj00141ou0gxo90osy","_id":"cl1iy71ji00551ou0dgoxfzhr"},{"post_id":"cl1iy71hd000o1ou0crtb6dbh","tag_id":"cl1iy71j9004a1ou0ciml26yl","_id":"cl1iy71jj00571ou0cn0c28mq"},{"post_id":"cl1iy71hd000o1ou0crtb6dbh","tag_id":"cl1iy71je004q1ou09dj524d0","_id":"cl1iy71jj00581ou06tlj8oeg"},{"post_id":"cl1iy71hd000o1ou0crtb6dbh","tag_id":"cl1iy71j400401ou02vwk20oj","_id":"cl1iy71jj005a1ou0coh6e5cp"},{"post_id":"cl1iy71hd000o1ou0crtb6dbh","tag_id":"cl1iy71j1003r1ou03mfd9qk3","_id":"cl1iy71jj005b1ou0gfjj4dik"},{"post_id":"cl1iy71hd000o1ou0crtb6dbh","tag_id":"cl1iy71jc004j1ou0212x37yh","_id":"cl1iy71jk005d1ou0est0fh2w"},{"post_id":"cl1iy71he000r1ou08rqkhpfl","tag_id":"cl1iy71hv00231ou00xj9hr5k","_id":"cl1iy71jk005e1ou08u59fhjs"},{"post_id":"cl1iy71he000r1ou08rqkhpfl","tag_id":"cl1iy71ji00561ou0a94qfmmb","_id":"cl1iy71jl005g1ou0dh30c97i"},{"post_id":"cl1iy71he000r1ou08rqkhpfl","tag_id":"cl1iy71i5002j1ou05k7ahavg","_id":"cl1iy71jl005h1ou0bl8uexdw"},{"post_id":"cl1iy71hf000t1ou08ruy0cv7","tag_id":"cl1iy71hg000x1ou0bxzx7cl3","_id":"cl1iy71jm005k1ou0b39fed4g"},{"post_id":"cl1iy71hf000t1ou08ruy0cv7","tag_id":"cl1iy71hj00141ou0gxo90osy","_id":"cl1iy71jm005l1ou0hjskggz3"},{"post_id":"cl1iy71hf000t1ou08ruy0cv7","tag_id":"cl1iy71jl005i1ou07jql8oyo","_id":"cl1iy71jm005n1ou0gql6b1ln"},{"post_id":"cl1iy71hg000v1ou014tocspq","tag_id":"cl1iy71hg000x1ou0bxzx7cl3","_id":"cl1iy71jo005q1ou0d445ddas"},{"post_id":"cl1iy71hg000v1ou014tocspq","tag_id":"cl1iy71hj00141ou0gxo90osy","_id":"cl1iy71jo005r1ou0gu8ef896"},{"post_id":"cl1iy71hg000v1ou014tocspq","tag_id":"cl1iy71jn005o1ou01af79t99","_id":"cl1iy71jo005t1ou00kvebsw7"},{"post_id":"cl1iy71hh000z1ou0hzoa7yvt","tag_id":"cl1iy71hg000x1ou0bxzx7cl3","_id":"cl1iy71jp005v1ou056ue13z4"},{"post_id":"cl1iy71hh000z1ou0hzoa7yvt","tag_id":"cl1iy71hj00141ou0gxo90osy","_id":"cl1iy71jp005w1ou01z47erpw"},{"post_id":"cl1iy71hh000z1ou0hzoa7yvt","tag_id":"cl1iy71jo005s1ou0fb8x4sui","_id":"cl1iy71jq005y1ou03j3l9cj7"},{"post_id":"cl1iy71hi00121ou0bth1emna","tag_id":"cl1iy71hg000x1ou0bxzx7cl3","_id":"cl1iy71js00601ou05m7ffoct"},{"post_id":"cl1iy71hi00121ou0bth1emna","tag_id":"cl1iy71hj00141ou0gxo90osy","_id":"cl1iy71js00611ou0f7h4a2pi"},{"post_id":"cl1iy71hi00121ou0bth1emna","tag_id":"cl1iy71jp005x1ou0a0bc82hf","_id":"cl1iy71js00631ou0g8me9mqp"},{"post_id":"cl1iy71hj00161ou0c8ivfaze","tag_id":"cl1iy71hv00231ou00xj9hr5k","_id":"cl1iy71jt00661ou0215eae0y"},{"post_id":"cl1iy71hj00161ou0c8ivfaze","tag_id":"cl1iy71js00621ou08gmhae56","_id":"cl1iy71jt00671ou07udd16pg"},{"post_id":"cl1iy71hj00161ou0c8ivfaze","tag_id":"cl1iy71js00641ou0bjzvg1ue","_id":"cl1iy71ju00691ou03zjhb5zh"},{"post_id":"cl1iy71hk00191ou0cmax4vnj","tag_id":"cl1iy71hv00231ou00xj9hr5k","_id":"cl1iy71jv006d1ou0h4bxa8y8"},{"post_id":"cl1iy71hk00191ou0cmax4vnj","tag_id":"cl1iy71ji00561ou0a94qfmmb","_id":"cl1iy71jw006e1ou01gs80dad"},{"post_id":"cl1iy71hk00191ou0cmax4vnj","tag_id":"cl1iy71i5002j1ou05k7ahavg","_id":"cl1iy71jw006g1ou0ahdg09o0"},{"post_id":"cl1iy71hk00191ou0cmax4vnj","tag_id":"cl1iy71ju006b1ou06gnl805b","_id":"cl1iy71jx006h1ou04odi66sh"},{"post_id":"cl1iy71hl001d1ou0catvh30l","tag_id":"cl1iy71hg000x1ou0bxzx7cl3","_id":"cl1iy71jy006j1ou03mjrh4a4"},{"post_id":"cl1iy71hl001d1ou0catvh30l","tag_id":"cl1iy71hj00141ou0gxo90osy","_id":"cl1iy71jz006k1ou0675tab44"},{"post_id":"cl1iy71hl001d1ou0catvh30l","tag_id":"cl1iy71j700481ou0h09we6ze","_id":"cl1iy71jz006m1ou0ffvobies"},{"post_id":"cl1iy71hl001d1ou0catvh30l","tag_id":"cl1iy71jw006f1ou0gymw4h2j","_id":"cl1iy71jz006n1ou00xfo3svl"},{"post_id":"cl1iy71hm001f1ou08tn3b8xz","tag_id":"cl1iy71hv00231ou00xj9hr5k","_id":"cl1iy71k1006p1ou07og25848"},{"post_id":"cl1iy71hm001f1ou08tn3b8xz","tag_id":"cl1iy71jz006l1ou0gsdbcwmc","_id":"cl1iy71k1006q1ou080pycjlg"},{"post_id":"cl1iy71hp001i1ou0btvw0eob","tag_id":"cl1iy71hv00231ou00xj9hr5k","_id":"cl1iy71k3006t1ou00yju4ahf"},{"post_id":"cl1iy71hp001i1ou0btvw0eob","tag_id":"cl1iy71k1006r1ou08ps2a2ao","_id":"cl1iy71k3006u1ou0axk4fpkk"},{"post_id":"cl1iy71hp001k1ou0efvc37ye","tag_id":"cl1iy71hv00231ou00xj9hr5k","_id":"cl1iy71k4006x1ou05obz6p0q"},{"post_id":"cl1iy71hp001k1ou0efvc37ye","tag_id":"cl1iy71ji00561ou0a94qfmmb","_id":"cl1iy71k4006y1ou04tl93if2"},{"post_id":"cl1iy71hq001m1ou05u855pcs","tag_id":"cl1iy71k4006w1ou0fekshmqv","_id":"cl1iy71k500711ou0h7710n45"},{"post_id":"cl1iy71hq001m1ou05u855pcs","tag_id":"cl1iy71hv00231ou00xj9hr5k","_id":"cl1iy71k500721ou0aqc649k6"},{"post_id":"cl1iy71hs001u1ou04w9r47qo","tag_id":"cl1iy71hj00141ou0gxo90osy","_id":"cl1iy71k600751ou0c1or9sz8"},{"post_id":"cl1iy71hs001u1ou04w9r47qo","tag_id":"cl1iy71hg000x1ou0bxzx7cl3","_id":"cl1iy71k600761ou0bnyigwvy"},{"post_id":"cl1iy71hs001u1ou04w9r47qo","tag_id":"cl1iy71jl005i1ou07jql8oyo","_id":"cl1iy71k700781ou0coak3p9a"},{"post_id":"cl1iy71hs001u1ou04w9r47qo","tag_id":"cl1iy71jw006f1ou0gymw4h2j","_id":"cl1iy71k700791ou0g9ach8q5"},{"post_id":"cl1iy71ht001y1ou0gtzfg822","tag_id":"cl1iy71hv00231ou00xj9hr5k","_id":"cl1iy71k7007b1ou01foq5jy8"},{"post_id":"cl1iy71ht001y1ou0gtzfg822","tag_id":"cl1iy71ji00561ou0a94qfmmb","_id":"cl1iy71k7007c1ou07mha9k6d"},{"post_id":"cl1iy71hu00211ou0d5zyfhtb","tag_id":"cl1iy71k7007a1ou03erz3wxr","_id":"cl1iy71k8007h1ou07r023z7k"},{"post_id":"cl1iy71hu00211ou0d5zyfhtb","tag_id":"cl1iy71k7007d1ou00u63dyh6","_id":"cl1iy71k9007i1ou0h87ydwxf"},{"post_id":"cl1iy71hu00211ou0d5zyfhtb","tag_id":"cl1iy71k8007e1ou04tuo4u1m","_id":"cl1iy71k9007k1ou0dl5sb23n"},{"post_id":"cl1iy71hu00211ou0d5zyfhtb","tag_id":"cl1iy71k8007f1ou013mj9196","_id":"cl1iy71k9007l1ou07t201yqe"},{"post_id":"cl1iy71hw00251ou0cs8hama7","tag_id":"cl1iy71hv00231ou00xj9hr5k","_id":"cl1iy71k9007n1ou05y1r4255"},{"post_id":"cl1iy71hw00251ou0cs8hama7","tag_id":"cl1iy71ji00561ou0a94qfmmb","_id":"cl1iy71k9007o1ou044cb0o2h"},{"post_id":"cl1iy71hy00291ou0fpkpc1xi","tag_id":"cl1iy71k9007j1ou05b7vaxts","_id":"cl1iy71ka007r1ou0binxdpp9"},{"post_id":"cl1iy71hy00291ou0fpkpc1xi","tag_id":"cl1iy71k9007m1ou070zf8mj2","_id":"cl1iy71ka007s1ou085yo5rzk"},{"post_id":"cl1iy71hy00291ou0fpkpc1xi","tag_id":"cl1iy71k9007p1ou0hrecfgiu","_id":"cl1iy71ka007u1ou07xtv25qz"},{"post_id":"cl1iy71i0002d1ou06qy49h26","tag_id":"cl1iy71k9007m1ou070zf8mj2","_id":"cl1iy71kb007v1ou01mnd5n9k"},{"post_id":"cl1iy71i2002g1ou05ve3gacx","tag_id":"cl1iy71hv00231ou00xj9hr5k","_id":"cl1iy71kb007x1ou0d1ps9edj"},{"post_id":"cl1iy71i2002g1ou05ve3gacx","tag_id":"cl1iy71hj00141ou0gxo90osy","_id":"cl1iy71kb007y1ou0f0bnfn8f"},{"post_id":"cl1iy71i2002g1ou05ve3gacx","tag_id":"cl1iy71ka007t1ou0h3ppdfjk","_id":"cl1iy71kc00801ou065hzfvw6"},{"post_id":"cl1iy71i5002k1ou07gzv7ezc","tag_id":"cl1iy71kb007w1ou03k0g45jj","_id":"cl1iy71kc00811ou06yus8xmh"},{"post_id":"cl1iy71i6002m1ou0702ca658","tag_id":"cl1iy71k9007m1ou070zf8mj2","_id":"cl1iy71kc00841ou01jxvbqg0"},{"post_id":"cl1iy71i6002m1ou0702ca658","tag_id":"cl1iy71kc00821ou01pmegbnw","_id":"cl1iy71kd00851ou08j38ek7o"},{"post_id":"cl1iy71i7002o1ou0dgri1uqu","tag_id":"cl1iy71kc00831ou06cjg72w2","_id":"cl1iy71kd00871ou0dm4r9yyo"},{"post_id":"cl1iy71i7002o1ou0dgri1uqu","tag_id":"cl1iy71ht001w1ou0g9dm5nqo","_id":"cl1iy71kd00881ou03a5a6fnt"},{"post_id":"cl1iy71i8002t1ou0dy0m1tgo","tag_id":"cl1iy71kd00861ou016vc3v8y","_id":"cl1iy71kd008a1ou07no7brjb"},{"post_id":"cl1iy71i8002t1ou0dy0m1tgo","tag_id":"cl1iy71ht001w1ou0g9dm5nqo","_id":"cl1iy71kd008b1ou018tg8423"},{"post_id":"cl1iy71ia002w1ou060vq6e48","tag_id":"cl1iy71k8007e1ou04tuo4u1m","_id":"cl1iy71kf008d1ou0higv731l"},{"post_id":"cl1iy71ig00321ou010le1cn9","tag_id":"cl1iy71ke008c1ou07tkq54yk","_id":"cl1iy71kh008g1ou0gvabdnpl"},{"post_id":"cl1iy71ig00321ou010le1cn9","tag_id":"cl1iy71kg008e1ou08bpr9m4s","_id":"cl1iy71kh008h1ou07csjffwq"},{"post_id":"cl1iy71in00361ou0cyhde4ks","tag_id":"cl1iy71hv00231ou00xj9hr5k","_id":"cl1iy71kj008l1ou0fcrz2ux0"},{"post_id":"cl1iy71in00361ou0cyhde4ks","tag_id":"cl1iy71k4006w1ou0fekshmqv","_id":"cl1iy71kj008m1ou01qn63ibm"},{"post_id":"cl1iy71in00361ou0cyhde4ks","tag_id":"cl1iy71ju006b1ou06gnl805b","_id":"cl1iy71kk008n1ou06iyx3v4g"},{"post_id":"cl1iy71in00361ou0cyhde4ks","tag_id":"cl1iy71ki008j1ou00o3f6bw5","_id":"cl1iy71kk008o1ou0dohu10v2"},{"post_id":"cl1iy71it003c1ou09mma7ic3","tag_id":"cl1iy71js00641ou0bjzvg1ue","_id":"cl1iy71kk008p1ou07kaj6n70"}],"Tag":[{"name":"hexo","_id":"cl1iy71h300051ou0bp50epvo"},{"name":"git","_id":"cl1iy71h6000a1ou08sm2bjz6"},{"name":"github","_id":"cl1iy71h8000f1ou094b8cp9m"},{"name":"typora","_id":"cl1iy71hb000l1ou0dob44mm4"},{"name":"next","_id":"cl1iy71he000q1ou0hdimgzd6"},{"name":"unity","_id":"cl1iy71hg000x1ou0bxzx7cl3"},{"name":"c#","_id":"cl1iy71hj00141ou0gxo90osy"},{"name":"unityhub","_id":"cl1iy71hk001b1ou08w93djpg"},{"name":"2d","_id":"cl1iy71ho001h1ou0g1316xb2"},{"name":"windows","_id":"cl1iy71ht001w1ou0g9dm5nqo"},{"name":"c++","_id":"cl1iy71hv00231ou00xj9hr5k"},{"name":"滑动窗口法","_id":"cl1iy71i0002b1ou0fb6k8obb"},{"name":"数组","_id":"cl1iy71i5002j1ou05k7ahavg"},{"name":"ps","_id":"cl1iy71ih00341ou05otj9tu3"},{"name":"像素","_id":"cl1iy71iq003b1ou07we5fs4p"},{"name":"prefab","_id":"cl1iy71j1003r1ou03mfd9qk3"},{"name":"trigger","_id":"cl1iy71j400401ou02vwk20oj"},{"name":"collision","_id":"cl1iy71j500411ou0ax2k4j11"},{"name":"animator","_id":"cl1iy71j700481ou0h09we6ze"},{"name":"collider","_id":"cl1iy71j9004a1ou0ciml26yl"},{"name":"awake","_id":"cl1iy71jb004h1ou019a1eh0d"},{"name":"canvas","_id":"cl1iy71jc004j1ou0212x37yh"},{"name":"joint","_id":"cl1iy71je004q1ou09dj524d0"},{"name":"动态规划","_id":"cl1iy71ji00561ou0a94qfmmb"},{"name":"tilemap","_id":"cl1iy71jl005i1ou07jql8oyo"},{"name":"raycast","_id":"cl1iy71jn005o1ou01af79t99"},{"name":"update","_id":"cl1iy71jo005s1ou0fb8x4sui"},{"name":"camera","_id":"cl1iy71jp005x1ou0a0bc82hf"},{"name":"原地算法","_id":"cl1iy71js00621ou08gmhae56"},{"name":"链表","_id":"cl1iy71js00641ou0bjzvg1ue"},{"name":"vector","_id":"cl1iy71ju006b1ou06gnl805b"},{"name":"audio","_id":"cl1iy71jw006f1ou0gymw4h2j"},{"name":"双指针法","_id":"cl1iy71jz006l1ou0gsdbcwmc"},{"name":"快慢指针","_id":"cl1iy71k1006r1ou08ps2a2ao"},{"name":"map","_id":"cl1iy71k4006w1ou0fekshmqv"},{"name":"三维重构","_id":"cl1iy71k7007a1ou03erz3wxr"},{"name":"图像处理","_id":"cl1iy71k7007d1ou00u63dyh6"},{"name":"三维点云","_id":"cl1iy71k8007e1ou04tuo4u1m"},{"name":"体尺测量","_id":"cl1iy71k8007f1ou013mj9196"},{"name":"pytorch","_id":"cl1iy71k9007j1ou05b7vaxts"},{"name":"python","_id":"cl1iy71k9007m1ou070zf8mj2"},{"name":"anaconda","_id":"cl1iy71k9007p1ou0hrecfgiu"},{"name":"迭代器","_id":"cl1iy71ka007t1ou0h3ppdfjk"},{"name":"pyhton","_id":"cl1iy71kb007w1ou03k0g45jj"},{"name":"数据结构","_id":"cl1iy71kc00821ou01pmegbnw"},{"name":"jupyter","_id":"cl1iy71kc00831ou06cjg72w2"},{"name":"爬虫","_id":"cl1iy71kd00861ou016vc3v8y"},{"name":"linux","_id":"cl1iy71ke008c1ou07tkq54yk"},{"name":"ubuntu","_id":"cl1iy71kg008e1ou08bpr9m4s"},{"name":"stack","_id":"cl1iy71ki008j1ou00o3f6bw5"}]}}