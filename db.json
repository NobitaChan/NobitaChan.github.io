{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/assets/background.png","path":"assets/background.png","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/2021-07-04-搭建个人博客总结.md","hash":"3feaa20070ddb92160e7fb23486536877a821413","modified":1626345657284},{"_id":"source/_posts/2021-07-08-【LeetCode.930】和相同的二元子数组.md","hash":"76fe646017906a5e219f14962e83cb14ae4e381c","modified":1627024095137},{"_id":"source/_posts/2021-07-06-《Speed Down》Unity2d游戏开发（一）.md","hash":"ba4212c8ec782b9f80789d40074f39d7708729fa","modified":1626596697256},{"_id":"source/_posts/2021-07-06-解决Github无法访问.md","hash":"899ecd2535906eb1ee3d70ac3fa2c1ea31a86a86","modified":1626345860825},{"_id":"source/_posts/2021-07-08-再临Unity.md","hash":"f2daf49c5ce35cadebd4ff4ffc466ca9c436abbf","modified":1626344786644},{"_id":"source/_posts/2021-07-14-《Speed Down》Unity2d游戏开发（三）.md","hash":"b1f6484eeed52f17cfee9119dbc2052e38c8592c","modified":1626344804171},{"_id":"source/_posts/2021-07-13-《Speed Down》Unity2d游戏开发（二）.md","hash":"09caad4a8ca562e21f88de3626e13efbdd13011a","modified":1626441107940},{"_id":"source/_posts/2021-07-14-《Speed Down》Unity2d游戏开发（四）.md","hash":"abb0f6c32f1a800038b1cdf457b298ee69c06007","modified":1626344810794},{"_id":"source/_posts/2021-07-15-《Speed Down》Unity2d游戏开发（六）.md","hash":"37466148b507c0df79119ccf2767b4ba0e0ddf1f","modified":1626515987909},{"_id":"source/_posts/2021-07-15-《Speed Down》Unity2d游戏开发（五）.md","hash":"14585f8e2019103367675b30c77a84b7f56ddf6e","modified":1626357515350},{"_id":"source/_posts/2021-07-16-《Speed Down》Unity2d游戏开发（完）.md","hash":"51f2f97ae7c4ca080a45ea7eb636531d68fb30fe","modified":1626450877431},{"_id":"source/_posts/2021-07-17-【LeetCode.剑指Offer.42】连续子数组的最大和.md","hash":"7d8781899c9da321b51037452df93adf1d367997","modified":1627024071633},{"_id":"source/_posts/2021-07-19-《Robbie Swifthand》Unity2d独立游戏学习（二）.md","hash":"70e9d5328d00307d284e8dd33df6f14d64cbe49b","modified":1626705531417},{"_id":"source/_posts/2021-07-23-《Robbie Swifthand》Unity2d独立游戏学习（四）.md","hash":"1daa49bbc561b6d4dd2c9940532074cd6f46c894","modified":1627485115141},{"_id":"source/_posts/2021-07-18-《Robbie Swifthand》Unity2d独立游戏学习（一）.md","hash":"2745f218d72c4cd2d43d45d7b2202003128c6e29","modified":1626619285617},{"_id":"source/_posts/2021-07-20-《Robbie Swifthand》Unity2d独立游戏学习（三）.md","hash":"9e958bf80743ea7abb359ecf6fe32a2e2fb4bf88","modified":1626855438832},{"_id":"source/_posts/2021-07-22-【LeetCode.138】 复制带随机指针的链表.md","hash":"d9deae8ac413c7da76a88766de69e39c8362b224","modified":1627024669852},{"_id":"source/_posts/更2021-07-06-剪辑视频入门总结.md","hash":"57f28f353d12c9c0df385ebe1da70d2808df92f4","modified":1627024817555},{"_id":"source/_posts/更2021-07-09-C++STL.md","hash":"e8f174bbeb5d63c8e28e2ec4a7975fa9e438578f","modified":1626344841147},{"_id":"source/_posts/置顶页面Top.md","hash":"afb350425d2f4f8cb9d36fbbb1168d5b4b0974cb","modified":1626345001184},{"_id":"source/tags/index.md","hash":"f51e5d45846b5a6b2c5313303ebf650556e25bff","modified":1625490765443},{"_id":"source/categories/index.md","hash":"dea7db88b4e81bdccdf5a866f27655d8fb623d02","modified":1625500055970},{"_id":"source/_posts/2021-07-26-【LeetCode.1143】最长公共子序列.md","hash":"26e9f0e2b3d84b4d059060371b977f53bd0ebbb3","modified":1627315268266},{"_id":"source/_data/styles.styl","hash":"9d3948468a44db8e2e6b889ab86d548f54552d0f","modified":1625911368737},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1625474600086},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1625474600082},{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1625474600082},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1625474600083},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1625474600087},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1625474600086},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1625474600087},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1625474600116},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1625474600087},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1625474600088},{"_id":"themes/next/_config.yml","hash":"5e39a15f4f5ceffa0f0be143c54a9512f184847e","modified":1625903939048},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1625474600083},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1625474600083},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1625474600093},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1625474600085},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1625474600085},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1625474600085},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1625474600085},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1625474600085},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1625474600086},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1625474600086},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1625474600086},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1625474600086},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1625474600089},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1625474600088},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1625474600089},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1625474600088},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1625474600089},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1625474600122},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1625474600089},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1625474600089},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1625474600090},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1625474600094},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1625474600094},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1625474600094},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1625474600090},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1625474600094},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1625474600095},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1625474600095},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1625474600094},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1625474600095},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1625474600095},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1625474600096},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1625474600096},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1625474600096},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1625474600096},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1625474600097},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1625474600097},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1625474600096},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1625474600097},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1625474600098},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1625474600097},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1625474600097},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1625474600098},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1625474600115},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1625474600098},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1625474600115},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1625474600098},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1625474600115},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1625474600115},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1625474600116},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1625474600115},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1625474600084},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1625474600084},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1625474600084},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1625474600084},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1625474600117},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1625474600120},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1625474600120},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1625474600120},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1625474600121},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1625474600121},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1625474600120},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1625474600090},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1625474600121},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1625474600122},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1625474600122},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1625474600123},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1625474600122},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1625474600123},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1625474600090},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1625474600123},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1625474600123},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1625474600124},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1625474600124},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1625474600124},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1625474600124},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1625474600124},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1625474600091},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1625474600147},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1625474600125},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1625474600091},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1625474600091},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1625474600141},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1625474600092},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1625474600092},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1625474600092},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1625474600093},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1625474600092},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1625474600093},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1625474600148},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1625474600093},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1625474600148},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1625474600093},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1625474600148},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1625474600148},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1625474600149},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1625474600149},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1625474600149},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1625474600150},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1625474600150},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1625474600149},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1625474600150},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1625474600150},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1625474600150},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1625474600151},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1625474600151},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1625474600151},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1625474600151},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1625474600152},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1625474600099},{"_id":"themes/next/source/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1625474600152},{"_id":"themes/next/layout/_macro/post.swig","hash":"60aa59b746995d8baa4a0c5b0d78eb5fe52f4ae4","modified":1625905178677},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1625474600099},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1625474600105},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1625474600105},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1625474600107},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1625474600153},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1625474600107},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1625474600106},{"_id":"themes/next/layout/_partials/footer.swig","hash":"4369b313cbbeae742cb35f86d23d99d4285f7359","modified":1625474600100},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1625474600102},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1625474600105},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1625474600102},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1625474600110},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1625474600099},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1625474600118},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1625474600118},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1625474600118},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1625474600118},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1625474600119},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1625474600119},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1625474600119},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1625474600119},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1625474600117},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1625474600117},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1625474600117},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1625474600108},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1625474600146},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1625474600111},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1625474600111},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1625474600146},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1625474600147},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1625474600146},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1625474600147},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1625474600152},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1625474600106},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1625474600152},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1625474600106},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1625474600106},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1625474600106},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1625474600105},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1625474600156},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1625474600100},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1625474600100},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1625474600155},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1625474600102},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1625474600102},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1625474600101},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1625474600101},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1625474600101},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1625474600102},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1625474600104},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1625474600101},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1625474600104},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1625474600104},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1625474600104},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1625474600103},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1625474600103},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1625474600103},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1625474600103},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1625474600103},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1625474600108},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1625474600108},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1625474600107},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1625474600109},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1625474600108},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1625474600108},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1625474600109},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1625474600110},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1625474600109},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1625474600109},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1625474600110},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1625474600111},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1625474600109},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1625474600110},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1625474600111},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1625474600114},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1625474600112},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1625474600113},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1625474600112},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1625474600114},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1625474600113},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1625474600113},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1625474600112},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1625474600125},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1625474600142},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1625474600126},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1625474600114},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1625474600130},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1625474600126},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1625474600113},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1625474600142},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1625474600142},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1625474600143},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1625474600142},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1625474600137},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1625474600143},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1625474600137},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1625474600137},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1625474600139},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1625474600139},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1625474600139},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1625474600141},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1625474600134},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1625474600134},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1625474600139},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1625474600143},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1625474600143},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1625474600144},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1625474600144},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1625474600144},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1625474600144},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1625474600145},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1625474600145},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1625474600145},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1625474600145},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1625474600146},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1625474600145},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1625474600154},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1625474600154},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1625474600128},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1625474600127},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1625474600128},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1625474600128},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1625474600128},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1625474600129},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1625474600129},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1625474600130},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1625474600129},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1625474600129},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1625474600130},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"78207f1d136bf750a265566f05999febb18ba39e","modified":1625904371368},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1625474600129},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1625474600126},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1625474600126},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1625474600127},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1625474600127},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1625474600127},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1625474600131},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1625474600131},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1625474600131},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1625474600138},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1625474600132},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1625474600138},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1625474600131},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1625474600138},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1625474600138},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1625474600140},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1625474600140},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1625474600132},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1625474600140},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1625474600141},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1625474600140},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1625474600141},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1625474600140},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1625474600134},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1625474600135},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1625474600135},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1625474600135},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1625474600135},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1625474600136},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1625474600136},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1625474600136},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1625474600132},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1625474600136},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1625474600136},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1625474600133},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1625474600133},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1625474600133},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1625474600133},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1625474600133},{"_id":"themes/next/source/images/avatar.jpg","hash":"acdc7d95a97b1c233e787bfc9d7b321c52a2cf3c","modified":1625497456410},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1625474600155},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1625474600154},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1625474600134},{"_id":"themes/next/source/assets/background.png","hash":"6cea513ac9097638ccc8c70bd3b0b9e1eb2a84da","modified":1625911300502},{"_id":"public/search.xml","hash":"3923e814d135b082b108b73f9add8c3f01ccdca1","modified":1627485174672},{"_id":"public/tags/index.html","hash":"5f3c6d4a805d9f5d4390ad94c5cb0c0d44a8c6cb","modified":1627485174672},{"_id":"public/categories/index.html","hash":"8cbcb086ad8cff93f2b2cb87165549c387bda2e5","modified":1627485174672},{"_id":"public/2021/07/09/置顶页面Top/index.html","hash":"a89e47415e5837beaed0edfa7b968f03596d4bba","modified":1627485174672},{"_id":"public/archives/page/3/index.html","hash":"352c394b96e884342106ebd37503a52707e90c8a","modified":1627485174672},{"_id":"public/archives/2021/page/3/index.html","hash":"fe2c4db0c1045ba47d30f2d7f1d3f3ebac829da2","modified":1627485174672},{"_id":"public/archives/2021/07/page/3/index.html","hash":"339bd7a5d67b0f4fd5d34840c3fbdb637ba6088e","modified":1627485174672},{"_id":"public/page/3/index.html","hash":"6a14da6fd7ebc26c018df72766911d378ce78eb2","modified":1627485174672},{"_id":"public/categories/琐碎/index.html","hash":"40daf6a54c6b40cf5eeaea6a6ce57b0fac2b5378","modified":1627485174672},{"_id":"public/categories/unity/page/2/index.html","hash":"e3b16f236bd740d896b43ed5850e9ab835bb90b5","modified":1627485174672},{"_id":"public/categories/算法/index.html","hash":"9b56b76582970bec9e19176e41f39cb75504e688","modified":1627485174672},{"_id":"public/categories/c/index.html","hash":"5e0e509c1a0e8cbca371e270e9eee39158aae533","modified":1627485174672},{"_id":"public/tags/hexo/index.html","hash":"adbd37952e723749d88166b58e09dd4fbc440baf","modified":1627485174672},{"_id":"public/tags/git/index.html","hash":"8a8595dd55530c228673fa1d133d38e1c2509881","modified":1627485174672},{"_id":"public/tags/github/index.html","hash":"ecd4811b4858972cd8857515a2219e4bc022dc5a","modified":1627485174672},{"_id":"public/tags/typora/index.html","hash":"2912cd3411edb15be92f7a268a1e9c742b69f49b","modified":1627485174672},{"_id":"public/tags/next/index.html","hash":"84b49826a59258f3dfdaadbb3ef068ee042207a3","modified":1627485174672},{"_id":"public/tags/unity/page/2/index.html","hash":"d549bed274d928330af3dcb1b50c236193be8031","modified":1627485174672},{"_id":"public/tags/c/index.html","hash":"3584ce75148df0409e6ff2d472cb8f58e7f09ba1","modified":1627485174672},{"_id":"public/tags/c/page/2/index.html","hash":"adbd0ab73f4e4479b89086cb3bf56ec1c4230d37","modified":1627485174672},{"_id":"public/tags/unityhub/index.html","hash":"cd36e245422fc0a7d4ab254b61c9dd6d0cc520bc","modified":1627485174672},{"_id":"public/tags/2d/index.html","hash":"45a1b8903c40e513b3a7365001624ab97db819ba","modified":1627485174672},{"_id":"public/tags/windows/index.html","hash":"19029c188ca167cb76253c7b83456ffe3fd08bd4","modified":1627485174672},{"_id":"public/tags/滑动窗口法/index.html","hash":"129fb47d2b32e7d45d6090783ef13dda79840319","modified":1627485174672},{"_id":"public/tags/数组/index.html","hash":"829355569eea668920e9ca5a689d71d858478be0","modified":1627485174672},{"_id":"public/tags/ps/index.html","hash":"b63bd4db8399f3e17f4d9af3d43be5cef8221c5f","modified":1627485174672},{"_id":"public/tags/像素/index.html","hash":"c2ff7f3b22672022d04eb02eb0fdc419bc885f3a","modified":1627485174672},{"_id":"public/tags/joint/index.html","hash":"f6bcd6b50cbb8d8e47324f8cab4f2f5887372d34","modified":1627485174672},{"_id":"public/tags/collider/index.html","hash":"d157d6a7de5e0491dfcc3832bceb409aa7142ffb","modified":1627485174672},{"_id":"public/tags/animator/index.html","hash":"7a99b96bed52106935da256b6f4ae52417011426","modified":1627485174672},{"_id":"public/tags/trigger/index.html","hash":"459a6bbb2cb8c4181bc8949cd7df8b3251aa6f10","modified":1627485174672},{"_id":"public/tags/prefab/index.html","hash":"ea0da68427b1a4ba914cdee2c7917256f2faf25f","modified":1627485174672},{"_id":"public/tags/collision/index.html","hash":"3d2179082dd4b721949508b2ed2b82b91eb5cef3","modified":1627485174672},{"_id":"public/tags/awake/index.html","hash":"97c1a073630448cc4672bd1dd9e6b2b430bba071","modified":1627485174672},{"_id":"public/tags/canvas/index.html","hash":"c4607129f94ae1a75402c02ee45d8b6e6d84861a","modified":1627485174672},{"_id":"public/tags/动态规划/index.html","hash":"b2f5017676b29e65d166ef1b783819c3ce255565","modified":1627485174672},{"_id":"public/tags/tile/index.html","hash":"c0eb410cf234074bc94281639a71be1413513acc","modified":1627485174672},{"_id":"public/tags/update/index.html","hash":"06dd0de2e57d35178e4ae884fe679599f5f83cbf","modified":1627485174672},{"_id":"public/tags/time/index.html","hash":"1b4f8ae91683e5de52aabf464ae12325dbd81b6f","modified":1627485174672},{"_id":"public/tags/raycast/index.html","hash":"d9e9442586083597600448699e8fa82306ba888c","modified":1627485174672},{"_id":"public/tags/原地算法/index.html","hash":"3f4a478039c7082ff09722391cadf3c288ea6e87","modified":1627485174672},{"_id":"public/tags/链表/index.html","hash":"fbb2260bb083fd97df3cd2e80e567507036b133a","modified":1627485174672},{"_id":"public/tags/camera/index.html","hash":"c727e0e76ba2e71b3175503abd23f7c6e75433d7","modified":1627485174672},{"_id":"public/tags/vector/index.html","hash":"3a5f7bb2284306fb9954a53026a30917dada5ae8","modified":1627485174672},{"_id":"public/tags/pr/index.html","hash":"8aed6cfa24647342aa76d605e2bfe639722a2fb1","modified":1627485174672},{"_id":"public/tags/map/index.html","hash":"446d06fd4a536063b4691e75b7d28e0bc20eef0e","modified":1627485174672},{"_id":"public/2021/07/26/2021-07-26-【LeetCode.1143】最长公共子序列/index.html","hash":"2eceae7b749d1800a619ccd9ab4dcce2ec67d719","modified":1627485174672},{"_id":"public/2021/07/23/2021-07-23-《Robbie Swifthand》Unity2d独立游戏学习（四）/index.html","hash":"6c517216c89e17763f182c980693aff00579a08d","modified":1627485174672},{"_id":"public/2021/07/22/2021-07-22-【LeetCode.138】 复制带随机指针的链表/index.html","hash":"3800127219e976e944600ef28318e96f593c0d52","modified":1627485174672},{"_id":"public/2021/07/20/2021-07-20-《Robbie Swifthand》Unity2d独立游戏学习（三）/index.html","hash":"5357baec830bcd2de50a7cebfd37aae5f857b975","modified":1627485174672},{"_id":"public/2021/07/19/2021-07-19-《Robbie Swifthand》Unity2d独立游戏学习（二）/index.html","hash":"efd211b2fb5f943b15c2cc4a50242e3cef7022cc","modified":1627485174672},{"_id":"public/2021/07/18/2021-07-18-《Robbie Swifthand》Unity2d独立游戏学习（一）/index.html","hash":"bde84f8a362a703cd61efc3cfce656d47b458f7b","modified":1627485174672},{"_id":"public/2021/07/17/2021-07-17-【LeetCode.剑指Offer.42】连续子数组的最大和/index.html","hash":"170e16a73ee9480d90e82e4f774866739dfb17a4","modified":1627485174672},{"_id":"public/2021/07/16/2021-07-16-《Speed Down》Unity2d游戏开发（完）/index.html","hash":"4ab72a506c6fa80883bb0bd956000c1f4ebe070c","modified":1627485174672},{"_id":"public/2021/07/15/2021-07-15-《Speed Down》Unity2d游戏开发（六）/index.html","hash":"4e243ef515c1965d5703949f932ed9149762c98b","modified":1627485174672},{"_id":"public/2021/07/15/2021-07-15-《Speed Down》Unity2d游戏开发（五）/index.html","hash":"58309979d61cf6b141df93f791690f2716bf3049","modified":1627485174672},{"_id":"public/2021/07/14/2021-07-14-《Speed Down》Unity2d游戏开发（四）/index.html","hash":"737af112644acb9d08f3c8319d6f7303c771eae9","modified":1627485174672},{"_id":"public/2021/07/14/2021-07-14-《Speed Down》Unity2d游戏开发（三）/index.html","hash":"e357ada83a94ab51c0455612060da49676cfafd9","modified":1627485174672},{"_id":"public/2021/07/13/2021-07-13-《Speed Down》Unity2d游戏开发（二）/index.html","hash":"1313d11324f6765a4a9275526e6eea927d47d5db","modified":1627485174672},{"_id":"public/2021/07/09/更2021-07-09-C++STL/index.html","hash":"b02e391ecc53c7fdd4f0ce20e27fc89ba4ffe3cc","modified":1627485174672},{"_id":"public/2021/07/08/2021-07-08-再临Unity/index.html","hash":"c11dd8315e4170d9d5d3503d49476775728061d5","modified":1627485174672},{"_id":"public/2021/07/08/2021-07-08-【LeetCode.930】和相同的二元子数组/index.html","hash":"577d21eb076af641853cf360d218001b54df6b33","modified":1627485174672},{"_id":"public/2021/07/06/2021-07-06-《Speed Down》Unity2d游戏开发（一）/index.html","hash":"d6f57da5056b378f1331e04afb4034a7090df125","modified":1627485174672},{"_id":"public/2021/07/06/2021-07-06-解决Github无法访问/index.html","hash":"9b420d6ab94f2e3133fd7c512900411c324a7bf1","modified":1627485174672},{"_id":"public/2021/07/06/更2021-07-06-剪辑视频入门总结/index.html","hash":"c3b02d772d9ff59c1720ef65116c318edd460942","modified":1627485174672},{"_id":"public/2021/07/04/2021-07-04-搭建个人博客总结/index.html","hash":"863ee826f115979f5cae58951a4fbf40203edc15","modified":1627485174672},{"_id":"public/archives/index.html","hash":"393e23b1439efa76226757f0dd088b4fbccf6067","modified":1627485174672},{"_id":"public/archives/page/2/index.html","hash":"eb338f89c5d60a279a7b1c5cdd5911642aba7b57","modified":1627485174672},{"_id":"public/archives/2021/index.html","hash":"19cb949f611a43c47862efee4c5e0c761f415266","modified":1627485174672},{"_id":"public/archives/2021/page/2/index.html","hash":"0e35af0fcd151c00fd4582dcba8a7df08cae6548","modified":1627485174672},{"_id":"public/archives/2021/07/index.html","hash":"cbcd576bf81ae353181da4ae49f0f29ab61f4f0e","modified":1627485174672},{"_id":"public/archives/2021/07/page/2/index.html","hash":"e9c9928e40d455faaebc5191a7aa930266a07144","modified":1627485174672},{"_id":"public/index.html","hash":"bdb7a838d8c19fbe4411f905969350501341233a","modified":1627485174672},{"_id":"public/page/2/index.html","hash":"da3ba423f528990a0585f472eceefae6083e9e04","modified":1627485174672},{"_id":"public/categories/unity/index.html","hash":"0eba7d768f9be49883e59fdb83d84de67f1c9aca","modified":1627485174672},{"_id":"public/tags/unity/index.html","hash":"be2ed0a0bfb54a7aa99e348fad815b4cbf90c75d","modified":1627485174672},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1627485174672},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1627485174672},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1627485174672},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1627485174672},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1627485174672},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1627485174672},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1627485174672},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1627485174672},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1627485174672},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1627485174672},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1627485174672},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1627485174672},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1627485174672},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1627485174672},{"_id":"public/images/avatar.jpg","hash":"acdc7d95a97b1c233e787bfc9d7b321c52a2cf3c","modified":1627485174672},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1627485174672},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1627485174672},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1627485174672},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1627485174672},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1627485174672},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1627485174672},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1627485174672},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1627485174672},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1627485174672},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1627485174672},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1627485174672},{"_id":"public/css/main.css","hash":"95f385619a22830b7586ae8d3594629c72803a47","modified":1627485174672},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1627485174672},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1627485174672},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1627485174672},{"_id":"public/assets/background.png","hash":"6cea513ac9097638ccc8c70bd3b0b9e1eb2a84da","modified":1627485174672}],"Category":[{"name":"琐碎","_id":"ckrnmnim60004f4u09ywq1c96"},{"name":"unity","_id":"ckrnmnim90009f4u0fgbp10dw"},{"name":"算法","_id":"ckrnmnimf000kf4u0526zhegj"},{"name":"c++","_id":"ckrnmnimt001kf4u06xg94433"}],"Data":[{"_id":"styles","data":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}],"Page":[{"title":"标签","date":"2021-07-05T13:11:11.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2021-07-05 21:11:11\ntype: \"tags\"\n---\n","updated":"2021-07-05T13:12:45.443Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckrnmnily0000f4u07ztr5fh3","content":"","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"","more":""},{"title":"分类","date":"2021-07-05T13:22:54.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2021-07-05 21:22:54\ntype: \"categories\"\n---\n","updated":"2021-07-05T15:47:35.970Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckrnmnim40002f4u026xc8cwc","content":"","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"","more":""}],"Post":[{"title":"搭建个人博客总结","date":"2021-07-03T16:00:00.000Z","_content":"\n\n\n### \t始、报错汇总\n\n\n\n### 终、报错汇总\n\n1.输入`git g -d`后报错：**fatal:  unable to access 'h...://github.com/....github.io.git/**\n\n解决方法1：重置一下git的代理：\n\n```\ngit config --global --unset git.proxy\n```\n\n解决方法2：删掉`node_modules`文件夹\n\n解决方法3：`git g` 和 `git d` 分两步输入\n\n解决方法4：挂梯子\n\n\n\n\n\n <!--more-->\n\n---\n\n\n\n### \t一、用Hexo在本地生成博客并部署（白嫖）到github\n\n后半部分个性化博客的教学先不看：\n\n[GitHub+Hexo 搭建个人网站详细教程](https://zhuanlan.zhihu.com/p/26625249)\n\n\n\n------\n\n\n\n### \t二、将博客的源代码也放到github托管\n\n文章最后面还有作者引用的原文，两篇文章结合一起看：\n\n[Hexo | 怎么去备份你的Hexo博客](https://www.jianshu.com/p/baab04284923)\n\n\n\n------\n\n\n\n### \t三、最后就是用我们的Typora来写作啦\n\n快捷键记不记无所谓，typora工具栏全都有：\n\n[Hexo博客写文章及基本操作](https://zhuanlan.zhihu.com/p/156915260)\n\n\n\n------\n\n\n\n### 四、应用next主题以及个性化\n\nnext和hexo好像还有版本适配的问题，我用旧版的next会把博客变成乱码，最终是这篇文章中的新版本适合我：\n\n[hexo的next主题个性化配置](https://zhuanlan.zhihu.com/p/60424755 )\n\n\n\n------\n\n\n\n","source":"_posts/2021-07-04-搭建个人博客总结.md","raw":"---\ntitle: 搭建个人博客总结\ndate: 2021-07-04\ncategories: 琐碎\ntags:\n  - hexo\n  - git\n  - github\n  - typora\n  - next\n\n---\n\n\n\n### \t始、报错汇总\n\n\n\n### 终、报错汇总\n\n1.输入`git g -d`后报错：**fatal:  unable to access 'h...://github.com/....github.io.git/**\n\n解决方法1：重置一下git的代理：\n\n```\ngit config --global --unset git.proxy\n```\n\n解决方法2：删掉`node_modules`文件夹\n\n解决方法3：`git g` 和 `git d` 分两步输入\n\n解决方法4：挂梯子\n\n\n\n\n\n <!--more-->\n\n---\n\n\n\n### \t一、用Hexo在本地生成博客并部署（白嫖）到github\n\n后半部分个性化博客的教学先不看：\n\n[GitHub+Hexo 搭建个人网站详细教程](https://zhuanlan.zhihu.com/p/26625249)\n\n\n\n------\n\n\n\n### \t二、将博客的源代码也放到github托管\n\n文章最后面还有作者引用的原文，两篇文章结合一起看：\n\n[Hexo | 怎么去备份你的Hexo博客](https://www.jianshu.com/p/baab04284923)\n\n\n\n------\n\n\n\n### \t三、最后就是用我们的Typora来写作啦\n\n快捷键记不记无所谓，typora工具栏全都有：\n\n[Hexo博客写文章及基本操作](https://zhuanlan.zhihu.com/p/156915260)\n\n\n\n------\n\n\n\n### 四、应用next主题以及个性化\n\nnext和hexo好像还有版本适配的问题，我用旧版的next会把博客变成乱码，最终是这篇文章中的新版本适合我：\n\n[hexo的next主题个性化配置](https://zhuanlan.zhihu.com/p/60424755 )\n\n\n\n------\n\n\n\n","slug":"2021-07-04-搭建个人博客总结","published":1,"updated":"2021-07-15T10:40:57.284Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnim10001f4u02mcnh9tp","content":"<h3 id=\"始、报错汇总\"><a href=\"#始、报错汇总\" class=\"headerlink\" title=\"始、报错汇总\"></a>始、报错汇总</h3><h3 id=\"终、报错汇总\"><a href=\"#终、报错汇总\" class=\"headerlink\" title=\"终、报错汇总\"></a>终、报错汇总</h3><p>1.输入<code>git g -d</code>后报错：<strong>fatal:  unable to access ‘h…://github.com/….github.io.git/</strong></p>\n<p>解决方法1：重置一下git的代理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global --unset git.proxy</span><br></pre></td></tr></table></figure>\n\n<p>解决方法2：删掉<code>node_modules</code>文件夹</p>\n<p>解决方法3：<code>git g</code> 和 <code>git d</code> 分两步输入</p>\n<p>解决方法4：挂梯子</p>\n <span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、用Hexo在本地生成博客并部署（白嫖）到github\"><a href=\"#一、用Hexo在本地生成博客并部署（白嫖）到github\" class=\"headerlink\" title=\"一、用Hexo在本地生成博客并部署（白嫖）到github\"></a>一、用Hexo在本地生成博客并部署（白嫖）到github</h3><p>后半部分个性化博客的教学先不看：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/26625249\">GitHub+Hexo 搭建个人网站详细教程</a></p>\n<hr>\n<h3 id=\"二、将博客的源代码也放到github托管\"><a href=\"#二、将博客的源代码也放到github托管\" class=\"headerlink\" title=\"二、将博客的源代码也放到github托管\"></a>二、将博客的源代码也放到github托管</h3><p>文章最后面还有作者引用的原文，两篇文章结合一起看：</p>\n<p><a href=\"https://www.jianshu.com/p/baab04284923\">Hexo | 怎么去备份你的Hexo博客</a></p>\n<hr>\n<h3 id=\"三、最后就是用我们的Typora来写作啦\"><a href=\"#三、最后就是用我们的Typora来写作啦\" class=\"headerlink\" title=\"三、最后就是用我们的Typora来写作啦\"></a>三、最后就是用我们的Typora来写作啦</h3><p>快捷键记不记无所谓，typora工具栏全都有：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/156915260\">Hexo博客写文章及基本操作</a></p>\n<hr>\n<h3 id=\"四、应用next主题以及个性化\"><a href=\"#四、应用next主题以及个性化\" class=\"headerlink\" title=\"四、应用next主题以及个性化\"></a>四、应用next主题以及个性化</h3><p>next和hexo好像还有版本适配的问题，我用旧版的next会把博客变成乱码，最终是这篇文章中的新版本适合我：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/60424755\">hexo的next主题个性化配置</a></p>\n<hr>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、报错汇总\"><a href=\"#始、报错汇总\" class=\"headerlink\" title=\"始、报错汇总\"></a>始、报错汇总</h3><h3 id=\"终、报错汇总\"><a href=\"#终、报错汇总\" class=\"headerlink\" title=\"终、报错汇总\"></a>终、报错汇总</h3><p>1.输入<code>git g -d</code>后报错：<strong>fatal:  unable to access ‘h…://github.com/….github.io.git/</strong></p>\n<p>解决方法1：重置一下git的代理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global --unset git.proxy</span><br></pre></td></tr></table></figure>\n\n<p>解决方法2：删掉<code>node_modules</code>文件夹</p>\n<p>解决方法3：<code>git g</code> 和 <code>git d</code> 分两步输入</p>\n<p>解决方法4：挂梯子</p>","more":"<hr>\n<h3 id=\"一、用Hexo在本地生成博客并部署（白嫖）到github\"><a href=\"#一、用Hexo在本地生成博客并部署（白嫖）到github\" class=\"headerlink\" title=\"一、用Hexo在本地生成博客并部署（白嫖）到github\"></a>一、用Hexo在本地生成博客并部署（白嫖）到github</h3><p>后半部分个性化博客的教学先不看：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/26625249\">GitHub+Hexo 搭建个人网站详细教程</a></p>\n<hr>\n<h3 id=\"二、将博客的源代码也放到github托管\"><a href=\"#二、将博客的源代码也放到github托管\" class=\"headerlink\" title=\"二、将博客的源代码也放到github托管\"></a>二、将博客的源代码也放到github托管</h3><p>文章最后面还有作者引用的原文，两篇文章结合一起看：</p>\n<p><a href=\"https://www.jianshu.com/p/baab04284923\">Hexo | 怎么去备份你的Hexo博客</a></p>\n<hr>\n<h3 id=\"三、最后就是用我们的Typora来写作啦\"><a href=\"#三、最后就是用我们的Typora来写作啦\" class=\"headerlink\" title=\"三、最后就是用我们的Typora来写作啦\"></a>三、最后就是用我们的Typora来写作啦</h3><p>快捷键记不记无所谓，typora工具栏全都有：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/156915260\">Hexo博客写文章及基本操作</a></p>\n<hr>\n<h3 id=\"四、应用next主题以及个性化\"><a href=\"#四、应用next主题以及个性化\" class=\"headerlink\" title=\"四、应用next主题以及个性化\"></a>四、应用next主题以及个性化</h3><p>next和hexo好像还有版本适配的问题，我用旧版的next会把博客变成乱码，最终是这篇文章中的新版本适合我：</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/60424755\">hexo的next主题个性化配置</a></p>\n<hr>"},{"title":"《Speed Down》Unity2d游戏开发（一）","date":"2021-07-06T09:45:05.000Z","_content":"\n\n\n### \t\t\t始、前言\n\n跟随M大学习unity2d游戏开发，先来一个简单的下100层游戏！\n\n\n\n版本：\n\nunity 2021.1.12f1c1\n\nunityhub 2.4.13\n\nvs 2019\n\n<!--more-->\n\n---\n\n\n\n### \t\t\t\t一、导入素材\n\n1.新建unity2d项目\n\n2.在assetstore中查找 Pixel Adventure 1并添加到我的资源\n\n3.在unity中打开Package Manager → My Assets → Pixel Adventure 1，下载并导入项目中\n\n资源栏就出现这个包啦！\n\n\n\n---\n\n\n\n### \t\t\t二、切换发布平台\n\n1.点击file → build setting → Android → switch platform\n\n2.发现自己unity没有这个模块，要手动在unityhub安装模块\n\n3.发现没有添加模块的按钮，要移除版本，前往官网找到改版本并选择从unityhub中下载\n\n4.添加下载Android Target Support\n\n\n\n---\n\n\n\n### \t\t\t三、背景图案设置\n\n1.新建3d object → quad，reset位置，设置scale中x为9，y为16\n\n2.调整主摄像机，包裹场景\n\n3.新建材质球background，修改shader为unlit → texture\n\n4.选择喜欢的背景图案，更改pixel per unit为64，拖到材质球中\n\n5.添加材质球到quad中\n\n6.相机中没有图片，因为相机和场景重叠了，修改相机z轴位置为-10\n\n简单的背景图片出现了，现在想要背景图案变成多个重复的图案，并且可以循环移动：\n\n7.设置图案advanced → wrap mode → repeat，表示图案是可以循环重复的（记得apply）\n\n8.更改材质球的tilling就可以看到场景图案铺垫的样子，可以看到改变offset的值就可以让场景移动\n\n\n\n---\n\n\n\n### \t\t四、脚本实现背景移动\n\n1.新建c#脚本，等unity加载完毕（右下角有转圈标识，没加载完就操作会出现奇怪的错误）\n\n2.编写脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class BackgroundMove : MonoBehaviour\n{\n    Material material;\n    Vector2 movement;\n\n    public Vector2 speed;\n    void Start()\n    {\n        material = GetComponent<Renderer>().material;\n    }\n\n    void Update()\n    {\n        movement += speed * Time.deltaTime;\n        material.mainTextureOffset = movement;\n    }\n}\n```\n\n注意：获取material时是获取组件Renderer中的material，即“material是Renderer的material”\n\n这样就可以通过改变背景脚本一栏中的speed来改变背景移动速度\n\n\n\n---\n\n\n\n### \t五、添加顶部尖刺\n\n1.找到素材中的spikes，修改pixel per unit 为16\n\n2.新建空物体TopSpikes用来存储所有的顶部尖刺\n\n3.将尖刺图案拖拽到TopSpikes下方成为子物体\n\n4.修改尖刺的rotation → z 为18翻转尖刺，修改scale → y为2延长图案\n\n5.按住`V`可以选择锚点对齐放置，`ctrl + d`复制物体，重复步骤直到填满顶部\n\n6.全选尖刺，添加组件polygon collider 2d 多边形碰撞体，打勾used by composite，即把这些尖刺的碰撞体合并起来\n\n7.添加组件composite collider 2d ，此时会自动添加rigibody 2d\n\n8.将rigibody 2d → body type改为static，这样尖刺就保持在原地不会掉下去\n\n9.调整composite collider 2d → offset 可以改变碰撞体的位置\n\n\n\n---\n\n\n\n### \t终、未完待续\n\n基本的场景搭建已经完成！\n","source":"_posts/2021-07-06-《Speed Down》Unity2d游戏开发（一）.md","raw":"---\ntitle: 《Speed Down》Unity2d游戏开发（一）\ndate: 2021-07-06 17:45:05\ncategories: unity\ntags:\n  - unity\n  - c#\n  - unityhub\n  - 2d\n---\n\n\n\n### \t\t\t始、前言\n\n跟随M大学习unity2d游戏开发，先来一个简单的下100层游戏！\n\n\n\n版本：\n\nunity 2021.1.12f1c1\n\nunityhub 2.4.13\n\nvs 2019\n\n<!--more-->\n\n---\n\n\n\n### \t\t\t\t一、导入素材\n\n1.新建unity2d项目\n\n2.在assetstore中查找 Pixel Adventure 1并添加到我的资源\n\n3.在unity中打开Package Manager → My Assets → Pixel Adventure 1，下载并导入项目中\n\n资源栏就出现这个包啦！\n\n\n\n---\n\n\n\n### \t\t\t二、切换发布平台\n\n1.点击file → build setting → Android → switch platform\n\n2.发现自己unity没有这个模块，要手动在unityhub安装模块\n\n3.发现没有添加模块的按钮，要移除版本，前往官网找到改版本并选择从unityhub中下载\n\n4.添加下载Android Target Support\n\n\n\n---\n\n\n\n### \t\t\t三、背景图案设置\n\n1.新建3d object → quad，reset位置，设置scale中x为9，y为16\n\n2.调整主摄像机，包裹场景\n\n3.新建材质球background，修改shader为unlit → texture\n\n4.选择喜欢的背景图案，更改pixel per unit为64，拖到材质球中\n\n5.添加材质球到quad中\n\n6.相机中没有图片，因为相机和场景重叠了，修改相机z轴位置为-10\n\n简单的背景图片出现了，现在想要背景图案变成多个重复的图案，并且可以循环移动：\n\n7.设置图案advanced → wrap mode → repeat，表示图案是可以循环重复的（记得apply）\n\n8.更改材质球的tilling就可以看到场景图案铺垫的样子，可以看到改变offset的值就可以让场景移动\n\n\n\n---\n\n\n\n### \t\t四、脚本实现背景移动\n\n1.新建c#脚本，等unity加载完毕（右下角有转圈标识，没加载完就操作会出现奇怪的错误）\n\n2.编写脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class BackgroundMove : MonoBehaviour\n{\n    Material material;\n    Vector2 movement;\n\n    public Vector2 speed;\n    void Start()\n    {\n        material = GetComponent<Renderer>().material;\n    }\n\n    void Update()\n    {\n        movement += speed * Time.deltaTime;\n        material.mainTextureOffset = movement;\n    }\n}\n```\n\n注意：获取material时是获取组件Renderer中的material，即“material是Renderer的material”\n\n这样就可以通过改变背景脚本一栏中的speed来改变背景移动速度\n\n\n\n---\n\n\n\n### \t五、添加顶部尖刺\n\n1.找到素材中的spikes，修改pixel per unit 为16\n\n2.新建空物体TopSpikes用来存储所有的顶部尖刺\n\n3.将尖刺图案拖拽到TopSpikes下方成为子物体\n\n4.修改尖刺的rotation → z 为18翻转尖刺，修改scale → y为2延长图案\n\n5.按住`V`可以选择锚点对齐放置，`ctrl + d`复制物体，重复步骤直到填满顶部\n\n6.全选尖刺，添加组件polygon collider 2d 多边形碰撞体，打勾used by composite，即把这些尖刺的碰撞体合并起来\n\n7.添加组件composite collider 2d ，此时会自动添加rigibody 2d\n\n8.将rigibody 2d → body type改为static，这样尖刺就保持在原地不会掉下去\n\n9.调整composite collider 2d → offset 可以改变碰撞体的位置\n\n\n\n---\n\n\n\n### \t终、未完待续\n\n基本的场景搭建已经完成！\n","slug":"2021-07-06-《Speed Down》Unity2d游戏开发（一）","published":1,"updated":"2021-07-18T08:24:57.256Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnim40003f4u0hrz1h0a2","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>跟随M大学习unity2d游戏开发，先来一个简单的下100层游戏！</p>\n<p>版本：</p>\n<p>unity 2021.1.12f1c1</p>\n<p>unityhub 2.4.13</p>\n<p>vs 2019</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、导入素材\"><a href=\"#一、导入素材\" class=\"headerlink\" title=\"一、导入素材\"></a>一、导入素材</h3><p>1.新建unity2d项目</p>\n<p>2.在assetstore中查找 Pixel Adventure 1并添加到我的资源</p>\n<p>3.在unity中打开Package Manager → My Assets → Pixel Adventure 1，下载并导入项目中</p>\n<p>资源栏就出现这个包啦！</p>\n<hr>\n<h3 id=\"二、切换发布平台\"><a href=\"#二、切换发布平台\" class=\"headerlink\" title=\"二、切换发布平台\"></a>二、切换发布平台</h3><p>1.点击file → build setting → Android → switch platform</p>\n<p>2.发现自己unity没有这个模块，要手动在unityhub安装模块</p>\n<p>3.发现没有添加模块的按钮，要移除版本，前往官网找到改版本并选择从unityhub中下载</p>\n<p>4.添加下载Android Target Support</p>\n<hr>\n<h3 id=\"三、背景图案设置\"><a href=\"#三、背景图案设置\" class=\"headerlink\" title=\"三、背景图案设置\"></a>三、背景图案设置</h3><p>1.新建3d object → quad，reset位置，设置scale中x为9，y为16</p>\n<p>2.调整主摄像机，包裹场景</p>\n<p>3.新建材质球background，修改shader为unlit → texture</p>\n<p>4.选择喜欢的背景图案，更改pixel per unit为64，拖到材质球中</p>\n<p>5.添加材质球到quad中</p>\n<p>6.相机中没有图片，因为相机和场景重叠了，修改相机z轴位置为-10</p>\n<p>简单的背景图片出现了，现在想要背景图案变成多个重复的图案，并且可以循环移动：</p>\n<p>7.设置图案advanced → wrap mode → repeat，表示图案是可以循环重复的（记得apply）</p>\n<p>8.更改材质球的tilling就可以看到场景图案铺垫的样子，可以看到改变offset的值就可以让场景移动</p>\n<hr>\n<h3 id=\"四、脚本实现背景移动\"><a href=\"#四、脚本实现背景移动\" class=\"headerlink\" title=\"四、脚本实现背景移动\"></a>四、脚本实现背景移动</h3><p>1.新建c#脚本，等unity加载完毕（右下角有转圈标识，没加载完就操作会出现奇怪的错误）</p>\n<p>2.编写脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class BackgroundMove : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Material material;</span><br><span class=\"line\">    Vector2 movement;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Vector2 speed;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        material = GetComponent&lt;Renderer&gt;().material;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        movement += speed * Time.deltaTime;</span><br><span class=\"line\">        material.mainTextureOffset = movement;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：获取material时是获取组件Renderer中的material，即“material是Renderer的material”</p>\n<p>这样就可以通过改变背景脚本一栏中的speed来改变背景移动速度</p>\n<hr>\n<h3 id=\"五、添加顶部尖刺\"><a href=\"#五、添加顶部尖刺\" class=\"headerlink\" title=\"五、添加顶部尖刺\"></a>五、添加顶部尖刺</h3><p>1.找到素材中的spikes，修改pixel per unit 为16</p>\n<p>2.新建空物体TopSpikes用来存储所有的顶部尖刺</p>\n<p>3.将尖刺图案拖拽到TopSpikes下方成为子物体</p>\n<p>4.修改尖刺的rotation → z 为18翻转尖刺，修改scale → y为2延长图案</p>\n<p>5.按住<code>V</code>可以选择锚点对齐放置，<code>ctrl + d</code>复制物体，重复步骤直到填满顶部</p>\n<p>6.全选尖刺，添加组件polygon collider 2d 多边形碰撞体，打勾used by composite，即把这些尖刺的碰撞体合并起来</p>\n<p>7.添加组件composite collider 2d ，此时会自动添加rigibody 2d</p>\n<p>8.将rigibody 2d → body type改为static，这样尖刺就保持在原地不会掉下去</p>\n<p>9.调整composite collider 2d → offset 可以改变碰撞体的位置</p>\n<hr>\n<h3 id=\"终、未完待续\"><a href=\"#终、未完待续\" class=\"headerlink\" title=\"终、未完待续\"></a>终、未完待续</h3><p>基本的场景搭建已经完成！</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>跟随M大学习unity2d游戏开发，先来一个简单的下100层游戏！</p>\n<p>版本：</p>\n<p>unity 2021.1.12f1c1</p>\n<p>unityhub 2.4.13</p>\n<p>vs 2019</p>","more":"<hr>\n<h3 id=\"一、导入素材\"><a href=\"#一、导入素材\" class=\"headerlink\" title=\"一、导入素材\"></a>一、导入素材</h3><p>1.新建unity2d项目</p>\n<p>2.在assetstore中查找 Pixel Adventure 1并添加到我的资源</p>\n<p>3.在unity中打开Package Manager → My Assets → Pixel Adventure 1，下载并导入项目中</p>\n<p>资源栏就出现这个包啦！</p>\n<hr>\n<h3 id=\"二、切换发布平台\"><a href=\"#二、切换发布平台\" class=\"headerlink\" title=\"二、切换发布平台\"></a>二、切换发布平台</h3><p>1.点击file → build setting → Android → switch platform</p>\n<p>2.发现自己unity没有这个模块，要手动在unityhub安装模块</p>\n<p>3.发现没有添加模块的按钮，要移除版本，前往官网找到改版本并选择从unityhub中下载</p>\n<p>4.添加下载Android Target Support</p>\n<hr>\n<h3 id=\"三、背景图案设置\"><a href=\"#三、背景图案设置\" class=\"headerlink\" title=\"三、背景图案设置\"></a>三、背景图案设置</h3><p>1.新建3d object → quad，reset位置，设置scale中x为9，y为16</p>\n<p>2.调整主摄像机，包裹场景</p>\n<p>3.新建材质球background，修改shader为unlit → texture</p>\n<p>4.选择喜欢的背景图案，更改pixel per unit为64，拖到材质球中</p>\n<p>5.添加材质球到quad中</p>\n<p>6.相机中没有图片，因为相机和场景重叠了，修改相机z轴位置为-10</p>\n<p>简单的背景图片出现了，现在想要背景图案变成多个重复的图案，并且可以循环移动：</p>\n<p>7.设置图案advanced → wrap mode → repeat，表示图案是可以循环重复的（记得apply）</p>\n<p>8.更改材质球的tilling就可以看到场景图案铺垫的样子，可以看到改变offset的值就可以让场景移动</p>\n<hr>\n<h3 id=\"四、脚本实现背景移动\"><a href=\"#四、脚本实现背景移动\" class=\"headerlink\" title=\"四、脚本实现背景移动\"></a>四、脚本实现背景移动</h3><p>1.新建c#脚本，等unity加载完毕（右下角有转圈标识，没加载完就操作会出现奇怪的错误）</p>\n<p>2.编写脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class BackgroundMove : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Material material;</span><br><span class=\"line\">    Vector2 movement;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Vector2 speed;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        material = GetComponent&lt;Renderer&gt;().material;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        movement += speed * Time.deltaTime;</span><br><span class=\"line\">        material.mainTextureOffset = movement;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：获取material时是获取组件Renderer中的material，即“material是Renderer的material”</p>\n<p>这样就可以通过改变背景脚本一栏中的speed来改变背景移动速度</p>\n<hr>\n<h3 id=\"五、添加顶部尖刺\"><a href=\"#五、添加顶部尖刺\" class=\"headerlink\" title=\"五、添加顶部尖刺\"></a>五、添加顶部尖刺</h3><p>1.找到素材中的spikes，修改pixel per unit 为16</p>\n<p>2.新建空物体TopSpikes用来存储所有的顶部尖刺</p>\n<p>3.将尖刺图案拖拽到TopSpikes下方成为子物体</p>\n<p>4.修改尖刺的rotation → z 为18翻转尖刺，修改scale → y为2延长图案</p>\n<p>5.按住<code>V</code>可以选择锚点对齐放置，<code>ctrl + d</code>复制物体，重复步骤直到填满顶部</p>\n<p>6.全选尖刺，添加组件polygon collider 2d 多边形碰撞体，打勾used by composite，即把这些尖刺的碰撞体合并起来</p>\n<p>7.添加组件composite collider 2d ，此时会自动添加rigibody 2d</p>\n<p>8.将rigibody 2d → body type改为static，这样尖刺就保持在原地不会掉下去</p>\n<p>9.调整composite collider 2d → offset 可以改变碰撞体的位置</p>\n<hr>\n<h3 id=\"终、未完待续\"><a href=\"#终、未完待续\" class=\"headerlink\" title=\"终、未完待续\"></a>终、未完待续</h3><p>基本的场景搭建已经完成！</p>"},{"title":"解决Github无法访问","date":"2021-07-05T16:00:00.000Z","_content":"\n\n\n### \t一、修改host文件\n\n​\t在**C:\\Windows\\System32\\drivers\\etc**中打开**host**文件（可以用记事本打开），在该文件中添加如下内容：\n\n```\n# GitHub Start \n140.82.114.4 github.com\n140.82.114.4 gist.github.com\n185.199.108.153 assets-cdn.github.com\n151.101.64.133 raw.githubusercontent.com\n151.101.108.133 gist.githubusercontent.com\n151.101.108.133 cloud.githubusercontent.com\n151.101.108.133 camo.githubusercontent.com\n151.101.108.133 avatars0.githubusercontent.com\n151.101.108.133 avatars1.githubusercontent.com\n151.101.108.133 avatars2.githubusercontent.com\n151.101.108.133 avatars3.githubusercontent.com\n151.101.108.133 avatars4.githubusercontent.com\n151.101.108.133 avatars5.githubusercontent.com\n151.101.108.133 avatars6.githubusercontent.com\n151.101.108.133 avatars7.githubusercontent.com\n151.101.108.133 avatars8.githubusercontent.com \n# GitHub End\n```\n\n保存文件，再次打开github速度飞快\n\n<!--more-->\n\n------\n\n\n\n### \t二、win10修改文件读写的权限\n\n​\twindows系统可能遇到无法修改系统文件的问题\n\n​\t1.找到要修改的文件\n\n​\t2.右键→属性→安全→编辑→user\n\n​\t3.在允许编辑那一栏打勾\n","source":"_posts/2021-07-06-解决Github无法访问.md","raw":"---\ntitle: 解决Github无法访问\ndate: 2021-07-06\ncategories: 琐碎\ntags:\n  - github\t\n  - windows\n---\n\n\n\n### \t一、修改host文件\n\n​\t在**C:\\Windows\\System32\\drivers\\etc**中打开**host**文件（可以用记事本打开），在该文件中添加如下内容：\n\n```\n# GitHub Start \n140.82.114.4 github.com\n140.82.114.4 gist.github.com\n185.199.108.153 assets-cdn.github.com\n151.101.64.133 raw.githubusercontent.com\n151.101.108.133 gist.githubusercontent.com\n151.101.108.133 cloud.githubusercontent.com\n151.101.108.133 camo.githubusercontent.com\n151.101.108.133 avatars0.githubusercontent.com\n151.101.108.133 avatars1.githubusercontent.com\n151.101.108.133 avatars2.githubusercontent.com\n151.101.108.133 avatars3.githubusercontent.com\n151.101.108.133 avatars4.githubusercontent.com\n151.101.108.133 avatars5.githubusercontent.com\n151.101.108.133 avatars6.githubusercontent.com\n151.101.108.133 avatars7.githubusercontent.com\n151.101.108.133 avatars8.githubusercontent.com \n# GitHub End\n```\n\n保存文件，再次打开github速度飞快\n\n<!--more-->\n\n------\n\n\n\n### \t二、win10修改文件读写的权限\n\n​\twindows系统可能遇到无法修改系统文件的问题\n\n​\t1.找到要修改的文件\n\n​\t2.右键→属性→安全→编辑→user\n\n​\t3.在允许编辑那一栏打勾\n","slug":"2021-07-06-解决Github无法访问","published":1,"updated":"2021-07-15T10:44:20.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnim70006f4u0hi1c32r3","content":"<h3 id=\"一、修改host文件\"><a href=\"#一、修改host文件\" class=\"headerlink\" title=\"一、修改host文件\"></a>一、修改host文件</h3><p>​    在<strong>C:\\Windows\\System32\\drivers\\etc</strong>中打开<strong>host</strong>文件（可以用记事本打开），在该文件中添加如下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># GitHub Start </span><br><span class=\"line\">140.82.114.4 github.com</span><br><span class=\"line\">140.82.114.4 gist.github.com</span><br><span class=\"line\">185.199.108.153 assets-cdn.github.com</span><br><span class=\"line\">151.101.64.133 raw.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 gist.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 cloud.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 camo.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars0.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars1.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars2.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars3.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars4.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars5.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars6.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars7.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars8.githubusercontent.com </span><br><span class=\"line\"># GitHub End</span><br></pre></td></tr></table></figure>\n\n<p>保存文件，再次打开github速度飞快</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"二、win10修改文件读写的权限\"><a href=\"#二、win10修改文件读写的权限\" class=\"headerlink\" title=\"二、win10修改文件读写的权限\"></a>二、win10修改文件读写的权限</h3><p>​    windows系统可能遇到无法修改系统文件的问题</p>\n<p>​    1.找到要修改的文件</p>\n<p>​    2.右键→属性→安全→编辑→user</p>\n<p>​    3.在允许编辑那一栏打勾</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"一、修改host文件\"><a href=\"#一、修改host文件\" class=\"headerlink\" title=\"一、修改host文件\"></a>一、修改host文件</h3><p>​    在<strong>C:\\Windows\\System32\\drivers\\etc</strong>中打开<strong>host</strong>文件（可以用记事本打开），在该文件中添加如下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># GitHub Start </span><br><span class=\"line\">140.82.114.4 github.com</span><br><span class=\"line\">140.82.114.4 gist.github.com</span><br><span class=\"line\">185.199.108.153 assets-cdn.github.com</span><br><span class=\"line\">151.101.64.133 raw.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 gist.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 cloud.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 camo.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars0.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars1.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars2.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars3.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars4.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars5.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars6.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars7.githubusercontent.com</span><br><span class=\"line\">151.101.108.133 avatars8.githubusercontent.com </span><br><span class=\"line\"># GitHub End</span><br></pre></td></tr></table></figure>\n\n<p>保存文件，再次打开github速度飞快</p>","more":"<hr>\n<h3 id=\"二、win10修改文件读写的权限\"><a href=\"#二、win10修改文件读写的权限\" class=\"headerlink\" title=\"二、win10修改文件读写的权限\"></a>二、win10修改文件读写的权限</h3><p>​    windows系统可能遇到无法修改系统文件的问题</p>\n<p>​    1.找到要修改的文件</p>\n<p>​    2.右键→属性→安全→编辑→user</p>\n<p>​    3.在允许编辑那一栏打勾</p>"},{"title":"【LeetCode.930】和相同的二元子数组","date":"2021-07-08T09:14:17.000Z","_content":"\n\n\n\n\n### \t题目：和相同的二元子数组\n\n​\t给你一个二元数组 `nums` ，和一个整数 `goal` ，请你统计并返回有多少个和为 `goal` 的 **非空** 子数组。\n\n​\t**子数组** 是数组的一段连续部分。\n\n \n\n示例 1：\n\n```\n输入：nums = [1,0,1,0,1], goal = 2\n输出：4\n解释：\n有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]\n```\n\n<!--more-->\n\n示例 2：\n\n```\n输入：nums = [0,0,0,0,0], goal = 0\n输出：15\n```\n\n\n提示：\n\n`1 <= nums.length <= 3 * 104`\n\n`nums[i]` 不是 `0` 就是 `1`\n\n`0 <= goal <= nums.length`\n\n\n\n------\n\n\n\n### \t题解：\n\n```\nclass Solution {\npublic:\n    //滑动窗口法\n    //右指针逐渐向右，左一指针找到第一个符合的位置，左二指针找到最后一个符合的位置\n    int numSubarraysWithSum(vector<int>& nums, int goal) {\n        int left1 = 0, left2 = 0;\n        int n = nums.size();\n        int sum1 = 0, sum2 = 0;\n        int ret = 0;\n\n        for(int right = 0; right < n; right++){\n            sum2 += nums[right];\n            sum1 += nums[right];\n            while(left2 <= right && sum2 >= goal){\n                sum2 -= nums[left2];\n                left2++;\n            }\n\n            while(left1 < left2 && sum1 > goal){\n                sum1 -= nums[left1];\n                left1++;\n            }\n\n            ret += left2 - left1;\n        }\n\n        return ret;\n    }\n};\n```\n\n\n\n------\n\n\n\n### \t易错点：\n\n1.提示2`nums[i]` 不是 `0` 就是 `1`，所以不用判断相等的情况`if(sum == goal)`\n\n2.三个只指针对应的大小关系，其中`left1 <= left2 <= right <= nums.size()`\n\n","source":"_posts/2021-07-08-【LeetCode.930】和相同的二元子数组.md","raw":"---\ntitle: 【LeetCode.930】和相同的二元子数组\ndate: 2021-07-08 17:14:17\ncategories: 算法\ntags:\n  - c++\n  - 滑动窗口法\n  - 数组\n---\n\n\n\n\n\n### \t题目：和相同的二元子数组\n\n​\t给你一个二元数组 `nums` ，和一个整数 `goal` ，请你统计并返回有多少个和为 `goal` 的 **非空** 子数组。\n\n​\t**子数组** 是数组的一段连续部分。\n\n \n\n示例 1：\n\n```\n输入：nums = [1,0,1,0,1], goal = 2\n输出：4\n解释：\n有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]\n```\n\n<!--more-->\n\n示例 2：\n\n```\n输入：nums = [0,0,0,0,0], goal = 0\n输出：15\n```\n\n\n提示：\n\n`1 <= nums.length <= 3 * 104`\n\n`nums[i]` 不是 `0` 就是 `1`\n\n`0 <= goal <= nums.length`\n\n\n\n------\n\n\n\n### \t题解：\n\n```\nclass Solution {\npublic:\n    //滑动窗口法\n    //右指针逐渐向右，左一指针找到第一个符合的位置，左二指针找到最后一个符合的位置\n    int numSubarraysWithSum(vector<int>& nums, int goal) {\n        int left1 = 0, left2 = 0;\n        int n = nums.size();\n        int sum1 = 0, sum2 = 0;\n        int ret = 0;\n\n        for(int right = 0; right < n; right++){\n            sum2 += nums[right];\n            sum1 += nums[right];\n            while(left2 <= right && sum2 >= goal){\n                sum2 -= nums[left2];\n                left2++;\n            }\n\n            while(left1 < left2 && sum1 > goal){\n                sum1 -= nums[left1];\n                left1++;\n            }\n\n            ret += left2 - left1;\n        }\n\n        return ret;\n    }\n};\n```\n\n\n\n------\n\n\n\n### \t易错点：\n\n1.提示2`nums[i]` 不是 `0` 就是 `1`，所以不用判断相等的情况`if(sum == goal)`\n\n2.三个只指针对应的大小关系，其中`left1 <= left2 <= right <= nums.size()`\n\n","slug":"2021-07-08-【LeetCode.930】和相同的二元子数组","published":1,"updated":"2021-07-23T07:08:15.137Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnim80007f4u022nbdwiu","content":"<h3 id=\"题目：和相同的二元子数组\"><a href=\"#题目：和相同的二元子数组\" class=\"headerlink\" title=\"题目：和相同的二元子数组\"></a>题目：和相同的二元子数组</h3><p>​    给你一个二元数组 <code>nums</code> ，和一个整数 <code>goal</code> ，请你统计并返回有多少个和为 <code>goal</code> 的 <strong>非空</strong> 子数组。</p>\n<p>​    <strong>子数组</strong> 是数组的一段连续部分。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,0,1,0,1], goal = 2</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：</span><br><span class=\"line\">有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,0,0,0,0], goal = 0</span><br><span class=\"line\">输出：15</span><br></pre></td></tr></table></figure>\n\n\n<p>提示：</p>\n<p><code>1 &lt;= nums.length &lt;= 3 * 104</code></p>\n<p><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></p>\n<p><code>0 &lt;= goal &lt;= nums.length</code></p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    //滑动窗口法</span><br><span class=\"line\">    //右指针逐渐向右，左一指针找到第一个符合的位置，左二指针找到最后一个符合的位置</span><br><span class=\"line\">    int numSubarraysWithSum(vector&lt;int&gt;&amp; nums, int goal) &#123;</span><br><span class=\"line\">        int left1 = 0, left2 = 0;</span><br><span class=\"line\">        int n = nums.size();</span><br><span class=\"line\">        int sum1 = 0, sum2 = 0;</span><br><span class=\"line\">        int ret = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">        for(int right = 0; right &lt; n; right++)&#123;</span><br><span class=\"line\">            sum2 += nums[right];</span><br><span class=\"line\">            sum1 += nums[right];</span><br><span class=\"line\">            while(left2 &lt;= right &amp;&amp; sum2 &gt;= goal)&#123;</span><br><span class=\"line\">                sum2 -= nums[left2];</span><br><span class=\"line\">                left2++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            while(left1 &lt; left2 &amp;&amp; sum1 &gt; goal)&#123;</span><br><span class=\"line\">                sum1 -= nums[left1];</span><br><span class=\"line\">                left1++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ret += left2 - left1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"易错点：\"><a href=\"#易错点：\" class=\"headerlink\" title=\"易错点：\"></a>易错点：</h3><p>1.提示2<code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code>，所以不用判断相等的情况<code>if(sum == goal)</code></p>\n<p>2.三个只指针对应的大小关系，其中<code>left1 &lt;= left2 &lt;= right &lt;= nums.size()</code></p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"题目：和相同的二元子数组\"><a href=\"#题目：和相同的二元子数组\" class=\"headerlink\" title=\"题目：和相同的二元子数组\"></a>题目：和相同的二元子数组</h3><p>​    给你一个二元数组 <code>nums</code> ，和一个整数 <code>goal</code> ，请你统计并返回有多少个和为 <code>goal</code> 的 <strong>非空</strong> 子数组。</p>\n<p>​    <strong>子数组</strong> 是数组的一段连续部分。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,0,1,0,1], goal = 2</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：</span><br><span class=\"line\">有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]</span><br></pre></td></tr></table></figure>","more":"<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,0,0,0,0], goal = 0</span><br><span class=\"line\">输出：15</span><br></pre></td></tr></table></figure>\n\n\n<p>提示：</p>\n<p><code>1 &lt;= nums.length &lt;= 3 * 104</code></p>\n<p><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></p>\n<p><code>0 &lt;= goal &lt;= nums.length</code></p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    //滑动窗口法</span><br><span class=\"line\">    //右指针逐渐向右，左一指针找到第一个符合的位置，左二指针找到最后一个符合的位置</span><br><span class=\"line\">    int numSubarraysWithSum(vector&lt;int&gt;&amp; nums, int goal) &#123;</span><br><span class=\"line\">        int left1 = 0, left2 = 0;</span><br><span class=\"line\">        int n = nums.size();</span><br><span class=\"line\">        int sum1 = 0, sum2 = 0;</span><br><span class=\"line\">        int ret = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">        for(int right = 0; right &lt; n; right++)&#123;</span><br><span class=\"line\">            sum2 += nums[right];</span><br><span class=\"line\">            sum1 += nums[right];</span><br><span class=\"line\">            while(left2 &lt;= right &amp;&amp; sum2 &gt;= goal)&#123;</span><br><span class=\"line\">                sum2 -= nums[left2];</span><br><span class=\"line\">                left2++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            while(left1 &lt; left2 &amp;&amp; sum1 &gt; goal)&#123;</span><br><span class=\"line\">                sum1 -= nums[left1];</span><br><span class=\"line\">                left1++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ret += left2 - left1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"易错点：\"><a href=\"#易错点：\" class=\"headerlink\" title=\"易错点：\"></a>易错点：</h3><p>1.提示2<code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code>，所以不用判断相等的情况<code>if(sum == goal)</code></p>\n<p>2.三个只指针对应的大小关系，其中<code>left1 &lt;= left2 &lt;= right &lt;= nums.size()</code></p>"},{"title":"再临Unity","date":"2021-07-08T10:29:49.000Z","_content":"\n\n\n\n\n# \t淦！\n\n\n\n### \t\t始、整理\n\n​\t闲来无事，想捣鼓一下unity，打开界面一脸懵逼。明明大学玩过一段时间的，这知识咋就不进脑子呢，又得重新学习\n\n<!--more-->\n\n------\n\n\n\n### \t\t一、Unity快速入门\n\n​\tunity的布局和一些用过的工具多少有些联系，搞懂界面还是不难的，先从常用操作入手吧！正好找到一个最近的精简unity入门视频：\n\n[游戏开发-Unity 光速入门](ttps://www.bilibili.com/video/BV1Yh411h7zk?p=2)\n\n\n\n------\n\n\n\n### \t\t二、C#\n\n​\tunity脚本编写用到c#，这语言光说入门还是比较轻松的：\n\n[快速学完C#编程](https://www.bilibili.com/video/BV1sy4y1u7cw)\n\n\n\n------\n\n\n\n### \t\t三、像素画资源\n\n​\t做点2D像素风练练手，资源就用PS自己画吧：\n\n[使用Photoshop绘制像素画](https://www.bilibili.com/video/BV1o4411V7dv)\n\n\n\n------\n\n\n\n### \t四、教程视频\n\nM大的教学对新手玩家真的友好，不愧是unity官方认证\n\n[M_Studio的个人空间](https://space.bilibili.com/370283072?spm_id_from=333.788.b_636f6d6d656e74.1)\n\n","source":"_posts/2021-07-08-再临Unity.md","raw":"---\ntitle: 再临Unity\ndate: 2021-07-08 18:29:49\ncategories: 琐碎\ntags:\n  - unity\n  - c#\n  - ps\n  - 像素\n---\n\n\n\n\n\n# \t淦！\n\n\n\n### \t\t始、整理\n\n​\t闲来无事，想捣鼓一下unity，打开界面一脸懵逼。明明大学玩过一段时间的，这知识咋就不进脑子呢，又得重新学习\n\n<!--more-->\n\n------\n\n\n\n### \t\t一、Unity快速入门\n\n​\tunity的布局和一些用过的工具多少有些联系，搞懂界面还是不难的，先从常用操作入手吧！正好找到一个最近的精简unity入门视频：\n\n[游戏开发-Unity 光速入门](ttps://www.bilibili.com/video/BV1Yh411h7zk?p=2)\n\n\n\n------\n\n\n\n### \t\t二、C#\n\n​\tunity脚本编写用到c#，这语言光说入门还是比较轻松的：\n\n[快速学完C#编程](https://www.bilibili.com/video/BV1sy4y1u7cw)\n\n\n\n------\n\n\n\n### \t\t三、像素画资源\n\n​\t做点2D像素风练练手，资源就用PS自己画吧：\n\n[使用Photoshop绘制像素画](https://www.bilibili.com/video/BV1o4411V7dv)\n\n\n\n------\n\n\n\n### \t四、教程视频\n\nM大的教学对新手玩家真的友好，不愧是unity官方认证\n\n[M_Studio的个人空间](https://space.bilibili.com/370283072?spm_id_from=333.788.b_636f6d6d656e74.1)\n\n","slug":"2021-07-08-再临Unity","published":1,"updated":"2021-07-15T10:26:26.644Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnim90008f4u04k0sggjj","content":"<h1 id=\"淦！\"><a href=\"#淦！\" class=\"headerlink\" title=\"淦！\"></a>淦！</h1><h3 id=\"始、整理\"><a href=\"#始、整理\" class=\"headerlink\" title=\"始、整理\"></a>始、整理</h3><p>​    闲来无事，想捣鼓一下unity，打开界面一脸懵逼。明明大学玩过一段时间的，这知识咋就不进脑子呢，又得重新学习</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、Unity快速入门\"><a href=\"#一、Unity快速入门\" class=\"headerlink\" title=\"一、Unity快速入门\"></a>一、Unity快速入门</h3><p>​    unity的布局和一些用过的工具多少有些联系，搞懂界面还是不难的，先从常用操作入手吧！正好找到一个最近的精简unity入门视频：</p>\n<p><a href=\"ttps://www.bilibili.com/video/BV1Yh411h7zk?p=2\">游戏开发-Unity 光速入门</a></p>\n<hr>\n<h3 id=\"二、C\"><a href=\"#二、C\" class=\"headerlink\" title=\"二、C#\"></a>二、C#</h3><p>​    unity脚本编写用到c#，这语言光说入门还是比较轻松的：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1sy4y1u7cw\">快速学完C#编程</a></p>\n<hr>\n<h3 id=\"三、像素画资源\"><a href=\"#三、像素画资源\" class=\"headerlink\" title=\"三、像素画资源\"></a>三、像素画资源</h3><p>​    做点2D像素风练练手，资源就用PS自己画吧：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1o4411V7dv\">使用Photoshop绘制像素画</a></p>\n<hr>\n<h3 id=\"四、教程视频\"><a href=\"#四、教程视频\" class=\"headerlink\" title=\"四、教程视频\"></a>四、教程视频</h3><p>M大的教学对新手玩家真的友好，不愧是unity官方认证</p>\n<p><a href=\"https://space.bilibili.com/370283072?spm_id_from=333.788.b_636f6d6d656e74.1\">M_Studio的个人空间</a></p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h1 id=\"淦！\"><a href=\"#淦！\" class=\"headerlink\" title=\"淦！\"></a>淦！</h1><h3 id=\"始、整理\"><a href=\"#始、整理\" class=\"headerlink\" title=\"始、整理\"></a>始、整理</h3><p>​    闲来无事，想捣鼓一下unity，打开界面一脸懵逼。明明大学玩过一段时间的，这知识咋就不进脑子呢，又得重新学习</p>","more":"<hr>\n<h3 id=\"一、Unity快速入门\"><a href=\"#一、Unity快速入门\" class=\"headerlink\" title=\"一、Unity快速入门\"></a>一、Unity快速入门</h3><p>​    unity的布局和一些用过的工具多少有些联系，搞懂界面还是不难的，先从常用操作入手吧！正好找到一个最近的精简unity入门视频：</p>\n<p><a href=\"ttps://www.bilibili.com/video/BV1Yh411h7zk?p=2\">游戏开发-Unity 光速入门</a></p>\n<hr>\n<h3 id=\"二、C\"><a href=\"#二、C\" class=\"headerlink\" title=\"二、C#\"></a>二、C#</h3><p>​    unity脚本编写用到c#，这语言光说入门还是比较轻松的：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1sy4y1u7cw\">快速学完C#编程</a></p>\n<hr>\n<h3 id=\"三、像素画资源\"><a href=\"#三、像素画资源\" class=\"headerlink\" title=\"三、像素画资源\"></a>三、像素画资源</h3><p>​    做点2D像素风练练手，资源就用PS自己画吧：</p>\n<p><a href=\"https://www.bilibili.com/video/BV1o4411V7dv\">使用Photoshop绘制像素画</a></p>\n<hr>\n<h3 id=\"四、教程视频\"><a href=\"#四、教程视频\" class=\"headerlink\" title=\"四、教程视频\"></a>四、教程视频</h3><p>M大的教学对新手玩家真的友好，不愧是unity官方认证</p>\n<p><a href=\"https://space.bilibili.com/370283072?spm_id_from=333.788.b_636f6d6d656e74.1\">M_Studio的个人空间</a></p>"},{"title":"《Speed Down》Unity2d游戏开发（二）","date":"2021-07-13T07:50:11.000Z","_content":"\n\n\n### \t始、前言\n\n上一次已经完成了场景搭建，那么这次的主要任务就是制作跳跃平台\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、普通平台\n\n1.选中pixel adventure 1 → assets → traps → falling platform 设置pixels per unit为16\n\n2.拖拽第一张图案到场景中，命名为BasePlatform\n\n3.新建BasePlatform的动画，将四个图案拖拽进动画中并调整采样率\n\n4.为BasePlatform添加碰撞器box collider 2d 并调整碰撞体积\n\n\n\n---\n\n\n\n### \t二、旋转平台\n\n1.前面的操作与上述普通平台相同，设置大小，命名，新建动画，添加碰撞器\n\n2.为了实现平台被碰撞时发生翻转，添加组件hinge joint 2d，可以设置旋转角度和速度等\n\n自动添加了rigidbody 2d，但是不取消也不会掉下来，为什么呢？\n\n猜测是joint关节会固定在背景里，超过一定的力才会 “脱臼”\n\n\n\n---\n\n\n\n### \t三、弹跳平台\n\n1.找到pixel adventure 1 → assets → traps → fan ，设置大小，命名，添加碰撞器\n\n2.这里新建两个动画，一个是静止时的动画，一个是启动时的动画（弹跳）\n\n3.新建脚本，实现碰撞时平台切换到弹跳动画：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class FanRun : MonoBehaviour\n{\n    Animator animator;\n    void Start()\n    {\n        animator = GetComponent<Animator>();\n    }\n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            animator.Play(\"Fan_run\");\n        }\n    }\n}\n```\n\n当标签为Player的物体碰撞到此平台时就会切换到启动动画啦\n\n\n\n---\n\n\n\n### \t四、摆动链锤\n\n1.新建空物体SpikeBall，分别添加两个子物体pixel adventure 1 → assets → traps → spiked ball → 轴心和大锤\n\n2.调整父子物体的相对位置\n\n3.给大锤添加组件Distance Joint 2D，给轴心添加rigid body 2d并拖拽到大锤的链接体\n\n4.给大锤添加碰撞体circle collider 2d\n\n\n\n---\n\n\n\n### \t五、脚本实现平台上升\n\n新建脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlatformUp : MonoBehaviour\n{\n    Vector3 movement;\n    public float speed;\n    void Start()\n    {\n        movement.y = speed;\n    }\n    void Update()\n    {\n        MovePlatform();\n    }\n    void MovePlatform()\n    {\n        transform.position += movement * Time.deltaTime;\n    }\n}\n```\n\n并挂载到所有的平台建筑下，这样就实现了平台的持续上升\n\n\n\n---\n\n\n\n### \t六、设置平台天花板\n\n平台总不能一直上升，要设置一个天花板，当平台到达天花板时就摧毁物体\n\n1.新建空物体TopLine移动到上方合适的位置，作为天花板\n\n2.在平台的上升代码中添加判断到达天花板的检测：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlatformUp : MonoBehaviour\n{\n    Vector3 movement;\n    public float speed;\n    GameObject topLine;\n\n    void Start()\n    {\n        movement.y = speed;\n        topLine = GameObject.Find(\"TopLine\");\n    }\n    void Update()\n    {\n        MovePlatform();\n    }\n\n    void MovePlatform()\n    {\n        transform.position += movement * Time.deltaTime;\n        if(transform.position.y > topLine.transform.position.y)\n        {\n            Destroy(gameObject);\n        }\n    }\n}\n```\n\n完成！平台到位自动销毁\n\n\n\n---\n\n\n\n### \t终、总结\n\n平台的制作到这就结束了！用到了几个joint组件，十分有趣\n\n","source":"_posts/2021-07-13-《Speed Down》Unity2d游戏开发（二）.md","raw":"---\ntitle: 《Speed Down》Unity2d游戏开发（二）\ndate: 2021-07-13 15:50:11\ncategories: unity\ntags:\n  - unity\n  - c#\n  - joint\n  - collider\n---\n\n\n\n### \t始、前言\n\n上一次已经完成了场景搭建，那么这次的主要任务就是制作跳跃平台\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、普通平台\n\n1.选中pixel adventure 1 → assets → traps → falling platform 设置pixels per unit为16\n\n2.拖拽第一张图案到场景中，命名为BasePlatform\n\n3.新建BasePlatform的动画，将四个图案拖拽进动画中并调整采样率\n\n4.为BasePlatform添加碰撞器box collider 2d 并调整碰撞体积\n\n\n\n---\n\n\n\n### \t二、旋转平台\n\n1.前面的操作与上述普通平台相同，设置大小，命名，新建动画，添加碰撞器\n\n2.为了实现平台被碰撞时发生翻转，添加组件hinge joint 2d，可以设置旋转角度和速度等\n\n自动添加了rigidbody 2d，但是不取消也不会掉下来，为什么呢？\n\n猜测是joint关节会固定在背景里，超过一定的力才会 “脱臼”\n\n\n\n---\n\n\n\n### \t三、弹跳平台\n\n1.找到pixel adventure 1 → assets → traps → fan ，设置大小，命名，添加碰撞器\n\n2.这里新建两个动画，一个是静止时的动画，一个是启动时的动画（弹跳）\n\n3.新建脚本，实现碰撞时平台切换到弹跳动画：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class FanRun : MonoBehaviour\n{\n    Animator animator;\n    void Start()\n    {\n        animator = GetComponent<Animator>();\n    }\n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            animator.Play(\"Fan_run\");\n        }\n    }\n}\n```\n\n当标签为Player的物体碰撞到此平台时就会切换到启动动画啦\n\n\n\n---\n\n\n\n### \t四、摆动链锤\n\n1.新建空物体SpikeBall，分别添加两个子物体pixel adventure 1 → assets → traps → spiked ball → 轴心和大锤\n\n2.调整父子物体的相对位置\n\n3.给大锤添加组件Distance Joint 2D，给轴心添加rigid body 2d并拖拽到大锤的链接体\n\n4.给大锤添加碰撞体circle collider 2d\n\n\n\n---\n\n\n\n### \t五、脚本实现平台上升\n\n新建脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlatformUp : MonoBehaviour\n{\n    Vector3 movement;\n    public float speed;\n    void Start()\n    {\n        movement.y = speed;\n    }\n    void Update()\n    {\n        MovePlatform();\n    }\n    void MovePlatform()\n    {\n        transform.position += movement * Time.deltaTime;\n    }\n}\n```\n\n并挂载到所有的平台建筑下，这样就实现了平台的持续上升\n\n\n\n---\n\n\n\n### \t六、设置平台天花板\n\n平台总不能一直上升，要设置一个天花板，当平台到达天花板时就摧毁物体\n\n1.新建空物体TopLine移动到上方合适的位置，作为天花板\n\n2.在平台的上升代码中添加判断到达天花板的检测：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlatformUp : MonoBehaviour\n{\n    Vector3 movement;\n    public float speed;\n    GameObject topLine;\n\n    void Start()\n    {\n        movement.y = speed;\n        topLine = GameObject.Find(\"TopLine\");\n    }\n    void Update()\n    {\n        MovePlatform();\n    }\n\n    void MovePlatform()\n    {\n        transform.position += movement * Time.deltaTime;\n        if(transform.position.y > topLine.transform.position.y)\n        {\n            Destroy(gameObject);\n        }\n    }\n}\n```\n\n完成！平台到位自动销毁\n\n\n\n---\n\n\n\n### \t终、总结\n\n平台的制作到这就结束了！用到了几个joint组件，十分有趣\n\n","slug":"2021-07-13-《Speed Down》Unity2d游戏开发（二）","published":1,"updated":"2021-07-16T13:11:47.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnima000bf4u083bp5rc8","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>上一次已经完成了场景搭建，那么这次的主要任务就是制作跳跃平台</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、普通平台\"><a href=\"#一、普通平台\" class=\"headerlink\" title=\"一、普通平台\"></a>一、普通平台</h3><p>1.选中pixel adventure 1 → assets → traps → falling platform 设置pixels per unit为16</p>\n<p>2.拖拽第一张图案到场景中，命名为BasePlatform</p>\n<p>3.新建BasePlatform的动画，将四个图案拖拽进动画中并调整采样率</p>\n<p>4.为BasePlatform添加碰撞器box collider 2d 并调整碰撞体积</p>\n<hr>\n<h3 id=\"二、旋转平台\"><a href=\"#二、旋转平台\" class=\"headerlink\" title=\"二、旋转平台\"></a>二、旋转平台</h3><p>1.前面的操作与上述普通平台相同，设置大小，命名，新建动画，添加碰撞器</p>\n<p>2.为了实现平台被碰撞时发生翻转，添加组件hinge joint 2d，可以设置旋转角度和速度等</p>\n<p>自动添加了rigidbody 2d，但是不取消也不会掉下来，为什么呢？</p>\n<p>猜测是joint关节会固定在背景里，超过一定的力才会 “脱臼”</p>\n<hr>\n<h3 id=\"三、弹跳平台\"><a href=\"#三、弹跳平台\" class=\"headerlink\" title=\"三、弹跳平台\"></a>三、弹跳平台</h3><p>1.找到pixel adventure 1 → assets → traps → fan ，设置大小，命名，添加碰撞器</p>\n<p>2.这里新建两个动画，一个是静止时的动画，一个是启动时的动画（弹跳）</p>\n<p>3.新建脚本，实现碰撞时平台切换到弹跳动画：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class FanRun : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Animator animator;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        animator = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void OnCollisionEnter2D(Collision2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.gameObject.CompareTag(&quot;Player&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            animator.Play(&quot;Fan_run&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当标签为Player的物体碰撞到此平台时就会切换到启动动画啦</p>\n<hr>\n<h3 id=\"四、摆动链锤\"><a href=\"#四、摆动链锤\" class=\"headerlink\" title=\"四、摆动链锤\"></a>四、摆动链锤</h3><p>1.新建空物体SpikeBall，分别添加两个子物体pixel adventure 1 → assets → traps → spiked ball → 轴心和大锤</p>\n<p>2.调整父子物体的相对位置</p>\n<p>3.给大锤添加组件Distance Joint 2D，给轴心添加rigid body 2d并拖拽到大锤的链接体</p>\n<p>4.给大锤添加碰撞体circle collider 2d</p>\n<hr>\n<h3 id=\"五、脚本实现平台上升\"><a href=\"#五、脚本实现平台上升\" class=\"headerlink\" title=\"五、脚本实现平台上升\"></a>五、脚本实现平台上升</h3><p>新建脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlatformUp : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector3 movement;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        movement.y = speed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MovePlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void MovePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        transform.position += movement * Time.deltaTime;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并挂载到所有的平台建筑下，这样就实现了平台的持续上升</p>\n<hr>\n<h3 id=\"六、设置平台天花板\"><a href=\"#六、设置平台天花板\" class=\"headerlink\" title=\"六、设置平台天花板\"></a>六、设置平台天花板</h3><p>平台总不能一直上升，要设置一个天花板，当平台到达天花板时就摧毁物体</p>\n<p>1.新建空物体TopLine移动到上方合适的位置，作为天花板</p>\n<p>2.在平台的上升代码中添加判断到达天花板的检测：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlatformUp : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector3 movement;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    GameObject topLine;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        movement.y = speed;</span><br><span class=\"line\">        topLine = GameObject.Find(&quot;TopLine&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MovePlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void MovePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        transform.position += movement * Time.deltaTime;</span><br><span class=\"line\">        if(transform.position.y &gt; topLine.transform.position.y)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完成！平台到位自动销毁</p>\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>平台的制作到这就结束了！用到了几个joint组件，十分有趣</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>上一次已经完成了场景搭建，那么这次的主要任务就是制作跳跃平台</p>","more":"<hr>\n<h3 id=\"一、普通平台\"><a href=\"#一、普通平台\" class=\"headerlink\" title=\"一、普通平台\"></a>一、普通平台</h3><p>1.选中pixel adventure 1 → assets → traps → falling platform 设置pixels per unit为16</p>\n<p>2.拖拽第一张图案到场景中，命名为BasePlatform</p>\n<p>3.新建BasePlatform的动画，将四个图案拖拽进动画中并调整采样率</p>\n<p>4.为BasePlatform添加碰撞器box collider 2d 并调整碰撞体积</p>\n<hr>\n<h3 id=\"二、旋转平台\"><a href=\"#二、旋转平台\" class=\"headerlink\" title=\"二、旋转平台\"></a>二、旋转平台</h3><p>1.前面的操作与上述普通平台相同，设置大小，命名，新建动画，添加碰撞器</p>\n<p>2.为了实现平台被碰撞时发生翻转，添加组件hinge joint 2d，可以设置旋转角度和速度等</p>\n<p>自动添加了rigidbody 2d，但是不取消也不会掉下来，为什么呢？</p>\n<p>猜测是joint关节会固定在背景里，超过一定的力才会 “脱臼”</p>\n<hr>\n<h3 id=\"三、弹跳平台\"><a href=\"#三、弹跳平台\" class=\"headerlink\" title=\"三、弹跳平台\"></a>三、弹跳平台</h3><p>1.找到pixel adventure 1 → assets → traps → fan ，设置大小，命名，添加碰撞器</p>\n<p>2.这里新建两个动画，一个是静止时的动画，一个是启动时的动画（弹跳）</p>\n<p>3.新建脚本，实现碰撞时平台切换到弹跳动画：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class FanRun : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Animator animator;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        animator = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void OnCollisionEnter2D(Collision2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.gameObject.CompareTag(&quot;Player&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            animator.Play(&quot;Fan_run&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当标签为Player的物体碰撞到此平台时就会切换到启动动画啦</p>\n<hr>\n<h3 id=\"四、摆动链锤\"><a href=\"#四、摆动链锤\" class=\"headerlink\" title=\"四、摆动链锤\"></a>四、摆动链锤</h3><p>1.新建空物体SpikeBall，分别添加两个子物体pixel adventure 1 → assets → traps → spiked ball → 轴心和大锤</p>\n<p>2.调整父子物体的相对位置</p>\n<p>3.给大锤添加组件Distance Joint 2D，给轴心添加rigid body 2d并拖拽到大锤的链接体</p>\n<p>4.给大锤添加碰撞体circle collider 2d</p>\n<hr>\n<h3 id=\"五、脚本实现平台上升\"><a href=\"#五、脚本实现平台上升\" class=\"headerlink\" title=\"五、脚本实现平台上升\"></a>五、脚本实现平台上升</h3><p>新建脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlatformUp : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector3 movement;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        movement.y = speed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MovePlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void MovePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        transform.position += movement * Time.deltaTime;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并挂载到所有的平台建筑下，这样就实现了平台的持续上升</p>\n<hr>\n<h3 id=\"六、设置平台天花板\"><a href=\"#六、设置平台天花板\" class=\"headerlink\" title=\"六、设置平台天花板\"></a>六、设置平台天花板</h3><p>平台总不能一直上升，要设置一个天花板，当平台到达天花板时就摧毁物体</p>\n<p>1.新建空物体TopLine移动到上方合适的位置，作为天花板</p>\n<p>2.在平台的上升代码中添加判断到达天花板的检测：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlatformUp : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector3 movement;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    GameObject topLine;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        movement.y = speed;</span><br><span class=\"line\">        topLine = GameObject.Find(&quot;TopLine&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MovePlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void MovePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        transform.position += movement * Time.deltaTime;</span><br><span class=\"line\">        if(transform.position.y &gt; topLine.transform.position.y)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>完成！平台到位自动销毁</p>\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>平台的制作到这就结束了！用到了几个joint组件，十分有趣</p>"},{"title":"《Speed Down》Unity2d游戏开发（三）","date":"2021-07-14T08:16:29.000Z","_content":"\n\n\n### \t始、前言\n\n背景和障碍物都搭建完毕了，现在来制作我们操作的主角！（洗个衣服先...）\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、添加动画及组件\n\n1.先选中资源中喜欢的角色，修改所有精灵图的ppu为32\n\n2.制作动画，idle、run、jump、hit\n\n3.添加组件rigidbody 2d并且勾选constraints → freeze rotation → z 以此锁定z轴，防止碰撞时产生z轴翻转\n\n4.添加碰撞组件box collider 2d\n\n\n\n---\n\n\n\n### \t二、脚本控制主角\n\n添加脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerController : MonoBehaviour\n{\n    Rigidbody2D rb;\n    Animator anim;\n    public float speed;\n    float xVelocity;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        anim = GetComponent<Animator>();\n    }\n\n    void Update()\n    {\n        Movement();\n    }\n\n    void Movement()\n    {\n        xVelocity = Input.GetAxisRaw(\"Horizontal\");\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n\n        if(xVelocity != 0)\n        {\n            transform.localScale = new Vector3(xVelocity, 1, 1);\n        }\n    }\n}\n```\n\n挂载到角色上，就可以用方向键控制左右移动了（wsad也可以）\n\n并且`transform.localScale = new Vector3(xVelocity, 1, 1);`还实现了图案的左右翻转（之前我还傻傻地自己画各个方向的图）\n\n\n\n---\n\n\n\n### \t三、切换跑步动画\n\n1.打开player的Animator界面，相互连接idle和run，新建speed变量，设置idle转换为run的条件为speed大于0.1，run转换为idle的条件为speed小于0.1，同时记得调整转换时间和混合时间等设置（这里全部取消）\n\n2.在`void Movement()`中添加代码：\n\n```\nanim.SetFloat(\"speed\", Mathf.Abs(rb.velocity.x));\n```\n\n\n\n---\n\n\n\n### \t四、切换下落动画\n\n1.动画all和idle相互连接，创建isOnGround变量来检测是否在平台上，把所有平台的Layer都改成新的Platform\n\n2.添加代码：\n\n```\n    public bool isOnGround;\n    public float checkRadius;\n    public LayerMask layer;\n    public GameObject groundCheck;\n    \n    void Update()\n    {\n        Movement();\n        isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);\n        anim.SetBool(\"isOnGround\", isOnGround);\n    } \n```\n\n3.在角色物体下方添加子物体CheckPoint并拖拽入角色的检测点位置\n\n4.修改参数就可以实现踩到平台时触发isOnGround，并且由fall动画转换到idle动画\n\n但是现在看不见检测范围，只能大致估计，怎么办呢？\n\n小技巧：添加代码：\n\n```\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);\n    }\n```\n\n上述代码是unity内置的方法，可以把检测范围可视化\n\n---\n\n\n\n### \t五、切换死亡动画\n\n1.修改尖刺的tag为新的Spike，状态机新建trigger型变量isDead，将Any State 连接到hit调整转换条件，这样就可以从任何状态转换到死亡状态\n\n2.添加代码：\n\n```\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if (collision.CompareTag(\"Spike\"))\n        {\n            anim.SetTrigger(\"isDead\");\n        }\n    }\n```\n\n这样就实现了播放死亡动画，接下来再加一个表示角色死亡的标志\n\n3.添加代码：\n\n```\n    public bool playerDead;\n    \n    public void PlayerDead()\n    {\n        playerDead = true;\n    }\n```\n\n4.找到玩家死亡的动画效果，在最后一帧添加函数`PlayerDead()`\n\n\n\n---\n\n\n\n### \t六、实现跳跃平台的跳跃效果\n\n1.设置跳跃平台的tag为新的Fan\n\n2.添加代码：\n\n```\n    public float bounceH;\n    \n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Fan\"))\n        {\n            rb.velocity = new Vector2(rb.velocity.x, bounceH);\n        }\n    }\n```\n\n这样以来，角色碰到跳跃平台时就会给rigidbody产生向上的大小为bounceH的力（就是被打飞了）\n\n发现之前说好的跳跃平台碰到角色会转起来现在好像没有转，原来是主角的tag没有设置成Player\n\n完美！\n\n\n\n---\n\n\n\n### \t终、吐槽\n\n角色的各种动画转换也太复杂了！难道每次添加一个新的动作就要和所有的动作一起调整吗，天啊！有没有简单的方法啊，快浇浇我吧！\n\n","source":"_posts/2021-07-14-《Speed Down》Unity2d游戏开发（三）.md","raw":"---\ntitle: 《Speed Down》Unity2d游戏开发（三）\ndate: 2021-07-14 16:16:29\ncategories:\tunity\ntags:\n  - unity\n  - c#\n  - animator\n  - trigger\n  - collider\n---\n\n\n\n### \t始、前言\n\n背景和障碍物都搭建完毕了，现在来制作我们操作的主角！（洗个衣服先...）\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、添加动画及组件\n\n1.先选中资源中喜欢的角色，修改所有精灵图的ppu为32\n\n2.制作动画，idle、run、jump、hit\n\n3.添加组件rigidbody 2d并且勾选constraints → freeze rotation → z 以此锁定z轴，防止碰撞时产生z轴翻转\n\n4.添加碰撞组件box collider 2d\n\n\n\n---\n\n\n\n### \t二、脚本控制主角\n\n添加脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerController : MonoBehaviour\n{\n    Rigidbody2D rb;\n    Animator anim;\n    public float speed;\n    float xVelocity;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        anim = GetComponent<Animator>();\n    }\n\n    void Update()\n    {\n        Movement();\n    }\n\n    void Movement()\n    {\n        xVelocity = Input.GetAxisRaw(\"Horizontal\");\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n\n        if(xVelocity != 0)\n        {\n            transform.localScale = new Vector3(xVelocity, 1, 1);\n        }\n    }\n}\n```\n\n挂载到角色上，就可以用方向键控制左右移动了（wsad也可以）\n\n并且`transform.localScale = new Vector3(xVelocity, 1, 1);`还实现了图案的左右翻转（之前我还傻傻地自己画各个方向的图）\n\n\n\n---\n\n\n\n### \t三、切换跑步动画\n\n1.打开player的Animator界面，相互连接idle和run，新建speed变量，设置idle转换为run的条件为speed大于0.1，run转换为idle的条件为speed小于0.1，同时记得调整转换时间和混合时间等设置（这里全部取消）\n\n2.在`void Movement()`中添加代码：\n\n```\nanim.SetFloat(\"speed\", Mathf.Abs(rb.velocity.x));\n```\n\n\n\n---\n\n\n\n### \t四、切换下落动画\n\n1.动画all和idle相互连接，创建isOnGround变量来检测是否在平台上，把所有平台的Layer都改成新的Platform\n\n2.添加代码：\n\n```\n    public bool isOnGround;\n    public float checkRadius;\n    public LayerMask layer;\n    public GameObject groundCheck;\n    \n    void Update()\n    {\n        Movement();\n        isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);\n        anim.SetBool(\"isOnGround\", isOnGround);\n    } \n```\n\n3.在角色物体下方添加子物体CheckPoint并拖拽入角色的检测点位置\n\n4.修改参数就可以实现踩到平台时触发isOnGround，并且由fall动画转换到idle动画\n\n但是现在看不见检测范围，只能大致估计，怎么办呢？\n\n小技巧：添加代码：\n\n```\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);\n    }\n```\n\n上述代码是unity内置的方法，可以把检测范围可视化\n\n---\n\n\n\n### \t五、切换死亡动画\n\n1.修改尖刺的tag为新的Spike，状态机新建trigger型变量isDead，将Any State 连接到hit调整转换条件，这样就可以从任何状态转换到死亡状态\n\n2.添加代码：\n\n```\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if (collision.CompareTag(\"Spike\"))\n        {\n            anim.SetTrigger(\"isDead\");\n        }\n    }\n```\n\n这样就实现了播放死亡动画，接下来再加一个表示角色死亡的标志\n\n3.添加代码：\n\n```\n    public bool playerDead;\n    \n    public void PlayerDead()\n    {\n        playerDead = true;\n    }\n```\n\n4.找到玩家死亡的动画效果，在最后一帧添加函数`PlayerDead()`\n\n\n\n---\n\n\n\n### \t六、实现跳跃平台的跳跃效果\n\n1.设置跳跃平台的tag为新的Fan\n\n2.添加代码：\n\n```\n    public float bounceH;\n    \n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Fan\"))\n        {\n            rb.velocity = new Vector2(rb.velocity.x, bounceH);\n        }\n    }\n```\n\n这样以来，角色碰到跳跃平台时就会给rigidbody产生向上的大小为bounceH的力（就是被打飞了）\n\n发现之前说好的跳跃平台碰到角色会转起来现在好像没有转，原来是主角的tag没有设置成Player\n\n完美！\n\n\n\n---\n\n\n\n### \t终、吐槽\n\n角色的各种动画转换也太复杂了！难道每次添加一个新的动作就要和所有的动作一起调整吗，天啊！有没有简单的方法啊，快浇浇我吧！\n\n","slug":"2021-07-14-《Speed Down》Unity2d游戏开发（三）","published":1,"updated":"2021-07-15T10:26:44.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnimb000cf4u05df17i9e","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>背景和障碍物都搭建完毕了，现在来制作我们操作的主角！（洗个衣服先…）</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、添加动画及组件\"><a href=\"#一、添加动画及组件\" class=\"headerlink\" title=\"一、添加动画及组件\"></a>一、添加动画及组件</h3><p>1.先选中资源中喜欢的角色，修改所有精灵图的ppu为32</p>\n<p>2.制作动画，idle、run、jump、hit</p>\n<p>3.添加组件rigidbody 2d并且勾选constraints → freeze rotation → z 以此锁定z轴，防止碰撞时产生z轴翻转</p>\n<p>4.添加碰撞组件box collider 2d</p>\n<hr>\n<h3 id=\"二、脚本控制主角\"><a href=\"#二、脚本控制主角\" class=\"headerlink\" title=\"二、脚本控制主角\"></a>二、脚本控制主角</h3><p>添加脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerController : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Rigidbody2D rb;</span><br><span class=\"line\">    Animator anim;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">        anim = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Movement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Movement()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\"></span><br><span class=\"line\">        if(xVelocity != 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            transform.localScale = new Vector3(xVelocity, 1, 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>挂载到角色上，就可以用方向键控制左右移动了（wsad也可以）</p>\n<p>并且<code>transform.localScale = new Vector3(xVelocity, 1, 1);</code>还实现了图案的左右翻转（之前我还傻傻地自己画各个方向的图）</p>\n<hr>\n<h3 id=\"三、切换跑步动画\"><a href=\"#三、切换跑步动画\" class=\"headerlink\" title=\"三、切换跑步动画\"></a>三、切换跑步动画</h3><p>1.打开player的Animator界面，相互连接idle和run，新建speed变量，设置idle转换为run的条件为speed大于0.1，run转换为idle的条件为speed小于0.1，同时记得调整转换时间和混合时间等设置（这里全部取消）</p>\n<p>2.在<code>void Movement()</code>中添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">anim.SetFloat(&quot;speed&quot;, Mathf.Abs(rb.velocity.x));</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"四、切换下落动画\"><a href=\"#四、切换下落动画\" class=\"headerlink\" title=\"四、切换下落动画\"></a>四、切换下落动画</h3><p>1.动画all和idle相互连接，创建isOnGround变量来检测是否在平台上，把所有平台的Layer都改成新的Platform</p>\n<p>2.添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public bool isOnGround;</span><br><span class=\"line\">public float checkRadius;</span><br><span class=\"line\">public LayerMask layer;</span><br><span class=\"line\">public GameObject groundCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">void Update()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Movement();</span><br><span class=\"line\">    isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);</span><br><span class=\"line\">    anim.SetBool(&quot;isOnGround&quot;, isOnGround);</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>3.在角色物体下方添加子物体CheckPoint并拖拽入角色的检测点位置</p>\n<p>4.修改参数就可以实现踩到平台时触发isOnGround，并且由fall动画转换到idle动画</p>\n<p>但是现在看不见检测范围，只能大致估计，怎么办呢？</p>\n<p>小技巧：添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void OnDrawGizmosSelected()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Gizmos.color = Color.green;</span><br><span class=\"line\">    Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码是unity内置的方法，可以把检测范围可视化</p>\n<hr>\n<h3 id=\"五、切换死亡动画\"><a href=\"#五、切换死亡动画\" class=\"headerlink\" title=\"五、切换死亡动画\"></a>五、切换死亡动画</h3><p>1.修改尖刺的tag为新的Spike，状态机新建trigger型变量isDead，将Any State 连接到hit调整转换条件，这样就可以从任何状态转换到死亡状态</p>\n<p>2.添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (collision.CompareTag(&quot;Spike&quot;))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        anim.SetTrigger(&quot;isDead&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就实现了播放死亡动画，接下来再加一个表示角色死亡的标志</p>\n<p>3.添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public bool playerDead;</span><br><span class=\"line\"></span><br><span class=\"line\">public void PlayerDead()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    playerDead = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.找到玩家死亡的动画效果，在最后一帧添加函数<code>PlayerDead()</code></p>\n<hr>\n<h3 id=\"六、实现跳跃平台的跳跃效果\"><a href=\"#六、实现跳跃平台的跳跃效果\" class=\"headerlink\" title=\"六、实现跳跃平台的跳跃效果\"></a>六、实现跳跃平台的跳跃效果</h3><p>1.设置跳跃平台的tag为新的Fan</p>\n<p>2.添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public float bounceH;</span><br><span class=\"line\"></span><br><span class=\"line\">private void OnCollisionEnter2D(Collision2D collision)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (collision.gameObject.CompareTag(&quot;Fan&quot;))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb.velocity = new Vector2(rb.velocity.x, bounceH);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样以来，角色碰到跳跃平台时就会给rigidbody产生向上的大小为bounceH的力（就是被打飞了）</p>\n<p>发现之前说好的跳跃平台碰到角色会转起来现在好像没有转，原来是主角的tag没有设置成Player</p>\n<p>完美！</p>\n<hr>\n<h3 id=\"终、吐槽\"><a href=\"#终、吐槽\" class=\"headerlink\" title=\"终、吐槽\"></a>终、吐槽</h3><p>角色的各种动画转换也太复杂了！难道每次添加一个新的动作就要和所有的动作一起调整吗，天啊！有没有简单的方法啊，快浇浇我吧！</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>背景和障碍物都搭建完毕了，现在来制作我们操作的主角！（洗个衣服先…）</p>","more":"<hr>\n<h3 id=\"一、添加动画及组件\"><a href=\"#一、添加动画及组件\" class=\"headerlink\" title=\"一、添加动画及组件\"></a>一、添加动画及组件</h3><p>1.先选中资源中喜欢的角色，修改所有精灵图的ppu为32</p>\n<p>2.制作动画，idle、run、jump、hit</p>\n<p>3.添加组件rigidbody 2d并且勾选constraints → freeze rotation → z 以此锁定z轴，防止碰撞时产生z轴翻转</p>\n<p>4.添加碰撞组件box collider 2d</p>\n<hr>\n<h3 id=\"二、脚本控制主角\"><a href=\"#二、脚本控制主角\" class=\"headerlink\" title=\"二、脚本控制主角\"></a>二、脚本控制主角</h3><p>添加脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerController : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Rigidbody2D rb;</span><br><span class=\"line\">    Animator anim;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">        anim = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Movement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Movement()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\"></span><br><span class=\"line\">        if(xVelocity != 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            transform.localScale = new Vector3(xVelocity, 1, 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>挂载到角色上，就可以用方向键控制左右移动了（wsad也可以）</p>\n<p>并且<code>transform.localScale = new Vector3(xVelocity, 1, 1);</code>还实现了图案的左右翻转（之前我还傻傻地自己画各个方向的图）</p>\n<hr>\n<h3 id=\"三、切换跑步动画\"><a href=\"#三、切换跑步动画\" class=\"headerlink\" title=\"三、切换跑步动画\"></a>三、切换跑步动画</h3><p>1.打开player的Animator界面，相互连接idle和run，新建speed变量，设置idle转换为run的条件为speed大于0.1，run转换为idle的条件为speed小于0.1，同时记得调整转换时间和混合时间等设置（这里全部取消）</p>\n<p>2.在<code>void Movement()</code>中添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">anim.SetFloat(&quot;speed&quot;, Mathf.Abs(rb.velocity.x));</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"四、切换下落动画\"><a href=\"#四、切换下落动画\" class=\"headerlink\" title=\"四、切换下落动画\"></a>四、切换下落动画</h3><p>1.动画all和idle相互连接，创建isOnGround变量来检测是否在平台上，把所有平台的Layer都改成新的Platform</p>\n<p>2.添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public bool isOnGround;</span><br><span class=\"line\">public float checkRadius;</span><br><span class=\"line\">public LayerMask layer;</span><br><span class=\"line\">public GameObject groundCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">void Update()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Movement();</span><br><span class=\"line\">    isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);</span><br><span class=\"line\">    anim.SetBool(&quot;isOnGround&quot;, isOnGround);</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>3.在角色物体下方添加子物体CheckPoint并拖拽入角色的检测点位置</p>\n<p>4.修改参数就可以实现踩到平台时触发isOnGround，并且由fall动画转换到idle动画</p>\n<p>但是现在看不见检测范围，只能大致估计，怎么办呢？</p>\n<p>小技巧：添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void OnDrawGizmosSelected()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Gizmos.color = Color.green;</span><br><span class=\"line\">    Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码是unity内置的方法，可以把检测范围可视化</p>\n<hr>\n<h3 id=\"五、切换死亡动画\"><a href=\"#五、切换死亡动画\" class=\"headerlink\" title=\"五、切换死亡动画\"></a>五、切换死亡动画</h3><p>1.修改尖刺的tag为新的Spike，状态机新建trigger型变量isDead，将Any State 连接到hit调整转换条件，这样就可以从任何状态转换到死亡状态</p>\n<p>2.添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (collision.CompareTag(&quot;Spike&quot;))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        anim.SetTrigger(&quot;isDead&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就实现了播放死亡动画，接下来再加一个表示角色死亡的标志</p>\n<p>3.添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public bool playerDead;</span><br><span class=\"line\"></span><br><span class=\"line\">public void PlayerDead()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    playerDead = true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.找到玩家死亡的动画效果，在最后一帧添加函数<code>PlayerDead()</code></p>\n<hr>\n<h3 id=\"六、实现跳跃平台的跳跃效果\"><a href=\"#六、实现跳跃平台的跳跃效果\" class=\"headerlink\" title=\"六、实现跳跃平台的跳跃效果\"></a>六、实现跳跃平台的跳跃效果</h3><p>1.设置跳跃平台的tag为新的Fan</p>\n<p>2.添加代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public float bounceH;</span><br><span class=\"line\"></span><br><span class=\"line\">private void OnCollisionEnter2D(Collision2D collision)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (collision.gameObject.CompareTag(&quot;Fan&quot;))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb.velocity = new Vector2(rb.velocity.x, bounceH);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样以来，角色碰到跳跃平台时就会给rigidbody产生向上的大小为bounceH的力（就是被打飞了）</p>\n<p>发现之前说好的跳跃平台碰到角色会转起来现在好像没有转，原来是主角的tag没有设置成Player</p>\n<p>完美！</p>\n<hr>\n<h3 id=\"终、吐槽\"><a href=\"#终、吐槽\" class=\"headerlink\" title=\"终、吐槽\"></a>终、吐槽</h3><p>角色的各种动画转换也太复杂了！难道每次添加一个新的动作就要和所有的动作一起调整吗，天啊！有没有简单的方法啊，快浇浇我吧！</p>"},{"title":"《Speed Down》Unity2d游戏开发（四）","date":"2021-07-14T12:55:23.000Z","_content":"\n\n\n### \t始、阶段调整\n\n这次不做新功能，先停一停把之前的东西调整一下，细节~太细了~\n\n<!--more-->\n\n---\n\n\n\n### 一、图案模糊\n\n顶部尖刺看起来有些模糊\n\n1.找到尖刺的图案，将Advanced → Filter Mode 修改成Point\n\n检查所有的图案是否模糊，套用这个方法\n\n\n\n---\n\n\n\n### 二、修改背景颜色\n\n1.选择主相机，修改Camera → Background 到喜欢的颜色\n\n\n\n---\n\n\n\n### 三、给链锤添加链子？\n\n听起来有点奇怪，但是我的链锤现在确实是没有链子，看起来像是原力驱动\n\n1.给链锤整体添加组件Line Renderer，选择喜欢材质、颜色、粗细，并把Position → Size改成2\n\n2.添加脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class SpikeBallLine : MonoBehaviour\n{\n\n    LineRenderer line;\n    public Transform begin;\n    public Transform end;\n\n    void Start()\n    {\n        line = GetComponent<LineRenderer>();\n\n    }\n\n    void Update()\n    {\n        line.SetPosition(0, begin.position);\n        line.SetPosition(1, end.position);\n    }\n}\n```\n\n挂载到链锤父物体上，注意脚本和线组件是同一级别的\n\n\n\n---\n\n\n\n### 四、保存预制体\n\n为了可以持续不断地随机生成平台，需要将平台保存为预制体\n\n1.创建prefabs文件夹，并把平台和人物添加到其中\n\n**Prefab是什么？**\n\n当制作好了游戏组件（场景中的任意一个gameobject）,我们希望将它制作成一个组件模版，用于批量的套用工作，例如说场景中本质上要重复使用的东西，比如：敌人、士兵、子弹或者一个砖块完全相同的墙体。这里说本质是因为默认生成的prefab其实和模版是一模一样的。就像是克隆体，但生成的位置、角度或者一些属性不同（这个就好像c++里边的类一样）；\n\n","source":"_posts/2021-07-14-《Speed Down》Unity2d游戏开发（四）.md","raw":"---\ntitle: 《Speed Down》Unity2d游戏开发（四）\ndate: 2021-07-14 20:55:23\ncategories:\tunity\ntags:\n  - unity\n  - c#\n  - prefab\n---\n\n\n\n### \t始、阶段调整\n\n这次不做新功能，先停一停把之前的东西调整一下，细节~太细了~\n\n<!--more-->\n\n---\n\n\n\n### 一、图案模糊\n\n顶部尖刺看起来有些模糊\n\n1.找到尖刺的图案，将Advanced → Filter Mode 修改成Point\n\n检查所有的图案是否模糊，套用这个方法\n\n\n\n---\n\n\n\n### 二、修改背景颜色\n\n1.选择主相机，修改Camera → Background 到喜欢的颜色\n\n\n\n---\n\n\n\n### 三、给链锤添加链子？\n\n听起来有点奇怪，但是我的链锤现在确实是没有链子，看起来像是原力驱动\n\n1.给链锤整体添加组件Line Renderer，选择喜欢材质、颜色、粗细，并把Position → Size改成2\n\n2.添加脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class SpikeBallLine : MonoBehaviour\n{\n\n    LineRenderer line;\n    public Transform begin;\n    public Transform end;\n\n    void Start()\n    {\n        line = GetComponent<LineRenderer>();\n\n    }\n\n    void Update()\n    {\n        line.SetPosition(0, begin.position);\n        line.SetPosition(1, end.position);\n    }\n}\n```\n\n挂载到链锤父物体上，注意脚本和线组件是同一级别的\n\n\n\n---\n\n\n\n### 四、保存预制体\n\n为了可以持续不断地随机生成平台，需要将平台保存为预制体\n\n1.创建prefabs文件夹，并把平台和人物添加到其中\n\n**Prefab是什么？**\n\n当制作好了游戏组件（场景中的任意一个gameobject）,我们希望将它制作成一个组件模版，用于批量的套用工作，例如说场景中本质上要重复使用的东西，比如：敌人、士兵、子弹或者一个砖块完全相同的墙体。这里说本质是因为默认生成的prefab其实和模版是一模一样的。就像是克隆体，但生成的位置、角度或者一些属性不同（这个就好像c++里边的类一样）；\n\n","slug":"2021-07-14-《Speed Down》Unity2d游戏开发（四）","published":1,"updated":"2021-07-15T10:26:50.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnimd000gf4u07ela5kt5","content":"<h3 id=\"始、阶段调整\"><a href=\"#始、阶段调整\" class=\"headerlink\" title=\"始、阶段调整\"></a>始、阶段调整</h3><p>这次不做新功能，先停一停把之前的东西调整一下，细节<del>太细了</del></p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、图案模糊\"><a href=\"#一、图案模糊\" class=\"headerlink\" title=\"一、图案模糊\"></a>一、图案模糊</h3><p>顶部尖刺看起来有些模糊</p>\n<p>1.找到尖刺的图案，将Advanced → Filter Mode 修改成Point</p>\n<p>检查所有的图案是否模糊，套用这个方法</p>\n<hr>\n<h3 id=\"二、修改背景颜色\"><a href=\"#二、修改背景颜色\" class=\"headerlink\" title=\"二、修改背景颜色\"></a>二、修改背景颜色</h3><p>1.选择主相机，修改Camera → Background 到喜欢的颜色</p>\n<hr>\n<h3 id=\"三、给链锤添加链子？\"><a href=\"#三、给链锤添加链子？\" class=\"headerlink\" title=\"三、给链锤添加链子？\"></a>三、给链锤添加链子？</h3><p>听起来有点奇怪，但是我的链锤现在确实是没有链子，看起来像是原力驱动</p>\n<p>1.给链锤整体添加组件Line Renderer，选择喜欢材质、颜色、粗细，并把Position → Size改成2</p>\n<p>2.添加脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class SpikeBallLine : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LineRenderer line;</span><br><span class=\"line\">    public Transform begin;</span><br><span class=\"line\">    public Transform end;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line = GetComponent&lt;LineRenderer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line.SetPosition(0, begin.position);</span><br><span class=\"line\">        line.SetPosition(1, end.position);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>挂载到链锤父物体上，注意脚本和线组件是同一级别的</p>\n<hr>\n<h3 id=\"四、保存预制体\"><a href=\"#四、保存预制体\" class=\"headerlink\" title=\"四、保存预制体\"></a>四、保存预制体</h3><p>为了可以持续不断地随机生成平台，需要将平台保存为预制体</p>\n<p>1.创建prefabs文件夹，并把平台和人物添加到其中</p>\n<p><strong>Prefab是什么？</strong></p>\n<p>当制作好了游戏组件（场景中的任意一个gameobject）,我们希望将它制作成一个组件模版，用于批量的套用工作，例如说场景中本质上要重复使用的东西，比如：敌人、士兵、子弹或者一个砖块完全相同的墙体。这里说本质是因为默认生成的prefab其实和模版是一模一样的。就像是克隆体，但生成的位置、角度或者一些属性不同（这个就好像c++里边的类一样）；</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、阶段调整\"><a href=\"#始、阶段调整\" class=\"headerlink\" title=\"始、阶段调整\"></a>始、阶段调整</h3><p>这次不做新功能，先停一停把之前的东西调整一下，细节<del>太细了</del></p>","more":"<hr>\n<h3 id=\"一、图案模糊\"><a href=\"#一、图案模糊\" class=\"headerlink\" title=\"一、图案模糊\"></a>一、图案模糊</h3><p>顶部尖刺看起来有些模糊</p>\n<p>1.找到尖刺的图案，将Advanced → Filter Mode 修改成Point</p>\n<p>检查所有的图案是否模糊，套用这个方法</p>\n<hr>\n<h3 id=\"二、修改背景颜色\"><a href=\"#二、修改背景颜色\" class=\"headerlink\" title=\"二、修改背景颜色\"></a>二、修改背景颜色</h3><p>1.选择主相机，修改Camera → Background 到喜欢的颜色</p>\n<hr>\n<h3 id=\"三、给链锤添加链子？\"><a href=\"#三、给链锤添加链子？\" class=\"headerlink\" title=\"三、给链锤添加链子？\"></a>三、给链锤添加链子？</h3><p>听起来有点奇怪，但是我的链锤现在确实是没有链子，看起来像是原力驱动</p>\n<p>1.给链锤整体添加组件Line Renderer，选择喜欢材质、颜色、粗细，并把Position → Size改成2</p>\n<p>2.添加脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class SpikeBallLine : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LineRenderer line;</span><br><span class=\"line\">    public Transform begin;</span><br><span class=\"line\">    public Transform end;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line = GetComponent&lt;LineRenderer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line.SetPosition(0, begin.position);</span><br><span class=\"line\">        line.SetPosition(1, end.position);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>挂载到链锤父物体上，注意脚本和线组件是同一级别的</p>\n<hr>\n<h3 id=\"四、保存预制体\"><a href=\"#四、保存预制体\" class=\"headerlink\" title=\"四、保存预制体\"></a>四、保存预制体</h3><p>为了可以持续不断地随机生成平台，需要将平台保存为预制体</p>\n<p>1.创建prefabs文件夹，并把平台和人物添加到其中</p>\n<p><strong>Prefab是什么？</strong></p>\n<p>当制作好了游戏组件（场景中的任意一个gameobject）,我们希望将它制作成一个组件模版，用于批量的套用工作，例如说场景中本质上要重复使用的东西，比如：敌人、士兵、子弹或者一个砖块完全相同的墙体。这里说本质是因为默认生成的prefab其实和模版是一模一样的。就像是克隆体，但生成的位置、角度或者一些属性不同（这个就好像c++里边的类一样）；</p>"},{"title":"《Speed Down》Unity2d游戏开发（五）","date":"2021-07-15T07:34:28.000Z","_content":"\n\n\n### \t一、随机生成平台\n\n1.可以删除其他平台，只留下一个开局的平台\n\n2.新建一个空物体作为平台出生点，调整大小，添加碰撞体，勾选is trigger，修改标签为spike\n\n<!--more-->\n\n3.新建脚本挂载到平台出生点：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Spawner : MonoBehaviour\n{\n    public List<GameObject> platform = new List<GameObject>();\n\n    public float spawnTime;\n    float countTime;\n    Vector3 spawnPosition;\n\n\n    void Update()\n    {\n        SpawnPlatform();\n    }\n\n    public void SpawnPlatform()\n    {\n        countTime += Time.deltaTime;\n        spawnPosition = transform.position;\n        spawnPosition.x = Random.Range(-3f, 3f);\n\n        if(countTime > spawnTime)\n        {\n            CreatePlatform();\n            countTime = 0;\n        }\n\n    }\n\n    public void CreatePlatform()\n    {\n        int index = Random.Range(0, platform.Count);\n        Instantiate(platform[index], spawnPosition, Quaternion.identity );\n    }\n}\n```\n\n4.回到unity设置脚本中平台列表的大小为3并且拖入三种基础平台\n\n5.设置好生成速度Spawn Time就可以开始玩啦！\n\n\n\n---\n\n\n\n### \t二、细节调整\n\n1.将链锤的锤子设置标签为spike（不小心删了链锤的预制体，我是sb，以后碰到警告操作不可撤回的要万分小心）\n\n2.角色检测碰到尖刺死亡的代码是在OnTriggerEnter2D中的，而顶部尖刺是触发器，链锤是碰撞器，需要将死亡代码复制到OnCollisionEnter2D中。注意两个函数接收的变量不同，需要按照提示修改一下\n\n3.改变平台列表的大小并拖入不同的平台，这样就可以调整游戏难度以及未来新增其他平台或者陷阱\n\n4.在平台出生点中修改代码，添加：\n\n```\n        GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );\n        newPlatform.transform.SetParent(transform);\n```\n\n这样就可以让新生成的平台作为平台出生点的子物体\n\n5.为了不让链锤连续生成太多以至于游戏难度过大，修改spawn代码：\n\n```\n    int spikeBallNum = 0;\n    \n        public void CreatePlatform()\n    {\n        int index = Random.Range(0, platform.Count);\n\n        if (index == 3)\n        {\n            spikeBallNum++;\n            if(spikeBallNum > 2)\n            {\n                index = 0;\n                spikeBallNum = 0;\n            }\n        }\n\n        GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );\n        newPlatform.transform.SetParent(transform);\n    }\n```\n\n当连续出现链锤时变成普通平台，免得出现必死局\n\n\n\n---\n\n\n\n### \t终、总结\n\n到此为止主要游戏内容都已经完成啦！最后就是制作一些UI管理游戏\n","source":"_posts/2021-07-15-《Speed Down》Unity2d游戏开发（五）.md","raw":"---\ntitle: 《Speed Down》Unity2d游戏开发（五）\ndate: 2021-07-15 15:34:28\ncategories:\tunity\ntags:\n  - unity\n  - c#\n  - trigger\n  - collision\n---\n\n\n\n### \t一、随机生成平台\n\n1.可以删除其他平台，只留下一个开局的平台\n\n2.新建一个空物体作为平台出生点，调整大小，添加碰撞体，勾选is trigger，修改标签为spike\n\n<!--more-->\n\n3.新建脚本挂载到平台出生点：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Spawner : MonoBehaviour\n{\n    public List<GameObject> platform = new List<GameObject>();\n\n    public float spawnTime;\n    float countTime;\n    Vector3 spawnPosition;\n\n\n    void Update()\n    {\n        SpawnPlatform();\n    }\n\n    public void SpawnPlatform()\n    {\n        countTime += Time.deltaTime;\n        spawnPosition = transform.position;\n        spawnPosition.x = Random.Range(-3f, 3f);\n\n        if(countTime > spawnTime)\n        {\n            CreatePlatform();\n            countTime = 0;\n        }\n\n    }\n\n    public void CreatePlatform()\n    {\n        int index = Random.Range(0, platform.Count);\n        Instantiate(platform[index], spawnPosition, Quaternion.identity );\n    }\n}\n```\n\n4.回到unity设置脚本中平台列表的大小为3并且拖入三种基础平台\n\n5.设置好生成速度Spawn Time就可以开始玩啦！\n\n\n\n---\n\n\n\n### \t二、细节调整\n\n1.将链锤的锤子设置标签为spike（不小心删了链锤的预制体，我是sb，以后碰到警告操作不可撤回的要万分小心）\n\n2.角色检测碰到尖刺死亡的代码是在OnTriggerEnter2D中的，而顶部尖刺是触发器，链锤是碰撞器，需要将死亡代码复制到OnCollisionEnter2D中。注意两个函数接收的变量不同，需要按照提示修改一下\n\n3.改变平台列表的大小并拖入不同的平台，这样就可以调整游戏难度以及未来新增其他平台或者陷阱\n\n4.在平台出生点中修改代码，添加：\n\n```\n        GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );\n        newPlatform.transform.SetParent(transform);\n```\n\n这样就可以让新生成的平台作为平台出生点的子物体\n\n5.为了不让链锤连续生成太多以至于游戏难度过大，修改spawn代码：\n\n```\n    int spikeBallNum = 0;\n    \n        public void CreatePlatform()\n    {\n        int index = Random.Range(0, platform.Count);\n\n        if (index == 3)\n        {\n            spikeBallNum++;\n            if(spikeBallNum > 2)\n            {\n                index = 0;\n                spikeBallNum = 0;\n            }\n        }\n\n        GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );\n        newPlatform.transform.SetParent(transform);\n    }\n```\n\n当连续出现链锤时变成普通平台，免得出现必死局\n\n\n\n---\n\n\n\n### \t终、总结\n\n到此为止主要游戏内容都已经完成啦！最后就是制作一些UI管理游戏\n","slug":"2021-07-15-《Speed Down》Unity2d游戏开发（五）","published":1,"updated":"2021-07-15T13:58:35.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnime000if4u02gtt3sp3","content":"<h3 id=\"一、随机生成平台\"><a href=\"#一、随机生成平台\" class=\"headerlink\" title=\"一、随机生成平台\"></a>一、随机生成平台</h3><p>1.可以删除其他平台，只留下一个开局的平台</p>\n<p>2.新建一个空物体作为平台出生点，调整大小，添加碰撞体，勾选is trigger，修改标签为spike</p>\n<span id=\"more\"></span>\n\n<p>3.新建脚本挂载到平台出生点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Spawner : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public List&lt;GameObject&gt; platform = new List&lt;GameObject&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public float spawnTime;</span><br><span class=\"line\">    float countTime;</span><br><span class=\"line\">    Vector3 spawnPosition;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SpawnPlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void SpawnPlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        countTime += Time.deltaTime;</span><br><span class=\"line\">        spawnPosition = transform.position;</span><br><span class=\"line\">        spawnPosition.x = Random.Range(-3f, 3f);</span><br><span class=\"line\"></span><br><span class=\"line\">        if(countTime &gt; spawnTime)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            CreatePlatform();</span><br><span class=\"line\">            countTime = 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void CreatePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int index = Random.Range(0, platform.Count);</span><br><span class=\"line\">        Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.回到unity设置脚本中平台列表的大小为3并且拖入三种基础平台</p>\n<p>5.设置好生成速度Spawn Time就可以开始玩啦！</p>\n<hr>\n<h3 id=\"二、细节调整\"><a href=\"#二、细节调整\" class=\"headerlink\" title=\"二、细节调整\"></a>二、细节调整</h3><p>1.将链锤的锤子设置标签为spike（不小心删了链锤的预制体，我是sb，以后碰到警告操作不可撤回的要万分小心）</p>\n<p>2.角色检测碰到尖刺死亡的代码是在OnTriggerEnter2D中的，而顶部尖刺是触发器，链锤是碰撞器，需要将死亡代码复制到OnCollisionEnter2D中。注意两个函数接收的变量不同，需要按照提示修改一下</p>\n<p>3.改变平台列表的大小并拖入不同的平台，这样就可以调整游戏难度以及未来新增其他平台或者陷阱</p>\n<p>4.在平台出生点中修改代码，添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class=\"line\">newPlatform.transform.SetParent(transform);</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以让新生成的平台作为平台出生点的子物体</p>\n<p>5.为了不让链锤连续生成太多以至于游戏难度过大，修改spawn代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int spikeBallNum = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void CreatePlatform()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int index = Random.Range(0, platform.Count);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (index == 3)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        spikeBallNum++;</span><br><span class=\"line\">        if(spikeBallNum &gt; 2)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            index = 0;</span><br><span class=\"line\">            spikeBallNum = 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class=\"line\">    newPlatform.transform.SetParent(transform);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当连续出现链锤时变成普通平台，免得出现必死局</p>\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>到此为止主要游戏内容都已经完成啦！最后就是制作一些UI管理游戏</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"一、随机生成平台\"><a href=\"#一、随机生成平台\" class=\"headerlink\" title=\"一、随机生成平台\"></a>一、随机生成平台</h3><p>1.可以删除其他平台，只留下一个开局的平台</p>\n<p>2.新建一个空物体作为平台出生点，调整大小，添加碰撞体，勾选is trigger，修改标签为spike</p>","more":"<p>3.新建脚本挂载到平台出生点：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Spawner : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public List&lt;GameObject&gt; platform = new List&lt;GameObject&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public float spawnTime;</span><br><span class=\"line\">    float countTime;</span><br><span class=\"line\">    Vector3 spawnPosition;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SpawnPlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void SpawnPlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        countTime += Time.deltaTime;</span><br><span class=\"line\">        spawnPosition = transform.position;</span><br><span class=\"line\">        spawnPosition.x = Random.Range(-3f, 3f);</span><br><span class=\"line\"></span><br><span class=\"line\">        if(countTime &gt; spawnTime)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            CreatePlatform();</span><br><span class=\"line\">            countTime = 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void CreatePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int index = Random.Range(0, platform.Count);</span><br><span class=\"line\">        Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>4.回到unity设置脚本中平台列表的大小为3并且拖入三种基础平台</p>\n<p>5.设置好生成速度Spawn Time就可以开始玩啦！</p>\n<hr>\n<h3 id=\"二、细节调整\"><a href=\"#二、细节调整\" class=\"headerlink\" title=\"二、细节调整\"></a>二、细节调整</h3><p>1.将链锤的锤子设置标签为spike（不小心删了链锤的预制体，我是sb，以后碰到警告操作不可撤回的要万分小心）</p>\n<p>2.角色检测碰到尖刺死亡的代码是在OnTriggerEnter2D中的，而顶部尖刺是触发器，链锤是碰撞器，需要将死亡代码复制到OnCollisionEnter2D中。注意两个函数接收的变量不同，需要按照提示修改一下</p>\n<p>3.改变平台列表的大小并拖入不同的平台，这样就可以调整游戏难度以及未来新增其他平台或者陷阱</p>\n<p>4.在平台出生点中修改代码，添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class=\"line\">newPlatform.transform.SetParent(transform);</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以让新生成的平台作为平台出生点的子物体</p>\n<p>5.为了不让链锤连续生成太多以至于游戏难度过大，修改spawn代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int spikeBallNum = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void CreatePlatform()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int index = Random.Range(0, platform.Count);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (index == 3)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        spikeBallNum++;</span><br><span class=\"line\">        if(spikeBallNum &gt; 2)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            index = 0;</span><br><span class=\"line\">            spikeBallNum = 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class=\"line\">    newPlatform.transform.SetParent(transform);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当连续出现链锤时变成普通平台，免得出现必死局</p>\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>到此为止主要游戏内容都已经完成啦！最后就是制作一些UI管理游戏</p>"},{"title":"《Speed Down》Unity2d游戏开发（六）","date":"2021-07-15T10:22:45.000Z","_content":"\n\n\n### \t始、前言\n\n《Speed Down》开发已经接近尾声啦！最后再来完善一下，变成真正能玩的游戏！\n\n<!--more-->\n\n---\n\n\n\n### \t一、分数统计\n\n1.新建UI → Text 物体，发现自动创建了Canvas并将Text作为子物体添加\n\n2.调整Text的位置大小等参数直到满意\n\n3.新建空物体命名GameManage，新建脚本也命名GameManage并挂载到空物体GameManage上：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\n\npublic class GameManage : MonoBehaviour\n{\n    static GameManage instance;\n    public Text score;\n\n    private void Awake()\n    {\n        if(instance != null)\n        {\n            Destroy(gameObject);\n        }\n        instance = this;\n    }\n\n    void Update()\n    {\n        score.text = Time.time.ToString(\"000\");\n    }\n}\n```\n\nAwake会在所有的Start之前调用，适合用作游戏的初始化\n\n返回unity就可以看到随时间增加分数\n\n\n\n---\n\n\n\n### \t二、失败界面\n\n1.在Canvas下添加Panel并按自己喜欢布置界面，添加两个按钮用作重新开始游戏和退出游戏\n\n2.在GameManage脚本中添加：\n\n```\n    public void RestartGame()\n    {\n        SceneManager.LoadScene(SceneManager.GetActiveScene().name);\n        Time.timeScale = 1;\n    }\n    \n        public void Exit()\n    {\n        Application.Quit();\n    }\n```\n\n3.给两个按钮添加刚刚新建的方法\n\n按钮的功能已经设置好，其中退出游戏的功能需要在项目build之后才能看到效果。现在我们希望游戏失败界面在失败后出现\n\n4.取消勾选Panel的标签上面的框，这样就平时就不会显示Panel\n\n5.在GameManage中添加：\n\n```\n    public static void GameOver(bool dead)\n    {\n        if (dead)\n        {\n            Time.timeScale = 0f;\n            instance.gameOverUI.SetActive(true);\n        }\n    }\n```\n\n注意：想要在其他脚本中调用方法，需要定义方法成static类型\n\n6.在PlayerController脚本中修改PlayerDead方法：\n\n```\n    public void PlayerDead()\n    {\n        playerDead = true;\n        GameManage.GameOver(playerDead);\n    }\n```\n\n当角色死亡时就会弹出失败界面\n\n\n\n---\n\n\n\n### \t终、测试\n\n最后测试了一下，发现重新开始游戏时不会将分数重置，需要将GameManage脚本中的`Time.time.ToString`改成`Time.timeSinceLevelLoad.ToString`，这样一来时间计数就会在场景重置时重置。\n","source":"_posts/2021-07-15-《Speed Down》Unity2d游戏开发（六）.md","raw":"---\ntitle: 《Speed Down》Unity2d游戏开发（六）\ndate: 2021-07-15 18:22:45\ncategories: unity\ntags:\n  - unity\n  - c#\n  - awake\n  - canvas\n---\n\n\n\n### \t始、前言\n\n《Speed Down》开发已经接近尾声啦！最后再来完善一下，变成真正能玩的游戏！\n\n<!--more-->\n\n---\n\n\n\n### \t一、分数统计\n\n1.新建UI → Text 物体，发现自动创建了Canvas并将Text作为子物体添加\n\n2.调整Text的位置大小等参数直到满意\n\n3.新建空物体命名GameManage，新建脚本也命名GameManage并挂载到空物体GameManage上：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\n\npublic class GameManage : MonoBehaviour\n{\n    static GameManage instance;\n    public Text score;\n\n    private void Awake()\n    {\n        if(instance != null)\n        {\n            Destroy(gameObject);\n        }\n        instance = this;\n    }\n\n    void Update()\n    {\n        score.text = Time.time.ToString(\"000\");\n    }\n}\n```\n\nAwake会在所有的Start之前调用，适合用作游戏的初始化\n\n返回unity就可以看到随时间增加分数\n\n\n\n---\n\n\n\n### \t二、失败界面\n\n1.在Canvas下添加Panel并按自己喜欢布置界面，添加两个按钮用作重新开始游戏和退出游戏\n\n2.在GameManage脚本中添加：\n\n```\n    public void RestartGame()\n    {\n        SceneManager.LoadScene(SceneManager.GetActiveScene().name);\n        Time.timeScale = 1;\n    }\n    \n        public void Exit()\n    {\n        Application.Quit();\n    }\n```\n\n3.给两个按钮添加刚刚新建的方法\n\n按钮的功能已经设置好，其中退出游戏的功能需要在项目build之后才能看到效果。现在我们希望游戏失败界面在失败后出现\n\n4.取消勾选Panel的标签上面的框，这样就平时就不会显示Panel\n\n5.在GameManage中添加：\n\n```\n    public static void GameOver(bool dead)\n    {\n        if (dead)\n        {\n            Time.timeScale = 0f;\n            instance.gameOverUI.SetActive(true);\n        }\n    }\n```\n\n注意：想要在其他脚本中调用方法，需要定义方法成static类型\n\n6.在PlayerController脚本中修改PlayerDead方法：\n\n```\n    public void PlayerDead()\n    {\n        playerDead = true;\n        GameManage.GameOver(playerDead);\n    }\n```\n\n当角色死亡时就会弹出失败界面\n\n\n\n---\n\n\n\n### \t终、测试\n\n最后测试了一下，发现重新开始游戏时不会将分数重置，需要将GameManage脚本中的`Time.time.ToString`改成`Time.timeSinceLevelLoad.ToString`，这样一来时间计数就会在场景重置时重置。\n","slug":"2021-07-15-《Speed Down》Unity2d游戏开发（六）","published":1,"updated":"2021-07-17T09:59:47.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnimf000mf4u0827m5j3j","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>《Speed Down》开发已经接近尾声啦！最后再来完善一下，变成真正能玩的游戏！</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、分数统计\"><a href=\"#一、分数统计\" class=\"headerlink\" title=\"一、分数统计\"></a>一、分数统计</h3><p>1.新建UI → Text 物体，发现自动创建了Canvas并将Text作为子物体添加</p>\n<p>2.调整Text的位置大小等参数直到满意</p>\n<p>3.新建空物体命名GameManage，新建脚本也命名GameManage并挂载到空物体GameManage上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">using UnityEngine.UI;</span><br><span class=\"line\">using UnityEngine.SceneManagement;</span><br><span class=\"line\"></span><br><span class=\"line\">public class GameManage : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static GameManage instance;</span><br><span class=\"line\">    public Text score;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void Awake()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(instance != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        instance = this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        score.text = Time.time.ToString(&quot;000&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Awake会在所有的Start之前调用，适合用作游戏的初始化</p>\n<p>返回unity就可以看到随时间增加分数</p>\n<hr>\n<h3 id=\"二、失败界面\"><a href=\"#二、失败界面\" class=\"headerlink\" title=\"二、失败界面\"></a>二、失败界面</h3><p>1.在Canvas下添加Panel并按自己喜欢布置界面，添加两个按钮用作重新开始游戏和退出游戏</p>\n<p>2.在GameManage脚本中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void RestartGame()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SceneManager.LoadScene(SceneManager.GetActiveScene().name);</span><br><span class=\"line\">    Time.timeScale = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void Exit()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Application.Quit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.给两个按钮添加刚刚新建的方法</p>\n<p>按钮的功能已经设置好，其中退出游戏的功能需要在项目build之后才能看到效果。现在我们希望游戏失败界面在失败后出现</p>\n<p>4.取消勾选Panel的标签上面的框，这样就平时就不会显示Panel</p>\n<p>5.在GameManage中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void GameOver(bool dead)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (dead)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Time.timeScale = 0f;</span><br><span class=\"line\">        instance.gameOverUI.SetActive(true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：想要在其他脚本中调用方法，需要定义方法成static类型</p>\n<p>6.在PlayerController脚本中修改PlayerDead方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void PlayerDead()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    playerDead = true;</span><br><span class=\"line\">    GameManage.GameOver(playerDead);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当角色死亡时就会弹出失败界面</p>\n<hr>\n<h3 id=\"终、测试\"><a href=\"#终、测试\" class=\"headerlink\" title=\"终、测试\"></a>终、测试</h3><p>最后测试了一下，发现重新开始游戏时不会将分数重置，需要将GameManage脚本中的<code>Time.time.ToString</code>改成<code>Time.timeSinceLevelLoad.ToString</code>，这样一来时间计数就会在场景重置时重置。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>《Speed Down》开发已经接近尾声啦！最后再来完善一下，变成真正能玩的游戏！</p>","more":"<hr>\n<h3 id=\"一、分数统计\"><a href=\"#一、分数统计\" class=\"headerlink\" title=\"一、分数统计\"></a>一、分数统计</h3><p>1.新建UI → Text 物体，发现自动创建了Canvas并将Text作为子物体添加</p>\n<p>2.调整Text的位置大小等参数直到满意</p>\n<p>3.新建空物体命名GameManage，新建脚本也命名GameManage并挂载到空物体GameManage上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">using UnityEngine.UI;</span><br><span class=\"line\">using UnityEngine.SceneManagement;</span><br><span class=\"line\"></span><br><span class=\"line\">public class GameManage : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static GameManage instance;</span><br><span class=\"line\">    public Text score;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void Awake()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(instance != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        instance = this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        score.text = Time.time.ToString(&quot;000&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Awake会在所有的Start之前调用，适合用作游戏的初始化</p>\n<p>返回unity就可以看到随时间增加分数</p>\n<hr>\n<h3 id=\"二、失败界面\"><a href=\"#二、失败界面\" class=\"headerlink\" title=\"二、失败界面\"></a>二、失败界面</h3><p>1.在Canvas下添加Panel并按自己喜欢布置界面，添加两个按钮用作重新开始游戏和退出游戏</p>\n<p>2.在GameManage脚本中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void RestartGame()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SceneManager.LoadScene(SceneManager.GetActiveScene().name);</span><br><span class=\"line\">    Time.timeScale = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void Exit()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Application.Quit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>3.给两个按钮添加刚刚新建的方法</p>\n<p>按钮的功能已经设置好，其中退出游戏的功能需要在项目build之后才能看到效果。现在我们希望游戏失败界面在失败后出现</p>\n<p>4.取消勾选Panel的标签上面的框，这样就平时就不会显示Panel</p>\n<p>5.在GameManage中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static void GameOver(bool dead)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (dead)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Time.timeScale = 0f;</span><br><span class=\"line\">        instance.gameOverUI.SetActive(true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：想要在其他脚本中调用方法，需要定义方法成static类型</p>\n<p>6.在PlayerController脚本中修改PlayerDead方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void PlayerDead()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    playerDead = true;</span><br><span class=\"line\">    GameManage.GameOver(playerDead);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当角色死亡时就会弹出失败界面</p>\n<hr>\n<h3 id=\"终、测试\"><a href=\"#终、测试\" class=\"headerlink\" title=\"终、测试\"></a>终、测试</h3><p>最后测试了一下，发现重新开始游戏时不会将分数重置，需要将GameManage脚本中的<code>Time.time.ToString</code>改成<code>Time.timeSinceLevelLoad.ToString</code>，这样一来时间计数就会在场景重置时重置。</p>"},{"title":"【LeetCode.剑指Offer.42】连续子数组的最大和","date":"2021-07-17T07:01:11.000Z","_content":"\n\n\n\n\n### \t题目：连续子数组的最大和\n\n输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的**最大值**。\n\n要求时间复杂度为**O(n)**。\n\n \n\n示例1:\n\n```\n输入: nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n```\n\n<!--more-->\n\n提示：\n\n`1 <= arr.length <= 10^5`\n`-100 <= arr[i] <= 100`\n\n\n\n---\n\n\n\n### 分析：\n\n我们用` f(i)`代表以第` i `个数结尾的「连续子数组的最大和」\n\n只需要求出每个位置的` f(i)`，然后返回 `f `数组中的最大值即可。那么我们如何求` f(i) `呢？\n\n我们可以考虑 `nums[i] `单独成为一段还是加入` f(i-1) `对应的那一段，这取决于` nums[i] `和`f(i−1) + nums[i] `的大小，我们希望获得一个比较大的\n\n于是可以写出这样的动态规划转移方程：\n`f(i) = max{ f(i−1) + nums[i], nums[i] }`\n\n\n\n---\n\n\n\n### 题解：\n\n```\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> f(n);\n        f[0] = nums[0];\n        int ret = nums[0];\n\n        for (int i =  1; i < n; i++) {\n            f[i] = max(f[i - 1] + nums[i], nums[i]);\n            ret = max(f[i], ret);\n        }\n        return ret;\n    }\n};\n```\n\n时间复杂度O(n)，空间复杂度O(n)\n\n\n\n---\n\n\n\n### 改进：\n\n由于 `f[i]` 只是与 `f[i - 1]` 和 `nums[i]` 有关，且 `ret` 只与当前的 `f[i]` 有关，不需要存储整个数组\n\n```\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int nowMax = 0;\n        int ret = nums[0];\n        for (auto x : nums) {\n            nowMax = max(nowMax + x, x);\n            ret = max(nowMax, ret);\n        }\n        return ret;\n    }\n};\n```\n\n时间复杂度O(n)，空间复杂度O(1)\n\n\n\n---\n\n\n\n### 细节：\n\n1.只需求出最大值，不用求出最大的子数组\n\n","source":"_posts/2021-07-17-【LeetCode.剑指Offer.42】连续子数组的最大和.md","raw":"---\ntitle: 【LeetCode.剑指Offer.42】连续子数组的最大和\ndate: 2021-07-17 15:01:11\ncategories: 算法\ntags:\n  - c++\n  - 动态规划\n  - 数组\n---\n\n\n\n\n\n### \t题目：连续子数组的最大和\n\n输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的**最大值**。\n\n要求时间复杂度为**O(n)**。\n\n \n\n示例1:\n\n```\n输入: nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n```\n\n<!--more-->\n\n提示：\n\n`1 <= arr.length <= 10^5`\n`-100 <= arr[i] <= 100`\n\n\n\n---\n\n\n\n### 分析：\n\n我们用` f(i)`代表以第` i `个数结尾的「连续子数组的最大和」\n\n只需要求出每个位置的` f(i)`，然后返回 `f `数组中的最大值即可。那么我们如何求` f(i) `呢？\n\n我们可以考虑 `nums[i] `单独成为一段还是加入` f(i-1) `对应的那一段，这取决于` nums[i] `和`f(i−1) + nums[i] `的大小，我们希望获得一个比较大的\n\n于是可以写出这样的动态规划转移方程：\n`f(i) = max{ f(i−1) + nums[i], nums[i] }`\n\n\n\n---\n\n\n\n### 题解：\n\n```\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> f(n);\n        f[0] = nums[0];\n        int ret = nums[0];\n\n        for (int i =  1; i < n; i++) {\n            f[i] = max(f[i - 1] + nums[i], nums[i]);\n            ret = max(f[i], ret);\n        }\n        return ret;\n    }\n};\n```\n\n时间复杂度O(n)，空间复杂度O(n)\n\n\n\n---\n\n\n\n### 改进：\n\n由于 `f[i]` 只是与 `f[i - 1]` 和 `nums[i]` 有关，且 `ret` 只与当前的 `f[i]` 有关，不需要存储整个数组\n\n```\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int nowMax = 0;\n        int ret = nums[0];\n        for (auto x : nums) {\n            nowMax = max(nowMax + x, x);\n            ret = max(nowMax, ret);\n        }\n        return ret;\n    }\n};\n```\n\n时间复杂度O(n)，空间复杂度O(1)\n\n\n\n---\n\n\n\n### 细节：\n\n1.只需求出最大值，不用求出最大的子数组\n\n","slug":"2021-07-17-【LeetCode.剑指Offer.42】连续子数组的最大和","published":1,"updated":"2021-07-23T07:07:51.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnimh000of4u01yfr5av2","content":"<h3 id=\"题目：连续子数组的最大和\"><a href=\"#题目：连续子数组的最大和\" class=\"headerlink\" title=\"题目：连续子数组的最大和\"></a>题目：连续子数组的最大和</h3><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的<strong>最大值</strong>。</p>\n<p>要求时间复杂度为**O(n)**。</p>\n<p>示例1:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class=\"line\">输出: 6</span><br><span class=\"line\">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<p>提示：</p>\n<p><code>1 &lt;= arr.length &lt;= 10^5</code><br><code>-100 &lt;= arr[i] &lt;= 100</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>我们用<code> f(i)</code>代表以第<code>i</code>个数结尾的「连续子数组的最大和」</p>\n<p>只需要求出每个位置的<code> f(i)</code>，然后返回 <code>f </code>数组中的最大值即可。那么我们如何求<code>f(i)</code>呢？</p>\n<p>我们可以考虑 <code>nums[i] </code>单独成为一段还是加入<code>f(i-1)</code>对应的那一段，这取决于<code>nums[i]</code>和<code>f(i−1) + nums[i] </code>的大小，我们希望获得一个比较大的</p>\n<p>于是可以写出这样的动态规划转移方程：<br><code>f(i) = max&#123; f(i−1) + nums[i], nums[i] &#125;</code></p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        int n = nums.size();</span><br><span class=\"line\">        vector&lt;int&gt; f(n);</span><br><span class=\"line\">        f[0] = nums[0];</span><br><span class=\"line\">        int ret = nums[0];</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i =  1; i &lt; n; i++) &#123;</span><br><span class=\"line\">            f[i] = max(f[i - 1] + nums[i], nums[i]);</span><br><span class=\"line\">            ret = max(f[i], ret);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n)，空间复杂度O(n)</p>\n<hr>\n<h3 id=\"改进：\"><a href=\"#改进：\" class=\"headerlink\" title=\"改进：\"></a>改进：</h3><p>由于 <code>f[i]</code> 只是与 <code>f[i - 1]</code> 和 <code>nums[i]</code> 有关，且 <code>ret</code> 只与当前的 <code>f[i]</code> 有关，不需要存储整个数组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        int nowMax = 0;</span><br><span class=\"line\">        int ret = nums[0];</span><br><span class=\"line\">        for (auto x : nums) &#123;</span><br><span class=\"line\">            nowMax = max(nowMax + x, x);</span><br><span class=\"line\">            ret = max(nowMax, ret);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n)，空间复杂度O(1)</p>\n<hr>\n<h3 id=\"细节：\"><a href=\"#细节：\" class=\"headerlink\" title=\"细节：\"></a>细节：</h3><p>1.只需求出最大值，不用求出最大的子数组</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"题目：连续子数组的最大和\"><a href=\"#题目：连续子数组的最大和\" class=\"headerlink\" title=\"题目：连续子数组的最大和\"></a>题目：连续子数组的最大和</h3><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的<strong>最大值</strong>。</p>\n<p>要求时间复杂度为**O(n)**。</p>\n<p>示例1:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class=\"line\">输出: 6</span><br><span class=\"line\">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>","more":"<p>提示：</p>\n<p><code>1 &lt;= arr.length &lt;= 10^5</code><br><code>-100 &lt;= arr[i] &lt;= 100</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>我们用<code> f(i)</code>代表以第<code>i</code>个数结尾的「连续子数组的最大和」</p>\n<p>只需要求出每个位置的<code> f(i)</code>，然后返回 <code>f </code>数组中的最大值即可。那么我们如何求<code>f(i)</code>呢？</p>\n<p>我们可以考虑 <code>nums[i] </code>单独成为一段还是加入<code>f(i-1)</code>对应的那一段，这取决于<code>nums[i]</code>和<code>f(i−1) + nums[i] </code>的大小，我们希望获得一个比较大的</p>\n<p>于是可以写出这样的动态规划转移方程：<br><code>f(i) = max&#123; f(i−1) + nums[i], nums[i] &#125;</code></p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        int n = nums.size();</span><br><span class=\"line\">        vector&lt;int&gt; f(n);</span><br><span class=\"line\">        f[0] = nums[0];</span><br><span class=\"line\">        int ret = nums[0];</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i =  1; i &lt; n; i++) &#123;</span><br><span class=\"line\">            f[i] = max(f[i - 1] + nums[i], nums[i]);</span><br><span class=\"line\">            ret = max(f[i], ret);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n)，空间复杂度O(n)</p>\n<hr>\n<h3 id=\"改进：\"><a href=\"#改进：\" class=\"headerlink\" title=\"改进：\"></a>改进：</h3><p>由于 <code>f[i]</code> 只是与 <code>f[i - 1]</code> 和 <code>nums[i]</code> 有关，且 <code>ret</code> 只与当前的 <code>f[i]</code> 有关，不需要存储整个数组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class=\"line\">        int nowMax = 0;</span><br><span class=\"line\">        int ret = nums[0];</span><br><span class=\"line\">        for (auto x : nums) &#123;</span><br><span class=\"line\">            nowMax = max(nowMax + x, x);</span><br><span class=\"line\">            ret = max(nowMax, ret);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O(n)，空间复杂度O(1)</p>\n<hr>\n<h3 id=\"细节：\"><a href=\"#细节：\" class=\"headerlink\" title=\"细节：\"></a>细节：</h3><p>1.只需求出最大值，不用求出最大的子数组</p>"},{"title":"《Speed Down》Unity2d游戏开发（完）","date":"2021-07-16T10:02:46.000Z","_content":"\n\n\n### \t始、前言\n\n”《Speed Down》Unity2d游戏开发“系列已经完结，这篇文章主要是复盘这次学习中遇到的问题和一些名词的解释，以供未来的我快速回顾，最后还会附上所有的脚本\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、素材\n\n素材这块完全不用自己制作嘛，光是这个Assetstore就有挺多素材的，而且很多无限制商用的，有空要收集一些可以白嫖的网站\n\n\n\n---\n\n\n\n### 二、2D 复合碰撞体 (Composite Collider 2D)\n\n2D 复合碰撞体组件是用于 2D 物理的碰撞体。与大多数碰撞体不同，此碰撞体没有定义固有的形状。相反，此碰撞体将合并所设置的 2D 盒型碰撞体 (Box Collider 2D) 或 2D 多边形碰撞体 (Polygon Collider 2D) 的形状。2D 复合碰撞体使用所有此类碰撞体的顶点（几何体），并将这些顶点合并为由 2D 复合碰撞体本身控制的新几何体。\n\n2D 盒型碰撞体和 2D 多边形碰撞体组件具有 Used By Composite 复选框。勾选此复选框即可将这些碰撞体附加到 2D 复合碰撞体。这些碰撞体还与 2D 复合碰撞体附加到同一 2D 刚体。启用 Used by Composite 时，其他属性会从该组件中消失，因为这些属性现在由附加的 2D 复合碰撞体控制。\n\n\n\n---\n\n\n\n### 三、Pixels Per Unit（PPU）\n\n在Inspector面板的图像设置中有一个Pixels Per Unit参数。它代表Unity的一个单位长度包含本图片多少个像素\n 在Unity中创建的Cube等基本图形默认就是一个Unity单位长度，一个单位长度在unity世界坐标中代表1米\n 例如默认值为100，则代表一个Unity单位包含本图片中100个像素\n\n\n\n---\n\n\n\n### 四、关节（joint）\n\n关节组件可以添加至多个游戏对象中，而添加关节的游戏对象将通过关节连接在一起并且感觉连带的物理效果。需要注意的是：关节必须依赖于刚体组件。所有 2D 关节的名称都以“2D”结尾。名称不以“2D”结尾的关节是 3D 关节。2D 关节用于 2D 游戏对象，而 3D 关节用于 3D 游戏对象。\n\n\n\n**3D关节**：\n\n**链条关节（hinge joint）**：将两个物体以链条的形式绑在一起，当力量大于链条的固定力矩时，两个物体就会产生相互的拉力。\n\n**固定关节（fixed joint）**：将两个物体永远以相对的位置固定在一起，即使发生物理改变，它们之间的相对位置也将不变。\n\n**弹簧关节（spring joint）**：将两个物体以弹簧的形式绑定在一起，挤压它们会得到向外的力，拉伸它们将得到向里的力。\n\n**角色关节（character joint）**：可以模拟角色的骨骼关节。\n\n**可配置关节（configurable joint）**：可以模拟任意关节的效果。\n\n\n\n**2D关节**：\n\n**2D 距离关节 (Distance Joint 2D)** - 连接由刚体物理组件控制的两个游戏对象，使这两个对象保持一定距离。\n\n**2D 固定关节 (Fixed Joint 2D)** - 将两个对象保持在相对于彼此的位置，确保对象始终以给定位置和角度偏移。例如，对象好像是采用刚性连接方式相连一样：对象不能彼此远离，不能相互靠近，也不能相对于彼此旋转。还可以使用此关节来创建刚度稍低的柔性连接。\n\n**2D 摩擦关节 (Friction Joint 2D)** - 将刚体物理组件控制的两个游戏对象之间的线速度和角速度降低到零（即：此关节使对象减速并停止）。例如，一个平台在旋转但抵抗该运动。\n\n**2D 铰链关节 (Hinge Joint 2D)** - 允许由刚体物理组件控制的游戏对象连接到空间中的一个点，使游戏对象可围绕该点旋转。例如，一把剪刀上的轴心。\n\n**2D 相对关节 (Relative Joint 2D)** - 允许由刚体物理组件控制的两个游戏对象基于彼此的位置来保持相对位置。使用此关节可将两个对象保持相互偏移。例如，在空间射击游戏中，玩家身后有额外的排炮。\n\n**2D 滑动关节 (Slider Joint 2D)** - 允许由刚体物理组件控制的游戏对象沿着空间中的一条线滑动（例如滑门）。\n\n**2D 弹簧关节 (Spring Joint 2D)** - 允许由刚体物理组件控制的两个游戏对象就像通过弹簧连接在一起一样。\n\n**2D 目标关节 (Target Joint 2D)** - 连接到指定目标，而不是像其他关节那样连接到另一个刚体对象。这是一种弹簧式关节，例如可将其用于拾取和移动处于重力作用下的对象。\n\n**2D 车轮关节 (Wheel Joint 2D)** - 模拟车轮和悬架。\n\n\n\n在关节这方面2D的花样比3D多\n\n\n\n---\n\n\n\n### 五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）\n\n要产生碰撞必须为游戏对象添加刚体（Rigidbody）和碰撞器，刚体可以让物体在物理影响下运动。碰撞体是物理组件的一类，它要与刚体一起添加到游戏对象上才能触发碰撞。如果两个刚体相互撞在一起，除非两个对象有碰撞体时物理引擎才会计算碰撞，在物理模拟中，没有碰撞体的刚体会彼此相互穿过。\n\n**物体发生碰撞的必要条件**：\n\n两个物体都必须带有碰撞器(Collider)，其中一个物体还必须带有Rigidbody刚体。\n\n在unity3d中，能检测碰撞发生的方式有两种，一种是利用碰撞器，另一种则是利用触发器。\n\n碰撞器：一群组件，它包含了很多种类，比如：Box Collider（盒碰撞体），Mesh Collider（网格碰撞体）等，这些碰撞器应用的场合不同，但都必须加到GameObjecet身上。\n\n触发器：只需要在检视面板中的碰撞器组件中勾选IsTrigger属性选择框。\n\n**触发信息检测**：\n\n1.MonoBehaviour.OnTriggerEnter(Collider collider)当进入触发器\n\n2.MonoBehaviour.OnTriggerExit(Collider collider)当退出触发器\n\n3.MonoBehaviour.OnTriggerStay(Collider collider)当逗留触发器\n\n**碰撞信息检测**：\n\n1.MonoBehaviour.OnCollisionEnter(Collision collision) 当进入碰撞器\n\n2.MonoBehaviour.OnCollisionExit(Collision collision) 当退出碰撞器\n\n3.MonoBehaviour.OnCollisionStay(Collision collision) 当逗留碰撞器\n\n**碰撞器和触发器的区别？**\n\n碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性\n\n当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；\n\n当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。\n\n也就是说在一次碰撞中，碰撞函数和触发函数只能二选一\n\n\n\n---\n\n\n\n### 六、预制体（Prefab）\n\n什么是预制体：\n\n在进行一些功能开发的时候, 我们常常将一些能够复用的对象制作成.prefab的预制体，然后将预制体存放到 Resources 目录之下, 使用时再动态加载到场景中并进行实例化. 例如 : 子弹、特效甚至音频等, 都能制作成预制体.\n\n预制体英文名称即 Prefab 是一种资源类型 —— 存储在项目视图中的一种可重复使用的游戏对象.\n\n预制体的优点：\n预制体可以多次放入到多个场景中;\n当你添加一个预制体到场景中, 就创建了它的一个实例;\n所有的预制体实例链接到原始预制, 基本上等于就是它的克隆;\n不管你的项目存在多少实例, 当你对预制体进行任何更改, 你将看到这些更改将应用于所有的实例上;\n\n\n\n---\n\n\n\n### 七、画布（Canvas）\n\nCanvas (画布) 是所有 UI 组件的父物体 , 也就是说每一个 UI 组件都必须在 Canvas 下 , 作为 Canvas 的子物体 , 当你创建一个 UI 控件时 , 如果在 Hierarchy 视图没有 Canvas 组件的话 , unity会自动帮你创建一个 Canvas , 并将你想创建的 UI 控件置于 Canvas 下.\n\nCanvas 的 Render Mode (渲染模式) 有三种 ：\n\n1.**Screen Space - Overlay**\n\n这种渲染模式表示 Canvas 下的所有的 UI 控件永远位于屏幕的前面 , 不管有没有相机 , UI元素永远在屏幕最前面\n\n2.**Screen Space - Camera**\n\n这种渲染模式 Canvas 和 摄像机之间有一定的距离 , 可以在摄像机和 Canvas 之间播放一些粒子特效\n\n3.**World Space**\n\n这种模式下 Canvas 就和普通的 3D 物体一样了 , 可以控制它的大小,旋转,缩放等 , 一般用来做血条\n\n\n\n---\n\n\n\n### 终、总结\n\n作为unity回坑第一课收获还是蛮丰富的，以前一直没有做笔记的习惯，东西学了又忘，忘了还没地方复习，以后要养成写学习日记的习惯。\n\n这次写的脚本都没有写注释，希望未来的我回来看的时候不会头大吧哈哈哈（这么简单的代码应该不至于）\n\n\n\n---\n\n\n\n### \t附录、脚本\n\n1.角色控制脚本，控制角色移动和检测角色状态：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerController : MonoBehaviour\n{\n    Rigidbody2D rb;\n    Animator anim;\n    public float speed;\n    float xVelocity;\n\n    public bool isOnGround;\n    public float checkRadius;\n    public LayerMask layer;\n    public GameObject groundCheck;\n\n    public bool playerDead;\n\n    public float bounceH;\n    \n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        anim = GetComponent<Animator>();\n    }\n\n    void Update()\n    {\n        Movement();\n        isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);\n        anim.SetBool(\"isOnGround\", isOnGround);\n    }\n\n    void Movement()\n    {\n        xVelocity = Input.GetAxisRaw(\"Horizontal\");\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n        anim.SetFloat(\"speed\", Mathf.Abs(rb.velocity.x));\n\n        if(xVelocity != 0)\n        {\n            transform.localScale = new Vector3(xVelocity, 1, 1);\n        }\n    }\n\n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Fan\"))\n        {\n            rb.velocity = new Vector2(rb.velocity.x, bounceH);\n        }\n        if (collision.gameObject.CompareTag(\"Spike\"))\n        {\n            anim.SetTrigger(\"isDead\");\n        }\n    }\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if (collision.CompareTag(\"Spike\"))\n        {\n            anim.SetTrigger(\"isDead\");\n        }\n    }\n\n    public void PlayerDead()\n    {\n        playerDead = true;\n        GameManage.GameOver(playerDead);\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);\n    }\n}\n```\n\n\n\n2.游戏管理脚本，涉及游戏重开和退出，以及控制界面：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\n\npublic class GameManage : MonoBehaviour\n{\n    static GameManage instance;\n    public Text score;\n\n    public GameObject gameOverUI;\n\n    private void Awake()\n    {\n        if(instance != null)\n        {\n            Destroy(gameObject);\n        }\n        instance = this;\n    }\n\n    void Update()\n    {\n        score.text = Time.timeSinceLevelLoad.ToString(\"000\");\n    }\n\n    public void RestartGame()\n    {\n        SceneManager.LoadScene(SceneManager.GetActiveScene().name);\n        Time.timeScale = 1;\n    }\n\n    public void Exit()\n    {\n        Application.Quit();\n    }\n\n    public static void GameOver(bool dead)\n    {\n        if (dead)\n        {\n            Time.timeScale = 0f;\n            instance.gameOverUI.SetActive(true);\n        }\n    }\n}\n```\n\n\n\n3.平台生成脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Spawner : MonoBehaviour\n{\n    public List<GameObject> platform = new List<GameObject>();\n\n    public float spawnTime;\n    float countTime;\n    Vector3 spawnPosition;\n\n    int spikeBallNum = 0;\n\n    void Update()\n    {\n        SpawnPlatform();\n    }\n\n    public void SpawnPlatform()\n    {\n        countTime += Time.deltaTime;\n        spawnPosition = transform.position;\n        spawnPosition.x = Random.Range(-3f, 3f);\n\n        if(countTime > spawnTime)\n        {\n            CreatePlatform();\n            countTime = 0;\n        }\n\n    }\n\n    public void CreatePlatform()\n    {\n        int index = Random.Range(0, platform.Count);\n\n        if (index == 3)\n        {\n            spikeBallNum++;\n            if(spikeBallNum > 2)\n            {\n                index = 0;\n                spikeBallNum = 0;\n            }\n        }\n\n        GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );\n        newPlatform.transform.SetParent(transform);\n    }\n}\n```\n\n\n\n4.平台上升脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlatformUp : MonoBehaviour\n{\n    Vector3 movement;\n    public float speed;\n    GameObject topLine;\n\n    void Start()\n    {\n        movement.y = speed;\n        topLine = GameObject.Find(\"TopLine\");\n    }\n\n\n    void Update()\n    {\n        MovePlatform();\n    }\n\n    void MovePlatform()\n    {\n        transform.position += movement * Time.deltaTime;\n        if(transform.position.y > topLine.transform.position.y)\n        {\n            Destroy(gameObject);\n        }\n    }\n}\n\n```\n\n\n\n5.链锤画线脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class SpikeBallLine : MonoBehaviour\n{\n\n    LineRenderer line;\n    public Transform begin;\n    public Transform end;\n\n    void Start()\n    {\n        line = GetComponent<LineRenderer>();\n\n    }\n\n    void Update()\n    {\n        line.SetPosition(0, begin.position);\n        line.SetPosition(1, end.position);\n    }\n}\n```\n\n\n\n6.跳跃平台旋转动画脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class FanRun : MonoBehaviour\n{\n    Animator animator;\n    void Start()\n    {\n        animator = GetComponent<Animator>();\n    }\n\n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            animator.Play(\"Fan_run\");\n        }\n    }\n\n}\n```\n\n","source":"_posts/2021-07-16-《Speed Down》Unity2d游戏开发（完）.md","raw":"---\ntitle: 《Speed Down》Unity2d游戏开发（完）\ndate: 2021-07-16 18:02:46\ncategories: unity\ntags:\n  - unity\n  - c#\n  - collider\n  - joint\n  - trigger\n  - prefab\n  - canvas\n---\n\n\n\n### \t始、前言\n\n”《Speed Down》Unity2d游戏开发“系列已经完结，这篇文章主要是复盘这次学习中遇到的问题和一些名词的解释，以供未来的我快速回顾，最后还会附上所有的脚本\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、素材\n\n素材这块完全不用自己制作嘛，光是这个Assetstore就有挺多素材的，而且很多无限制商用的，有空要收集一些可以白嫖的网站\n\n\n\n---\n\n\n\n### 二、2D 复合碰撞体 (Composite Collider 2D)\n\n2D 复合碰撞体组件是用于 2D 物理的碰撞体。与大多数碰撞体不同，此碰撞体没有定义固有的形状。相反，此碰撞体将合并所设置的 2D 盒型碰撞体 (Box Collider 2D) 或 2D 多边形碰撞体 (Polygon Collider 2D) 的形状。2D 复合碰撞体使用所有此类碰撞体的顶点（几何体），并将这些顶点合并为由 2D 复合碰撞体本身控制的新几何体。\n\n2D 盒型碰撞体和 2D 多边形碰撞体组件具有 Used By Composite 复选框。勾选此复选框即可将这些碰撞体附加到 2D 复合碰撞体。这些碰撞体还与 2D 复合碰撞体附加到同一 2D 刚体。启用 Used by Composite 时，其他属性会从该组件中消失，因为这些属性现在由附加的 2D 复合碰撞体控制。\n\n\n\n---\n\n\n\n### 三、Pixels Per Unit（PPU）\n\n在Inspector面板的图像设置中有一个Pixels Per Unit参数。它代表Unity的一个单位长度包含本图片多少个像素\n 在Unity中创建的Cube等基本图形默认就是一个Unity单位长度，一个单位长度在unity世界坐标中代表1米\n 例如默认值为100，则代表一个Unity单位包含本图片中100个像素\n\n\n\n---\n\n\n\n### 四、关节（joint）\n\n关节组件可以添加至多个游戏对象中，而添加关节的游戏对象将通过关节连接在一起并且感觉连带的物理效果。需要注意的是：关节必须依赖于刚体组件。所有 2D 关节的名称都以“2D”结尾。名称不以“2D”结尾的关节是 3D 关节。2D 关节用于 2D 游戏对象，而 3D 关节用于 3D 游戏对象。\n\n\n\n**3D关节**：\n\n**链条关节（hinge joint）**：将两个物体以链条的形式绑在一起，当力量大于链条的固定力矩时，两个物体就会产生相互的拉力。\n\n**固定关节（fixed joint）**：将两个物体永远以相对的位置固定在一起，即使发生物理改变，它们之间的相对位置也将不变。\n\n**弹簧关节（spring joint）**：将两个物体以弹簧的形式绑定在一起，挤压它们会得到向外的力，拉伸它们将得到向里的力。\n\n**角色关节（character joint）**：可以模拟角色的骨骼关节。\n\n**可配置关节（configurable joint）**：可以模拟任意关节的效果。\n\n\n\n**2D关节**：\n\n**2D 距离关节 (Distance Joint 2D)** - 连接由刚体物理组件控制的两个游戏对象，使这两个对象保持一定距离。\n\n**2D 固定关节 (Fixed Joint 2D)** - 将两个对象保持在相对于彼此的位置，确保对象始终以给定位置和角度偏移。例如，对象好像是采用刚性连接方式相连一样：对象不能彼此远离，不能相互靠近，也不能相对于彼此旋转。还可以使用此关节来创建刚度稍低的柔性连接。\n\n**2D 摩擦关节 (Friction Joint 2D)** - 将刚体物理组件控制的两个游戏对象之间的线速度和角速度降低到零（即：此关节使对象减速并停止）。例如，一个平台在旋转但抵抗该运动。\n\n**2D 铰链关节 (Hinge Joint 2D)** - 允许由刚体物理组件控制的游戏对象连接到空间中的一个点，使游戏对象可围绕该点旋转。例如，一把剪刀上的轴心。\n\n**2D 相对关节 (Relative Joint 2D)** - 允许由刚体物理组件控制的两个游戏对象基于彼此的位置来保持相对位置。使用此关节可将两个对象保持相互偏移。例如，在空间射击游戏中，玩家身后有额外的排炮。\n\n**2D 滑动关节 (Slider Joint 2D)** - 允许由刚体物理组件控制的游戏对象沿着空间中的一条线滑动（例如滑门）。\n\n**2D 弹簧关节 (Spring Joint 2D)** - 允许由刚体物理组件控制的两个游戏对象就像通过弹簧连接在一起一样。\n\n**2D 目标关节 (Target Joint 2D)** - 连接到指定目标，而不是像其他关节那样连接到另一个刚体对象。这是一种弹簧式关节，例如可将其用于拾取和移动处于重力作用下的对象。\n\n**2D 车轮关节 (Wheel Joint 2D)** - 模拟车轮和悬架。\n\n\n\n在关节这方面2D的花样比3D多\n\n\n\n---\n\n\n\n### 五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）\n\n要产生碰撞必须为游戏对象添加刚体（Rigidbody）和碰撞器，刚体可以让物体在物理影响下运动。碰撞体是物理组件的一类，它要与刚体一起添加到游戏对象上才能触发碰撞。如果两个刚体相互撞在一起，除非两个对象有碰撞体时物理引擎才会计算碰撞，在物理模拟中，没有碰撞体的刚体会彼此相互穿过。\n\n**物体发生碰撞的必要条件**：\n\n两个物体都必须带有碰撞器(Collider)，其中一个物体还必须带有Rigidbody刚体。\n\n在unity3d中，能检测碰撞发生的方式有两种，一种是利用碰撞器，另一种则是利用触发器。\n\n碰撞器：一群组件，它包含了很多种类，比如：Box Collider（盒碰撞体），Mesh Collider（网格碰撞体）等，这些碰撞器应用的场合不同，但都必须加到GameObjecet身上。\n\n触发器：只需要在检视面板中的碰撞器组件中勾选IsTrigger属性选择框。\n\n**触发信息检测**：\n\n1.MonoBehaviour.OnTriggerEnter(Collider collider)当进入触发器\n\n2.MonoBehaviour.OnTriggerExit(Collider collider)当退出触发器\n\n3.MonoBehaviour.OnTriggerStay(Collider collider)当逗留触发器\n\n**碰撞信息检测**：\n\n1.MonoBehaviour.OnCollisionEnter(Collision collision) 当进入碰撞器\n\n2.MonoBehaviour.OnCollisionExit(Collision collision) 当退出碰撞器\n\n3.MonoBehaviour.OnCollisionStay(Collision collision) 当逗留碰撞器\n\n**碰撞器和触发器的区别？**\n\n碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性\n\n当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；\n\n当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。\n\n也就是说在一次碰撞中，碰撞函数和触发函数只能二选一\n\n\n\n---\n\n\n\n### 六、预制体（Prefab）\n\n什么是预制体：\n\n在进行一些功能开发的时候, 我们常常将一些能够复用的对象制作成.prefab的预制体，然后将预制体存放到 Resources 目录之下, 使用时再动态加载到场景中并进行实例化. 例如 : 子弹、特效甚至音频等, 都能制作成预制体.\n\n预制体英文名称即 Prefab 是一种资源类型 —— 存储在项目视图中的一种可重复使用的游戏对象.\n\n预制体的优点：\n预制体可以多次放入到多个场景中;\n当你添加一个预制体到场景中, 就创建了它的一个实例;\n所有的预制体实例链接到原始预制, 基本上等于就是它的克隆;\n不管你的项目存在多少实例, 当你对预制体进行任何更改, 你将看到这些更改将应用于所有的实例上;\n\n\n\n---\n\n\n\n### 七、画布（Canvas）\n\nCanvas (画布) 是所有 UI 组件的父物体 , 也就是说每一个 UI 组件都必须在 Canvas 下 , 作为 Canvas 的子物体 , 当你创建一个 UI 控件时 , 如果在 Hierarchy 视图没有 Canvas 组件的话 , unity会自动帮你创建一个 Canvas , 并将你想创建的 UI 控件置于 Canvas 下.\n\nCanvas 的 Render Mode (渲染模式) 有三种 ：\n\n1.**Screen Space - Overlay**\n\n这种渲染模式表示 Canvas 下的所有的 UI 控件永远位于屏幕的前面 , 不管有没有相机 , UI元素永远在屏幕最前面\n\n2.**Screen Space - Camera**\n\n这种渲染模式 Canvas 和 摄像机之间有一定的距离 , 可以在摄像机和 Canvas 之间播放一些粒子特效\n\n3.**World Space**\n\n这种模式下 Canvas 就和普通的 3D 物体一样了 , 可以控制它的大小,旋转,缩放等 , 一般用来做血条\n\n\n\n---\n\n\n\n### 终、总结\n\n作为unity回坑第一课收获还是蛮丰富的，以前一直没有做笔记的习惯，东西学了又忘，忘了还没地方复习，以后要养成写学习日记的习惯。\n\n这次写的脚本都没有写注释，希望未来的我回来看的时候不会头大吧哈哈哈（这么简单的代码应该不至于）\n\n\n\n---\n\n\n\n### \t附录、脚本\n\n1.角色控制脚本，控制角色移动和检测角色状态：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerController : MonoBehaviour\n{\n    Rigidbody2D rb;\n    Animator anim;\n    public float speed;\n    float xVelocity;\n\n    public bool isOnGround;\n    public float checkRadius;\n    public LayerMask layer;\n    public GameObject groundCheck;\n\n    public bool playerDead;\n\n    public float bounceH;\n    \n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        anim = GetComponent<Animator>();\n    }\n\n    void Update()\n    {\n        Movement();\n        isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);\n        anim.SetBool(\"isOnGround\", isOnGround);\n    }\n\n    void Movement()\n    {\n        xVelocity = Input.GetAxisRaw(\"Horizontal\");\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n        anim.SetFloat(\"speed\", Mathf.Abs(rb.velocity.x));\n\n        if(xVelocity != 0)\n        {\n            transform.localScale = new Vector3(xVelocity, 1, 1);\n        }\n    }\n\n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Fan\"))\n        {\n            rb.velocity = new Vector2(rb.velocity.x, bounceH);\n        }\n        if (collision.gameObject.CompareTag(\"Spike\"))\n        {\n            anim.SetTrigger(\"isDead\");\n        }\n    }\n    private void OnTriggerEnter2D(Collider2D collision)\n    {\n        if (collision.CompareTag(\"Spike\"))\n        {\n            anim.SetTrigger(\"isDead\");\n        }\n    }\n\n    public void PlayerDead()\n    {\n        playerDead = true;\n        GameManage.GameOver(playerDead);\n    }\n\n    private void OnDrawGizmosSelected()\n    {\n        Gizmos.color = Color.green;\n        Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);\n    }\n}\n```\n\n\n\n2.游戏管理脚本，涉及游戏重开和退出，以及控制界面：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\nusing UnityEngine.UI;\nusing UnityEngine.SceneManagement;\n\npublic class GameManage : MonoBehaviour\n{\n    static GameManage instance;\n    public Text score;\n\n    public GameObject gameOverUI;\n\n    private void Awake()\n    {\n        if(instance != null)\n        {\n            Destroy(gameObject);\n        }\n        instance = this;\n    }\n\n    void Update()\n    {\n        score.text = Time.timeSinceLevelLoad.ToString(\"000\");\n    }\n\n    public void RestartGame()\n    {\n        SceneManager.LoadScene(SceneManager.GetActiveScene().name);\n        Time.timeScale = 1;\n    }\n\n    public void Exit()\n    {\n        Application.Quit();\n    }\n\n    public static void GameOver(bool dead)\n    {\n        if (dead)\n        {\n            Time.timeScale = 0f;\n            instance.gameOverUI.SetActive(true);\n        }\n    }\n}\n```\n\n\n\n3.平台生成脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class Spawner : MonoBehaviour\n{\n    public List<GameObject> platform = new List<GameObject>();\n\n    public float spawnTime;\n    float countTime;\n    Vector3 spawnPosition;\n\n    int spikeBallNum = 0;\n\n    void Update()\n    {\n        SpawnPlatform();\n    }\n\n    public void SpawnPlatform()\n    {\n        countTime += Time.deltaTime;\n        spawnPosition = transform.position;\n        spawnPosition.x = Random.Range(-3f, 3f);\n\n        if(countTime > spawnTime)\n        {\n            CreatePlatform();\n            countTime = 0;\n        }\n\n    }\n\n    public void CreatePlatform()\n    {\n        int index = Random.Range(0, platform.Count);\n\n        if (index == 3)\n        {\n            spikeBallNum++;\n            if(spikeBallNum > 2)\n            {\n                index = 0;\n                spikeBallNum = 0;\n            }\n        }\n\n        GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );\n        newPlatform.transform.SetParent(transform);\n    }\n}\n```\n\n\n\n4.平台上升脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlatformUp : MonoBehaviour\n{\n    Vector3 movement;\n    public float speed;\n    GameObject topLine;\n\n    void Start()\n    {\n        movement.y = speed;\n        topLine = GameObject.Find(\"TopLine\");\n    }\n\n\n    void Update()\n    {\n        MovePlatform();\n    }\n\n    void MovePlatform()\n    {\n        transform.position += movement * Time.deltaTime;\n        if(transform.position.y > topLine.transform.position.y)\n        {\n            Destroy(gameObject);\n        }\n    }\n}\n\n```\n\n\n\n5.链锤画线脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class SpikeBallLine : MonoBehaviour\n{\n\n    LineRenderer line;\n    public Transform begin;\n    public Transform end;\n\n    void Start()\n    {\n        line = GetComponent<LineRenderer>();\n\n    }\n\n    void Update()\n    {\n        line.SetPosition(0, begin.position);\n        line.SetPosition(1, end.position);\n    }\n}\n```\n\n\n\n6.跳跃平台旋转动画脚本：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class FanRun : MonoBehaviour\n{\n    Animator animator;\n    void Start()\n    {\n        animator = GetComponent<Animator>();\n    }\n\n    private void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.CompareTag(\"Player\"))\n        {\n            animator.Play(\"Fan_run\");\n        }\n    }\n\n}\n```\n\n","slug":"2021-07-16-《Speed Down》Unity2d游戏开发（完）","published":1,"updated":"2021-07-16T15:54:37.431Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnimi000rf4u06yi8defz","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>”《Speed Down》Unity2d游戏开发“系列已经完结，这篇文章主要是复盘这次学习中遇到的问题和一些名词的解释，以供未来的我快速回顾，最后还会附上所有的脚本</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、素材\"><a href=\"#一、素材\" class=\"headerlink\" title=\"一、素材\"></a>一、素材</h3><p>素材这块完全不用自己制作嘛，光是这个Assetstore就有挺多素材的，而且很多无限制商用的，有空要收集一些可以白嫖的网站</p>\n<hr>\n<h3 id=\"二、2D-复合碰撞体-Composite-Collider-2D\"><a href=\"#二、2D-复合碰撞体-Composite-Collider-2D\" class=\"headerlink\" title=\"二、2D 复合碰撞体 (Composite Collider 2D)\"></a>二、2D 复合碰撞体 (Composite Collider 2D)</h3><p>2D 复合碰撞体组件是用于 2D 物理的碰撞体。与大多数碰撞体不同，此碰撞体没有定义固有的形状。相反，此碰撞体将合并所设置的 2D 盒型碰撞体 (Box Collider 2D) 或 2D 多边形碰撞体 (Polygon Collider 2D) 的形状。2D 复合碰撞体使用所有此类碰撞体的顶点（几何体），并将这些顶点合并为由 2D 复合碰撞体本身控制的新几何体。</p>\n<p>2D 盒型碰撞体和 2D 多边形碰撞体组件具有 Used By Composite 复选框。勾选此复选框即可将这些碰撞体附加到 2D 复合碰撞体。这些碰撞体还与 2D 复合碰撞体附加到同一 2D 刚体。启用 Used by Composite 时，其他属性会从该组件中消失，因为这些属性现在由附加的 2D 复合碰撞体控制。</p>\n<hr>\n<h3 id=\"三、Pixels-Per-Unit（PPU）\"><a href=\"#三、Pixels-Per-Unit（PPU）\" class=\"headerlink\" title=\"三、Pixels Per Unit（PPU）\"></a>三、Pixels Per Unit（PPU）</h3><p>在Inspector面板的图像设置中有一个Pixels Per Unit参数。它代表Unity的一个单位长度包含本图片多少个像素<br> 在Unity中创建的Cube等基本图形默认就是一个Unity单位长度，一个单位长度在unity世界坐标中代表1米<br> 例如默认值为100，则代表一个Unity单位包含本图片中100个像素</p>\n<hr>\n<h3 id=\"四、关节（joint）\"><a href=\"#四、关节（joint）\" class=\"headerlink\" title=\"四、关节（joint）\"></a>四、关节（joint）</h3><p>关节组件可以添加至多个游戏对象中，而添加关节的游戏对象将通过关节连接在一起并且感觉连带的物理效果。需要注意的是：关节必须依赖于刚体组件。所有 2D 关节的名称都以“2D”结尾。名称不以“2D”结尾的关节是 3D 关节。2D 关节用于 2D 游戏对象，而 3D 关节用于 3D 游戏对象。</p>\n<p><strong>3D关节</strong>：</p>\n<p><strong>链条关节（hinge joint）</strong>：将两个物体以链条的形式绑在一起，当力量大于链条的固定力矩时，两个物体就会产生相互的拉力。</p>\n<p><strong>固定关节（fixed joint）</strong>：将两个物体永远以相对的位置固定在一起，即使发生物理改变，它们之间的相对位置也将不变。</p>\n<p><strong>弹簧关节（spring joint）</strong>：将两个物体以弹簧的形式绑定在一起，挤压它们会得到向外的力，拉伸它们将得到向里的力。</p>\n<p><strong>角色关节（character joint）</strong>：可以模拟角色的骨骼关节。</p>\n<p><strong>可配置关节（configurable joint）</strong>：可以模拟任意关节的效果。</p>\n<p><strong>2D关节</strong>：</p>\n<p><strong>2D 距离关节 (Distance Joint 2D)</strong> - 连接由刚体物理组件控制的两个游戏对象，使这两个对象保持一定距离。</p>\n<p><strong>2D 固定关节 (Fixed Joint 2D)</strong> - 将两个对象保持在相对于彼此的位置，确保对象始终以给定位置和角度偏移。例如，对象好像是采用刚性连接方式相连一样：对象不能彼此远离，不能相互靠近，也不能相对于彼此旋转。还可以使用此关节来创建刚度稍低的柔性连接。</p>\n<p><strong>2D 摩擦关节 (Friction Joint 2D)</strong> - 将刚体物理组件控制的两个游戏对象之间的线速度和角速度降低到零（即：此关节使对象减速并停止）。例如，一个平台在旋转但抵抗该运动。</p>\n<p><strong>2D 铰链关节 (Hinge Joint 2D)</strong> - 允许由刚体物理组件控制的游戏对象连接到空间中的一个点，使游戏对象可围绕该点旋转。例如，一把剪刀上的轴心。</p>\n<p><strong>2D 相对关节 (Relative Joint 2D)</strong> - 允许由刚体物理组件控制的两个游戏对象基于彼此的位置来保持相对位置。使用此关节可将两个对象保持相互偏移。例如，在空间射击游戏中，玩家身后有额外的排炮。</p>\n<p><strong>2D 滑动关节 (Slider Joint 2D)</strong> - 允许由刚体物理组件控制的游戏对象沿着空间中的一条线滑动（例如滑门）。</p>\n<p><strong>2D 弹簧关节 (Spring Joint 2D)</strong> - 允许由刚体物理组件控制的两个游戏对象就像通过弹簧连接在一起一样。</p>\n<p><strong>2D 目标关节 (Target Joint 2D)</strong> - 连接到指定目标，而不是像其他关节那样连接到另一个刚体对象。这是一种弹簧式关节，例如可将其用于拾取和移动处于重力作用下的对象。</p>\n<p><strong>2D 车轮关节 (Wheel Joint 2D)</strong> - 模拟车轮和悬架。</p>\n<p>在关节这方面2D的花样比3D多</p>\n<hr>\n<h3 id=\"五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）\"><a href=\"#五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）\" class=\"headerlink\" title=\"五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）\"></a>五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）</h3><p>要产生碰撞必须为游戏对象添加刚体（Rigidbody）和碰撞器，刚体可以让物体在物理影响下运动。碰撞体是物理组件的一类，它要与刚体一起添加到游戏对象上才能触发碰撞。如果两个刚体相互撞在一起，除非两个对象有碰撞体时物理引擎才会计算碰撞，在物理模拟中，没有碰撞体的刚体会彼此相互穿过。</p>\n<p><strong>物体发生碰撞的必要条件</strong>：</p>\n<p>两个物体都必须带有碰撞器(Collider)，其中一个物体还必须带有Rigidbody刚体。</p>\n<p>在unity3d中，能检测碰撞发生的方式有两种，一种是利用碰撞器，另一种则是利用触发器。</p>\n<p>碰撞器：一群组件，它包含了很多种类，比如：Box Collider（盒碰撞体），Mesh Collider（网格碰撞体）等，这些碰撞器应用的场合不同，但都必须加到GameObjecet身上。</p>\n<p>触发器：只需要在检视面板中的碰撞器组件中勾选IsTrigger属性选择框。</p>\n<p><strong>触发信息检测</strong>：</p>\n<p>1.MonoBehaviour.OnTriggerEnter(Collider collider)当进入触发器</p>\n<p>2.MonoBehaviour.OnTriggerExit(Collider collider)当退出触发器</p>\n<p>3.MonoBehaviour.OnTriggerStay(Collider collider)当逗留触发器</p>\n<p><strong>碰撞信息检测</strong>：</p>\n<p>1.MonoBehaviour.OnCollisionEnter(Collision collision) 当进入碰撞器</p>\n<p>2.MonoBehaviour.OnCollisionExit(Collision collision) 当退出碰撞器</p>\n<p>3.MonoBehaviour.OnCollisionStay(Collision collision) 当逗留碰撞器</p>\n<p><strong>碰撞器和触发器的区别？</strong></p>\n<p>碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性</p>\n<p>当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；</p>\n<p>当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。</p>\n<p>也就是说在一次碰撞中，碰撞函数和触发函数只能二选一</p>\n<hr>\n<h3 id=\"六、预制体（Prefab）\"><a href=\"#六、预制体（Prefab）\" class=\"headerlink\" title=\"六、预制体（Prefab）\"></a>六、预制体（Prefab）</h3><p>什么是预制体：</p>\n<p>在进行一些功能开发的时候, 我们常常将一些能够复用的对象制作成.prefab的预制体，然后将预制体存放到 Resources 目录之下, 使用时再动态加载到场景中并进行实例化. 例如 : 子弹、特效甚至音频等, 都能制作成预制体.</p>\n<p>预制体英文名称即 Prefab 是一种资源类型 —— 存储在项目视图中的一种可重复使用的游戏对象.</p>\n<p>预制体的优点：<br>预制体可以多次放入到多个场景中;<br>当你添加一个预制体到场景中, 就创建了它的一个实例;<br>所有的预制体实例链接到原始预制, 基本上等于就是它的克隆;<br>不管你的项目存在多少实例, 当你对预制体进行任何更改, 你将看到这些更改将应用于所有的实例上;</p>\n<hr>\n<h3 id=\"七、画布（Canvas）\"><a href=\"#七、画布（Canvas）\" class=\"headerlink\" title=\"七、画布（Canvas）\"></a>七、画布（Canvas）</h3><p>Canvas (画布) 是所有 UI 组件的父物体 , 也就是说每一个 UI 组件都必须在 Canvas 下 , 作为 Canvas 的子物体 , 当你创建一个 UI 控件时 , 如果在 Hierarchy 视图没有 Canvas 组件的话 , unity会自动帮你创建一个 Canvas , 并将你想创建的 UI 控件置于 Canvas 下.</p>\n<p>Canvas 的 Render Mode (渲染模式) 有三种 ：</p>\n<p>1.<strong>Screen Space - Overlay</strong></p>\n<p>这种渲染模式表示 Canvas 下的所有的 UI 控件永远位于屏幕的前面 , 不管有没有相机 , UI元素永远在屏幕最前面</p>\n<p>2.<strong>Screen Space - Camera</strong></p>\n<p>这种渲染模式 Canvas 和 摄像机之间有一定的距离 , 可以在摄像机和 Canvas 之间播放一些粒子特效</p>\n<p>3.<strong>World Space</strong></p>\n<p>这种模式下 Canvas 就和普通的 3D 物体一样了 , 可以控制它的大小,旋转,缩放等 , 一般用来做血条</p>\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>作为unity回坑第一课收获还是蛮丰富的，以前一直没有做笔记的习惯，东西学了又忘，忘了还没地方复习，以后要养成写学习日记的习惯。</p>\n<p>这次写的脚本都没有写注释，希望未来的我回来看的时候不会头大吧哈哈哈（这么简单的代码应该不至于）</p>\n<hr>\n<h3 id=\"附录、脚本\"><a href=\"#附录、脚本\" class=\"headerlink\" title=\"附录、脚本\"></a>附录、脚本</h3><p>1.角色控制脚本，控制角色移动和检测角色状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerController : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Rigidbody2D rb;</span><br><span class=\"line\">    Animator anim;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    public bool isOnGround;</span><br><span class=\"line\">    public float checkRadius;</span><br><span class=\"line\">    public LayerMask layer;</span><br><span class=\"line\">    public GameObject groundCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">    public bool playerDead;</span><br><span class=\"line\"></span><br><span class=\"line\">    public float bounceH;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">        anim = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Movement();</span><br><span class=\"line\">        isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);</span><br><span class=\"line\">        anim.SetBool(&quot;isOnGround&quot;, isOnGround);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Movement()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\">        anim.SetFloat(&quot;speed&quot;, Mathf.Abs(rb.velocity.x));</span><br><span class=\"line\"></span><br><span class=\"line\">        if(xVelocity != 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            transform.localScale = new Vector3(xVelocity, 1, 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnCollisionEnter2D(Collision2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.gameObject.CompareTag(&quot;Fan&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rb.velocity = new Vector2(rb.velocity.x, bounceH);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (collision.gameObject.CompareTag(&quot;Spike&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            anim.SetTrigger(&quot;isDead&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.CompareTag(&quot;Spike&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            anim.SetTrigger(&quot;isDead&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void PlayerDead()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        playerDead = true;</span><br><span class=\"line\">        GameManage.GameOver(playerDead);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnDrawGizmosSelected()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Gizmos.color = Color.green;</span><br><span class=\"line\">        Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.游戏管理脚本，涉及游戏重开和退出，以及控制界面：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">using UnityEngine.UI;</span><br><span class=\"line\">using UnityEngine.SceneManagement;</span><br><span class=\"line\"></span><br><span class=\"line\">public class GameManage : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static GameManage instance;</span><br><span class=\"line\">    public Text score;</span><br><span class=\"line\"></span><br><span class=\"line\">    public GameObject gameOverUI;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void Awake()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(instance != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        instance = this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        score.text = Time.timeSinceLevelLoad.ToString(&quot;000&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void RestartGame()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SceneManager.LoadScene(SceneManager.GetActiveScene().name);</span><br><span class=\"line\">        Time.timeScale = 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void Exit()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Application.Quit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void GameOver(bool dead)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (dead)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Time.timeScale = 0f;</span><br><span class=\"line\">            instance.gameOverUI.SetActive(true);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>3.平台生成脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Spawner : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public List&lt;GameObject&gt; platform = new List&lt;GameObject&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public float spawnTime;</span><br><span class=\"line\">    float countTime;</span><br><span class=\"line\">    Vector3 spawnPosition;</span><br><span class=\"line\"></span><br><span class=\"line\">    int spikeBallNum = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SpawnPlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void SpawnPlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        countTime += Time.deltaTime;</span><br><span class=\"line\">        spawnPosition = transform.position;</span><br><span class=\"line\">        spawnPosition.x = Random.Range(-3f, 3f);</span><br><span class=\"line\"></span><br><span class=\"line\">        if(countTime &gt; spawnTime)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            CreatePlatform();</span><br><span class=\"line\">            countTime = 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void CreatePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int index = Random.Range(0, platform.Count);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (index == 3)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            spikeBallNum++;</span><br><span class=\"line\">            if(spikeBallNum &gt; 2)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                index = 0;</span><br><span class=\"line\">                spikeBallNum = 0;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class=\"line\">        newPlatform.transform.SetParent(transform);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>4.平台上升脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlatformUp : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector3 movement;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    GameObject topLine;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        movement.y = speed;</span><br><span class=\"line\">        topLine = GameObject.Find(&quot;TopLine&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MovePlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void MovePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        transform.position += movement * Time.deltaTime;</span><br><span class=\"line\">        if(transform.position.y &gt; topLine.transform.position.y)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>5.链锤画线脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class SpikeBallLine : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LineRenderer line;</span><br><span class=\"line\">    public Transform begin;</span><br><span class=\"line\">    public Transform end;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line = GetComponent&lt;LineRenderer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line.SetPosition(0, begin.position);</span><br><span class=\"line\">        line.SetPosition(1, end.position);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>6.跳跃平台旋转动画脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class FanRun : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Animator animator;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        animator = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnCollisionEnter2D(Collision2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.gameObject.CompareTag(&quot;Player&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            animator.Play(&quot;Fan_run&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>”《Speed Down》Unity2d游戏开发“系列已经完结，这篇文章主要是复盘这次学习中遇到的问题和一些名词的解释，以供未来的我快速回顾，最后还会附上所有的脚本</p>","more":"<hr>\n<h3 id=\"一、素材\"><a href=\"#一、素材\" class=\"headerlink\" title=\"一、素材\"></a>一、素材</h3><p>素材这块完全不用自己制作嘛，光是这个Assetstore就有挺多素材的，而且很多无限制商用的，有空要收集一些可以白嫖的网站</p>\n<hr>\n<h3 id=\"二、2D-复合碰撞体-Composite-Collider-2D\"><a href=\"#二、2D-复合碰撞体-Composite-Collider-2D\" class=\"headerlink\" title=\"二、2D 复合碰撞体 (Composite Collider 2D)\"></a>二、2D 复合碰撞体 (Composite Collider 2D)</h3><p>2D 复合碰撞体组件是用于 2D 物理的碰撞体。与大多数碰撞体不同，此碰撞体没有定义固有的形状。相反，此碰撞体将合并所设置的 2D 盒型碰撞体 (Box Collider 2D) 或 2D 多边形碰撞体 (Polygon Collider 2D) 的形状。2D 复合碰撞体使用所有此类碰撞体的顶点（几何体），并将这些顶点合并为由 2D 复合碰撞体本身控制的新几何体。</p>\n<p>2D 盒型碰撞体和 2D 多边形碰撞体组件具有 Used By Composite 复选框。勾选此复选框即可将这些碰撞体附加到 2D 复合碰撞体。这些碰撞体还与 2D 复合碰撞体附加到同一 2D 刚体。启用 Used by Composite 时，其他属性会从该组件中消失，因为这些属性现在由附加的 2D 复合碰撞体控制。</p>\n<hr>\n<h3 id=\"三、Pixels-Per-Unit（PPU）\"><a href=\"#三、Pixels-Per-Unit（PPU）\" class=\"headerlink\" title=\"三、Pixels Per Unit（PPU）\"></a>三、Pixels Per Unit（PPU）</h3><p>在Inspector面板的图像设置中有一个Pixels Per Unit参数。它代表Unity的一个单位长度包含本图片多少个像素<br> 在Unity中创建的Cube等基本图形默认就是一个Unity单位长度，一个单位长度在unity世界坐标中代表1米<br> 例如默认值为100，则代表一个Unity单位包含本图片中100个像素</p>\n<hr>\n<h3 id=\"四、关节（joint）\"><a href=\"#四、关节（joint）\" class=\"headerlink\" title=\"四、关节（joint）\"></a>四、关节（joint）</h3><p>关节组件可以添加至多个游戏对象中，而添加关节的游戏对象将通过关节连接在一起并且感觉连带的物理效果。需要注意的是：关节必须依赖于刚体组件。所有 2D 关节的名称都以“2D”结尾。名称不以“2D”结尾的关节是 3D 关节。2D 关节用于 2D 游戏对象，而 3D 关节用于 3D 游戏对象。</p>\n<p><strong>3D关节</strong>：</p>\n<p><strong>链条关节（hinge joint）</strong>：将两个物体以链条的形式绑在一起，当力量大于链条的固定力矩时，两个物体就会产生相互的拉力。</p>\n<p><strong>固定关节（fixed joint）</strong>：将两个物体永远以相对的位置固定在一起，即使发生物理改变，它们之间的相对位置也将不变。</p>\n<p><strong>弹簧关节（spring joint）</strong>：将两个物体以弹簧的形式绑定在一起，挤压它们会得到向外的力，拉伸它们将得到向里的力。</p>\n<p><strong>角色关节（character joint）</strong>：可以模拟角色的骨骼关节。</p>\n<p><strong>可配置关节（configurable joint）</strong>：可以模拟任意关节的效果。</p>\n<p><strong>2D关节</strong>：</p>\n<p><strong>2D 距离关节 (Distance Joint 2D)</strong> - 连接由刚体物理组件控制的两个游戏对象，使这两个对象保持一定距离。</p>\n<p><strong>2D 固定关节 (Fixed Joint 2D)</strong> - 将两个对象保持在相对于彼此的位置，确保对象始终以给定位置和角度偏移。例如，对象好像是采用刚性连接方式相连一样：对象不能彼此远离，不能相互靠近，也不能相对于彼此旋转。还可以使用此关节来创建刚度稍低的柔性连接。</p>\n<p><strong>2D 摩擦关节 (Friction Joint 2D)</strong> - 将刚体物理组件控制的两个游戏对象之间的线速度和角速度降低到零（即：此关节使对象减速并停止）。例如，一个平台在旋转但抵抗该运动。</p>\n<p><strong>2D 铰链关节 (Hinge Joint 2D)</strong> - 允许由刚体物理组件控制的游戏对象连接到空间中的一个点，使游戏对象可围绕该点旋转。例如，一把剪刀上的轴心。</p>\n<p><strong>2D 相对关节 (Relative Joint 2D)</strong> - 允许由刚体物理组件控制的两个游戏对象基于彼此的位置来保持相对位置。使用此关节可将两个对象保持相互偏移。例如，在空间射击游戏中，玩家身后有额外的排炮。</p>\n<p><strong>2D 滑动关节 (Slider Joint 2D)</strong> - 允许由刚体物理组件控制的游戏对象沿着空间中的一条线滑动（例如滑门）。</p>\n<p><strong>2D 弹簧关节 (Spring Joint 2D)</strong> - 允许由刚体物理组件控制的两个游戏对象就像通过弹簧连接在一起一样。</p>\n<p><strong>2D 目标关节 (Target Joint 2D)</strong> - 连接到指定目标，而不是像其他关节那样连接到另一个刚体对象。这是一种弹簧式关节，例如可将其用于拾取和移动处于重力作用下的对象。</p>\n<p><strong>2D 车轮关节 (Wheel Joint 2D)</strong> - 模拟车轮和悬架。</p>\n<p>在关节这方面2D的花样比3D多</p>\n<hr>\n<h3 id=\"五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）\"><a href=\"#五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）\" class=\"headerlink\" title=\"五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）\"></a>五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）</h3><p>要产生碰撞必须为游戏对象添加刚体（Rigidbody）和碰撞器，刚体可以让物体在物理影响下运动。碰撞体是物理组件的一类，它要与刚体一起添加到游戏对象上才能触发碰撞。如果两个刚体相互撞在一起，除非两个对象有碰撞体时物理引擎才会计算碰撞，在物理模拟中，没有碰撞体的刚体会彼此相互穿过。</p>\n<p><strong>物体发生碰撞的必要条件</strong>：</p>\n<p>两个物体都必须带有碰撞器(Collider)，其中一个物体还必须带有Rigidbody刚体。</p>\n<p>在unity3d中，能检测碰撞发生的方式有两种，一种是利用碰撞器，另一种则是利用触发器。</p>\n<p>碰撞器：一群组件，它包含了很多种类，比如：Box Collider（盒碰撞体），Mesh Collider（网格碰撞体）等，这些碰撞器应用的场合不同，但都必须加到GameObjecet身上。</p>\n<p>触发器：只需要在检视面板中的碰撞器组件中勾选IsTrigger属性选择框。</p>\n<p><strong>触发信息检测</strong>：</p>\n<p>1.MonoBehaviour.OnTriggerEnter(Collider collider)当进入触发器</p>\n<p>2.MonoBehaviour.OnTriggerExit(Collider collider)当退出触发器</p>\n<p>3.MonoBehaviour.OnTriggerStay(Collider collider)当逗留触发器</p>\n<p><strong>碰撞信息检测</strong>：</p>\n<p>1.MonoBehaviour.OnCollisionEnter(Collision collision) 当进入碰撞器</p>\n<p>2.MonoBehaviour.OnCollisionExit(Collision collision) 当退出碰撞器</p>\n<p>3.MonoBehaviour.OnCollisionStay(Collision collision) 当逗留碰撞器</p>\n<p><strong>碰撞器和触发器的区别？</strong></p>\n<p>碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性</p>\n<p>当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；</p>\n<p>当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。</p>\n<p>也就是说在一次碰撞中，碰撞函数和触发函数只能二选一</p>\n<hr>\n<h3 id=\"六、预制体（Prefab）\"><a href=\"#六、预制体（Prefab）\" class=\"headerlink\" title=\"六、预制体（Prefab）\"></a>六、预制体（Prefab）</h3><p>什么是预制体：</p>\n<p>在进行一些功能开发的时候, 我们常常将一些能够复用的对象制作成.prefab的预制体，然后将预制体存放到 Resources 目录之下, 使用时再动态加载到场景中并进行实例化. 例如 : 子弹、特效甚至音频等, 都能制作成预制体.</p>\n<p>预制体英文名称即 Prefab 是一种资源类型 —— 存储在项目视图中的一种可重复使用的游戏对象.</p>\n<p>预制体的优点：<br>预制体可以多次放入到多个场景中;<br>当你添加一个预制体到场景中, 就创建了它的一个实例;<br>所有的预制体实例链接到原始预制, 基本上等于就是它的克隆;<br>不管你的项目存在多少实例, 当你对预制体进行任何更改, 你将看到这些更改将应用于所有的实例上;</p>\n<hr>\n<h3 id=\"七、画布（Canvas）\"><a href=\"#七、画布（Canvas）\" class=\"headerlink\" title=\"七、画布（Canvas）\"></a>七、画布（Canvas）</h3><p>Canvas (画布) 是所有 UI 组件的父物体 , 也就是说每一个 UI 组件都必须在 Canvas 下 , 作为 Canvas 的子物体 , 当你创建一个 UI 控件时 , 如果在 Hierarchy 视图没有 Canvas 组件的话 , unity会自动帮你创建一个 Canvas , 并将你想创建的 UI 控件置于 Canvas 下.</p>\n<p>Canvas 的 Render Mode (渲染模式) 有三种 ：</p>\n<p>1.<strong>Screen Space - Overlay</strong></p>\n<p>这种渲染模式表示 Canvas 下的所有的 UI 控件永远位于屏幕的前面 , 不管有没有相机 , UI元素永远在屏幕最前面</p>\n<p>2.<strong>Screen Space - Camera</strong></p>\n<p>这种渲染模式 Canvas 和 摄像机之间有一定的距离 , 可以在摄像机和 Canvas 之间播放一些粒子特效</p>\n<p>3.<strong>World Space</strong></p>\n<p>这种模式下 Canvas 就和普通的 3D 物体一样了 , 可以控制它的大小,旋转,缩放等 , 一般用来做血条</p>\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>作为unity回坑第一课收获还是蛮丰富的，以前一直没有做笔记的习惯，东西学了又忘，忘了还没地方复习，以后要养成写学习日记的习惯。</p>\n<p>这次写的脚本都没有写注释，希望未来的我回来看的时候不会头大吧哈哈哈（这么简单的代码应该不至于）</p>\n<hr>\n<h3 id=\"附录、脚本\"><a href=\"#附录、脚本\" class=\"headerlink\" title=\"附录、脚本\"></a>附录、脚本</h3><p>1.角色控制脚本，控制角色移动和检测角色状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerController : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Rigidbody2D rb;</span><br><span class=\"line\">    Animator anim;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    public bool isOnGround;</span><br><span class=\"line\">    public float checkRadius;</span><br><span class=\"line\">    public LayerMask layer;</span><br><span class=\"line\">    public GameObject groundCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">    public bool playerDead;</span><br><span class=\"line\"></span><br><span class=\"line\">    public float bounceH;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">        anim = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Movement();</span><br><span class=\"line\">        isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);</span><br><span class=\"line\">        anim.SetBool(&quot;isOnGround&quot;, isOnGround);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Movement()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\">        anim.SetFloat(&quot;speed&quot;, Mathf.Abs(rb.velocity.x));</span><br><span class=\"line\"></span><br><span class=\"line\">        if(xVelocity != 0)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            transform.localScale = new Vector3(xVelocity, 1, 1);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnCollisionEnter2D(Collision2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.gameObject.CompareTag(&quot;Fan&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rb.velocity = new Vector2(rb.velocity.x, bounceH);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (collision.gameObject.CompareTag(&quot;Spike&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            anim.SetTrigger(&quot;isDead&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.CompareTag(&quot;Spike&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            anim.SetTrigger(&quot;isDead&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void PlayerDead()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        playerDead = true;</span><br><span class=\"line\">        GameManage.GameOver(playerDead);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnDrawGizmosSelected()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Gizmos.color = Color.green;</span><br><span class=\"line\">        Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.游戏管理脚本，涉及游戏重开和退出，以及控制界面：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">using UnityEngine.UI;</span><br><span class=\"line\">using UnityEngine.SceneManagement;</span><br><span class=\"line\"></span><br><span class=\"line\">public class GameManage : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    static GameManage instance;</span><br><span class=\"line\">    public Text score;</span><br><span class=\"line\"></span><br><span class=\"line\">    public GameObject gameOverUI;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void Awake()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(instance != null)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        instance = this;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        score.text = Time.timeSinceLevelLoad.ToString(&quot;000&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void RestartGame()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SceneManager.LoadScene(SceneManager.GetActiveScene().name);</span><br><span class=\"line\">        Time.timeScale = 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void Exit()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Application.Quit();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void GameOver(bool dead)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (dead)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Time.timeScale = 0f;</span><br><span class=\"line\">            instance.gameOverUI.SetActive(true);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>3.平台生成脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Spawner : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public List&lt;GameObject&gt; platform = new List&lt;GameObject&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    public float spawnTime;</span><br><span class=\"line\">    float countTime;</span><br><span class=\"line\">    Vector3 spawnPosition;</span><br><span class=\"line\"></span><br><span class=\"line\">    int spikeBallNum = 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        SpawnPlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void SpawnPlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        countTime += Time.deltaTime;</span><br><span class=\"line\">        spawnPosition = transform.position;</span><br><span class=\"line\">        spawnPosition.x = Random.Range(-3f, 3f);</span><br><span class=\"line\"></span><br><span class=\"line\">        if(countTime &gt; spawnTime)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            CreatePlatform();</span><br><span class=\"line\">            countTime = 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void CreatePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int index = Random.Range(0, platform.Count);</span><br><span class=\"line\"></span><br><span class=\"line\">        if (index == 3)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            spikeBallNum++;</span><br><span class=\"line\">            if(spikeBallNum &gt; 2)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                index = 0;</span><br><span class=\"line\">                spikeBallNum = 0;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class=\"line\">        newPlatform.transform.SetParent(transform);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>4.平台上升脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlatformUp : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector3 movement;</span><br><span class=\"line\">    public float speed;</span><br><span class=\"line\">    GameObject topLine;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        movement.y = speed;</span><br><span class=\"line\">        topLine = GameObject.Find(&quot;TopLine&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        MovePlatform();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void MovePlatform()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        transform.position += movement * Time.deltaTime;</span><br><span class=\"line\">        if(transform.position.y &gt; topLine.transform.position.y)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            Destroy(gameObject);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<p>5.链锤画线脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class SpikeBallLine : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    LineRenderer line;</span><br><span class=\"line\">    public Transform begin;</span><br><span class=\"line\">    public Transform end;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line = GetComponent&lt;LineRenderer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        line.SetPosition(0, begin.position);</span><br><span class=\"line\">        line.SetPosition(1, end.position);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>6.跳跃平台旋转动画脚本：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class FanRun : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Animator animator;</span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        animator = GetComponent&lt;Animator&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void OnCollisionEnter2D(Collision2D collision)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (collision.gameObject.CompareTag(&quot;Player&quot;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            animator.Play(&quot;Fan_run&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"《Robbie Swifthand》Unity2d独立游戏学习（一）","date":"2021-07-18T08:16:23.000Z","_content":"\n\n\n### \t始、前言\n\n继续跟M大学习unity2d开发，这次是《从独立游戏学习开发》系列，我们将从一款已经上架steam的独立游戏《Robbie Swifthand and the Orb of Mysteries》中学习\n\n\n\n版本：\n\nunity 2021.1.12f1c1\n\nvs 2019\n\nunityhub 2.1.14\n\n\n\n<!--more-->\n\n---\n\n\n\n### 一、导入资源\n\n1.资源地址：https://pan.baidu.com/s/1c0I1pO7Rr8w4s4SGcfscHA\n\n提取码:   a338\n\n2.新建2d unity项目，界面左上角工具栏中Assets - import package - custom assets ，导入刚刚下载的资源\n\n3.导入过程中提示更新API，选择“Yes”\n\n4.导入完成后发现脚本报错，原因是我的新版unity自带的脚本和资源里的有冲突，需要删除对应的新脚本\n\n\n\n---\n\n\n\n### 二、整理资源\n\n导入工作完成后Assets文件夹下出现了大量的文件夹，先看看他们都是些什么\n\n1._Extended：额外的扩展包，后期需要用到的资源\n\n2.Addons：插件，新版本unity有自带的，这里需要删掉\n\n3.Audio：音乐素材\n\n4.Fonts：字体\n\n5.Gizmos：小插件，这里包含2D摄像机跟踪\n\n6.Level：背景前景素材，用于制作透视效果\n\n7.Props：道具，里面是一些游戏元素的预制体\n\n8.Robbie：本游戏主角，包含主角的素材、动画等\n\n9.Scripts：脚本，包含几个简单代码，其他的自己写\n\n10.Tilemaps：用来存放游戏素材，即项目中正在用的素材（为啥得用他给我的文件夹，我就不）\n\n11.UI：用户界面用到的素材\n\n12.VFX：特效\n\n\n\n---\n\n\n\n### 三、绘制背景准备工作\n\n1.找到windows - 2D - Tile Palette调出调色板窗口\n\n2.新建调色板，起名Background，存放到Tilemap文件夹里新建的Palettes文件夹\n\n3.将Level中的素材BG walls 拖入调色板里，保存到Tilemap - Tile 新建的Background文件夹\n\n4.重复2~3步骤，制作Platform和Shadow的调色板，同样管理好切割的瓦片\n\n5.在调色板界面中点击Edit 就可以修改调色板的素材（界面中几个画画工具都玩一下）\n\n6.在Hierarchy中新建2D Object - Tilemap ，命名为Background\n\n7.在调色板Active Tilemap 中可以选择要绘制的对象\n\n8.同样地，在Grid 父物体下新建Tilemap 三个物体，分别命名Background Detailed、Shadow、Platform\n\n9.设置Sorting Layer，添加四种，分别为Background、Platform、Player、Foreground（Sorting Layer 中越往下排的层级在镜头中越靠前）\n\n10.分别设置Tilemap的Sorting Layer ，其中Order In Layer 又可以在同Layer 中再排序一次\n\n（设置都要套娃？）\n\n11.拖入主角Robbie，设置Sorting Layer 为Player\n\n\n\n---\n\n\n\n### 四、设置Rule Tile\n\nRule Tile 是超强的瓦片绘制工具，通过设定瓦片生成规则，实现利用一个瓦片就可以任意拖拽生成各种不规则图案。新版本的unity已经成为内置功能，可以直接创建使用\n\n1.在Tilemaps - Tile - Backgrounds中新建Rule Tile，命名为BG rule ，默认图片随便选个背景瓦片\n\n2.添加瓦片，并给每个瓦片设置规则，上面的规则比下面的规则优先。\n\n规则为：检测九宫格中是否存在其他同样在列表中的瓦片，绿色箭头表示那个方向**必**存在此类瓦片，红色叉叉表示**必**不存在此类瓦片，没有设置的方向就是没要求\n\n3.设置好每个瓦片后，将BG rule 拖入调色板Palette 中， 这样就可以用这个瓦片随意画图啦！\n\n4.多设置几个功能瓦片堆积在一起可以变成大瓦片，方便大面积作图\n\n5.同上，设置Shadows 瓦片的Rule Tile\n\n6.设置Platforms 瓦片的Rule Tile 时，我们希望平台瓦片随机生成，而不用某种特定规则。在Rule Tile 下添加一个瓦片，在Output中选择Random，Size设置为4，将要随机生成的四种瓦片拖入空格中\n\n\n\n---\n\n\n\n### 五、绘制地图\n\n可以随意绘制地图，但是有几个注意点：\n\n1.在调色板中选取瓦片时，要记得在Active Tilemap 中选择要绘制的对象\n\n2.瓦片要绘制两层以上，因为各种规则瓦片在只有一层时会非常难看\n\n3.Shadows 瓦片覆盖在在Platforms 瓦片上面，后面调灯光的时候就会有很美妙的效果\n\n4.地图记得留一个出口位置\n\n\n\n---\n\n\n\n### 终、睡觉\n\n画地图还挺过瘾的，先这样了，洗澡睡觉！\n","source":"_posts/2021-07-18-《Robbie Swifthand》Unity2d独立游戏学习（一）.md","raw":"---\ntitle: 《Robbie Swifthand》Unity2d独立游戏学习（一）\ndate: 2021-07-18 16:16:23\ncategories: unity\ntags:\n  - unity\n  - c#\n  - tile\n---\n\n\n\n### \t始、前言\n\n继续跟M大学习unity2d开发，这次是《从独立游戏学习开发》系列，我们将从一款已经上架steam的独立游戏《Robbie Swifthand and the Orb of Mysteries》中学习\n\n\n\n版本：\n\nunity 2021.1.12f1c1\n\nvs 2019\n\nunityhub 2.1.14\n\n\n\n<!--more-->\n\n---\n\n\n\n### 一、导入资源\n\n1.资源地址：https://pan.baidu.com/s/1c0I1pO7Rr8w4s4SGcfscHA\n\n提取码:   a338\n\n2.新建2d unity项目，界面左上角工具栏中Assets - import package - custom assets ，导入刚刚下载的资源\n\n3.导入过程中提示更新API，选择“Yes”\n\n4.导入完成后发现脚本报错，原因是我的新版unity自带的脚本和资源里的有冲突，需要删除对应的新脚本\n\n\n\n---\n\n\n\n### 二、整理资源\n\n导入工作完成后Assets文件夹下出现了大量的文件夹，先看看他们都是些什么\n\n1._Extended：额外的扩展包，后期需要用到的资源\n\n2.Addons：插件，新版本unity有自带的，这里需要删掉\n\n3.Audio：音乐素材\n\n4.Fonts：字体\n\n5.Gizmos：小插件，这里包含2D摄像机跟踪\n\n6.Level：背景前景素材，用于制作透视效果\n\n7.Props：道具，里面是一些游戏元素的预制体\n\n8.Robbie：本游戏主角，包含主角的素材、动画等\n\n9.Scripts：脚本，包含几个简单代码，其他的自己写\n\n10.Tilemaps：用来存放游戏素材，即项目中正在用的素材（为啥得用他给我的文件夹，我就不）\n\n11.UI：用户界面用到的素材\n\n12.VFX：特效\n\n\n\n---\n\n\n\n### 三、绘制背景准备工作\n\n1.找到windows - 2D - Tile Palette调出调色板窗口\n\n2.新建调色板，起名Background，存放到Tilemap文件夹里新建的Palettes文件夹\n\n3.将Level中的素材BG walls 拖入调色板里，保存到Tilemap - Tile 新建的Background文件夹\n\n4.重复2~3步骤，制作Platform和Shadow的调色板，同样管理好切割的瓦片\n\n5.在调色板界面中点击Edit 就可以修改调色板的素材（界面中几个画画工具都玩一下）\n\n6.在Hierarchy中新建2D Object - Tilemap ，命名为Background\n\n7.在调色板Active Tilemap 中可以选择要绘制的对象\n\n8.同样地，在Grid 父物体下新建Tilemap 三个物体，分别命名Background Detailed、Shadow、Platform\n\n9.设置Sorting Layer，添加四种，分别为Background、Platform、Player、Foreground（Sorting Layer 中越往下排的层级在镜头中越靠前）\n\n10.分别设置Tilemap的Sorting Layer ，其中Order In Layer 又可以在同Layer 中再排序一次\n\n（设置都要套娃？）\n\n11.拖入主角Robbie，设置Sorting Layer 为Player\n\n\n\n---\n\n\n\n### 四、设置Rule Tile\n\nRule Tile 是超强的瓦片绘制工具，通过设定瓦片生成规则，实现利用一个瓦片就可以任意拖拽生成各种不规则图案。新版本的unity已经成为内置功能，可以直接创建使用\n\n1.在Tilemaps - Tile - Backgrounds中新建Rule Tile，命名为BG rule ，默认图片随便选个背景瓦片\n\n2.添加瓦片，并给每个瓦片设置规则，上面的规则比下面的规则优先。\n\n规则为：检测九宫格中是否存在其他同样在列表中的瓦片，绿色箭头表示那个方向**必**存在此类瓦片，红色叉叉表示**必**不存在此类瓦片，没有设置的方向就是没要求\n\n3.设置好每个瓦片后，将BG rule 拖入调色板Palette 中， 这样就可以用这个瓦片随意画图啦！\n\n4.多设置几个功能瓦片堆积在一起可以变成大瓦片，方便大面积作图\n\n5.同上，设置Shadows 瓦片的Rule Tile\n\n6.设置Platforms 瓦片的Rule Tile 时，我们希望平台瓦片随机生成，而不用某种特定规则。在Rule Tile 下添加一个瓦片，在Output中选择Random，Size设置为4，将要随机生成的四种瓦片拖入空格中\n\n\n\n---\n\n\n\n### 五、绘制地图\n\n可以随意绘制地图，但是有几个注意点：\n\n1.在调色板中选取瓦片时，要记得在Active Tilemap 中选择要绘制的对象\n\n2.瓦片要绘制两层以上，因为各种规则瓦片在只有一层时会非常难看\n\n3.Shadows 瓦片覆盖在在Platforms 瓦片上面，后面调灯光的时候就会有很美妙的效果\n\n4.地图记得留一个出口位置\n\n\n\n---\n\n\n\n### 终、睡觉\n\n画地图还挺过瘾的，先这样了，洗澡睡觉！\n","slug":"2021-07-18-《Robbie Swifthand》Unity2d独立游戏学习（一）","published":1,"updated":"2021-07-18T14:41:25.617Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnimi000tf4u0afc8dytq","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>继续跟M大学习unity2d开发，这次是《从独立游戏学习开发》系列，我们将从一款已经上架steam的独立游戏《Robbie Swifthand and the Orb of Mysteries》中学习</p>\n<p>版本：</p>\n<p>unity 2021.1.12f1c1</p>\n<p>vs 2019</p>\n<p>unityhub 2.1.14</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、导入资源\"><a href=\"#一、导入资源\" class=\"headerlink\" title=\"一、导入资源\"></a>一、导入资源</h3><p>1.资源地址：<a href=\"https://pan.baidu.com/s/1c0I1pO7Rr8w4s4SGcfscHA\">https://pan.baidu.com/s/1c0I1pO7Rr8w4s4SGcfscHA</a></p>\n<p>提取码:   a338</p>\n<p>2.新建2d unity项目，界面左上角工具栏中Assets - import package - custom assets ，导入刚刚下载的资源</p>\n<p>3.导入过程中提示更新API，选择“Yes”</p>\n<p>4.导入完成后发现脚本报错，原因是我的新版unity自带的脚本和资源里的有冲突，需要删除对应的新脚本</p>\n<hr>\n<h3 id=\"二、整理资源\"><a href=\"#二、整理资源\" class=\"headerlink\" title=\"二、整理资源\"></a>二、整理资源</h3><p>导入工作完成后Assets文件夹下出现了大量的文件夹，先看看他们都是些什么</p>\n<p>1._Extended：额外的扩展包，后期需要用到的资源</p>\n<p>2.Addons：插件，新版本unity有自带的，这里需要删掉</p>\n<p>3.Audio：音乐素材</p>\n<p>4.Fonts：字体</p>\n<p>5.Gizmos：小插件，这里包含2D摄像机跟踪</p>\n<p>6.Level：背景前景素材，用于制作透视效果</p>\n<p>7.Props：道具，里面是一些游戏元素的预制体</p>\n<p>8.Robbie：本游戏主角，包含主角的素材、动画等</p>\n<p>9.Scripts：脚本，包含几个简单代码，其他的自己写</p>\n<p>10.Tilemaps：用来存放游戏素材，即项目中正在用的素材（为啥得用他给我的文件夹，我就不）</p>\n<p>11.UI：用户界面用到的素材</p>\n<p>12.VFX：特效</p>\n<hr>\n<h3 id=\"三、绘制背景准备工作\"><a href=\"#三、绘制背景准备工作\" class=\"headerlink\" title=\"三、绘制背景准备工作\"></a>三、绘制背景准备工作</h3><p>1.找到windows - 2D - Tile Palette调出调色板窗口</p>\n<p>2.新建调色板，起名Background，存放到Tilemap文件夹里新建的Palettes文件夹</p>\n<p>3.将Level中的素材BG walls 拖入调色板里，保存到Tilemap - Tile 新建的Background文件夹</p>\n<p>4.重复2~3步骤，制作Platform和Shadow的调色板，同样管理好切割的瓦片</p>\n<p>5.在调色板界面中点击Edit 就可以修改调色板的素材（界面中几个画画工具都玩一下）</p>\n<p>6.在Hierarchy中新建2D Object - Tilemap ，命名为Background</p>\n<p>7.在调色板Active Tilemap 中可以选择要绘制的对象</p>\n<p>8.同样地，在Grid 父物体下新建Tilemap 三个物体，分别命名Background Detailed、Shadow、Platform</p>\n<p>9.设置Sorting Layer，添加四种，分别为Background、Platform、Player、Foreground（Sorting Layer 中越往下排的层级在镜头中越靠前）</p>\n<p>10.分别设置Tilemap的Sorting Layer ，其中Order In Layer 又可以在同Layer 中再排序一次</p>\n<p>（设置都要套娃？）</p>\n<p>11.拖入主角Robbie，设置Sorting Layer 为Player</p>\n<hr>\n<h3 id=\"四、设置Rule-Tile\"><a href=\"#四、设置Rule-Tile\" class=\"headerlink\" title=\"四、设置Rule Tile\"></a>四、设置Rule Tile</h3><p>Rule Tile 是超强的瓦片绘制工具，通过设定瓦片生成规则，实现利用一个瓦片就可以任意拖拽生成各种不规则图案。新版本的unity已经成为内置功能，可以直接创建使用</p>\n<p>1.在Tilemaps - Tile - Backgrounds中新建Rule Tile，命名为BG rule ，默认图片随便选个背景瓦片</p>\n<p>2.添加瓦片，并给每个瓦片设置规则，上面的规则比下面的规则优先。</p>\n<p>规则为：检测九宫格中是否存在其他同样在列表中的瓦片，绿色箭头表示那个方向<strong>必</strong>存在此类瓦片，红色叉叉表示<strong>必</strong>不存在此类瓦片，没有设置的方向就是没要求</p>\n<p>3.设置好每个瓦片后，将BG rule 拖入调色板Palette 中， 这样就可以用这个瓦片随意画图啦！</p>\n<p>4.多设置几个功能瓦片堆积在一起可以变成大瓦片，方便大面积作图</p>\n<p>5.同上，设置Shadows 瓦片的Rule Tile</p>\n<p>6.设置Platforms 瓦片的Rule Tile 时，我们希望平台瓦片随机生成，而不用某种特定规则。在Rule Tile 下添加一个瓦片，在Output中选择Random，Size设置为4，将要随机生成的四种瓦片拖入空格中</p>\n<hr>\n<h3 id=\"五、绘制地图\"><a href=\"#五、绘制地图\" class=\"headerlink\" title=\"五、绘制地图\"></a>五、绘制地图</h3><p>可以随意绘制地图，但是有几个注意点：</p>\n<p>1.在调色板中选取瓦片时，要记得在Active Tilemap 中选择要绘制的对象</p>\n<p>2.瓦片要绘制两层以上，因为各种规则瓦片在只有一层时会非常难看</p>\n<p>3.Shadows 瓦片覆盖在在Platforms 瓦片上面，后面调灯光的时候就会有很美妙的效果</p>\n<p>4.地图记得留一个出口位置</p>\n<hr>\n<h3 id=\"终、睡觉\"><a href=\"#终、睡觉\" class=\"headerlink\" title=\"终、睡觉\"></a>终、睡觉</h3><p>画地图还挺过瘾的，先这样了，洗澡睡觉！</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>继续跟M大学习unity2d开发，这次是《从独立游戏学习开发》系列，我们将从一款已经上架steam的独立游戏《Robbie Swifthand and the Orb of Mysteries》中学习</p>\n<p>版本：</p>\n<p>unity 2021.1.12f1c1</p>\n<p>vs 2019</p>\n<p>unityhub 2.1.14</p>","more":"<hr>\n<h3 id=\"一、导入资源\"><a href=\"#一、导入资源\" class=\"headerlink\" title=\"一、导入资源\"></a>一、导入资源</h3><p>1.资源地址：<a href=\"https://pan.baidu.com/s/1c0I1pO7Rr8w4s4SGcfscHA\">https://pan.baidu.com/s/1c0I1pO7Rr8w4s4SGcfscHA</a></p>\n<p>提取码:   a338</p>\n<p>2.新建2d unity项目，界面左上角工具栏中Assets - import package - custom assets ，导入刚刚下载的资源</p>\n<p>3.导入过程中提示更新API，选择“Yes”</p>\n<p>4.导入完成后发现脚本报错，原因是我的新版unity自带的脚本和资源里的有冲突，需要删除对应的新脚本</p>\n<hr>\n<h3 id=\"二、整理资源\"><a href=\"#二、整理资源\" class=\"headerlink\" title=\"二、整理资源\"></a>二、整理资源</h3><p>导入工作完成后Assets文件夹下出现了大量的文件夹，先看看他们都是些什么</p>\n<p>1._Extended：额外的扩展包，后期需要用到的资源</p>\n<p>2.Addons：插件，新版本unity有自带的，这里需要删掉</p>\n<p>3.Audio：音乐素材</p>\n<p>4.Fonts：字体</p>\n<p>5.Gizmos：小插件，这里包含2D摄像机跟踪</p>\n<p>6.Level：背景前景素材，用于制作透视效果</p>\n<p>7.Props：道具，里面是一些游戏元素的预制体</p>\n<p>8.Robbie：本游戏主角，包含主角的素材、动画等</p>\n<p>9.Scripts：脚本，包含几个简单代码，其他的自己写</p>\n<p>10.Tilemaps：用来存放游戏素材，即项目中正在用的素材（为啥得用他给我的文件夹，我就不）</p>\n<p>11.UI：用户界面用到的素材</p>\n<p>12.VFX：特效</p>\n<hr>\n<h3 id=\"三、绘制背景准备工作\"><a href=\"#三、绘制背景准备工作\" class=\"headerlink\" title=\"三、绘制背景准备工作\"></a>三、绘制背景准备工作</h3><p>1.找到windows - 2D - Tile Palette调出调色板窗口</p>\n<p>2.新建调色板，起名Background，存放到Tilemap文件夹里新建的Palettes文件夹</p>\n<p>3.将Level中的素材BG walls 拖入调色板里，保存到Tilemap - Tile 新建的Background文件夹</p>\n<p>4.重复2~3步骤，制作Platform和Shadow的调色板，同样管理好切割的瓦片</p>\n<p>5.在调色板界面中点击Edit 就可以修改调色板的素材（界面中几个画画工具都玩一下）</p>\n<p>6.在Hierarchy中新建2D Object - Tilemap ，命名为Background</p>\n<p>7.在调色板Active Tilemap 中可以选择要绘制的对象</p>\n<p>8.同样地，在Grid 父物体下新建Tilemap 三个物体，分别命名Background Detailed、Shadow、Platform</p>\n<p>9.设置Sorting Layer，添加四种，分别为Background、Platform、Player、Foreground（Sorting Layer 中越往下排的层级在镜头中越靠前）</p>\n<p>10.分别设置Tilemap的Sorting Layer ，其中Order In Layer 又可以在同Layer 中再排序一次</p>\n<p>（设置都要套娃？）</p>\n<p>11.拖入主角Robbie，设置Sorting Layer 为Player</p>\n<hr>\n<h3 id=\"四、设置Rule-Tile\"><a href=\"#四、设置Rule-Tile\" class=\"headerlink\" title=\"四、设置Rule Tile\"></a>四、设置Rule Tile</h3><p>Rule Tile 是超强的瓦片绘制工具，通过设定瓦片生成规则，实现利用一个瓦片就可以任意拖拽生成各种不规则图案。新版本的unity已经成为内置功能，可以直接创建使用</p>\n<p>1.在Tilemaps - Tile - Backgrounds中新建Rule Tile，命名为BG rule ，默认图片随便选个背景瓦片</p>\n<p>2.添加瓦片，并给每个瓦片设置规则，上面的规则比下面的规则优先。</p>\n<p>规则为：检测九宫格中是否存在其他同样在列表中的瓦片，绿色箭头表示那个方向<strong>必</strong>存在此类瓦片，红色叉叉表示<strong>必</strong>不存在此类瓦片，没有设置的方向就是没要求</p>\n<p>3.设置好每个瓦片后，将BG rule 拖入调色板Palette 中， 这样就可以用这个瓦片随意画图啦！</p>\n<p>4.多设置几个功能瓦片堆积在一起可以变成大瓦片，方便大面积作图</p>\n<p>5.同上，设置Shadows 瓦片的Rule Tile</p>\n<p>6.设置Platforms 瓦片的Rule Tile 时，我们希望平台瓦片随机生成，而不用某种特定规则。在Rule Tile 下添加一个瓦片，在Output中选择Random，Size设置为4，将要随机生成的四种瓦片拖入空格中</p>\n<hr>\n<h3 id=\"五、绘制地图\"><a href=\"#五、绘制地图\" class=\"headerlink\" title=\"五、绘制地图\"></a>五、绘制地图</h3><p>可以随意绘制地图，但是有几个注意点：</p>\n<p>1.在调色板中选取瓦片时，要记得在Active Tilemap 中选择要绘制的对象</p>\n<p>2.瓦片要绘制两层以上，因为各种规则瓦片在只有一层时会非常难看</p>\n<p>3.Shadows 瓦片覆盖在在Platforms 瓦片上面，后面调灯光的时候就会有很美妙的效果</p>\n<p>4.地图记得留一个出口位置</p>\n<hr>\n<h3 id=\"终、睡觉\"><a href=\"#终、睡觉\" class=\"headerlink\" title=\"终、睡觉\"></a>终、睡觉</h3><p>画地图还挺过瘾的，先这样了，洗澡睡觉！</p>"},{"title":"《Robbie Swifthand》Unity2d独立游戏学习（二）","date":"2021-07-19T07:23:30.000Z","_content":"\n\n\n### \t一、添加物理组件\n\n1.给Platforms 添加Tilemap Collider 2D，勾选Used By Composite，添加Composite Collider 2D\n\n2.将Platforms自动添加的Rigidbody 2D 选择成Static 模式\n\n3.给主角添加Rigidbody 2D，把Collision Detection选择成Continuous连续不断地检测碰撞，把Interpolate 设置成Interpolate产生碰撞时会有一个缓冲的效果\n\n4.添加Box Collider 2D，调整主角碰撞器大小，size - y 最好设置在 2 以下，这样就可以通过两格高的空间\n\n5.运行，发现在角落处下落会导致角色翻转，需要在主角Rigidbody 2D 中锁定 z 轴\n\n6.为了避免角色碰到墙壁时会卡进墙体里，给主角Box Collider 2D添加Material 物理材质Teflon（资源包里的，摩擦力和弹力都是0）\n\n7.新增Layer ，主角设置成Player，Platforms 设置成Ground，以供后面进行碰撞检测\n\n\n\n<!--more-->\n\n\n\n---\n\n\n\n### 二、角色移动\n\n1.在Scripts文件夹新建PlayerMovement脚本，编写代码：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerMovement : MonoBehaviour\n{\n    private Rigidbody2D rb;\n\n    [Header(\"移动参数\")]\n    public float speed = 10f;\n    public float crouchSpeedDivisor = 5f;\n    private float xVelocity;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n    }\n\n    void Update()//每帧调用\n    {\n        \n    }\n\n    private void FixedUpdate()//每一段时间调用，默认0.02s\n    {\n        GroundMovement();\n    }\n\n    void GroundMovement()\n    {\n        xVelocity = Input.GetAxis(\"Horizontal\");//-1f ~ 1f\n        //在FixedUpdate()中调用无需Time.deltatime\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n        flipDirection();\n    }\n\n\n    void flipDirection()\n    {\n        if (xVelocity > 0) transform.localScale = new Vector2 (1, 1);\n        else if (xVelocity < 0) transform.localScale = new Vector2(-1, 1);\n    }\n}\n```\n\n键盘左右键可以让主角左右移动，并且会改变图案方向\n\n\n\n---\n\n\n\n### 三、下蹲\n\n1.打开Edit - Project Settings - Input ，复制Jump 命名为Crouch，Positive Button 改为down，Alt Positive Button 改为 s\n\n2.修改角色移动代码：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerMovement : MonoBehaviour\n{\n    private Rigidbody2D rb;\n    private BoxCollider2D cd;\n\n    [Header(\"移动参数\")]\n    public float speed = 10f;\n    public float crouchSpeedFactor = 0.5f;\n    private float xVelocity;\n\n    [Header(\"角色状态\")]\n    public bool isCrouch;\n\n    //碰撞体尺寸\n    private Vector2 crouchOffset;\n    private Vector2 crouchSize;\n    private Vector2 standOffset;\n    private Vector2 standSize;\n\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        cd = GetComponent<BoxCollider2D>();\n\n        standOffset = cd.offset;\n        standSize = cd.size;\n        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);\n        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);\n    }\n\n\n    void Update()//每帧调用\n    {\n        \n    }\n\n\n    private void FixedUpdate()//每一段时间调用，默认0.02s\n    {\n        GroundMovement();\n    }\n    void GroundMovement()//移动的各种数值\n    {\n        xVelocity = Input.GetAxis(\"Horizontal\");//-1f ~ 1f\n        if (Input.GetButton(\"Crouch\")) Crouch();\n        else if (isCrouch) StandUp();\n\n        //在FixedUpdate()中调用无需Time.deltatime\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n        flipDirection();\n    }\n    void flipDirection()//改变角色图案方向\n    {\n        if (xVelocity > 0) transform.localScale = new Vector2 (1, 1);\n        else if (xVelocity < 0) transform.localScale = new Vector2(-1, 1);\n    }\n\n    void Crouch()//下蹲时的各种改变\n    {\n        isCrouch = true;\n        xVelocity *= crouchSpeedFactor;\n        cd.size = crouchSize;\n        cd.offset = crouchOffset;\n    }\n    void StandUp()//从下蹲转变为站立时各种变化\n    {\n        isCrouch = false;\n        xVelocity /= crouchSpeedFactor;\n        cd.size = standSize;\n        cd.offset = standOffset;\n    }\n}\n```\n\n顺便给每个函数添加了注释\n\n现在，按下s键或者方向下键就会让角色的碰撞体 “蹲下\" （移动速度变慢并且碰撞体高度减半）\n\n\n\n测试一下确实可以通过高度为1的障碍了，但是在经过障碍的途中如果松开下蹲键，就会穿模卡在墙里，因为缺少了在通过障碍时需要持续下蹲的判断，这一部分放到后面再处理\n\n\n\n---\n\n\n\n### 四、跳跃\n\n1.打开Edit - Project Setting - Physics 2D，将 y 轴重力改大一点，这里改为-50\n\n2.先添加与跳跃有关的参数：\n\n```\n    [Header(\"跳跃参数\")]\n    public float jumpForce = 5f;\n    public float jumpHoldForce = 3f;\n    public float jumpHoldDuration = 0.1f;\n    public float crouchJumpBoost = 3f;\n    float jumpTime;\n```\n\n其中jumpTime 是允许长按跳跃加高的时间\n\n\n\n3.添加判断各种状态的参数：\n\n```\n    [Header(\"按键状态\")]\n    public bool jumpPressed;\n    public bool jumpHeld;\n    public bool crouchHeld;\n\n    [Header(\"角色状态\")]\n    public bool isCrouch;\n    public bool isOnGround;\n    public bool isJump;\n\n    [Header(\"环境检测\")]\n    public LayerMask groundLayer;\n```\n\n同时可以更新一下之前的下蹲判断，用刚刚定义的状态参数\n\n\n\n4.在Update（）中获取按键信息：\n\n```\n    void Update()//每帧调用\n    {\n        //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化\n        if (Input.GetButtonDown(\"Jump\")) jumpPressed = true;\n\n        jumpHeld = Input.GetButton(\"Jump\");\n        crouchHeld = Input.GetButton(\"Crouch\");\n    }\n```\n\n\n\n5.添加判断是否在地面上：\n\n```\n\tvoid PhysicsCheck()//检测是否在地面，并修改状态\n    {\n        isOnGround = cd.IsTouchingLayers(groundLayer);\n\n    }\n```\n\n记得在FixedUpdate（）中调用，物理性质都推荐放在FixedUpdate中\n\n\n\n6.添加跳跃函数：\n\n```\n    void MidAirMovement()//跳跃移动\n    {\n        if(jumpPressed && isOnGround && !isJump)//起跳\n        {\n            if(crouchHeld)//判断是否要蹲跳\n            {\n                rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);\n            }\n            jumpTime = Time.time + jumpHoldDuration;\n            rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);\n            jumpPressed = false;\n            isJump = true;\n        }\n\n        else if(isJump)\n        {\n            if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);\n            if (jumpTime < Time.time) isJump = false;\n        }\n\n    }\n```\n\n精髓就是`jumpTime = Time.time + jumpHoldDuration;`，`if (jumpTime < Time.time) isJump = false;` \n\n这两句代码可以很好地对能否在空中持续加速进行判断\n\n\n\n---\n\n\n\n### 终、总结\n\n这次的跳跃代码真的收获不少，Update和FixedUpdate可以理解成完全独立的两个函数\n\n这一波折腾下来角色控制脚本 PlayerMovement 有点长了，这里先全部放上来记录一下，以便日后回顾\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerMovement : MonoBehaviour\n{\n    //组件\n    private Rigidbody2D rb;\n    private BoxCollider2D cd;\n\n    [Header(\"移动参数\")]\n    public float speed = 10f;\n    public float crouchSpeedFactor = 0.5f;\n    float xVelocity;\n\n    [Header(\"跳跃参数\")]\n    public float jumpForce = 5f;\n    public float jumpHoldForce = 3f;\n    public float jumpHoldDuration = 0.1f;\n    public float crouchJumpBoost = 3f;\n    float jumpTime;\n\n    [Header(\"按键状态\")]\n    public bool jumpPressed;\n    public bool jumpHeld;\n    public bool crouchHeld;\n\n    [Header(\"角色状态\")]\n    public bool isCrouch;\n    public bool isOnGround;\n    public bool isJump;\n\n    [Header(\"环境检测\")]\n    public LayerMask groundLayer;\n\n    //碰撞体尺寸\n    private Vector2 crouchOffset;\n    private Vector2 crouchSize;\n    private Vector2 standOffset;\n    private Vector2 standSize;\n\n    void Start()\n    {\n        //获取组件\n        rb = GetComponent<Rigidbody2D>();\n        cd = GetComponent<BoxCollider2D>();\n\n        //初始化\n        standOffset = cd.offset;\n        standSize = cd.size;\n        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);\n        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);\n    }\n\n\n    void Update()//每帧调用\n    {\n        //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化\n        if (Input.GetButtonDown(\"Jump\")) jumpPressed = true;\n\n        jumpHeld = Input.GetButton(\"Jump\");\n        crouchHeld = Input.GetButton(\"Crouch\");\n    }\n\n\n    private void FixedUpdate()//每一段时间调用，unity默认0.02s\n    {\n        PhysicsCheck();\n        GroundMovement();\n        MidAirMovement();\n    }\n\n    void PhysicsCheck()//检测是否在地面，并修改状态\n    {\n        isOnGround = cd.IsTouchingLayers(groundLayer);\n\n    }\n\n\n    void GroundMovement()//移动的各种数值\n    {\n        xVelocity = Input.GetAxis(\"Horizontal\");//-1f ~ 1f\n        if (crouchHeld && !isCrouch && isOnGround) Crouch();\n        else if ((isCrouch && !crouchHeld) || isJump) StandUp();\n\n\n        //在FixedUpdate()中调用无需Time.deltatime\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n        flipDirection();\n    }\n\n    void MidAirMovement()//跳跃移动\n    {\n        if(jumpPressed && isOnGround && !isJump)//起跳\n        {\n            if(crouchHeld)//判断是否要蹲跳\n            {\n                rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);\n            }\n            jumpTime = Time.time + jumpHoldDuration;\n            rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);\n            jumpPressed = false;\n            isJump = true;\n        }\n\n        else if(isJump)\n        {\n            if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);\n            if (jumpTime < Time.time) isJump = false;\n        }\n\n    }\n\n    void flipDirection()//改变角色图案方向\n    {\n        if (xVelocity > 0) transform.localScale = new Vector2 (1, 1);\n        else if (xVelocity < 0) transform.localScale = new Vector2(-1, 1);\n    }\n\n    void Crouch()//下蹲时的各种改变\n    {\n        isCrouch = true;\n        xVelocity *= crouchSpeedFactor;\n        cd.size = crouchSize;\n        cd.offset = crouchOffset;\n    }\n\n    void StandUp()//从下蹲转变为站立时各种变化\n    {\n        isCrouch = false;\n        xVelocity /= crouchSpeedFactor;\n        cd.size = standSize;\n        cd.offset = standOffset;\n    }\n}\n```\n\n","source":"_posts/2021-07-19-《Robbie Swifthand》Unity2d独立游戏学习（二）.md","raw":"---\ntitle: 《Robbie Swifthand》Unity2d独立游戏学习（二）\ndate: 2021-07-19 15:23:30\ncategories: unity\ntags:\n  - unity\n  - c#\n  - update\n  - time\n---\n\n\n\n### \t一、添加物理组件\n\n1.给Platforms 添加Tilemap Collider 2D，勾选Used By Composite，添加Composite Collider 2D\n\n2.将Platforms自动添加的Rigidbody 2D 选择成Static 模式\n\n3.给主角添加Rigidbody 2D，把Collision Detection选择成Continuous连续不断地检测碰撞，把Interpolate 设置成Interpolate产生碰撞时会有一个缓冲的效果\n\n4.添加Box Collider 2D，调整主角碰撞器大小，size - y 最好设置在 2 以下，这样就可以通过两格高的空间\n\n5.运行，发现在角落处下落会导致角色翻转，需要在主角Rigidbody 2D 中锁定 z 轴\n\n6.为了避免角色碰到墙壁时会卡进墙体里，给主角Box Collider 2D添加Material 物理材质Teflon（资源包里的，摩擦力和弹力都是0）\n\n7.新增Layer ，主角设置成Player，Platforms 设置成Ground，以供后面进行碰撞检测\n\n\n\n<!--more-->\n\n\n\n---\n\n\n\n### 二、角色移动\n\n1.在Scripts文件夹新建PlayerMovement脚本，编写代码：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerMovement : MonoBehaviour\n{\n    private Rigidbody2D rb;\n\n    [Header(\"移动参数\")]\n    public float speed = 10f;\n    public float crouchSpeedDivisor = 5f;\n    private float xVelocity;\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n    }\n\n    void Update()//每帧调用\n    {\n        \n    }\n\n    private void FixedUpdate()//每一段时间调用，默认0.02s\n    {\n        GroundMovement();\n    }\n\n    void GroundMovement()\n    {\n        xVelocity = Input.GetAxis(\"Horizontal\");//-1f ~ 1f\n        //在FixedUpdate()中调用无需Time.deltatime\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n        flipDirection();\n    }\n\n\n    void flipDirection()\n    {\n        if (xVelocity > 0) transform.localScale = new Vector2 (1, 1);\n        else if (xVelocity < 0) transform.localScale = new Vector2(-1, 1);\n    }\n}\n```\n\n键盘左右键可以让主角左右移动，并且会改变图案方向\n\n\n\n---\n\n\n\n### 三、下蹲\n\n1.打开Edit - Project Settings - Input ，复制Jump 命名为Crouch，Positive Button 改为down，Alt Positive Button 改为 s\n\n2.修改角色移动代码：\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerMovement : MonoBehaviour\n{\n    private Rigidbody2D rb;\n    private BoxCollider2D cd;\n\n    [Header(\"移动参数\")]\n    public float speed = 10f;\n    public float crouchSpeedFactor = 0.5f;\n    private float xVelocity;\n\n    [Header(\"角色状态\")]\n    public bool isCrouch;\n\n    //碰撞体尺寸\n    private Vector2 crouchOffset;\n    private Vector2 crouchSize;\n    private Vector2 standOffset;\n    private Vector2 standSize;\n\n\n    void Start()\n    {\n        rb = GetComponent<Rigidbody2D>();\n        cd = GetComponent<BoxCollider2D>();\n\n        standOffset = cd.offset;\n        standSize = cd.size;\n        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);\n        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);\n    }\n\n\n    void Update()//每帧调用\n    {\n        \n    }\n\n\n    private void FixedUpdate()//每一段时间调用，默认0.02s\n    {\n        GroundMovement();\n    }\n    void GroundMovement()//移动的各种数值\n    {\n        xVelocity = Input.GetAxis(\"Horizontal\");//-1f ~ 1f\n        if (Input.GetButton(\"Crouch\")) Crouch();\n        else if (isCrouch) StandUp();\n\n        //在FixedUpdate()中调用无需Time.deltatime\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n        flipDirection();\n    }\n    void flipDirection()//改变角色图案方向\n    {\n        if (xVelocity > 0) transform.localScale = new Vector2 (1, 1);\n        else if (xVelocity < 0) transform.localScale = new Vector2(-1, 1);\n    }\n\n    void Crouch()//下蹲时的各种改变\n    {\n        isCrouch = true;\n        xVelocity *= crouchSpeedFactor;\n        cd.size = crouchSize;\n        cd.offset = crouchOffset;\n    }\n    void StandUp()//从下蹲转变为站立时各种变化\n    {\n        isCrouch = false;\n        xVelocity /= crouchSpeedFactor;\n        cd.size = standSize;\n        cd.offset = standOffset;\n    }\n}\n```\n\n顺便给每个函数添加了注释\n\n现在，按下s键或者方向下键就会让角色的碰撞体 “蹲下\" （移动速度变慢并且碰撞体高度减半）\n\n\n\n测试一下确实可以通过高度为1的障碍了，但是在经过障碍的途中如果松开下蹲键，就会穿模卡在墙里，因为缺少了在通过障碍时需要持续下蹲的判断，这一部分放到后面再处理\n\n\n\n---\n\n\n\n### 四、跳跃\n\n1.打开Edit - Project Setting - Physics 2D，将 y 轴重力改大一点，这里改为-50\n\n2.先添加与跳跃有关的参数：\n\n```\n    [Header(\"跳跃参数\")]\n    public float jumpForce = 5f;\n    public float jumpHoldForce = 3f;\n    public float jumpHoldDuration = 0.1f;\n    public float crouchJumpBoost = 3f;\n    float jumpTime;\n```\n\n其中jumpTime 是允许长按跳跃加高的时间\n\n\n\n3.添加判断各种状态的参数：\n\n```\n    [Header(\"按键状态\")]\n    public bool jumpPressed;\n    public bool jumpHeld;\n    public bool crouchHeld;\n\n    [Header(\"角色状态\")]\n    public bool isCrouch;\n    public bool isOnGround;\n    public bool isJump;\n\n    [Header(\"环境检测\")]\n    public LayerMask groundLayer;\n```\n\n同时可以更新一下之前的下蹲判断，用刚刚定义的状态参数\n\n\n\n4.在Update（）中获取按键信息：\n\n```\n    void Update()//每帧调用\n    {\n        //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化\n        if (Input.GetButtonDown(\"Jump\")) jumpPressed = true;\n\n        jumpHeld = Input.GetButton(\"Jump\");\n        crouchHeld = Input.GetButton(\"Crouch\");\n    }\n```\n\n\n\n5.添加判断是否在地面上：\n\n```\n\tvoid PhysicsCheck()//检测是否在地面，并修改状态\n    {\n        isOnGround = cd.IsTouchingLayers(groundLayer);\n\n    }\n```\n\n记得在FixedUpdate（）中调用，物理性质都推荐放在FixedUpdate中\n\n\n\n6.添加跳跃函数：\n\n```\n    void MidAirMovement()//跳跃移动\n    {\n        if(jumpPressed && isOnGround && !isJump)//起跳\n        {\n            if(crouchHeld)//判断是否要蹲跳\n            {\n                rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);\n            }\n            jumpTime = Time.time + jumpHoldDuration;\n            rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);\n            jumpPressed = false;\n            isJump = true;\n        }\n\n        else if(isJump)\n        {\n            if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);\n            if (jumpTime < Time.time) isJump = false;\n        }\n\n    }\n```\n\n精髓就是`jumpTime = Time.time + jumpHoldDuration;`，`if (jumpTime < Time.time) isJump = false;` \n\n这两句代码可以很好地对能否在空中持续加速进行判断\n\n\n\n---\n\n\n\n### 终、总结\n\n这次的跳跃代码真的收获不少，Update和FixedUpdate可以理解成完全独立的两个函数\n\n这一波折腾下来角色控制脚本 PlayerMovement 有点长了，这里先全部放上来记录一下，以便日后回顾\n\n```\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class PlayerMovement : MonoBehaviour\n{\n    //组件\n    private Rigidbody2D rb;\n    private BoxCollider2D cd;\n\n    [Header(\"移动参数\")]\n    public float speed = 10f;\n    public float crouchSpeedFactor = 0.5f;\n    float xVelocity;\n\n    [Header(\"跳跃参数\")]\n    public float jumpForce = 5f;\n    public float jumpHoldForce = 3f;\n    public float jumpHoldDuration = 0.1f;\n    public float crouchJumpBoost = 3f;\n    float jumpTime;\n\n    [Header(\"按键状态\")]\n    public bool jumpPressed;\n    public bool jumpHeld;\n    public bool crouchHeld;\n\n    [Header(\"角色状态\")]\n    public bool isCrouch;\n    public bool isOnGround;\n    public bool isJump;\n\n    [Header(\"环境检测\")]\n    public LayerMask groundLayer;\n\n    //碰撞体尺寸\n    private Vector2 crouchOffset;\n    private Vector2 crouchSize;\n    private Vector2 standOffset;\n    private Vector2 standSize;\n\n    void Start()\n    {\n        //获取组件\n        rb = GetComponent<Rigidbody2D>();\n        cd = GetComponent<BoxCollider2D>();\n\n        //初始化\n        standOffset = cd.offset;\n        standSize = cd.size;\n        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);\n        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);\n    }\n\n\n    void Update()//每帧调用\n    {\n        //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化\n        if (Input.GetButtonDown(\"Jump\")) jumpPressed = true;\n\n        jumpHeld = Input.GetButton(\"Jump\");\n        crouchHeld = Input.GetButton(\"Crouch\");\n    }\n\n\n    private void FixedUpdate()//每一段时间调用，unity默认0.02s\n    {\n        PhysicsCheck();\n        GroundMovement();\n        MidAirMovement();\n    }\n\n    void PhysicsCheck()//检测是否在地面，并修改状态\n    {\n        isOnGround = cd.IsTouchingLayers(groundLayer);\n\n    }\n\n\n    void GroundMovement()//移动的各种数值\n    {\n        xVelocity = Input.GetAxis(\"Horizontal\");//-1f ~ 1f\n        if (crouchHeld && !isCrouch && isOnGround) Crouch();\n        else if ((isCrouch && !crouchHeld) || isJump) StandUp();\n\n\n        //在FixedUpdate()中调用无需Time.deltatime\n        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);\n        flipDirection();\n    }\n\n    void MidAirMovement()//跳跃移动\n    {\n        if(jumpPressed && isOnGround && !isJump)//起跳\n        {\n            if(crouchHeld)//判断是否要蹲跳\n            {\n                rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);\n            }\n            jumpTime = Time.time + jumpHoldDuration;\n            rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);\n            jumpPressed = false;\n            isJump = true;\n        }\n\n        else if(isJump)\n        {\n            if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);\n            if (jumpTime < Time.time) isJump = false;\n        }\n\n    }\n\n    void flipDirection()//改变角色图案方向\n    {\n        if (xVelocity > 0) transform.localScale = new Vector2 (1, 1);\n        else if (xVelocity < 0) transform.localScale = new Vector2(-1, 1);\n    }\n\n    void Crouch()//下蹲时的各种改变\n    {\n        isCrouch = true;\n        xVelocity *= crouchSpeedFactor;\n        cd.size = crouchSize;\n        cd.offset = crouchOffset;\n    }\n\n    void StandUp()//从下蹲转变为站立时各种变化\n    {\n        isCrouch = false;\n        xVelocity /= crouchSpeedFactor;\n        cd.size = standSize;\n        cd.offset = standOffset;\n    }\n}\n```\n\n","slug":"2021-07-19-《Robbie Swifthand》Unity2d独立游戏学习（二）","published":1,"updated":"2021-07-19T14:38:51.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnimj000vf4u024ty9ck5","content":"<h3 id=\"一、添加物理组件\"><a href=\"#一、添加物理组件\" class=\"headerlink\" title=\"一、添加物理组件\"></a>一、添加物理组件</h3><p>1.给Platforms 添加Tilemap Collider 2D，勾选Used By Composite，添加Composite Collider 2D</p>\n<p>2.将Platforms自动添加的Rigidbody 2D 选择成Static 模式</p>\n<p>3.给主角添加Rigidbody 2D，把Collision Detection选择成Continuous连续不断地检测碰撞，把Interpolate 设置成Interpolate产生碰撞时会有一个缓冲的效果</p>\n<p>4.添加Box Collider 2D，调整主角碰撞器大小，size - y 最好设置在 2 以下，这样就可以通过两格高的空间</p>\n<p>5.运行，发现在角落处下落会导致角色翻转，需要在主角Rigidbody 2D 中锁定 z 轴</p>\n<p>6.为了避免角色碰到墙壁时会卡进墙体里，给主角Box Collider 2D添加Material 物理材质Teflon（资源包里的，摩擦力和弹力都是0）</p>\n<p>7.新增Layer ，主角设置成Player，Platforms 设置成Ground，以供后面进行碰撞检测</p>\n<span id=\"more\"></span>\n\n\n\n<hr>\n<h3 id=\"二、角色移动\"><a href=\"#二、角色移动\" class=\"headerlink\" title=\"二、角色移动\"></a>二、角色移动</h3><p>1.在Scripts文件夹新建PlayerMovement脚本，编写代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerMovement : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private Rigidbody2D rb;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;移动参数&quot;)]</span><br><span class=\"line\">    public float speed = 10f;</span><br><span class=\"line\">    public float crouchSpeedDivisor = 5f;</span><br><span class=\"line\">    private float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()//每帧调用</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void FixedUpdate()//每一段时间调用，默认0.02s</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        GroundMovement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void GroundMovement()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxis(&quot;Horizontal&quot;);//-1f ~ 1f</span><br><span class=\"line\">        //在FixedUpdate()中调用无需Time.deltatime</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\">        flipDirection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void flipDirection()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (xVelocity &gt; 0) transform.localScale = new Vector2 (1, 1);</span><br><span class=\"line\">        else if (xVelocity &lt; 0) transform.localScale = new Vector2(-1, 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>键盘左右键可以让主角左右移动，并且会改变图案方向</p>\n<hr>\n<h3 id=\"三、下蹲\"><a href=\"#三、下蹲\" class=\"headerlink\" title=\"三、下蹲\"></a>三、下蹲</h3><p>1.打开Edit - Project Settings - Input ，复制Jump 命名为Crouch，Positive Button 改为down，Alt Positive Button 改为 s</p>\n<p>2.修改角色移动代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerMovement : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private Rigidbody2D rb;</span><br><span class=\"line\">    private BoxCollider2D cd;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;移动参数&quot;)]</span><br><span class=\"line\">    public float speed = 10f;</span><br><span class=\"line\">    public float crouchSpeedFactor = 0.5f;</span><br><span class=\"line\">    private float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;角色状态&quot;)]</span><br><span class=\"line\">    public bool isCrouch;</span><br><span class=\"line\"></span><br><span class=\"line\">    //碰撞体尺寸</span><br><span class=\"line\">    private Vector2 crouchOffset;</span><br><span class=\"line\">    private Vector2 crouchSize;</span><br><span class=\"line\">    private Vector2 standOffset;</span><br><span class=\"line\">    private Vector2 standSize;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">        cd = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        standOffset = cd.offset;</span><br><span class=\"line\">        standSize = cd.size;</span><br><span class=\"line\">        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);</span><br><span class=\"line\">        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()//每帧调用</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private void FixedUpdate()//每一段时间调用，默认0.02s</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        GroundMovement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void GroundMovement()//移动的各种数值</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxis(&quot;Horizontal&quot;);//-1f ~ 1f</span><br><span class=\"line\">        if (Input.GetButton(&quot;Crouch&quot;)) Crouch();</span><br><span class=\"line\">        else if (isCrouch) StandUp();</span><br><span class=\"line\"></span><br><span class=\"line\">        //在FixedUpdate()中调用无需Time.deltatime</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\">        flipDirection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void flipDirection()//改变角色图案方向</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (xVelocity &gt; 0) transform.localScale = new Vector2 (1, 1);</span><br><span class=\"line\">        else if (xVelocity &lt; 0) transform.localScale = new Vector2(-1, 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Crouch()//下蹲时的各种改变</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isCrouch = true;</span><br><span class=\"line\">        xVelocity *= crouchSpeedFactor;</span><br><span class=\"line\">        cd.size = crouchSize;</span><br><span class=\"line\">        cd.offset = crouchOffset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void StandUp()//从下蹲转变为站立时各种变化</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isCrouch = false;</span><br><span class=\"line\">        xVelocity /= crouchSpeedFactor;</span><br><span class=\"line\">        cd.size = standSize;</span><br><span class=\"line\">        cd.offset = standOffset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>顺便给每个函数添加了注释</p>\n<p>现在，按下s键或者方向下键就会让角色的碰撞体 “蹲下” （移动速度变慢并且碰撞体高度减半）</p>\n<p>测试一下确实可以通过高度为1的障碍了，但是在经过障碍的途中如果松开下蹲键，就会穿模卡在墙里，因为缺少了在通过障碍时需要持续下蹲的判断，这一部分放到后面再处理</p>\n<hr>\n<h3 id=\"四、跳跃\"><a href=\"#四、跳跃\" class=\"headerlink\" title=\"四、跳跃\"></a>四、跳跃</h3><p>1.打开Edit - Project Setting - Physics 2D，将 y 轴重力改大一点，这里改为-50</p>\n<p>2.先添加与跳跃有关的参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;跳跃参数&quot;)]</span><br><span class=\"line\">public float jumpForce = 5f;</span><br><span class=\"line\">public float jumpHoldForce = 3f;</span><br><span class=\"line\">public float jumpHoldDuration = 0.1f;</span><br><span class=\"line\">public float crouchJumpBoost = 3f;</span><br><span class=\"line\">float jumpTime;</span><br></pre></td></tr></table></figure>\n\n<p>其中jumpTime 是允许长按跳跃加高的时间</p>\n<p>3.添加判断各种状态的参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;按键状态&quot;)]</span><br><span class=\"line\">public bool jumpPressed;</span><br><span class=\"line\">public bool jumpHeld;</span><br><span class=\"line\">public bool crouchHeld;</span><br><span class=\"line\"></span><br><span class=\"line\">[Header(&quot;角色状态&quot;)]</span><br><span class=\"line\">public bool isCrouch;</span><br><span class=\"line\">public bool isOnGround;</span><br><span class=\"line\">public bool isJump;</span><br><span class=\"line\"></span><br><span class=\"line\">[Header(&quot;环境检测&quot;)]</span><br><span class=\"line\">public LayerMask groundLayer;</span><br></pre></td></tr></table></figure>\n\n<p>同时可以更新一下之前的下蹲判断，用刚刚定义的状态参数</p>\n<p>4.在Update（）中获取按键信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Update()//每帧调用</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化</span><br><span class=\"line\">    if (Input.GetButtonDown(&quot;Jump&quot;)) jumpPressed = true;</span><br><span class=\"line\"></span><br><span class=\"line\">    jumpHeld = Input.GetButton(&quot;Jump&quot;);</span><br><span class=\"line\">    crouchHeld = Input.GetButton(&quot;Crouch&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>5.添加判断是否在地面上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       isOnGround = cd.IsTouchingLayers(groundLayer);</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>记得在FixedUpdate（）中调用，物理性质都推荐放在FixedUpdate中</p>\n<p>6.添加跳跃函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void MidAirMovement()//跳跃移动</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump)//起跳</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(crouchHeld)//判断是否要蹲跳</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        jumpTime = Time.time + jumpHoldDuration;</span><br><span class=\"line\">        rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);</span><br><span class=\"line\">        jumpPressed = false;</span><br><span class=\"line\">        isJump = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    else if(isJump)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);</span><br><span class=\"line\">        if (jumpTime &lt; Time.time) isJump = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>精髓就是<code>jumpTime = Time.time + jumpHoldDuration;</code>，<code>if (jumpTime &lt; Time.time) isJump = false;</code> </p>\n<p>这两句代码可以很好地对能否在空中持续加速进行判断</p>\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>这次的跳跃代码真的收获不少，Update和FixedUpdate可以理解成完全独立的两个函数</p>\n<p>这一波折腾下来角色控制脚本 PlayerMovement 有点长了，这里先全部放上来记录一下，以便日后回顾</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerMovement : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //组件</span><br><span class=\"line\">    private Rigidbody2D rb;</span><br><span class=\"line\">    private BoxCollider2D cd;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;移动参数&quot;)]</span><br><span class=\"line\">    public float speed = 10f;</span><br><span class=\"line\">    public float crouchSpeedFactor = 0.5f;</span><br><span class=\"line\">    float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;跳跃参数&quot;)]</span><br><span class=\"line\">    public float jumpForce = 5f;</span><br><span class=\"line\">    public float jumpHoldForce = 3f;</span><br><span class=\"line\">    public float jumpHoldDuration = 0.1f;</span><br><span class=\"line\">    public float crouchJumpBoost = 3f;</span><br><span class=\"line\">    float jumpTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;按键状态&quot;)]</span><br><span class=\"line\">    public bool jumpPressed;</span><br><span class=\"line\">    public bool jumpHeld;</span><br><span class=\"line\">    public bool crouchHeld;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;角色状态&quot;)]</span><br><span class=\"line\">    public bool isCrouch;</span><br><span class=\"line\">    public bool isOnGround;</span><br><span class=\"line\">    public bool isJump;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;环境检测&quot;)]</span><br><span class=\"line\">    public LayerMask groundLayer;</span><br><span class=\"line\"></span><br><span class=\"line\">    //碰撞体尺寸</span><br><span class=\"line\">    private Vector2 crouchOffset;</span><br><span class=\"line\">    private Vector2 crouchSize;</span><br><span class=\"line\">    private Vector2 standOffset;</span><br><span class=\"line\">    private Vector2 standSize;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //获取组件</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">        cd = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        //初始化</span><br><span class=\"line\">        standOffset = cd.offset;</span><br><span class=\"line\">        standSize = cd.size;</span><br><span class=\"line\">        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);</span><br><span class=\"line\">        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()//每帧调用</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化</span><br><span class=\"line\">        if (Input.GetButtonDown(&quot;Jump&quot;)) jumpPressed = true;</span><br><span class=\"line\"></span><br><span class=\"line\">        jumpHeld = Input.GetButton(&quot;Jump&quot;);</span><br><span class=\"line\">        crouchHeld = Input.GetButton(&quot;Crouch&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private void FixedUpdate()//每一段时间调用，unity默认0.02s</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        PhysicsCheck();</span><br><span class=\"line\">        GroundMovement();</span><br><span class=\"line\">        MidAirMovement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isOnGround = cd.IsTouchingLayers(groundLayer);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void GroundMovement()//移动的各种数值</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxis(&quot;Horizontal&quot;);//-1f ~ 1f</span><br><span class=\"line\">        if (crouchHeld &amp;&amp; !isCrouch &amp;&amp; isOnGround) Crouch();</span><br><span class=\"line\">        else if ((isCrouch &amp;&amp; !crouchHeld) || isJump) StandUp();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        //在FixedUpdate()中调用无需Time.deltatime</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\">        flipDirection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void MidAirMovement()//跳跃移动</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump)//起跳</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if(crouchHeld)//判断是否要蹲跳</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            jumpTime = Time.time + jumpHoldDuration;</span><br><span class=\"line\">            rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);</span><br><span class=\"line\">            jumpPressed = false;</span><br><span class=\"line\">            isJump = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        else if(isJump)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);</span><br><span class=\"line\">            if (jumpTime &lt; Time.time) isJump = false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void flipDirection()//改变角色图案方向</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (xVelocity &gt; 0) transform.localScale = new Vector2 (1, 1);</span><br><span class=\"line\">        else if (xVelocity &lt; 0) transform.localScale = new Vector2(-1, 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Crouch()//下蹲时的各种改变</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isCrouch = true;</span><br><span class=\"line\">        xVelocity *= crouchSpeedFactor;</span><br><span class=\"line\">        cd.size = crouchSize;</span><br><span class=\"line\">        cd.offset = crouchOffset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void StandUp()//从下蹲转变为站立时各种变化</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isCrouch = false;</span><br><span class=\"line\">        xVelocity /= crouchSpeedFactor;</span><br><span class=\"line\">        cd.size = standSize;</span><br><span class=\"line\">        cd.offset = standOffset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"一、添加物理组件\"><a href=\"#一、添加物理组件\" class=\"headerlink\" title=\"一、添加物理组件\"></a>一、添加物理组件</h3><p>1.给Platforms 添加Tilemap Collider 2D，勾选Used By Composite，添加Composite Collider 2D</p>\n<p>2.将Platforms自动添加的Rigidbody 2D 选择成Static 模式</p>\n<p>3.给主角添加Rigidbody 2D，把Collision Detection选择成Continuous连续不断地检测碰撞，把Interpolate 设置成Interpolate产生碰撞时会有一个缓冲的效果</p>\n<p>4.添加Box Collider 2D，调整主角碰撞器大小，size - y 最好设置在 2 以下，这样就可以通过两格高的空间</p>\n<p>5.运行，发现在角落处下落会导致角色翻转，需要在主角Rigidbody 2D 中锁定 z 轴</p>\n<p>6.为了避免角色碰到墙壁时会卡进墙体里，给主角Box Collider 2D添加Material 物理材质Teflon（资源包里的，摩擦力和弹力都是0）</p>\n<p>7.新增Layer ，主角设置成Player，Platforms 设置成Ground，以供后面进行碰撞检测</p>","more":"<hr>\n<h3 id=\"二、角色移动\"><a href=\"#二、角色移动\" class=\"headerlink\" title=\"二、角色移动\"></a>二、角色移动</h3><p>1.在Scripts文件夹新建PlayerMovement脚本，编写代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerMovement : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private Rigidbody2D rb;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;移动参数&quot;)]</span><br><span class=\"line\">    public float speed = 10f;</span><br><span class=\"line\">    public float crouchSpeedDivisor = 5f;</span><br><span class=\"line\">    private float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()//每帧调用</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    private void FixedUpdate()//每一段时间调用，默认0.02s</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        GroundMovement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void GroundMovement()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxis(&quot;Horizontal&quot;);//-1f ~ 1f</span><br><span class=\"line\">        //在FixedUpdate()中调用无需Time.deltatime</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\">        flipDirection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void flipDirection()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (xVelocity &gt; 0) transform.localScale = new Vector2 (1, 1);</span><br><span class=\"line\">        else if (xVelocity &lt; 0) transform.localScale = new Vector2(-1, 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>键盘左右键可以让主角左右移动，并且会改变图案方向</p>\n<hr>\n<h3 id=\"三、下蹲\"><a href=\"#三、下蹲\" class=\"headerlink\" title=\"三、下蹲\"></a>三、下蹲</h3><p>1.打开Edit - Project Settings - Input ，复制Jump 命名为Crouch，Positive Button 改为down，Alt Positive Button 改为 s</p>\n<p>2.修改角色移动代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerMovement : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    private Rigidbody2D rb;</span><br><span class=\"line\">    private BoxCollider2D cd;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;移动参数&quot;)]</span><br><span class=\"line\">    public float speed = 10f;</span><br><span class=\"line\">    public float crouchSpeedFactor = 0.5f;</span><br><span class=\"line\">    private float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;角色状态&quot;)]</span><br><span class=\"line\">    public bool isCrouch;</span><br><span class=\"line\"></span><br><span class=\"line\">    //碰撞体尺寸</span><br><span class=\"line\">    private Vector2 crouchOffset;</span><br><span class=\"line\">    private Vector2 crouchSize;</span><br><span class=\"line\">    private Vector2 standOffset;</span><br><span class=\"line\">    private Vector2 standSize;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">        cd = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        standOffset = cd.offset;</span><br><span class=\"line\">        standSize = cd.size;</span><br><span class=\"line\">        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);</span><br><span class=\"line\">        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()//每帧调用</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private void FixedUpdate()//每一段时间调用，默认0.02s</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        GroundMovement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void GroundMovement()//移动的各种数值</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxis(&quot;Horizontal&quot;);//-1f ~ 1f</span><br><span class=\"line\">        if (Input.GetButton(&quot;Crouch&quot;)) Crouch();</span><br><span class=\"line\">        else if (isCrouch) StandUp();</span><br><span class=\"line\"></span><br><span class=\"line\">        //在FixedUpdate()中调用无需Time.deltatime</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\">        flipDirection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void flipDirection()//改变角色图案方向</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (xVelocity &gt; 0) transform.localScale = new Vector2 (1, 1);</span><br><span class=\"line\">        else if (xVelocity &lt; 0) transform.localScale = new Vector2(-1, 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Crouch()//下蹲时的各种改变</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isCrouch = true;</span><br><span class=\"line\">        xVelocity *= crouchSpeedFactor;</span><br><span class=\"line\">        cd.size = crouchSize;</span><br><span class=\"line\">        cd.offset = crouchOffset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    void StandUp()//从下蹲转变为站立时各种变化</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isCrouch = false;</span><br><span class=\"line\">        xVelocity /= crouchSpeedFactor;</span><br><span class=\"line\">        cd.size = standSize;</span><br><span class=\"line\">        cd.offset = standOffset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>顺便给每个函数添加了注释</p>\n<p>现在，按下s键或者方向下键就会让角色的碰撞体 “蹲下” （移动速度变慢并且碰撞体高度减半）</p>\n<p>测试一下确实可以通过高度为1的障碍了，但是在经过障碍的途中如果松开下蹲键，就会穿模卡在墙里，因为缺少了在通过障碍时需要持续下蹲的判断，这一部分放到后面再处理</p>\n<hr>\n<h3 id=\"四、跳跃\"><a href=\"#四、跳跃\" class=\"headerlink\" title=\"四、跳跃\"></a>四、跳跃</h3><p>1.打开Edit - Project Setting - Physics 2D，将 y 轴重力改大一点，这里改为-50</p>\n<p>2.先添加与跳跃有关的参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;跳跃参数&quot;)]</span><br><span class=\"line\">public float jumpForce = 5f;</span><br><span class=\"line\">public float jumpHoldForce = 3f;</span><br><span class=\"line\">public float jumpHoldDuration = 0.1f;</span><br><span class=\"line\">public float crouchJumpBoost = 3f;</span><br><span class=\"line\">float jumpTime;</span><br></pre></td></tr></table></figure>\n\n<p>其中jumpTime 是允许长按跳跃加高的时间</p>\n<p>3.添加判断各种状态的参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;按键状态&quot;)]</span><br><span class=\"line\">public bool jumpPressed;</span><br><span class=\"line\">public bool jumpHeld;</span><br><span class=\"line\">public bool crouchHeld;</span><br><span class=\"line\"></span><br><span class=\"line\">[Header(&quot;角色状态&quot;)]</span><br><span class=\"line\">public bool isCrouch;</span><br><span class=\"line\">public bool isOnGround;</span><br><span class=\"line\">public bool isJump;</span><br><span class=\"line\"></span><br><span class=\"line\">[Header(&quot;环境检测&quot;)]</span><br><span class=\"line\">public LayerMask groundLayer;</span><br></pre></td></tr></table></figure>\n\n<p>同时可以更新一下之前的下蹲判断，用刚刚定义的状态参数</p>\n<p>4.在Update（）中获取按键信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void Update()//每帧调用</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化</span><br><span class=\"line\">    if (Input.GetButtonDown(&quot;Jump&quot;)) jumpPressed = true;</span><br><span class=\"line\"></span><br><span class=\"line\">    jumpHeld = Input.GetButton(&quot;Jump&quot;);</span><br><span class=\"line\">    crouchHeld = Input.GetButton(&quot;Crouch&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>5.添加判断是否在地面上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">       isOnGround = cd.IsTouchingLayers(groundLayer);</span><br><span class=\"line\"></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>记得在FixedUpdate（）中调用，物理性质都推荐放在FixedUpdate中</p>\n<p>6.添加跳跃函数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void MidAirMovement()//跳跃移动</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump)//起跳</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(crouchHeld)//判断是否要蹲跳</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        jumpTime = Time.time + jumpHoldDuration;</span><br><span class=\"line\">        rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);</span><br><span class=\"line\">        jumpPressed = false;</span><br><span class=\"line\">        isJump = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    else if(isJump)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);</span><br><span class=\"line\">        if (jumpTime &lt; Time.time) isJump = false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>精髓就是<code>jumpTime = Time.time + jumpHoldDuration;</code>，<code>if (jumpTime &lt; Time.time) isJump = false;</code> </p>\n<p>这两句代码可以很好地对能否在空中持续加速进行判断</p>\n<hr>\n<h3 id=\"终、总结\"><a href=\"#终、总结\" class=\"headerlink\" title=\"终、总结\"></a>终、总结</h3><p>这次的跳跃代码真的收获不少，Update和FixedUpdate可以理解成完全独立的两个函数</p>\n<p>这一波折腾下来角色控制脚本 PlayerMovement 有点长了，这里先全部放上来记录一下，以便日后回顾</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">using System.Collections;</span><br><span class=\"line\">using System.Collections.Generic;</span><br><span class=\"line\">using UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PlayerMovement : MonoBehaviour</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //组件</span><br><span class=\"line\">    private Rigidbody2D rb;</span><br><span class=\"line\">    private BoxCollider2D cd;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;移动参数&quot;)]</span><br><span class=\"line\">    public float speed = 10f;</span><br><span class=\"line\">    public float crouchSpeedFactor = 0.5f;</span><br><span class=\"line\">    float xVelocity;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;跳跃参数&quot;)]</span><br><span class=\"line\">    public float jumpForce = 5f;</span><br><span class=\"line\">    public float jumpHoldForce = 3f;</span><br><span class=\"line\">    public float jumpHoldDuration = 0.1f;</span><br><span class=\"line\">    public float crouchJumpBoost = 3f;</span><br><span class=\"line\">    float jumpTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;按键状态&quot;)]</span><br><span class=\"line\">    public bool jumpPressed;</span><br><span class=\"line\">    public bool jumpHeld;</span><br><span class=\"line\">    public bool crouchHeld;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;角色状态&quot;)]</span><br><span class=\"line\">    public bool isCrouch;</span><br><span class=\"line\">    public bool isOnGround;</span><br><span class=\"line\">    public bool isJump;</span><br><span class=\"line\"></span><br><span class=\"line\">    [Header(&quot;环境检测&quot;)]</span><br><span class=\"line\">    public LayerMask groundLayer;</span><br><span class=\"line\"></span><br><span class=\"line\">    //碰撞体尺寸</span><br><span class=\"line\">    private Vector2 crouchOffset;</span><br><span class=\"line\">    private Vector2 crouchSize;</span><br><span class=\"line\">    private Vector2 standOffset;</span><br><span class=\"line\">    private Vector2 standSize;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Start()</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //获取组件</span><br><span class=\"line\">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class=\"line\">        cd = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">        //初始化</span><br><span class=\"line\">        standOffset = cd.offset;</span><br><span class=\"line\">        standSize = cd.size;</span><br><span class=\"line\">        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);</span><br><span class=\"line\">        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void Update()//每帧调用</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化</span><br><span class=\"line\">        if (Input.GetButtonDown(&quot;Jump&quot;)) jumpPressed = true;</span><br><span class=\"line\"></span><br><span class=\"line\">        jumpHeld = Input.GetButton(&quot;Jump&quot;);</span><br><span class=\"line\">        crouchHeld = Input.GetButton(&quot;Crouch&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private void FixedUpdate()//每一段时间调用，unity默认0.02s</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        PhysicsCheck();</span><br><span class=\"line\">        GroundMovement();</span><br><span class=\"line\">        MidAirMovement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isOnGround = cd.IsTouchingLayers(groundLayer);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    void GroundMovement()//移动的各种数值</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        xVelocity = Input.GetAxis(&quot;Horizontal&quot;);//-1f ~ 1f</span><br><span class=\"line\">        if (crouchHeld &amp;&amp; !isCrouch &amp;&amp; isOnGround) Crouch();</span><br><span class=\"line\">        else if ((isCrouch &amp;&amp; !crouchHeld) || isJump) StandUp();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        //在FixedUpdate()中调用无需Time.deltatime</span><br><span class=\"line\">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class=\"line\">        flipDirection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void MidAirMovement()//跳跃移动</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump)//起跳</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if(crouchHeld)//判断是否要蹲跳</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            jumpTime = Time.time + jumpHoldDuration;</span><br><span class=\"line\">            rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);</span><br><span class=\"line\">            jumpPressed = false;</span><br><span class=\"line\">            isJump = true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        else if(isJump)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);</span><br><span class=\"line\">            if (jumpTime &lt; Time.time) isJump = false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void flipDirection()//改变角色图案方向</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (xVelocity &gt; 0) transform.localScale = new Vector2 (1, 1);</span><br><span class=\"line\">        else if (xVelocity &lt; 0) transform.localScale = new Vector2(-1, 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void Crouch()//下蹲时的各种改变</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isCrouch = true;</span><br><span class=\"line\">        xVelocity *= crouchSpeedFactor;</span><br><span class=\"line\">        cd.size = crouchSize;</span><br><span class=\"line\">        cd.offset = crouchOffset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void StandUp()//从下蹲转变为站立时各种变化</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        isCrouch = false;</span><br><span class=\"line\">        xVelocity /= crouchSpeedFactor;</span><br><span class=\"line\">        cd.size = standSize;</span><br><span class=\"line\">        cd.offset = standOffset;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"《Robbie Swifthand》Unity2d独立游戏学习（三）","date":"2021-07-20T07:36:35.000Z","_content":"\n\n\n\n\n### \t始、前言\n\n简单的角色移动已经完成了，这次来学习用Raycast 射线检测的方法让角色的状态检测变得更细致\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、Physics2D.Raycast 脚本API\n\n```\npublic static RaycastHit2D Raycast (Vector2 origin, Vector2 direction, float distance= Mathf.Infinity, int layerMask= DefaultRaycastLayers, float minDepth= -Mathf.Infinity, float maxDepth= Mathf.Infinity);\n```\n\n参数\n\n| origin    | 射线在 2D 空间中的起点。                    |\n| --------- | ------------------------------------------- |\n| direction | 表示射线方向的矢量。                        |\n| distance  | 射线的最大投射距离。                        |\n| layerMask | 过滤器，用于仅在特定层上检测碰撞体。        |\n| minDepth  | 仅包括 Z 坐标（深度）大于或等于该值的对象。 |\n| maxDepth  | 仅包括 Z 坐标（深度）小于或等于该值的对象。 |\n\n返回**`RaycastHit2D`** 返回的投射数量。\n\n描述：\n\n向场景中的碰撞体投射射线。\n\n从概念上说，*射线投射* 类似于从空间中的某个点朝特定方向发射一条光束。在该过程中，可以检测并报告与光束接触的任何对象。\n\n函数返回一个 `RaycastHit` 对象，该对象引用了射线命中的碰撞体（如果未命中任何对象，则结果的碰撞体属性将为 NULL）。*`layerMask`* 可用于仅在特定层上有选择地检测对象（例如，这让您能够仅将检测应用于敌人角色）。\n\n使用 `contactFilter` 的此方法重载可以按 `ContactFilter2D` 中提供的选项筛选结果。\n\n对于确定视线、炮火击中的目标以及游戏中的许多其他目的来说，射线投射很有用。\n\n此外，这还将检测位于射线起点的碰撞体。在这种情况下，射线从碰撞体内部开始，并且不与碰撞体表面交叠。这意味着无法计算碰撞法线，在这种情况下，返回的碰撞法线设置为正在测试的射线向量的倒数。这可轻松检测到，因为此类结果始终是 `RaycastHit2D` 分数为零。\n\n\n\n---\n\n\n\n### 二、脚部、头顶碰撞\n\n1. 在`[Header(\"环境检测\")]`新建几个需要用到的变量\n\n```\n    [Header(\"环境检测\")]\n    public LayerMask groundLayer;\n    public float footOffset = 0.35f;\n    public float headClearance = 0.5f;\n    public float groundDistance = 0.2f;\n```\n\n\n\n2.重写一个射线检测的方法，包含射线可视化\n\n```\n    RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer)//自己封装的射线检测方法\n    {\n        Vector2 pos = transform.position;\n        RaycastHit2D hit = Physics2D.Raycast(pos + offset, rayDirection, length, layer);\n        Debug.DrawRay(pos + offset, rayDirection, hit ? Color.red : Color.green);\n        return hit;\n    }\n```\n\n\n\n3.更改地面检测函数`PhysicsCheck()`\n\n```\n    void PhysicsCheck()//检测是否在地面，并修改状态\n    {\n        RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);\n        RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);\n        isOnGround = leftCheck || rightCheck;\n\n    }\n```\n\n保存回到unity，运行\n\n角色碰撞体左右脚下方都出现了射线，并且会按照射线方向检测是否碰撞到地面，以此改变`isOnGround`，可以调整参数让检测距离更 “舒服”\n\n下面来增加头顶的检测\n\n\n\n4.在`[Header(\"角色状态\")]`中增加头顶状态 `public bool isHeadBlocked;`\n\n\n\n5.修改`PhysicsCheck()`：\n\n```\n    void PhysicsCheck()//检测是否在地面，并修改状态\n    {\n        RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);\n        RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);\n        isOnGround = leftCheck || rightCheck;\n\n        RaycastHit2D headCheck = Raycast(new Vector2(0f, cd.size.y), Vector2.up, headClearance, groundLayer);\n        isHeadBlocked = headCheck;\n    }\n```\n\n同样，修改`public`参数就可以调整检测距离（注意射线的长度不等于检测距离）\n\n\n\n---\n\n\n\n### 三、悬挂检测\n\n判断悬挂需要三条射线，分别是头顶射线，眼部射线，垂直射线。\n\n悬挂在边缘的条件：头顶射线**无**碰撞，眼部射线有碰撞，垂直射线**有**碰撞\n\n1.在`[Header(\"环境检测\")]`添加变量：\n\n```\n    [Header(\"环境检测\")]\n    //悬挂\n    public float playerHeight = 2f;\n    public float playerEyeHeight = 1.5f;\n    public float grabDistance = 0.2f;\n    public float reachOffset = 0.5f;\n```\n\n\n\n2.在`[Header(\"角色状态\")]`添加状态：\n\n```\n\t[Header(\"角色状态\")]\n    public bool isHanging;\n```\n\n\n\n3.在`PhysicsCheck()`中添加悬挂的各种射线生成以及悬挂状态判断：\n\n```\n    void PhysicsCheck()//物理检测，并修改状态\n    {\n        //悬挂系列射线\n        float direction = transform.localScale.x;\n        Vector2 grabDirection = new Vector2(direction, 0f);\n        RaycastHit2D blockedCheck = Raycast(new Vector2(direction * footOffset, playerHeight), grabDirection, grabDistance, groundLayer);\n        RaycastHit2D wallCheck = Raycast(new Vector2(direction * footOffset, playerEyeHeight), grabDirection, grabDistance, groundLayer);\n        RaycastHit2D ledgeCheck = Raycast(new Vector2(direction * reachOffset, playerHeight), Vector2.down, grabDistance, groundLayer);\n        if (!isOnGround && !blockedCheck && wallCheck && ledgeCheck && rb.velocity.y < 0f)\n        {\n            Vector3 pos = transform.position;\n            pos.x += (wallCheck.distance - 0.05f) * direction;\n            pos.y -= ledgeCheck.distance;\n            transform.position = pos; \n            rb.bodyType = RigidbodyType2D.Static;\n            isHanging = true;\n        }\n    }\n```\n\n其中`pos.x += (wallCheck.distance - 0.05f) * direction;`稍微调整一下悬挂的位置，可以按照图案的位置来调整\n\n\n\n4.悬挂状态已经设置好了，现在我们希望在悬挂时按跳跃键会有一个固定的跳跃高度，并且会取消刚体的锁定\n\n在`[Header(\"跳跃参数\")]`中添加：\n\n```\n\t[Header(\"跳跃参数\")]\n    public float hangingJumpForce = 15f;\n```\n\n\n\n5.在`MidAirMovement()`添加悬挂跳跃：\n\n```\n    void MidAirMovement()//空中移动\n    {\n        if (isHanging)//悬挂时两种选择\n        {\n            if (jumpPressed)\n            {\n                rb.bodyType = RigidbodyType2D.Dynamic;\n                rb.AddForce(new Vector2(0f, hangingJumpForce), ForceMode2D.Impulse);\n                //rb.velocity = new Vector2(rb.velocity.x, hangingJumpForce);\n                isHanging = false;\n            }\n            if (crouchPressed)\n            {\n                rb.bodyType = RigidbodyType2D.Dynamic;\n                crouchPressed = false;\n                isHanging = false;\n            } \n        }\n    }\n```\n\n其中`crouchPressed`要在`[Header(\"按键状态\")]`中设置好，并且在`Update()`中赋值，以此来和`crouchHeld`分开\n\n\n\n---\n\n\n\n### \t终、阶段总结\n\n到此为止，已经完成了各种基础运动的逻辑\n\n自我感觉有些状态的判断没有很好的归类，比如悬挂状态，应该和下蹲&站立一样新建一个悬挂的函数，在悬挂函数中完成悬挂的各种处理，最后使`isHanging = true`，这样代码应该会比较 ”整齐”\n","source":"_posts/2021-07-20-《Robbie Swifthand》Unity2d独立游戏学习（三）.md","raw":"---\ntitle: 《Robbie Swifthand》Unity2d独立游戏学习（三）\ndate: 2021-07-20 15:36:35\ncategories: unity\ntags:\n  - unity\n  - c#\n  - raycast\n---\n\n\n\n\n\n### \t始、前言\n\n简单的角色移动已经完成了，这次来学习用Raycast 射线检测的方法让角色的状态检测变得更细致\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t一、Physics2D.Raycast 脚本API\n\n```\npublic static RaycastHit2D Raycast (Vector2 origin, Vector2 direction, float distance= Mathf.Infinity, int layerMask= DefaultRaycastLayers, float minDepth= -Mathf.Infinity, float maxDepth= Mathf.Infinity);\n```\n\n参数\n\n| origin    | 射线在 2D 空间中的起点。                    |\n| --------- | ------------------------------------------- |\n| direction | 表示射线方向的矢量。                        |\n| distance  | 射线的最大投射距离。                        |\n| layerMask | 过滤器，用于仅在特定层上检测碰撞体。        |\n| minDepth  | 仅包括 Z 坐标（深度）大于或等于该值的对象。 |\n| maxDepth  | 仅包括 Z 坐标（深度）小于或等于该值的对象。 |\n\n返回**`RaycastHit2D`** 返回的投射数量。\n\n描述：\n\n向场景中的碰撞体投射射线。\n\n从概念上说，*射线投射* 类似于从空间中的某个点朝特定方向发射一条光束。在该过程中，可以检测并报告与光束接触的任何对象。\n\n函数返回一个 `RaycastHit` 对象，该对象引用了射线命中的碰撞体（如果未命中任何对象，则结果的碰撞体属性将为 NULL）。*`layerMask`* 可用于仅在特定层上有选择地检测对象（例如，这让您能够仅将检测应用于敌人角色）。\n\n使用 `contactFilter` 的此方法重载可以按 `ContactFilter2D` 中提供的选项筛选结果。\n\n对于确定视线、炮火击中的目标以及游戏中的许多其他目的来说，射线投射很有用。\n\n此外，这还将检测位于射线起点的碰撞体。在这种情况下，射线从碰撞体内部开始，并且不与碰撞体表面交叠。这意味着无法计算碰撞法线，在这种情况下，返回的碰撞法线设置为正在测试的射线向量的倒数。这可轻松检测到，因为此类结果始终是 `RaycastHit2D` 分数为零。\n\n\n\n---\n\n\n\n### 二、脚部、头顶碰撞\n\n1. 在`[Header(\"环境检测\")]`新建几个需要用到的变量\n\n```\n    [Header(\"环境检测\")]\n    public LayerMask groundLayer;\n    public float footOffset = 0.35f;\n    public float headClearance = 0.5f;\n    public float groundDistance = 0.2f;\n```\n\n\n\n2.重写一个射线检测的方法，包含射线可视化\n\n```\n    RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer)//自己封装的射线检测方法\n    {\n        Vector2 pos = transform.position;\n        RaycastHit2D hit = Physics2D.Raycast(pos + offset, rayDirection, length, layer);\n        Debug.DrawRay(pos + offset, rayDirection, hit ? Color.red : Color.green);\n        return hit;\n    }\n```\n\n\n\n3.更改地面检测函数`PhysicsCheck()`\n\n```\n    void PhysicsCheck()//检测是否在地面，并修改状态\n    {\n        RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);\n        RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);\n        isOnGround = leftCheck || rightCheck;\n\n    }\n```\n\n保存回到unity，运行\n\n角色碰撞体左右脚下方都出现了射线，并且会按照射线方向检测是否碰撞到地面，以此改变`isOnGround`，可以调整参数让检测距离更 “舒服”\n\n下面来增加头顶的检测\n\n\n\n4.在`[Header(\"角色状态\")]`中增加头顶状态 `public bool isHeadBlocked;`\n\n\n\n5.修改`PhysicsCheck()`：\n\n```\n    void PhysicsCheck()//检测是否在地面，并修改状态\n    {\n        RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);\n        RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);\n        isOnGround = leftCheck || rightCheck;\n\n        RaycastHit2D headCheck = Raycast(new Vector2(0f, cd.size.y), Vector2.up, headClearance, groundLayer);\n        isHeadBlocked = headCheck;\n    }\n```\n\n同样，修改`public`参数就可以调整检测距离（注意射线的长度不等于检测距离）\n\n\n\n---\n\n\n\n### 三、悬挂检测\n\n判断悬挂需要三条射线，分别是头顶射线，眼部射线，垂直射线。\n\n悬挂在边缘的条件：头顶射线**无**碰撞，眼部射线有碰撞，垂直射线**有**碰撞\n\n1.在`[Header(\"环境检测\")]`添加变量：\n\n```\n    [Header(\"环境检测\")]\n    //悬挂\n    public float playerHeight = 2f;\n    public float playerEyeHeight = 1.5f;\n    public float grabDistance = 0.2f;\n    public float reachOffset = 0.5f;\n```\n\n\n\n2.在`[Header(\"角色状态\")]`添加状态：\n\n```\n\t[Header(\"角色状态\")]\n    public bool isHanging;\n```\n\n\n\n3.在`PhysicsCheck()`中添加悬挂的各种射线生成以及悬挂状态判断：\n\n```\n    void PhysicsCheck()//物理检测，并修改状态\n    {\n        //悬挂系列射线\n        float direction = transform.localScale.x;\n        Vector2 grabDirection = new Vector2(direction, 0f);\n        RaycastHit2D blockedCheck = Raycast(new Vector2(direction * footOffset, playerHeight), grabDirection, grabDistance, groundLayer);\n        RaycastHit2D wallCheck = Raycast(new Vector2(direction * footOffset, playerEyeHeight), grabDirection, grabDistance, groundLayer);\n        RaycastHit2D ledgeCheck = Raycast(new Vector2(direction * reachOffset, playerHeight), Vector2.down, grabDistance, groundLayer);\n        if (!isOnGround && !blockedCheck && wallCheck && ledgeCheck && rb.velocity.y < 0f)\n        {\n            Vector3 pos = transform.position;\n            pos.x += (wallCheck.distance - 0.05f) * direction;\n            pos.y -= ledgeCheck.distance;\n            transform.position = pos; \n            rb.bodyType = RigidbodyType2D.Static;\n            isHanging = true;\n        }\n    }\n```\n\n其中`pos.x += (wallCheck.distance - 0.05f) * direction;`稍微调整一下悬挂的位置，可以按照图案的位置来调整\n\n\n\n4.悬挂状态已经设置好了，现在我们希望在悬挂时按跳跃键会有一个固定的跳跃高度，并且会取消刚体的锁定\n\n在`[Header(\"跳跃参数\")]`中添加：\n\n```\n\t[Header(\"跳跃参数\")]\n    public float hangingJumpForce = 15f;\n```\n\n\n\n5.在`MidAirMovement()`添加悬挂跳跃：\n\n```\n    void MidAirMovement()//空中移动\n    {\n        if (isHanging)//悬挂时两种选择\n        {\n            if (jumpPressed)\n            {\n                rb.bodyType = RigidbodyType2D.Dynamic;\n                rb.AddForce(new Vector2(0f, hangingJumpForce), ForceMode2D.Impulse);\n                //rb.velocity = new Vector2(rb.velocity.x, hangingJumpForce);\n                isHanging = false;\n            }\n            if (crouchPressed)\n            {\n                rb.bodyType = RigidbodyType2D.Dynamic;\n                crouchPressed = false;\n                isHanging = false;\n            } \n        }\n    }\n```\n\n其中`crouchPressed`要在`[Header(\"按键状态\")]`中设置好，并且在`Update()`中赋值，以此来和`crouchHeld`分开\n\n\n\n---\n\n\n\n### \t终、阶段总结\n\n到此为止，已经完成了各种基础运动的逻辑\n\n自我感觉有些状态的判断没有很好的归类，比如悬挂状态，应该和下蹲&站立一样新建一个悬挂的函数，在悬挂函数中完成悬挂的各种处理，最后使`isHanging = true`，这样代码应该会比较 ”整齐”\n","slug":"2021-07-20-《Robbie Swifthand》Unity2d独立游戏学习（三）","published":1,"updated":"2021-07-21T08:17:18.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmniml000zf4u077ml5639","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>简单的角色移动已经完成了，这次来学习用Raycast 射线检测的方法让角色的状态检测变得更细致</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、Physics2D-Raycast-脚本API\"><a href=\"#一、Physics2D-Raycast-脚本API\" class=\"headerlink\" title=\"一、Physics2D.Raycast 脚本API\"></a>一、Physics2D.Raycast 脚本API</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static RaycastHit2D Raycast (Vector2 origin, Vector2 direction, float distance= Mathf.Infinity, int layerMask= DefaultRaycastLayers, float minDepth= -Mathf.Infinity, float maxDepth= Mathf.Infinity);</span><br></pre></td></tr></table></figure>\n\n<p>参数</p>\n<table>\n<thead>\n<tr>\n<th>origin</th>\n<th>射线在 2D 空间中的起点。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>direction</td>\n<td>表示射线方向的矢量。</td>\n</tr>\n<tr>\n<td>distance</td>\n<td>射线的最大投射距离。</td>\n</tr>\n<tr>\n<td>layerMask</td>\n<td>过滤器，用于仅在特定层上检测碰撞体。</td>\n</tr>\n<tr>\n<td>minDepth</td>\n<td>仅包括 Z 坐标（深度）大于或等于该值的对象。</td>\n</tr>\n<tr>\n<td>maxDepth</td>\n<td>仅包括 Z 坐标（深度）小于或等于该值的对象。</td>\n</tr>\n</tbody></table>\n<p>返回**<code>RaycastHit2D</code>** 返回的投射数量。</p>\n<p>描述：</p>\n<p>向场景中的碰撞体投射射线。</p>\n<p>从概念上说，<em>射线投射</em> 类似于从空间中的某个点朝特定方向发射一条光束。在该过程中，可以检测并报告与光束接触的任何对象。</p>\n<p>函数返回一个 <code>RaycastHit</code> 对象，该对象引用了射线命中的碰撞体（如果未命中任何对象，则结果的碰撞体属性将为 NULL）。*<code>layerMask</code>* 可用于仅在特定层上有选择地检测对象（例如，这让您能够仅将检测应用于敌人角色）。</p>\n<p>使用 <code>contactFilter</code> 的此方法重载可以按 <code>ContactFilter2D</code> 中提供的选项筛选结果。</p>\n<p>对于确定视线、炮火击中的目标以及游戏中的许多其他目的来说，射线投射很有用。</p>\n<p>此外，这还将检测位于射线起点的碰撞体。在这种情况下，射线从碰撞体内部开始，并且不与碰撞体表面交叠。这意味着无法计算碰撞法线，在这种情况下，返回的碰撞法线设置为正在测试的射线向量的倒数。这可轻松检测到，因为此类结果始终是 <code>RaycastHit2D</code> 分数为零。</p>\n<hr>\n<h3 id=\"二、脚部、头顶碰撞\"><a href=\"#二、脚部、头顶碰撞\" class=\"headerlink\" title=\"二、脚部、头顶碰撞\"></a>二、脚部、头顶碰撞</h3><ol>\n<li>在<code>[Header(&quot;环境检测&quot;)]</code>新建几个需要用到的变量</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;环境检测&quot;)]</span><br><span class=\"line\">public LayerMask groundLayer;</span><br><span class=\"line\">public float footOffset = 0.35f;</span><br><span class=\"line\">public float headClearance = 0.5f;</span><br><span class=\"line\">public float groundDistance = 0.2f;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.重写一个射线检测的方法，包含射线可视化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer)//自己封装的射线检测方法</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector2 pos = transform.position;</span><br><span class=\"line\">    RaycastHit2D hit = Physics2D.Raycast(pos + offset, rayDirection, length, layer);</span><br><span class=\"line\">    Debug.DrawRay(pos + offset, rayDirection, hit ? Color.red : Color.green);</span><br><span class=\"line\">    return hit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>3.更改地面检测函数<code>PhysicsCheck()</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class=\"line\">    RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class=\"line\">    isOnGround = leftCheck || rightCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>保存回到unity，运行</p>\n<p>角色碰撞体左右脚下方都出现了射线，并且会按照射线方向检测是否碰撞到地面，以此改变<code>isOnGround</code>，可以调整参数让检测距离更 “舒服”</p>\n<p>下面来增加头顶的检测</p>\n<p>4.在<code>[Header(&quot;角色状态&quot;)]</code>中增加头顶状态 <code>public bool isHeadBlocked;</code></p>\n<p>5.修改<code>PhysicsCheck()</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class=\"line\">    RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class=\"line\">    isOnGround = leftCheck || rightCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">    RaycastHit2D headCheck = Raycast(new Vector2(0f, cd.size.y), Vector2.up, headClearance, groundLayer);</span><br><span class=\"line\">    isHeadBlocked = headCheck;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样，修改<code>public</code>参数就可以调整检测距离（注意射线的长度不等于检测距离）</p>\n<hr>\n<h3 id=\"三、悬挂检测\"><a href=\"#三、悬挂检测\" class=\"headerlink\" title=\"三、悬挂检测\"></a>三、悬挂检测</h3><p>判断悬挂需要三条射线，分别是头顶射线，眼部射线，垂直射线。</p>\n<p>悬挂在边缘的条件：头顶射线<strong>无</strong>碰撞，眼部射线有碰撞，垂直射线<strong>有</strong>碰撞</p>\n<p>1.在<code>[Header(&quot;环境检测&quot;)]</code>添加变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;环境检测&quot;)]</span><br><span class=\"line\">//悬挂</span><br><span class=\"line\">public float playerHeight = 2f;</span><br><span class=\"line\">public float playerEyeHeight = 1.5f;</span><br><span class=\"line\">public float grabDistance = 0.2f;</span><br><span class=\"line\">public float reachOffset = 0.5f;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.在<code>[Header(&quot;角色状态&quot;)]</code>添加状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;角色状态&quot;)]</span><br><span class=\"line\">   public bool isHanging;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>3.在<code>PhysicsCheck()</code>中添加悬挂的各种射线生成以及悬挂状态判断：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void PhysicsCheck()//物理检测，并修改状态</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //悬挂系列射线</span><br><span class=\"line\">    float direction = transform.localScale.x;</span><br><span class=\"line\">    Vector2 grabDirection = new Vector2(direction, 0f);</span><br><span class=\"line\">    RaycastHit2D blockedCheck = Raycast(new Vector2(direction * footOffset, playerHeight), grabDirection, grabDistance, groundLayer);</span><br><span class=\"line\">    RaycastHit2D wallCheck = Raycast(new Vector2(direction * footOffset, playerEyeHeight), grabDirection, grabDistance, groundLayer);</span><br><span class=\"line\">    RaycastHit2D ledgeCheck = Raycast(new Vector2(direction * reachOffset, playerHeight), Vector2.down, grabDistance, groundLayer);</span><br><span class=\"line\">    if (!isOnGround &amp;&amp; !blockedCheck &amp;&amp; wallCheck &amp;&amp; ledgeCheck &amp;&amp; rb.velocity.y &lt; 0f)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Vector3 pos = transform.position;</span><br><span class=\"line\">        pos.x += (wallCheck.distance - 0.05f) * direction;</span><br><span class=\"line\">        pos.y -= ledgeCheck.distance;</span><br><span class=\"line\">        transform.position = pos; </span><br><span class=\"line\">        rb.bodyType = RigidbodyType2D.Static;</span><br><span class=\"line\">        isHanging = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>pos.x += (wallCheck.distance - 0.05f) * direction;</code>稍微调整一下悬挂的位置，可以按照图案的位置来调整</p>\n<p>4.悬挂状态已经设置好了，现在我们希望在悬挂时按跳跃键会有一个固定的跳跃高度，并且会取消刚体的锁定</p>\n<p>在<code>[Header(&quot;跳跃参数&quot;)]</code>中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;跳跃参数&quot;)]</span><br><span class=\"line\">   public float hangingJumpForce = 15f;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>5.在<code>MidAirMovement()</code>添加悬挂跳跃：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void MidAirMovement()//空中移动</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (isHanging)//悬挂时两种选择</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (jumpPressed)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rb.bodyType = RigidbodyType2D.Dynamic;</span><br><span class=\"line\">            rb.AddForce(new Vector2(0f, hangingJumpForce), ForceMode2D.Impulse);</span><br><span class=\"line\">            //rb.velocity = new Vector2(rb.velocity.x, hangingJumpForce);</span><br><span class=\"line\">            isHanging = false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (crouchPressed)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rb.bodyType = RigidbodyType2D.Dynamic;</span><br><span class=\"line\">            crouchPressed = false;</span><br><span class=\"line\">            isHanging = false;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>crouchPressed</code>要在<code>[Header(&quot;按键状态&quot;)]</code>中设置好，并且在<code>Update()</code>中赋值，以此来和<code>crouchHeld</code>分开</p>\n<hr>\n<h3 id=\"终、阶段总结\"><a href=\"#终、阶段总结\" class=\"headerlink\" title=\"终、阶段总结\"></a>终、阶段总结</h3><p>到此为止，已经完成了各种基础运动的逻辑</p>\n<p>自我感觉有些状态的判断没有很好的归类，比如悬挂状态，应该和下蹲&amp;站立一样新建一个悬挂的函数，在悬挂函数中完成悬挂的各种处理，最后使<code>isHanging = true</code>，这样代码应该会比较 ”整齐”</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>简单的角色移动已经完成了，这次来学习用Raycast 射线检测的方法让角色的状态检测变得更细致</p>","more":"<hr>\n<h3 id=\"一、Physics2D-Raycast-脚本API\"><a href=\"#一、Physics2D-Raycast-脚本API\" class=\"headerlink\" title=\"一、Physics2D.Raycast 脚本API\"></a>一、Physics2D.Raycast 脚本API</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static RaycastHit2D Raycast (Vector2 origin, Vector2 direction, float distance= Mathf.Infinity, int layerMask= DefaultRaycastLayers, float minDepth= -Mathf.Infinity, float maxDepth= Mathf.Infinity);</span><br></pre></td></tr></table></figure>\n\n<p>参数</p>\n<table>\n<thead>\n<tr>\n<th>origin</th>\n<th>射线在 2D 空间中的起点。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>direction</td>\n<td>表示射线方向的矢量。</td>\n</tr>\n<tr>\n<td>distance</td>\n<td>射线的最大投射距离。</td>\n</tr>\n<tr>\n<td>layerMask</td>\n<td>过滤器，用于仅在特定层上检测碰撞体。</td>\n</tr>\n<tr>\n<td>minDepth</td>\n<td>仅包括 Z 坐标（深度）大于或等于该值的对象。</td>\n</tr>\n<tr>\n<td>maxDepth</td>\n<td>仅包括 Z 坐标（深度）小于或等于该值的对象。</td>\n</tr>\n</tbody></table>\n<p>返回**<code>RaycastHit2D</code>** 返回的投射数量。</p>\n<p>描述：</p>\n<p>向场景中的碰撞体投射射线。</p>\n<p>从概念上说，<em>射线投射</em> 类似于从空间中的某个点朝特定方向发射一条光束。在该过程中，可以检测并报告与光束接触的任何对象。</p>\n<p>函数返回一个 <code>RaycastHit</code> 对象，该对象引用了射线命中的碰撞体（如果未命中任何对象，则结果的碰撞体属性将为 NULL）。*<code>layerMask</code>* 可用于仅在特定层上有选择地检测对象（例如，这让您能够仅将检测应用于敌人角色）。</p>\n<p>使用 <code>contactFilter</code> 的此方法重载可以按 <code>ContactFilter2D</code> 中提供的选项筛选结果。</p>\n<p>对于确定视线、炮火击中的目标以及游戏中的许多其他目的来说，射线投射很有用。</p>\n<p>此外，这还将检测位于射线起点的碰撞体。在这种情况下，射线从碰撞体内部开始，并且不与碰撞体表面交叠。这意味着无法计算碰撞法线，在这种情况下，返回的碰撞法线设置为正在测试的射线向量的倒数。这可轻松检测到，因为此类结果始终是 <code>RaycastHit2D</code> 分数为零。</p>\n<hr>\n<h3 id=\"二、脚部、头顶碰撞\"><a href=\"#二、脚部、头顶碰撞\" class=\"headerlink\" title=\"二、脚部、头顶碰撞\"></a>二、脚部、头顶碰撞</h3><ol>\n<li>在<code>[Header(&quot;环境检测&quot;)]</code>新建几个需要用到的变量</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;环境检测&quot;)]</span><br><span class=\"line\">public LayerMask groundLayer;</span><br><span class=\"line\">public float footOffset = 0.35f;</span><br><span class=\"line\">public float headClearance = 0.5f;</span><br><span class=\"line\">public float groundDistance = 0.2f;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.重写一个射线检测的方法，包含射线可视化</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer)//自己封装的射线检测方法</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Vector2 pos = transform.position;</span><br><span class=\"line\">    RaycastHit2D hit = Physics2D.Raycast(pos + offset, rayDirection, length, layer);</span><br><span class=\"line\">    Debug.DrawRay(pos + offset, rayDirection, hit ? Color.red : Color.green);</span><br><span class=\"line\">    return hit;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>3.更改地面检测函数<code>PhysicsCheck()</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class=\"line\">    RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class=\"line\">    isOnGround = leftCheck || rightCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>保存回到unity，运行</p>\n<p>角色碰撞体左右脚下方都出现了射线，并且会按照射线方向检测是否碰撞到地面，以此改变<code>isOnGround</code>，可以调整参数让检测距离更 “舒服”</p>\n<p>下面来增加头顶的检测</p>\n<p>4.在<code>[Header(&quot;角色状态&quot;)]</code>中增加头顶状态 <code>public bool isHeadBlocked;</code></p>\n<p>5.修改<code>PhysicsCheck()</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class=\"line\">    RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class=\"line\">    isOnGround = leftCheck || rightCheck;</span><br><span class=\"line\"></span><br><span class=\"line\">    RaycastHit2D headCheck = Raycast(new Vector2(0f, cd.size.y), Vector2.up, headClearance, groundLayer);</span><br><span class=\"line\">    isHeadBlocked = headCheck;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样，修改<code>public</code>参数就可以调整检测距离（注意射线的长度不等于检测距离）</p>\n<hr>\n<h3 id=\"三、悬挂检测\"><a href=\"#三、悬挂检测\" class=\"headerlink\" title=\"三、悬挂检测\"></a>三、悬挂检测</h3><p>判断悬挂需要三条射线，分别是头顶射线，眼部射线，垂直射线。</p>\n<p>悬挂在边缘的条件：头顶射线<strong>无</strong>碰撞，眼部射线有碰撞，垂直射线<strong>有</strong>碰撞</p>\n<p>1.在<code>[Header(&quot;环境检测&quot;)]</code>添加变量：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;环境检测&quot;)]</span><br><span class=\"line\">//悬挂</span><br><span class=\"line\">public float playerHeight = 2f;</span><br><span class=\"line\">public float playerEyeHeight = 1.5f;</span><br><span class=\"line\">public float grabDistance = 0.2f;</span><br><span class=\"line\">public float reachOffset = 0.5f;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>2.在<code>[Header(&quot;角色状态&quot;)]</code>添加状态：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;角色状态&quot;)]</span><br><span class=\"line\">   public bool isHanging;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>3.在<code>PhysicsCheck()</code>中添加悬挂的各种射线生成以及悬挂状态判断：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void PhysicsCheck()//物理检测，并修改状态</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    //悬挂系列射线</span><br><span class=\"line\">    float direction = transform.localScale.x;</span><br><span class=\"line\">    Vector2 grabDirection = new Vector2(direction, 0f);</span><br><span class=\"line\">    RaycastHit2D blockedCheck = Raycast(new Vector2(direction * footOffset, playerHeight), grabDirection, grabDistance, groundLayer);</span><br><span class=\"line\">    RaycastHit2D wallCheck = Raycast(new Vector2(direction * footOffset, playerEyeHeight), grabDirection, grabDistance, groundLayer);</span><br><span class=\"line\">    RaycastHit2D ledgeCheck = Raycast(new Vector2(direction * reachOffset, playerHeight), Vector2.down, grabDistance, groundLayer);</span><br><span class=\"line\">    if (!isOnGround &amp;&amp; !blockedCheck &amp;&amp; wallCheck &amp;&amp; ledgeCheck &amp;&amp; rb.velocity.y &lt; 0f)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Vector3 pos = transform.position;</span><br><span class=\"line\">        pos.x += (wallCheck.distance - 0.05f) * direction;</span><br><span class=\"line\">        pos.y -= ledgeCheck.distance;</span><br><span class=\"line\">        transform.position = pos; </span><br><span class=\"line\">        rb.bodyType = RigidbodyType2D.Static;</span><br><span class=\"line\">        isHanging = true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>pos.x += (wallCheck.distance - 0.05f) * direction;</code>稍微调整一下悬挂的位置，可以按照图案的位置来调整</p>\n<p>4.悬挂状态已经设置好了，现在我们希望在悬挂时按跳跃键会有一个固定的跳跃高度，并且会取消刚体的锁定</p>\n<p>在<code>[Header(&quot;跳跃参数&quot;)]</code>中添加：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Header(&quot;跳跃参数&quot;)]</span><br><span class=\"line\">   public float hangingJumpForce = 15f;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>5.在<code>MidAirMovement()</code>添加悬挂跳跃：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void MidAirMovement()//空中移动</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (isHanging)//悬挂时两种选择</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (jumpPressed)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rb.bodyType = RigidbodyType2D.Dynamic;</span><br><span class=\"line\">            rb.AddForce(new Vector2(0f, hangingJumpForce), ForceMode2D.Impulse);</span><br><span class=\"line\">            //rb.velocity = new Vector2(rb.velocity.x, hangingJumpForce);</span><br><span class=\"line\">            isHanging = false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (crouchPressed)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rb.bodyType = RigidbodyType2D.Dynamic;</span><br><span class=\"line\">            crouchPressed = false;</span><br><span class=\"line\">            isHanging = false;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中<code>crouchPressed</code>要在<code>[Header(&quot;按键状态&quot;)]</code>中设置好，并且在<code>Update()</code>中赋值，以此来和<code>crouchHeld</code>分开</p>\n<hr>\n<h3 id=\"终、阶段总结\"><a href=\"#终、阶段总结\" class=\"headerlink\" title=\"终、阶段总结\"></a>终、阶段总结</h3><p>到此为止，已经完成了各种基础运动的逻辑</p>\n<p>自我感觉有些状态的判断没有很好的归类，比如悬挂状态，应该和下蹲&amp;站立一样新建一个悬挂的函数，在悬挂函数中完成悬挂的各种处理，最后使<code>isHanging = true</code>，这样代码应该会比较 ”整齐”</p>"},{"title":"【LeetCode.138】 复制带随机指针的链表","date":"2021-07-22T06:59:35.000Z","_content":"\n\n\n### \t题目：复制带随机指针的链表\n\n​\t给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。\n\n​\t构造这个链表的 **深拷贝**。 深拷贝应该正好由 `n` 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。\n\n​\t例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 x 和 `y` ，同样有 `x.random --> y` 。\n\n​\t返回复制链表的头节点。\n\n​\t用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：\n\n**val**：一个表示 `Node.val` 的整数。\n**random_index**：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为  `null` 。\n\t你的代码 只 接受原链表的头节点 `head` 作为传入参数。\n\n <!--more-->\n\n示例 1：\n\n```\n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n```\n\n示例 2：\n\n```\n输入：head = [[1,1],[2,1]]\n输出：[[1,1],[2,1]]\n```\n\n示例 3：\n\n```\n输入：head = [[3,null],[3,0],[3,null]]\n输出：[[3,null],[3,0],[3,null]]\n```\n\n示例 4：\n\n```\n输入：head = []\n输出：[]\n解释：给定的链表为空（空指针），因此返回 null。\n```\n\n\n提示：\n\n`0 <= n <= 1000`\n`-10000 <= Node.val <= 10000`\n`Node.random 为空（null）或指向链表中的节点。`\n\n\n\n---\n\n\n\n### \t分析：\n\n​\t首先将该链表中每一个节点拆分为两个相连的节点，例如对于链表 `A→B→C`，我们可以将其拆分为 `A→A ′ →B→B ′ →C→C ′` 。对于任意一个原节点 `S`，其拷贝节点 `S ′` 即为其后继节点。\n\n​\t这样，我们可以直接找到每一个拷贝节点 `S ′` 的随机指针应当指向的节点，即为其原节点 `S` 的随机指针指向的节点 `T` 的后继节点 `T ′` 。需要注意原节点的随机指针可能为空，我们需要特别判断这种情况。\n\n当我们完成了拷贝节点的随机指针的赋值，我们只需要将这个链表按照原节点与拷贝节点的种类进行拆分即可，只需要遍历一次。同样需要注意最后一个拷贝节点的后继节点为空，我们需要特别判断这种情况。\n\n\n\n---\n\n\n\n### \t题解：\n\n```\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        if(!head) return NULL;\n        Node * ret = head;\n        \n        // 将A→B→C，拆分为 A→A ′ →B→B ′ →C→C ′\n        while(ret){\n            Node *q = new Node(ret->val);\n            q->next = ret->next;   \n            ret->next = q;      \n            ret = q->next;\n        }\n        ret = head;\n        \n        // S ′ 指向其原节点 S 的随机指针指向的节点 T 的后继节点 T ′\n        while(ret){\n            Node* pre = ret;\n            ret = ret->next;\n            if(pre->random) ret->random = pre->random->next;\n            else ret->random = NULL;            \n            ret = ret->next;\n        }\n        ret = head->next;\n        Node* p = head;\n        Node * q = ret;\n        Node * now = ret;\n        \n        //拆分原数组和拷贝数组\n        while(p->next){\n            now = now->next;\n            q = p->next;\n            p->next = now;          \n            p = q;\n        }\n        return ret;\n    }\n};\n```\n\n","source":"_posts/2021-07-22-【LeetCode.138】 复制带随机指针的链表.md","raw":"---\ntitle: 【LeetCode.138】 复制带随机指针的链表\ndate: 2021-07-22 14:59:35\ncategories:\t算法\ntags:\n  - c++\n  - 原地算法\n  - 链表\n---\n\n\n\n### \t题目：复制带随机指针的链表\n\n​\t给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。\n\n​\t构造这个链表的 **深拷贝**。 深拷贝应该正好由 `n` 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。\n\n​\t例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 x 和 `y` ，同样有 `x.random --> y` 。\n\n​\t返回复制链表的头节点。\n\n​\t用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：\n\n**val**：一个表示 `Node.val` 的整数。\n**random_index**：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为  `null` 。\n\t你的代码 只 接受原链表的头节点 `head` 作为传入参数。\n\n <!--more-->\n\n示例 1：\n\n```\n输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n```\n\n示例 2：\n\n```\n输入：head = [[1,1],[2,1]]\n输出：[[1,1],[2,1]]\n```\n\n示例 3：\n\n```\n输入：head = [[3,null],[3,0],[3,null]]\n输出：[[3,null],[3,0],[3,null]]\n```\n\n示例 4：\n\n```\n输入：head = []\n输出：[]\n解释：给定的链表为空（空指针），因此返回 null。\n```\n\n\n提示：\n\n`0 <= n <= 1000`\n`-10000 <= Node.val <= 10000`\n`Node.random 为空（null）或指向链表中的节点。`\n\n\n\n---\n\n\n\n### \t分析：\n\n​\t首先将该链表中每一个节点拆分为两个相连的节点，例如对于链表 `A→B→C`，我们可以将其拆分为 `A→A ′ →B→B ′ →C→C ′` 。对于任意一个原节点 `S`，其拷贝节点 `S ′` 即为其后继节点。\n\n​\t这样，我们可以直接找到每一个拷贝节点 `S ′` 的随机指针应当指向的节点，即为其原节点 `S` 的随机指针指向的节点 `T` 的后继节点 `T ′` 。需要注意原节点的随机指针可能为空，我们需要特别判断这种情况。\n\n当我们完成了拷贝节点的随机指针的赋值，我们只需要将这个链表按照原节点与拷贝节点的种类进行拆分即可，只需要遍历一次。同样需要注意最后一个拷贝节点的后继节点为空，我们需要特别判断这种情况。\n\n\n\n---\n\n\n\n### \t题解：\n\n```\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        if(!head) return NULL;\n        Node * ret = head;\n        \n        // 将A→B→C，拆分为 A→A ′ →B→B ′ →C→C ′\n        while(ret){\n            Node *q = new Node(ret->val);\n            q->next = ret->next;   \n            ret->next = q;      \n            ret = q->next;\n        }\n        ret = head;\n        \n        // S ′ 指向其原节点 S 的随机指针指向的节点 T 的后继节点 T ′\n        while(ret){\n            Node* pre = ret;\n            ret = ret->next;\n            if(pre->random) ret->random = pre->random->next;\n            else ret->random = NULL;            \n            ret = ret->next;\n        }\n        ret = head->next;\n        Node* p = head;\n        Node * q = ret;\n        Node * now = ret;\n        \n        //拆分原数组和拷贝数组\n        while(p->next){\n            now = now->next;\n            q = p->next;\n            p->next = now;          \n            p = q;\n        }\n        return ret;\n    }\n};\n```\n\n","slug":"2021-07-22-【LeetCode.138】 复制带随机指针的链表","published":1,"updated":"2021-07-23T07:17:49.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnimm0012f4u0gyguakd6","content":"<h3 id=\"题目：复制带随机指针的链表\"><a href=\"#题目：复制带随机指针的链表\" class=\"headerlink\" title=\"题目：复制带随机指针的链表\"></a>题目：复制带随机指针的链表</h3><p>​    给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>\n<p>​    构造这个链表的 <strong>深拷贝</strong>。 深拷贝应该正好由 <code>n</code> 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p>\n<p>​    例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 x 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p>\n<p>​    返回复制链表的头节点。</p>\n<p>​    用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p>\n<p><strong>val</strong>：一个表示 <code>Node.val</code> 的整数。<br><strong>random_index</strong>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为  <code>null</code> 。<br>    你的代码 只 接受原链表的头节点 <code>head</code> 作为传入参数。</p>\n <span id=\"more\"></span>\n\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class=\"line\">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [[1,1],[2,1]]</span><br><span class=\"line\">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure>\n\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class=\"line\">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure>\n\n<p>示例 4：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = []</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure>\n\n\n<p>提示：</p>\n<p><code>0 &lt;= n &lt;= 1000</code><br><code>-10000 &lt;= Node.val &lt;= 10000</code><br><code>Node.random 为空（null）或指向链表中的节点。</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>​    首先将该链表中每一个节点拆分为两个相连的节点，例如对于链表 <code>A→B→C</code>，我们可以将其拆分为 <code>A→A ′ →B→B ′ →C→C ′</code> 。对于任意一个原节点 <code>S</code>，其拷贝节点 <code>S ′</code> 即为其后继节点。</p>\n<p>​    这样，我们可以直接找到每一个拷贝节点 <code>S ′</code> 的随机指针应当指向的节点，即为其原节点 <code>S</code> 的随机指针指向的节点 <code>T</code> 的后继节点 <code>T ′</code> 。需要注意原节点的随机指针可能为空，我们需要特别判断这种情况。</p>\n<p>当我们完成了拷贝节点的随机指针的赋值，我们只需要将这个链表按照原节点与拷贝节点的种类进行拆分即可，只需要遍历一次。同样需要注意最后一个拷贝节点的后继节点为空，我们需要特别判断这种情况。</p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Node* copyRandomList(Node* head) &#123;</span><br><span class=\"line\">        if(!head) return NULL;</span><br><span class=\"line\">        Node * ret = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 将A→B→C，拆分为 A→A ′ →B→B ′ →C→C ′</span><br><span class=\"line\">        while(ret)&#123;</span><br><span class=\"line\">            Node *q = new Node(ret-&gt;val);</span><br><span class=\"line\">            q-&gt;next = ret-&gt;next;   </span><br><span class=\"line\">            ret-&gt;next = q;      </span><br><span class=\"line\">            ret = q-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // S ′ 指向其原节点 S 的随机指针指向的节点 T 的后继节点 T ′</span><br><span class=\"line\">        while(ret)&#123;</span><br><span class=\"line\">            Node* pre = ret;</span><br><span class=\"line\">            ret = ret-&gt;next;</span><br><span class=\"line\">            if(pre-&gt;random) ret-&gt;random = pre-&gt;random-&gt;next;</span><br><span class=\"line\">            else ret-&gt;random = NULL;            </span><br><span class=\"line\">            ret = ret-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret = head-&gt;next;</span><br><span class=\"line\">        Node* p = head;</span><br><span class=\"line\">        Node * q = ret;</span><br><span class=\"line\">        Node * now = ret;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //拆分原数组和拷贝数组</span><br><span class=\"line\">        while(p-&gt;next)&#123;</span><br><span class=\"line\">            now = now-&gt;next;</span><br><span class=\"line\">            q = p-&gt;next;</span><br><span class=\"line\">            p-&gt;next = now;          </span><br><span class=\"line\">            p = q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"题目：复制带随机指针的链表\"><a href=\"#题目：复制带随机指针的链表\" class=\"headerlink\" title=\"题目：复制带随机指针的链表\"></a>题目：复制带随机指针的链表</h3><p>​    给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>\n<p>​    构造这个链表的 <strong>深拷贝</strong>。 深拷贝应该正好由 <code>n</code> 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p>\n<p>​    例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 x 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p>\n<p>​    返回复制链表的头节点。</p>\n<p>​    用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p>\n<p><strong>val</strong>：一个表示 <code>Node.val</code> 的整数。<br><strong>random_index</strong>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为  <code>null</code> 。<br>    你的代码 只 接受原链表的头节点 <code>head</code> 作为传入参数。</p>","more":"<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class=\"line\">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [[1,1],[2,1]]</span><br><span class=\"line\">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure>\n\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class=\"line\">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure>\n\n<p>示例 4：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：head = []</span><br><span class=\"line\">输出：[]</span><br><span class=\"line\">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure>\n\n\n<p>提示：</p>\n<p><code>0 &lt;= n &lt;= 1000</code><br><code>-10000 &lt;= Node.val &lt;= 10000</code><br><code>Node.random 为空（null）或指向链表中的节点。</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>​    首先将该链表中每一个节点拆分为两个相连的节点，例如对于链表 <code>A→B→C</code>，我们可以将其拆分为 <code>A→A ′ →B→B ′ →C→C ′</code> 。对于任意一个原节点 <code>S</code>，其拷贝节点 <code>S ′</code> 即为其后继节点。</p>\n<p>​    这样，我们可以直接找到每一个拷贝节点 <code>S ′</code> 的随机指针应当指向的节点，即为其原节点 <code>S</code> 的随机指针指向的节点 <code>T</code> 的后继节点 <code>T ′</code> 。需要注意原节点的随机指针可能为空，我们需要特别判断这种情况。</p>\n<p>当我们完成了拷贝节点的随机指针的赋值，我们只需要将这个链表按照原节点与拷贝节点的种类进行拆分即可，只需要遍历一次。同样需要注意最后一个拷贝节点的后继节点为空，我们需要特别判断这种情况。</p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    Node* copyRandomList(Node* head) &#123;</span><br><span class=\"line\">        if(!head) return NULL;</span><br><span class=\"line\">        Node * ret = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 将A→B→C，拆分为 A→A ′ →B→B ′ →C→C ′</span><br><span class=\"line\">        while(ret)&#123;</span><br><span class=\"line\">            Node *q = new Node(ret-&gt;val);</span><br><span class=\"line\">            q-&gt;next = ret-&gt;next;   </span><br><span class=\"line\">            ret-&gt;next = q;      </span><br><span class=\"line\">            ret = q-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret = head;</span><br><span class=\"line\">        </span><br><span class=\"line\">        // S ′ 指向其原节点 S 的随机指针指向的节点 T 的后继节点 T ′</span><br><span class=\"line\">        while(ret)&#123;</span><br><span class=\"line\">            Node* pre = ret;</span><br><span class=\"line\">            ret = ret-&gt;next;</span><br><span class=\"line\">            if(pre-&gt;random) ret-&gt;random = pre-&gt;random-&gt;next;</span><br><span class=\"line\">            else ret-&gt;random = NULL;            </span><br><span class=\"line\">            ret = ret-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ret = head-&gt;next;</span><br><span class=\"line\">        Node* p = head;</span><br><span class=\"line\">        Node * q = ret;</span><br><span class=\"line\">        Node * now = ret;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //拆分原数组和拷贝数组</span><br><span class=\"line\">        while(p-&gt;next)&#123;</span><br><span class=\"line\">            now = now-&gt;next;</span><br><span class=\"line\">            q = p-&gt;next;</span><br><span class=\"line\">            p-&gt;next = now;          </span><br><span class=\"line\">            p = q;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>"},{"title":"《Robbie Swifthand》Unity2d独立游戏学习（四）","date":"2021-07-23T07:22:41.000Z","_content":"\n\n\n### \t始、前言\n\n接下来做一些视觉上的东西，首先是然镜头跟随主角移动，还有场景的灯光效果\n\n\n\n<!--more-->\n\n---\n\n### \t一、摄像机\n\n1.可以选择Camera 修改背景颜色\n\n2.将摄像机的Projection 修改为Perspective，这样就设置成了透视模式，可以通过修改图层深度来产生景深效果\n\n3.为了产生景深效果，将Grid 中的Background 的Transform → Position → z 设置为 1， 同样地，将Background Details 设置为0.99，Platforms 不变， Shadow 为 - 0.1\n\n4.在unity界面Window → Package Manager 中添加 Cinemachine\n\n5.创建2D Camera物体，将主角拖拽到相机的Follow中，摄像机会跟随角色移动\n\n6.可以设置Camera Distance 到一个合适的位置，这个选项会影响游戏画面的远近\n\n7.选择2D Camera → Extensions → Add Extension 添加一个CinemachineConfiner\n\n8.新建空项目，添加多边形碰撞体，设置成触发器，拖拽到2D摄像机的Confiner中。这样就可以通过调整多边形的形状来限制摄像机的移动范围啦\n\n完成，调试\n\n发现阴影没有遮挡角色，要把Shadow 的Sorting Layer 修改成Foreground\n\n\n\n---\n\n\n\n### 二、2D灯光效果\n\n1.在Props 中找到墙灯，打开预制体修改父物体和子物体的Sorting Layer为Background（粒子效果又是一个大坑）\n\n2.拖入场景之前添加点光源，设置光源的z 轴为 -0.2 ，这样就可以在所有背景的前面照亮它们（更靠近摄像机），还可以修改颜色的照明距离等\n\n拖入火炬后为什么场景没有被照亮呢？因为场景中的物体都还没添加法线贴图\n\n3.打开Level 文件夹，将Platform 和Background 的材质球拖入对应的场景物体中（材质会自动对应瓦片）\n\n4.打开Props 添加另外一种灯：悬挂蓝灯，蓝灯会左右摇摆，因为它有一个动画效果修改z 轴旋转\n\n5.调整场景的整体灯光，打开Window → Rendering → Lighting，在Environment Lighting 中可以调整颜色和亮度\n\n","source":"_posts/2021-07-23-《Robbie Swifthand》Unity2d独立游戏学习（四）.md","raw":"---\ntitle: 《Robbie Swifthand》Unity2d独立游戏学习（四）\ndate: 2021-07-23 15:22:41\ncategories: unity\ntags:\n  - unity\n  - c#\n  - camera\n---\n\n\n\n### \t始、前言\n\n接下来做一些视觉上的东西，首先是然镜头跟随主角移动，还有场景的灯光效果\n\n\n\n<!--more-->\n\n---\n\n### \t一、摄像机\n\n1.可以选择Camera 修改背景颜色\n\n2.将摄像机的Projection 修改为Perspective，这样就设置成了透视模式，可以通过修改图层深度来产生景深效果\n\n3.为了产生景深效果，将Grid 中的Background 的Transform → Position → z 设置为 1， 同样地，将Background Details 设置为0.99，Platforms 不变， Shadow 为 - 0.1\n\n4.在unity界面Window → Package Manager 中添加 Cinemachine\n\n5.创建2D Camera物体，将主角拖拽到相机的Follow中，摄像机会跟随角色移动\n\n6.可以设置Camera Distance 到一个合适的位置，这个选项会影响游戏画面的远近\n\n7.选择2D Camera → Extensions → Add Extension 添加一个CinemachineConfiner\n\n8.新建空项目，添加多边形碰撞体，设置成触发器，拖拽到2D摄像机的Confiner中。这样就可以通过调整多边形的形状来限制摄像机的移动范围啦\n\n完成，调试\n\n发现阴影没有遮挡角色，要把Shadow 的Sorting Layer 修改成Foreground\n\n\n\n---\n\n\n\n### 二、2D灯光效果\n\n1.在Props 中找到墙灯，打开预制体修改父物体和子物体的Sorting Layer为Background（粒子效果又是一个大坑）\n\n2.拖入场景之前添加点光源，设置光源的z 轴为 -0.2 ，这样就可以在所有背景的前面照亮它们（更靠近摄像机），还可以修改颜色的照明距离等\n\n拖入火炬后为什么场景没有被照亮呢？因为场景中的物体都还没添加法线贴图\n\n3.打开Level 文件夹，将Platform 和Background 的材质球拖入对应的场景物体中（材质会自动对应瓦片）\n\n4.打开Props 添加另外一种灯：悬挂蓝灯，蓝灯会左右摇摆，因为它有一个动画效果修改z 轴旋转\n\n5.调整场景的整体灯光，打开Window → Rendering → Lighting，在Environment Lighting 中可以调整颜色和亮度\n\n","slug":"2021-07-23-《Robbie Swifthand》Unity2d独立游戏学习（四）","published":1,"updated":"2021-07-28T15:11:55.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnimn0016f4u02tch4bir","content":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>接下来做一些视觉上的东西，首先是然镜头跟随主角移动，还有场景的灯光效果</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、摄像机\"><a href=\"#一、摄像机\" class=\"headerlink\" title=\"一、摄像机\"></a>一、摄像机</h3><p>1.可以选择Camera 修改背景颜色</p>\n<p>2.将摄像机的Projection 修改为Perspective，这样就设置成了透视模式，可以通过修改图层深度来产生景深效果</p>\n<p>3.为了产生景深效果，将Grid 中的Background 的Transform → Position → z 设置为 1， 同样地，将Background Details 设置为0.99，Platforms 不变， Shadow 为 - 0.1</p>\n<p>4.在unity界面Window → Package Manager 中添加 Cinemachine</p>\n<p>5.创建2D Camera物体，将主角拖拽到相机的Follow中，摄像机会跟随角色移动</p>\n<p>6.可以设置Camera Distance 到一个合适的位置，这个选项会影响游戏画面的远近</p>\n<p>7.选择2D Camera → Extensions → Add Extension 添加一个CinemachineConfiner</p>\n<p>8.新建空项目，添加多边形碰撞体，设置成触发器，拖拽到2D摄像机的Confiner中。这样就可以通过调整多边形的形状来限制摄像机的移动范围啦</p>\n<p>完成，调试</p>\n<p>发现阴影没有遮挡角色，要把Shadow 的Sorting Layer 修改成Foreground</p>\n<hr>\n<h3 id=\"二、2D灯光效果\"><a href=\"#二、2D灯光效果\" class=\"headerlink\" title=\"二、2D灯光效果\"></a>二、2D灯光效果</h3><p>1.在Props 中找到墙灯，打开预制体修改父物体和子物体的Sorting Layer为Background（粒子效果又是一个大坑）</p>\n<p>2.拖入场景之前添加点光源，设置光源的z 轴为 -0.2 ，这样就可以在所有背景的前面照亮它们（更靠近摄像机），还可以修改颜色的照明距离等</p>\n<p>拖入火炬后为什么场景没有被照亮呢？因为场景中的物体都还没添加法线贴图</p>\n<p>3.打开Level 文件夹，将Platform 和Background 的材质球拖入对应的场景物体中（材质会自动对应瓦片）</p>\n<p>4.打开Props 添加另外一种灯：悬挂蓝灯，蓝灯会左右摇摆，因为它有一个动画效果修改z 轴旋转</p>\n<p>5.调整场景的整体灯光，打开Window → Rendering → Lighting，在Environment Lighting 中可以调整颜色和亮度</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、前言\"><a href=\"#始、前言\" class=\"headerlink\" title=\"始、前言\"></a>始、前言</h3><p>接下来做一些视觉上的东西，首先是然镜头跟随主角移动，还有场景的灯光效果</p>","more":"<hr>\n<h3 id=\"一、摄像机\"><a href=\"#一、摄像机\" class=\"headerlink\" title=\"一、摄像机\"></a>一、摄像机</h3><p>1.可以选择Camera 修改背景颜色</p>\n<p>2.将摄像机的Projection 修改为Perspective，这样就设置成了透视模式，可以通过修改图层深度来产生景深效果</p>\n<p>3.为了产生景深效果，将Grid 中的Background 的Transform → Position → z 设置为 1， 同样地，将Background Details 设置为0.99，Platforms 不变， Shadow 为 - 0.1</p>\n<p>4.在unity界面Window → Package Manager 中添加 Cinemachine</p>\n<p>5.创建2D Camera物体，将主角拖拽到相机的Follow中，摄像机会跟随角色移动</p>\n<p>6.可以设置Camera Distance 到一个合适的位置，这个选项会影响游戏画面的远近</p>\n<p>7.选择2D Camera → Extensions → Add Extension 添加一个CinemachineConfiner</p>\n<p>8.新建空项目，添加多边形碰撞体，设置成触发器，拖拽到2D摄像机的Confiner中。这样就可以通过调整多边形的形状来限制摄像机的移动范围啦</p>\n<p>完成，调试</p>\n<p>发现阴影没有遮挡角色，要把Shadow 的Sorting Layer 修改成Foreground</p>\n<hr>\n<h3 id=\"二、2D灯光效果\"><a href=\"#二、2D灯光效果\" class=\"headerlink\" title=\"二、2D灯光效果\"></a>二、2D灯光效果</h3><p>1.在Props 中找到墙灯，打开预制体修改父物体和子物体的Sorting Layer为Background（粒子效果又是一个大坑）</p>\n<p>2.拖入场景之前添加点光源，设置光源的z 轴为 -0.2 ，这样就可以在所有背景的前面照亮它们（更靠近摄像机），还可以修改颜色的照明距离等</p>\n<p>拖入火炬后为什么场景没有被照亮呢？因为场景中的物体都还没添加法线贴图</p>\n<p>3.打开Level 文件夹，将Platform 和Background 的材质球拖入对应的场景物体中（材质会自动对应瓦片）</p>\n<p>4.打开Props 添加另外一种灯：悬挂蓝灯，蓝灯会左右摇摆，因为它有一个动画效果修改z 轴旋转</p>\n<p>5.调整场景的整体灯光，打开Window → Rendering → Lighting，在Environment Lighting 中可以调整颜色和亮度</p>"},{"title":"【LeetCode.1143】最长公共子序列","date":"2021-07-26T15:32:25.000Z","_content":"\n\n\n### \t题目： 最长公共子序列\n\n​\t给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 公共子序列 ，返回 `0` 。\n\n​\t一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n\n​\t例如，`\"ace\"` 是 `\"abcde\"` 的子序列，但 `\"aec\"` 不是 `\"abcde\"` 的子序列。\n​\t两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。\n\n \n\n<!--more-->\n\n示例 1：\n\n```\n输入：text1 = \"abcde\", text2 = \"ace\" \n输出：3  \n解释：最长公共子序列是 \"ace\" ，它的长度为 3 。\n```\n\n示例 2：\n\n```\n输入：text1 = \"abc\", text2 = \"abc\"\n输出：3\n解释：最长公共子序列是 \"abc\" ，它的长度为 3 。\n```\n\n示例 3：\n\n```\n输入：text1 = \"abc\", text2 = \"def\"\n输出：0\n解释：两个字符串没有公共子序列，返回 0 。\n```\n\n\n\n提示：\n\n`1 <= text1.length, text2.length <= 1000`\n`text1 和 text2 仅由小写英文字符组成。`\n\n\n\n---\n\n\n\n### 分析：\n\n定义 `dp[i][j]` 表示 `text1[0:i]` 和 `text2[0:j]` 的最长公共子序列，其中 `text1[0:i]` 表示数组中从`0`到`i`长度为 `i + 1`的子数组\n\n当 `text1[i - 1] == text2[j - 1]` 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 `1`，所以 `dp[i][j] = dp[i - 1][j - 1] + 1`；举个例子，比如对于 `ac` 和 `bc` 而言，他们的最长公共子序列的长度等于 `a` 和 `b` 的最长公共子序列长度 `0 + 1 = 1`。\n当 `text1[i - 1] != text2[j - 1]` 时，说明两个子字符串的最后一位不相等，那么此时的状态 `dp[i][j]` 应该是 `dp[i - 1][j]` 和 `dp[i][j - 1]` 的最大值。举个例子，比如对于 `ace` 和 `bc` 而言，他们的最长公共子序列的长度等于 ① `ace` 和 `b` 的最长公共子序列长度`0` 与 ② `ac` 和 `bc` 的最长公共子序列长度`1` 的最大值，即 `1`。\n\n综上状态转移方程为：\n\n`dp[i][j] = dp[i - 1][j - 1] + 1, 当 text1[i - 1] == text2[j - 1];text1[i−1]==text2[j−1];`\n`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]), 当 text1[i - 1] != text2[j - 1]text1[i−1]!=text2[j−1]`\n\n\n\n----\n\n\n\n### 题解：\n\n```\nclass Solution {\npublic:\n\t//动态规划\n    int longestCommonSubsequence(string text1, string text2) {\n        int n = text1.size(), m = text2.size();\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\n        //逐渐将text1[i - 1]和text2[j - 1]纳入考虑，更新dp数组\n        for(int i = 1; i <= n; i++){\n            char c1 = text1[i - 1];\n            for(int j = 1; j <= m; j++){\n                char c2 = text2[j - 1];\n                if(c1 == c2) dp[i][j] = dp[i - 1][j - 1] + 1;\n                else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);\n            }\n        }\n        return dp[n][m];\n    }\n};\n```\n\n\n\n---\n\n\n\n### 总结：\n\n遇到考查动态规划的题也算有点头绪了，我的感悟是这是一种从无到有的思想：一步一步将单个信息纳入考虑范围，然后按照条件更新已知的情报。其中的难点在于`dp`数组的定义，怎么样的定义才能有效快捷地达成目的呢？\n","source":"_posts/2021-07-26-【LeetCode.1143】最长公共子序列.md","raw":"---\ntitle: 【LeetCode.1143】最长公共子序列\ndate: 2021-07-26 23:32:25\ncategories:\t算法\ntags:\n  - c++\n  - 动态规划\n  - 数组\n  - vector\n---\n\n\n\n### \t题目： 最长公共子序列\n\n​\t给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 公共子序列 ，返回 `0` 。\n\n​\t一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n\n​\t例如，`\"ace\"` 是 `\"abcde\"` 的子序列，但 `\"aec\"` 不是 `\"abcde\"` 的子序列。\n​\t两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。\n\n \n\n<!--more-->\n\n示例 1：\n\n```\n输入：text1 = \"abcde\", text2 = \"ace\" \n输出：3  \n解释：最长公共子序列是 \"ace\" ，它的长度为 3 。\n```\n\n示例 2：\n\n```\n输入：text1 = \"abc\", text2 = \"abc\"\n输出：3\n解释：最长公共子序列是 \"abc\" ，它的长度为 3 。\n```\n\n示例 3：\n\n```\n输入：text1 = \"abc\", text2 = \"def\"\n输出：0\n解释：两个字符串没有公共子序列，返回 0 。\n```\n\n\n\n提示：\n\n`1 <= text1.length, text2.length <= 1000`\n`text1 和 text2 仅由小写英文字符组成。`\n\n\n\n---\n\n\n\n### 分析：\n\n定义 `dp[i][j]` 表示 `text1[0:i]` 和 `text2[0:j]` 的最长公共子序列，其中 `text1[0:i]` 表示数组中从`0`到`i`长度为 `i + 1`的子数组\n\n当 `text1[i - 1] == text2[j - 1]` 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 `1`，所以 `dp[i][j] = dp[i - 1][j - 1] + 1`；举个例子，比如对于 `ac` 和 `bc` 而言，他们的最长公共子序列的长度等于 `a` 和 `b` 的最长公共子序列长度 `0 + 1 = 1`。\n当 `text1[i - 1] != text2[j - 1]` 时，说明两个子字符串的最后一位不相等，那么此时的状态 `dp[i][j]` 应该是 `dp[i - 1][j]` 和 `dp[i][j - 1]` 的最大值。举个例子，比如对于 `ace` 和 `bc` 而言，他们的最长公共子序列的长度等于 ① `ace` 和 `b` 的最长公共子序列长度`0` 与 ② `ac` 和 `bc` 的最长公共子序列长度`1` 的最大值，即 `1`。\n\n综上状态转移方程为：\n\n`dp[i][j] = dp[i - 1][j - 1] + 1, 当 text1[i - 1] == text2[j - 1];text1[i−1]==text2[j−1];`\n`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]), 当 text1[i - 1] != text2[j - 1]text1[i−1]!=text2[j−1]`\n\n\n\n----\n\n\n\n### 题解：\n\n```\nclass Solution {\npublic:\n\t//动态规划\n    int longestCommonSubsequence(string text1, string text2) {\n        int n = text1.size(), m = text2.size();\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\n        //逐渐将text1[i - 1]和text2[j - 1]纳入考虑，更新dp数组\n        for(int i = 1; i <= n; i++){\n            char c1 = text1[i - 1];\n            for(int j = 1; j <= m; j++){\n                char c2 = text2[j - 1];\n                if(c1 == c2) dp[i][j] = dp[i - 1][j - 1] + 1;\n                else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);\n            }\n        }\n        return dp[n][m];\n    }\n};\n```\n\n\n\n---\n\n\n\n### 总结：\n\n遇到考查动态规划的题也算有点头绪了，我的感悟是这是一种从无到有的思想：一步一步将单个信息纳入考虑范围，然后按照条件更新已知的情报。其中的难点在于`dp`数组的定义，怎么样的定义才能有效快捷地达成目的呢？\n","slug":"2021-07-26-【LeetCode.1143】最长公共子序列","published":1,"updated":"2021-07-26T16:01:08.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnimo0019f4u0hgt84s3k","content":"<h3 id=\"题目：-最长公共子序列\"><a href=\"#题目：-最长公共子序列\" class=\"headerlink\" title=\"题目： 最长公共子序列\"></a>题目： 最长公共子序列</h3><p>​    给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 公共子序列 ，返回 <code>0</code> 。</p>\n<p>​    一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>\n<p>​    例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。<br>​    两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>\n<span id=\"more\"></span>\n\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class=\"line\">输出：3  </span><br><span class=\"line\">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>\n\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>提示：</p>\n<p><code>1 &lt;= text1.length, text2.length &lt;= 1000</code><br><code>text1 和 text2 仅由小写英文字符组成。</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>定义 <code>dp[i][j]</code> 表示 <code>text1[0:i]</code> 和 <code>text2[0:j]</code> 的最长公共子序列，其中 <code>text1[0:i]</code> 表示数组中从<code>0</code>到<code>i</code>长度为 <code>i + 1</code>的子数组</p>\n<p>当 <code>text1[i - 1] == text2[j - 1]</code> 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 <code>1</code>，所以 <code>dp[i][j] = dp[i - 1][j - 1] + 1</code>；举个例子，比如对于 <code>ac</code> 和 <code>bc</code> 而言，他们的最长公共子序列的长度等于 <code>a</code> 和 <code>b</code> 的最长公共子序列长度 <code>0 + 1 = 1</code>。<br>当 <code>text1[i - 1] != text2[j - 1]</code> 时，说明两个子字符串的最后一位不相等，那么此时的状态 <code>dp[i][j]</code> 应该是 <code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code> 的最大值。举个例子，比如对于 <code>ace</code> 和 <code>bc</code> 而言，他们的最长公共子序列的长度等于 ① <code>ace</code> 和 <code>b</code> 的最长公共子序列长度<code>0</code> 与 ② <code>ac</code> 和 <code>bc</code> 的最长公共子序列长度<code>1</code> 的最大值，即 <code>1</code>。</p>\n<p>综上状态转移方程为：</p>\n<p><code>dp[i][j] = dp[i - 1][j - 1] + 1, 当 text1[i - 1] == text2[j - 1];text1[i−1]==text2[j−1];</code><br><code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]), 当 text1[i - 1] != text2[j - 1]text1[i−1]!=text2[j−1]</code></p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\t//动态规划</span><br><span class=\"line\">    int longestCommonSubsequence(string text1, string text2) &#123;</span><br><span class=\"line\">        int n = text1.size(), m = text2.size();</span><br><span class=\"line\">        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1));</span><br><span class=\"line\">        //逐渐将text1[i - 1]和text2[j - 1]纳入考虑，更新dp数组</span><br><span class=\"line\">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            char c1 = text1[i - 1];</span><br><span class=\"line\">            for(int j = 1; j &lt;= m; j++)&#123;</span><br><span class=\"line\">                char c2 = text2[j - 1];</span><br><span class=\"line\">                if(c1 == c2) dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class=\"line\">                else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[n][m];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>遇到考查动态规划的题也算有点头绪了，我的感悟是这是一种从无到有的思想：一步一步将单个信息纳入考虑范围，然后按照条件更新已知的情报。其中的难点在于<code>dp</code>数组的定义，怎么样的定义才能有效快捷地达成目的呢？</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"题目：-最长公共子序列\"><a href=\"#题目：-最长公共子序列\" class=\"headerlink\" title=\"题目： 最长公共子序列\"></a>题目： 最长公共子序列</h3><p>​    给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 公共子序列 ，返回 <code>0</code> 。</p>\n<p>​    一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>\n<p>​    例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。<br>​    两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>","more":"<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class=\"line\">输出：3  </span><br><span class=\"line\">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>\n\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>\n\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure>\n\n\n\n<p>提示：</p>\n<p><code>1 &lt;= text1.length, text2.length &lt;= 1000</code><br><code>text1 和 text2 仅由小写英文字符组成。</code></p>\n<hr>\n<h3 id=\"分析：\"><a href=\"#分析：\" class=\"headerlink\" title=\"分析：\"></a>分析：</h3><p>定义 <code>dp[i][j]</code> 表示 <code>text1[0:i]</code> 和 <code>text2[0:j]</code> 的最长公共子序列，其中 <code>text1[0:i]</code> 表示数组中从<code>0</code>到<code>i</code>长度为 <code>i + 1</code>的子数组</p>\n<p>当 <code>text1[i - 1] == text2[j - 1]</code> 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 <code>1</code>，所以 <code>dp[i][j] = dp[i - 1][j - 1] + 1</code>；举个例子，比如对于 <code>ac</code> 和 <code>bc</code> 而言，他们的最长公共子序列的长度等于 <code>a</code> 和 <code>b</code> 的最长公共子序列长度 <code>0 + 1 = 1</code>。<br>当 <code>text1[i - 1] != text2[j - 1]</code> 时，说明两个子字符串的最后一位不相等，那么此时的状态 <code>dp[i][j]</code> 应该是 <code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code> 的最大值。举个例子，比如对于 <code>ace</code> 和 <code>bc</code> 而言，他们的最长公共子序列的长度等于 ① <code>ace</code> 和 <code>b</code> 的最长公共子序列长度<code>0</code> 与 ② <code>ac</code> 和 <code>bc</code> 的最长公共子序列长度<code>1</code> 的最大值，即 <code>1</code>。</p>\n<p>综上状态转移方程为：</p>\n<p><code>dp[i][j] = dp[i - 1][j - 1] + 1, 当 text1[i - 1] == text2[j - 1];text1[i−1]==text2[j−1];</code><br><code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]), 当 text1[i - 1] != text2[j - 1]text1[i−1]!=text2[j−1]</code></p>\n<hr>\n<h3 id=\"题解：\"><a href=\"#题解：\" class=\"headerlink\" title=\"题解：\"></a>题解：</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\t//动态规划</span><br><span class=\"line\">    int longestCommonSubsequence(string text1, string text2) &#123;</span><br><span class=\"line\">        int n = text1.size(), m = text2.size();</span><br><span class=\"line\">        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1));</span><br><span class=\"line\">        //逐渐将text1[i - 1]和text2[j - 1]纳入考虑，更新dp数组</span><br><span class=\"line\">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class=\"line\">            char c1 = text1[i - 1];</span><br><span class=\"line\">            for(int j = 1; j &lt;= m; j++)&#123;</span><br><span class=\"line\">                char c2 = text2[j - 1];</span><br><span class=\"line\">                if(c1 == c2) dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class=\"line\">                else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dp[n][m];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>遇到考查动态规划的题也算有点头绪了，我的感悟是这是一种从无到有的思想：一步一步将单个信息纳入考虑范围，然后按照条件更新已知的情报。其中的难点在于<code>dp</code>数组的定义，怎么样的定义才能有效快捷地达成目的呢？</p>"},{"title":"剪辑视频自我总结","date":"2021-07-06T06:32:25.000Z","_content":"\n\n\n\n\n### \t\t始、梳理\n\n1.视频剪辑用强大的**Premiere**\n\n\n\n2.因为目标是上传B站，而B站有CC字幕功能，可以视频和字幕分开做，减少工作量，这里选择：\n\n[网易见外工作台 (youdao.com)](https://jianwai.youdao.com/index/0)\n\n\n\n3.语音不想自己配音，使用了**迅捷文字转换语音**\n\n\n\n<!--more-->\n\n------\n\n\n\n### \t一、精简入门，了解Pr视频剪辑\n\n自认为学习新的软件使用不能一开始就看官网手册或完整教学，而是先获得一个大概的认知：\n\n[10分钟快速上手premiere剪辑！]([10分钟快速上手premiere剪辑！仅含1句废话，全程干货输出，带你了解pr工作逻辑，新人快速入门视频剪辑，真的好想让你看到第一次标题写这么长来表达激动的心情_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1h7411U7BX?from=search&seid=11730757113337564851))\n\n\n\n------\n\n\n\n### \t二、\n\n","source":"_posts/更2021-07-06-剪辑视频入门总结.md","raw":"---\ntitle: 剪辑视频自我总结\ndate: 2021-07-06 14:32:25\ncategories: 琐碎\ntags:\n  - pr\n---\n\n\n\n\n\n### \t\t始、梳理\n\n1.视频剪辑用强大的**Premiere**\n\n\n\n2.因为目标是上传B站，而B站有CC字幕功能，可以视频和字幕分开做，减少工作量，这里选择：\n\n[网易见外工作台 (youdao.com)](https://jianwai.youdao.com/index/0)\n\n\n\n3.语音不想自己配音，使用了**迅捷文字转换语音**\n\n\n\n<!--more-->\n\n------\n\n\n\n### \t一、精简入门，了解Pr视频剪辑\n\n自认为学习新的软件使用不能一开始就看官网手册或完整教学，而是先获得一个大概的认知：\n\n[10分钟快速上手premiere剪辑！]([10分钟快速上手premiere剪辑！仅含1句废话，全程干货输出，带你了解pr工作逻辑，新人快速入门视频剪辑，真的好想让你看到第一次标题写这么长来表达激动的心情_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1h7411U7BX?from=search&seid=11730757113337564851))\n\n\n\n------\n\n\n\n### \t二、\n\n","slug":"更2021-07-06-剪辑视频入门总结","published":1,"updated":"2021-07-23T07:20:17.555Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnimp001df4u0f0zg3du3","content":"<h3 id=\"始、梳理\"><a href=\"#始、梳理\" class=\"headerlink\" title=\"始、梳理\"></a>始、梳理</h3><p>1.视频剪辑用强大的<strong>Premiere</strong></p>\n<p>2.因为目标是上传B站，而B站有CC字幕功能，可以视频和字幕分开做，减少工作量，这里选择：</p>\n<p><a href=\"https://jianwai.youdao.com/index/0\">网易见外工作台 (youdao.com)</a></p>\n<p>3.语音不想自己配音，使用了<strong>迅捷文字转换语音</strong></p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、精简入门，了解Pr视频剪辑\"><a href=\"#一、精简入门，了解Pr视频剪辑\" class=\"headerlink\" title=\"一、精简入门，了解Pr视频剪辑\"></a>一、精简入门，了解Pr视频剪辑</h3><p>自认为学习新的软件使用不能一开始就看官网手册或完整教学，而是先获得一个大概的认知：</p>\n<p><a href=\"%5B10%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bpremiere%E5%89%AA%E8%BE%91%EF%BC%81%E4%BB%85%E5%90%AB1%E5%8F%A5%E5%BA%9F%E8%AF%9D%EF%BC%8C%E5%85%A8%E7%A8%8B%E5%B9%B2%E8%B4%A7%E8%BE%93%E5%87%BA%EF%BC%8C%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3pr%E5%B7%A5%E4%BD%9C%E9%80%BB%E8%BE%91%EF%BC%8C%E6%96%B0%E4%BA%BA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%EF%BC%8C%E7%9C%9F%E7%9A%84%E5%A5%BD%E6%83%B3%E8%AE%A9%E4%BD%A0%E7%9C%8B%E5%88%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%A0%87%E9%A2%98%E5%86%99%E8%BF%99%E4%B9%88%E9%95%BF%E6%9D%A5%E8%A1%A8%E8%BE%BE%E6%BF%80%E5%8A%A8%E7%9A%84%E5%BF%83%E6%83%85_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1h7411U7BX?from=search&seid=11730757113337564851)\">10分钟快速上手premiere剪辑！</a></p>\n<hr>\n<h3 id=\"二、\"><a href=\"#二、\" class=\"headerlink\" title=\"二、\"></a>二、</h3>","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、梳理\"><a href=\"#始、梳理\" class=\"headerlink\" title=\"始、梳理\"></a>始、梳理</h3><p>1.视频剪辑用强大的<strong>Premiere</strong></p>\n<p>2.因为目标是上传B站，而B站有CC字幕功能，可以视频和字幕分开做，减少工作量，这里选择：</p>\n<p><a href=\"https://jianwai.youdao.com/index/0\">网易见外工作台 (youdao.com)</a></p>\n<p>3.语音不想自己配音，使用了<strong>迅捷文字转换语音</strong></p>","more":"<hr>\n<h3 id=\"一、精简入门，了解Pr视频剪辑\"><a href=\"#一、精简入门，了解Pr视频剪辑\" class=\"headerlink\" title=\"一、精简入门，了解Pr视频剪辑\"></a>一、精简入门，了解Pr视频剪辑</h3><p>自认为学习新的软件使用不能一开始就看官网手册或完整教学，而是先获得一个大概的认知：</p>\n<p><a href=\"%5B10%E5%88%86%E9%92%9F%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bpremiere%E5%89%AA%E8%BE%91%EF%BC%81%E4%BB%85%E5%90%AB1%E5%8F%A5%E5%BA%9F%E8%AF%9D%EF%BC%8C%E5%85%A8%E7%A8%8B%E5%B9%B2%E8%B4%A7%E8%BE%93%E5%87%BA%EF%BC%8C%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3pr%E5%B7%A5%E4%BD%9C%E9%80%BB%E8%BE%91%EF%BC%8C%E6%96%B0%E4%BA%BA%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%EF%BC%8C%E7%9C%9F%E7%9A%84%E5%A5%BD%E6%83%B3%E8%AE%A9%E4%BD%A0%E7%9C%8B%E5%88%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%A0%87%E9%A2%98%E5%86%99%E8%BF%99%E4%B9%88%E9%95%BF%E6%9D%A5%E8%A1%A8%E8%BE%BE%E6%BF%80%E5%8A%A8%E7%9A%84%E5%BF%83%E6%83%85_%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9_bilibili%5D(https://www.bilibili.com/video/BV1h7411U7BX?from=search&seid=11730757113337564851)\">10分钟快速上手premiere剪辑！</a></p>\n<hr>\n<h3 id=\"二、\"><a href=\"#二、\" class=\"headerlink\" title=\"二、\"></a>二、</h3>"},{"title":"C++STL","date":"2021-07-09T12:53:36.000Z","_content":"\n\n\n### \t始、STL初识\n\nSTL(standard template library)标准模板库\n\n广义上分为容器、算法、迭代器（容器和算法之间通过迭代器无缝连接）\n\n六大组件：容器、算法、迭代器、仿函数、适配器、空间配置器\n\n**主要学习以下四个：**\n\n​\t**容器**：vector、list、deque、set、map等\n\n​\t**算法(Algorithms)**：sort、find、copy、for_each等\n\n​\t**迭代器**：扮演容器与算法之间的胶合剂（每个容器都有自己专属的迭代器），迭代器可以理解成**指针**\n\n​\t**仿函数**：类似函数，可作为算法的某种策略\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t\t一、vector容器\n\nvector容器可以理解成**数组**\n\n\n\n初始化：`vector<数据类型> 容器名 (容器大小)`\n\n容器输入：`容器名. push_back(数据)`，尾插法插入数据\n\n起始迭代器：`容器名. begin()`，指向第一个元素\n\n结束迭代器：`容器名. end()`，指向最后一个元素的下一个位置\n\n自定义专属迭代器：`vector<数据类型> : : iterator 迭代器名`\n\n\n\n### \t二、遍历算法：`for_each`\n\n```\nfor_each(InputIterator beg, InputIterator end, Function f) {\n  while(beg != end) \n    f(*beg++);\n}\n```\n\n\n\n\n\n---\n\n\n\n### \t\t三、map/multimap容器\n\nmap容器可以理解成**哈希表**\n\n\n\n**map中每个元素都是pair(对组元素)**\n\npair中第一个元素为key(键值)，第二个元素为value(实值)\n\n所有元素会根据键值自动排序\n\nmap不允许容器中有重复的key值\n\nmultimap允许容器中有重复的key值\n\n\n\n默认构造：`map<key类型, value类型> 容器名`\n\n拷贝构造：`map<key类型, value类型> 容器名 (拷贝容器名)`\n\n赋值：`容器名 = 目标容器名`\n\n插入数据：`容器名. insert(pair<key类型, value类型>(key, value))`\n\n\n\n","source":"_posts/更2021-07-09-C++STL.md","raw":"---\ntitle: C++STL\ndate: 2021-07-09 20:53:36\ncategories: c++\ntags:\n  - c++\n  - map\n  - vector\n---\n\n\n\n### \t始、STL初识\n\nSTL(standard template library)标准模板库\n\n广义上分为容器、算法、迭代器（容器和算法之间通过迭代器无缝连接）\n\n六大组件：容器、算法、迭代器、仿函数、适配器、空间配置器\n\n**主要学习以下四个：**\n\n​\t**容器**：vector、list、deque、set、map等\n\n​\t**算法(Algorithms)**：sort、find、copy、for_each等\n\n​\t**迭代器**：扮演容器与算法之间的胶合剂（每个容器都有自己专属的迭代器），迭代器可以理解成**指针**\n\n​\t**仿函数**：类似函数，可作为算法的某种策略\n\n\n\n<!--more-->\n\n---\n\n\n\n### \t\t一、vector容器\n\nvector容器可以理解成**数组**\n\n\n\n初始化：`vector<数据类型> 容器名 (容器大小)`\n\n容器输入：`容器名. push_back(数据)`，尾插法插入数据\n\n起始迭代器：`容器名. begin()`，指向第一个元素\n\n结束迭代器：`容器名. end()`，指向最后一个元素的下一个位置\n\n自定义专属迭代器：`vector<数据类型> : : iterator 迭代器名`\n\n\n\n### \t二、遍历算法：`for_each`\n\n```\nfor_each(InputIterator beg, InputIterator end, Function f) {\n  while(beg != end) \n    f(*beg++);\n}\n```\n\n\n\n\n\n---\n\n\n\n### \t\t三、map/multimap容器\n\nmap容器可以理解成**哈希表**\n\n\n\n**map中每个元素都是pair(对组元素)**\n\npair中第一个元素为key(键值)，第二个元素为value(实值)\n\n所有元素会根据键值自动排序\n\nmap不允许容器中有重复的key值\n\nmultimap允许容器中有重复的key值\n\n\n\n默认构造：`map<key类型, value类型> 容器名`\n\n拷贝构造：`map<key类型, value类型> 容器名 (拷贝容器名)`\n\n赋值：`容器名 = 目标容器名`\n\n插入数据：`容器名. insert(pair<key类型, value类型>(key, value))`\n\n\n\n","slug":"更2021-07-09-C++STL","published":1,"updated":"2021-07-15T10:27:21.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnimp001ff4u04umt6z1r","content":"<h3 id=\"始、STL初识\"><a href=\"#始、STL初识\" class=\"headerlink\" title=\"始、STL初识\"></a>始、STL初识</h3><p>STL(standard template library)标准模板库</p>\n<p>广义上分为容器、算法、迭代器（容器和算法之间通过迭代器无缝连接）</p>\n<p>六大组件：容器、算法、迭代器、仿函数、适配器、空间配置器</p>\n<p><strong>主要学习以下四个：</strong></p>\n<p>​    <strong>容器</strong>：vector、list、deque、set、map等</p>\n<p>​    **算法(Algorithms)**：sort、find、copy、for_each等</p>\n<p>​    <strong>迭代器</strong>：扮演容器与算法之间的胶合剂（每个容器都有自己专属的迭代器），迭代器可以理解成<strong>指针</strong></p>\n<p>​    <strong>仿函数</strong>：类似函数，可作为算法的某种策略</p>\n<span id=\"more\"></span>\n\n<hr>\n<h3 id=\"一、vector容器\"><a href=\"#一、vector容器\" class=\"headerlink\" title=\"一、vector容器\"></a>一、vector容器</h3><p>vector容器可以理解成<strong>数组</strong></p>\n<p>初始化：<code>vector&lt;数据类型&gt; 容器名 (容器大小)</code></p>\n<p>容器输入：<code>容器名. push_back(数据)</code>，尾插法插入数据</p>\n<p>起始迭代器：<code>容器名. begin()</code>，指向第一个元素</p>\n<p>结束迭代器：<code>容器名. end()</code>，指向最后一个元素的下一个位置</p>\n<p>自定义专属迭代器：<code>vector&lt;数据类型&gt; : : iterator 迭代器名</code></p>\n<h3 id=\"二、遍历算法：for-each\"><a href=\"#二、遍历算法：for-each\" class=\"headerlink\" title=\"二、遍历算法：for_each\"></a>二、遍历算法：<code>for_each</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for_each(InputIterator beg, InputIterator end, Function f) &#123;</span><br><span class=\"line\">  while(beg != end) </span><br><span class=\"line\">    f(*beg++);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<hr>\n<h3 id=\"三、map-multimap容器\"><a href=\"#三、map-multimap容器\" class=\"headerlink\" title=\"三、map/multimap容器\"></a>三、map/multimap容器</h3><p>map容器可以理解成<strong>哈希表</strong></p>\n<p><strong>map中每个元素都是pair(对组元素)</strong></p>\n<p>pair中第一个元素为key(键值)，第二个元素为value(实值)</p>\n<p>所有元素会根据键值自动排序</p>\n<p>map不允许容器中有重复的key值</p>\n<p>multimap允许容器中有重复的key值</p>\n<p>默认构造：<code>map&lt;key类型, value类型&gt; 容器名</code></p>\n<p>拷贝构造：<code>map&lt;key类型, value类型&gt; 容器名 (拷贝容器名)</code></p>\n<p>赋值：<code>容器名 = 目标容器名</code></p>\n<p>插入数据：<code>容器名. insert(pair&lt;key类型, value类型&gt;(key, value))</code></p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"<h3 id=\"始、STL初识\"><a href=\"#始、STL初识\" class=\"headerlink\" title=\"始、STL初识\"></a>始、STL初识</h3><p>STL(standard template library)标准模板库</p>\n<p>广义上分为容器、算法、迭代器（容器和算法之间通过迭代器无缝连接）</p>\n<p>六大组件：容器、算法、迭代器、仿函数、适配器、空间配置器</p>\n<p><strong>主要学习以下四个：</strong></p>\n<p>​    <strong>容器</strong>：vector、list、deque、set、map等</p>\n<p>​    **算法(Algorithms)**：sort、find、copy、for_each等</p>\n<p>​    <strong>迭代器</strong>：扮演容器与算法之间的胶合剂（每个容器都有自己专属的迭代器），迭代器可以理解成<strong>指针</strong></p>\n<p>​    <strong>仿函数</strong>：类似函数，可作为算法的某种策略</p>","more":"<hr>\n<h3 id=\"一、vector容器\"><a href=\"#一、vector容器\" class=\"headerlink\" title=\"一、vector容器\"></a>一、vector容器</h3><p>vector容器可以理解成<strong>数组</strong></p>\n<p>初始化：<code>vector&lt;数据类型&gt; 容器名 (容器大小)</code></p>\n<p>容器输入：<code>容器名. push_back(数据)</code>，尾插法插入数据</p>\n<p>起始迭代器：<code>容器名. begin()</code>，指向第一个元素</p>\n<p>结束迭代器：<code>容器名. end()</code>，指向最后一个元素的下一个位置</p>\n<p>自定义专属迭代器：<code>vector&lt;数据类型&gt; : : iterator 迭代器名</code></p>\n<h3 id=\"二、遍历算法：for-each\"><a href=\"#二、遍历算法：for-each\" class=\"headerlink\" title=\"二、遍历算法：for_each\"></a>二、遍历算法：<code>for_each</code></h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for_each(InputIterator beg, InputIterator end, Function f) &#123;</span><br><span class=\"line\">  while(beg != end) </span><br><span class=\"line\">    f(*beg++);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<hr>\n<h3 id=\"三、map-multimap容器\"><a href=\"#三、map-multimap容器\" class=\"headerlink\" title=\"三、map/multimap容器\"></a>三、map/multimap容器</h3><p>map容器可以理解成<strong>哈希表</strong></p>\n<p><strong>map中每个元素都是pair(对组元素)</strong></p>\n<p>pair中第一个元素为key(键值)，第二个元素为value(实值)</p>\n<p>所有元素会根据键值自动排序</p>\n<p>map不允许容器中有重复的key值</p>\n<p>multimap允许容器中有重复的key值</p>\n<p>默认构造：<code>map&lt;key类型, value类型&gt; 容器名</code></p>\n<p>拷贝构造：<code>map&lt;key类型, value类型&gt; 容器名 (拷贝容器名)</code></p>\n<p>赋值：<code>容器名 = 目标容器名</code></p>\n<p>插入数据：<code>容器名. insert(pair&lt;key类型, value类型&gt;(key, value))</code></p>"},{"top":true,"title":"Top","date":"2021-07-09T15:38:24.000Z","_content":"\n\n\n\n\n### 版本：\n\nhexo 5.4\n\nnext 7.8\n\n\n\n### \thexo + github 常用指令：\n\n新建文章：`hexo n 文章名`\n\n发布到本地：`hexo s`\n\n部署到github：`hexo clean` ， `hexo g -d`\n\n备份源文件到github：`git add .` ， `git commit -m 备注` ，  `git push origin hexo`\n\n","source":"_posts/置顶页面Top.md","raw":"---\ntop: true\ntitle: Top\ndate: 2021-07-09 23:38:24\ncategories: 琐碎\ntags:\n---\n\n\n\n\n\n### 版本：\n\nhexo 5.4\n\nnext 7.8\n\n\n\n### \thexo + github 常用指令：\n\n新建文章：`hexo n 文章名`\n\n发布到本地：`hexo s`\n\n部署到github：`hexo clean` ， `hexo g -d`\n\n备份源文件到github：`git add .` ， `git commit -m 备注` ，  `git push origin hexo`\n\n","slug":"置顶页面Top","published":1,"updated":"2021-07-15T10:30:01.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrnmnims001if4u007zv0wmx","content":"<h3 id=\"版本：\"><a href=\"#版本：\" class=\"headerlink\" title=\"版本：\"></a>版本：</h3><p>hexo 5.4</p>\n<p>next 7.8</p>\n<h3 id=\"hexo-github-常用指令：\"><a href=\"#hexo-github-常用指令：\" class=\"headerlink\" title=\"hexo + github 常用指令：\"></a>hexo + github 常用指令：</h3><p>新建文章：<code>hexo n 文章名</code></p>\n<p>发布到本地：<code>hexo s</code></p>\n<p>部署到github：<code>hexo clean</code> ， <code>hexo g -d</code></p>\n<p>备份源文件到github：<code>git add .</code> ， <code>git commit -m 备注</code> ，  <code>git push origin hexo</code></p>\n","site":{"data":{"styles":"body {\n  background: url(\"/assets/background.png\");\n  background-repeat: no-repeat;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n  opacity: 0.95;\nmobile()\n}\n.post {\n  margin-top: 60px;\n  margin-bottom: 60px;\n  padding: 25px;\n  -webkit-box-shadow: 0 0 5px rgba(202,203,203,0.5);\n  -moz-box-shadow: 0 0 5px rgba(202,203,204,0.5);\n}\n.site-meta {\n  background: $black;\n}\n.brand {\n  color: $white;\n}\n.site-subtitle {\n  color: $orange;\n}\n"}},"excerpt":"","more":"<h3 id=\"版本：\"><a href=\"#版本：\" class=\"headerlink\" title=\"版本：\"></a>版本：</h3><p>hexo 5.4</p>\n<p>next 7.8</p>\n<h3 id=\"hexo-github-常用指令：\"><a href=\"#hexo-github-常用指令：\" class=\"headerlink\" title=\"hexo + github 常用指令：\"></a>hexo + github 常用指令：</h3><p>新建文章：<code>hexo n 文章名</code></p>\n<p>发布到本地：<code>hexo s</code></p>\n<p>部署到github：<code>hexo clean</code> ， <code>hexo g -d</code></p>\n<p>备份源文件到github：<code>git add .</code> ， <code>git commit -m 备注</code> ，  <code>git push origin hexo</code></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckrnmnim10001f4u02mcnh9tp","category_id":"ckrnmnim60004f4u09ywq1c96","_id":"ckrnmnimb000df4u05o2s136w"},{"post_id":"ckrnmnim90008f4u04k0sggjj","category_id":"ckrnmnim60004f4u09ywq1c96","_id":"ckrnmnime000hf4u088y38tye"},{"post_id":"ckrnmnima000bf4u083bp5rc8","category_id":"ckrnmnim90009f4u0fgbp10dw","_id":"ckrnmnime000jf4u0b2tu9osa"},{"post_id":"ckrnmnim40003f4u0hrz1h0a2","category_id":"ckrnmnim90009f4u0fgbp10dw","_id":"ckrnmnimg000nf4u047l6bwgc"},{"post_id":"ckrnmnimb000cf4u05df17i9e","category_id":"ckrnmnim90009f4u0fgbp10dw","_id":"ckrnmnimh000pf4u004nw4l2y"},{"post_id":"ckrnmnimd000gf4u07ela5kt5","category_id":"ckrnmnim90009f4u0fgbp10dw","_id":"ckrnmnimi000sf4u0grzx8s05"},{"post_id":"ckrnmnim70006f4u0hi1c32r3","category_id":"ckrnmnim60004f4u09ywq1c96","_id":"ckrnmnimj000uf4u09g5z196z"},{"post_id":"ckrnmnime000if4u02gtt3sp3","category_id":"ckrnmnim90009f4u0fgbp10dw","_id":"ckrnmnimk000wf4u0c60x9f5c"},{"post_id":"ckrnmnimf000mf4u0827m5j3j","category_id":"ckrnmnim90009f4u0fgbp10dw","_id":"ckrnmnimm0010f4u00nv16wbf"},{"post_id":"ckrnmnim80007f4u022nbdwiu","category_id":"ckrnmnimf000kf4u0526zhegj","_id":"ckrnmnimn0013f4u09czk30li"},{"post_id":"ckrnmnimh000of4u01yfr5av2","category_id":"ckrnmnimf000kf4u0526zhegj","_id":"ckrnmnimn0017f4u0bdr91j69"},{"post_id":"ckrnmnimi000rf4u06yi8defz","category_id":"ckrnmnim90009f4u0fgbp10dw","_id":"ckrnmnimo001af4u0a8freo19"},{"post_id":"ckrnmnimi000tf4u0afc8dytq","category_id":"ckrnmnim90009f4u0fgbp10dw","_id":"ckrnmnimp001ef4u0c6z36u0y"},{"post_id":"ckrnmnimj000vf4u024ty9ck5","category_id":"ckrnmnim90009f4u0fgbp10dw","_id":"ckrnmnims001gf4u0ax2x22vk"},{"post_id":"ckrnmniml000zf4u077ml5639","category_id":"ckrnmnim90009f4u0fgbp10dw","_id":"ckrnmnimt001jf4u08i7t10sa"},{"post_id":"ckrnmnimm0012f4u0gyguakd6","category_id":"ckrnmnimf000kf4u0526zhegj","_id":"ckrnmnimt001lf4u0cv3j3f0o"},{"post_id":"ckrnmnimn0016f4u02tch4bir","category_id":"ckrnmnim90009f4u0fgbp10dw","_id":"ckrnmnimt001mf4u0gj2n907s"},{"post_id":"ckrnmnimo0019f4u0hgt84s3k","category_id":"ckrnmnimf000kf4u0526zhegj","_id":"ckrnmnimu001pf4u0ev1j5s76"},{"post_id":"ckrnmnimp001df4u0f0zg3du3","category_id":"ckrnmnim60004f4u09ywq1c96","_id":"ckrnmnimu001rf4u0dzcn0672"},{"post_id":"ckrnmnims001if4u007zv0wmx","category_id":"ckrnmnim60004f4u09ywq1c96","_id":"ckrnmnimv001uf4u0cbu23nu5"},{"post_id":"ckrnmnimp001ff4u04umt6z1r","category_id":"ckrnmnimt001kf4u06xg94433","_id":"ckrnmnimv001wf4u024aaffre"}],"PostTag":[{"post_id":"ckrnmnim10001f4u02mcnh9tp","tag_id":"ckrnmnim70005f4u0b202bbpw","_id":"ckrnmniml000yf4u0dkke1q0y"},{"post_id":"ckrnmnim10001f4u02mcnh9tp","tag_id":"ckrnmnim9000af4u085v3dm2h","_id":"ckrnmnimm0011f4u06c7x69i2"},{"post_id":"ckrnmnim10001f4u02mcnh9tp","tag_id":"ckrnmnimc000ff4u021vod180","_id":"ckrnmnimn0015f4u0fj3ndzoo"},{"post_id":"ckrnmnim10001f4u02mcnh9tp","tag_id":"ckrnmnimf000lf4u09jja03b7","_id":"ckrnmnimo0018f4u098aw8y0b"},{"post_id":"ckrnmnim10001f4u02mcnh9tp","tag_id":"ckrnmnimh000qf4u06f8zdo3k","_id":"ckrnmnimp001cf4u0h0wj5jcm"},{"post_id":"ckrnmnim40003f4u0hrz1h0a2","tag_id":"ckrnmnimk000xf4u0hvb7ggol","_id":"ckrnmnimu001of4u0c3b123b7"},{"post_id":"ckrnmnim40003f4u0hrz1h0a2","tag_id":"ckrnmnimn0014f4u0c44ohu7t","_id":"ckrnmnimu001qf4u0dr1xgrpl"},{"post_id":"ckrnmnim40003f4u0hrz1h0a2","tag_id":"ckrnmnimo001bf4u05qx92x89","_id":"ckrnmnimu001tf4u0bh3tbx5j"},{"post_id":"ckrnmnim40003f4u0hrz1h0a2","tag_id":"ckrnmnims001hf4u00fqr3r17","_id":"ckrnmnimv001vf4u0gdo93iob"},{"post_id":"ckrnmnim70006f4u0hi1c32r3","tag_id":"ckrnmnimc000ff4u021vod180","_id":"ckrnmnimv001yf4u01qz5c692"},{"post_id":"ckrnmnim70006f4u0hi1c32r3","tag_id":"ckrnmnimu001sf4u0f24taoem","_id":"ckrnmnimv001zf4u0bv358s26"},{"post_id":"ckrnmnim80007f4u022nbdwiu","tag_id":"ckrnmnimv001xf4u0gbycau85","_id":"ckrnmnimw0023f4u027kf8zpb"},{"post_id":"ckrnmnim80007f4u022nbdwiu","tag_id":"ckrnmnimv0020f4u0aizeezym","_id":"ckrnmnimx0024f4u003c188dv"},{"post_id":"ckrnmnim80007f4u022nbdwiu","tag_id":"ckrnmnimv0021f4u0722ne8iy","_id":"ckrnmnimx0026f4u0ggng2tae"},{"post_id":"ckrnmnim90008f4u04k0sggjj","tag_id":"ckrnmnimk000xf4u0hvb7ggol","_id":"ckrnmnimy002af4u07aa695eb"},{"post_id":"ckrnmnim90008f4u04k0sggjj","tag_id":"ckrnmnimn0014f4u0c44ohu7t","_id":"ckrnmnimy002bf4u079zsggrr"},{"post_id":"ckrnmnim90008f4u04k0sggjj","tag_id":"ckrnmnimx0027f4u00e0faza8","_id":"ckrnmnimz002df4u0cona42la"},{"post_id":"ckrnmnim90008f4u04k0sggjj","tag_id":"ckrnmnimx0028f4u0hur0flgx","_id":"ckrnmnimz002ef4u0713gen8e"},{"post_id":"ckrnmnima000bf4u083bp5rc8","tag_id":"ckrnmnimk000xf4u0hvb7ggol","_id":"ckrnmnin0002if4u05smf506j"},{"post_id":"ckrnmnima000bf4u083bp5rc8","tag_id":"ckrnmnimn0014f4u0c44ohu7t","_id":"ckrnmnin0002jf4u0914bdoby"},{"post_id":"ckrnmnima000bf4u083bp5rc8","tag_id":"ckrnmnimz002ff4u0ecnw6s1o","_id":"ckrnmnin0002lf4u0c9v97701"},{"post_id":"ckrnmnima000bf4u083bp5rc8","tag_id":"ckrnmnimz002gf4u026066t7f","_id":"ckrnmnin0002mf4u0bidc4k1x"},{"post_id":"ckrnmnimb000cf4u05df17i9e","tag_id":"ckrnmnimk000xf4u0hvb7ggol","_id":"ckrnmnin2002rf4u008584okr"},{"post_id":"ckrnmnimb000cf4u05df17i9e","tag_id":"ckrnmnimn0014f4u0c44ohu7t","_id":"ckrnmnin2002sf4u00p2qdvsh"},{"post_id":"ckrnmnimb000cf4u05df17i9e","tag_id":"ckrnmnin0002nf4u0fcmtgnnl","_id":"ckrnmnin2002uf4u00z7agw78"},{"post_id":"ckrnmnimb000cf4u05df17i9e","tag_id":"ckrnmnin1002of4u0el6ddl6t","_id":"ckrnmnin2002vf4u0h4mxd8bo"},{"post_id":"ckrnmnimb000cf4u05df17i9e","tag_id":"ckrnmnimz002gf4u026066t7f","_id":"ckrnmnin3002xf4u0asoeatnj"},{"post_id":"ckrnmnimd000gf4u07ela5kt5","tag_id":"ckrnmnimk000xf4u0hvb7ggol","_id":"ckrnmnin3002zf4u0bweng4dy"},{"post_id":"ckrnmnimd000gf4u07ela5kt5","tag_id":"ckrnmnimn0014f4u0c44ohu7t","_id":"ckrnmnin30030f4u0dl895oh7"},{"post_id":"ckrnmnimd000gf4u07ela5kt5","tag_id":"ckrnmnin2002wf4u0c7jse5ni","_id":"ckrnmnin40032f4u026lq1tj7"},{"post_id":"ckrnmnime000if4u02gtt3sp3","tag_id":"ckrnmnimk000xf4u0hvb7ggol","_id":"ckrnmnin50036f4u0bn8n41m8"},{"post_id":"ckrnmnime000if4u02gtt3sp3","tag_id":"ckrnmnimn0014f4u0c44ohu7t","_id":"ckrnmnin50037f4u04km0bir9"},{"post_id":"ckrnmnime000if4u02gtt3sp3","tag_id":"ckrnmnin1002of4u0el6ddl6t","_id":"ckrnmnin50039f4u073tz2rxa"},{"post_id":"ckrnmnime000if4u02gtt3sp3","tag_id":"ckrnmnin40034f4u07z7kfl82","_id":"ckrnmnin5003af4u0fpm2gxt4"},{"post_id":"ckrnmnimf000mf4u0827m5j3j","tag_id":"ckrnmnimk000xf4u0hvb7ggol","_id":"ckrnmnin6003ef4u0235rg7xw"},{"post_id":"ckrnmnimf000mf4u0827m5j3j","tag_id":"ckrnmnimn0014f4u0c44ohu7t","_id":"ckrnmnin6003ff4u08liu33f3"},{"post_id":"ckrnmnimf000mf4u0827m5j3j","tag_id":"ckrnmnin5003bf4u0esbu1uk3","_id":"ckrnmnin6003hf4u00zm2cug0"},{"post_id":"ckrnmnimf000mf4u0827m5j3j","tag_id":"ckrnmnin5003cf4u02dbka9vs","_id":"ckrnmnin6003if4u0541j77ha"},{"post_id":"ckrnmnimh000of4u01yfr5av2","tag_id":"ckrnmnimv001xf4u0gbycau85","_id":"ckrnmnin7003lf4u0fyk1hw4e"},{"post_id":"ckrnmnimh000of4u01yfr5av2","tag_id":"ckrnmnin6003gf4u0faub31ts","_id":"ckrnmnin7003mf4u07mhl1uqd"},{"post_id":"ckrnmnimh000of4u01yfr5av2","tag_id":"ckrnmnimv0021f4u0722ne8iy","_id":"ckrnmnin7003of4u0hmfx67pq"},{"post_id":"ckrnmnimi000rf4u06yi8defz","tag_id":"ckrnmnimk000xf4u0hvb7ggol","_id":"ckrnmnin9003vf4u0hhfl7vls"},{"post_id":"ckrnmnimi000rf4u06yi8defz","tag_id":"ckrnmnimn0014f4u0c44ohu7t","_id":"ckrnmnin9003wf4u0d30v9jyh"},{"post_id":"ckrnmnimi000rf4u06yi8defz","tag_id":"ckrnmnimz002gf4u026066t7f","_id":"ckrnmnina003yf4u05o2b3m4a"},{"post_id":"ckrnmnimi000rf4u06yi8defz","tag_id":"ckrnmnimz002ff4u0ecnw6s1o","_id":"ckrnmnina003zf4u0eos006cx"},{"post_id":"ckrnmnimi000rf4u06yi8defz","tag_id":"ckrnmnin1002of4u0el6ddl6t","_id":"ckrnmnina0041f4u0h7401m55"},{"post_id":"ckrnmnimi000rf4u06yi8defz","tag_id":"ckrnmnin2002wf4u0c7jse5ni","_id":"ckrnmnina0042f4u0cjuh2lir"},{"post_id":"ckrnmnimi000rf4u06yi8defz","tag_id":"ckrnmnin5003cf4u02dbka9vs","_id":"ckrnmninb0044f4u07z2gbbrm"},{"post_id":"ckrnmnimi000tf4u0afc8dytq","tag_id":"ckrnmnimk000xf4u0hvb7ggol","_id":"ckrnmninb0045f4u0a6akepd1"},{"post_id":"ckrnmnimi000tf4u0afc8dytq","tag_id":"ckrnmnimn0014f4u0c44ohu7t","_id":"ckrnmninb0047f4u0gofmho7l"},{"post_id":"ckrnmnimi000tf4u0afc8dytq","tag_id":"ckrnmnina0040f4u00ue939mx","_id":"ckrnmninb0048f4u0gcgrgfdr"},{"post_id":"ckrnmnimj000vf4u024ty9ck5","tag_id":"ckrnmnimk000xf4u0hvb7ggol","_id":"ckrnmninc004cf4u0cjuk7459"},{"post_id":"ckrnmnimj000vf4u024ty9ck5","tag_id":"ckrnmnimn0014f4u0c44ohu7t","_id":"ckrnmninc004df4u08n6j9slk"},{"post_id":"ckrnmnimj000vf4u024ty9ck5","tag_id":"ckrnmninb0049f4u0000r2i6h","_id":"ckrnmninc004ff4u0ezfg5wj7"},{"post_id":"ckrnmnimj000vf4u024ty9ck5","tag_id":"ckrnmninc004af4u05lt4fxg0","_id":"ckrnmnind004gf4u0bhrpc4nh"},{"post_id":"ckrnmniml000zf4u077ml5639","tag_id":"ckrnmnimk000xf4u0hvb7ggol","_id":"ckrnmnind004if4u0dzkmb3jf"},{"post_id":"ckrnmniml000zf4u077ml5639","tag_id":"ckrnmnimn0014f4u0c44ohu7t","_id":"ckrnmnind004jf4u066f8epyf"},{"post_id":"ckrnmniml000zf4u077ml5639","tag_id":"ckrnmninc004ef4u040k1cxqy","_id":"ckrnmnind004lf4u0g9059d7b"},{"post_id":"ckrnmnimm0012f4u0gyguakd6","tag_id":"ckrnmnimv001xf4u0gbycau85","_id":"ckrnmnine004of4u08juh2in4"},{"post_id":"ckrnmnimm0012f4u0gyguakd6","tag_id":"ckrnmnind004kf4u069cdhoau","_id":"ckrnmnine004pf4u0fj1hbxid"},{"post_id":"ckrnmnimm0012f4u0gyguakd6","tag_id":"ckrnmnine004mf4u0ak2e00ci","_id":"ckrnmninf004rf4u0a541ekxz"},{"post_id":"ckrnmnimn0016f4u02tch4bir","tag_id":"ckrnmnimk000xf4u0hvb7ggol","_id":"ckrnmninf004sf4u010gp6j50"},{"post_id":"ckrnmnimn0016f4u02tch4bir","tag_id":"ckrnmnimn0014f4u0c44ohu7t","_id":"ckrnmninf004uf4u07ic423a2"},{"post_id":"ckrnmnimn0016f4u02tch4bir","tag_id":"ckrnmnine004nf4u081icbnpz","_id":"ckrnmninf004vf4u0e8li5z3h"},{"post_id":"ckrnmnimo0019f4u0hgt84s3k","tag_id":"ckrnmnimv001xf4u0gbycau85","_id":"ckrnmning004zf4u04ai85eo1"},{"post_id":"ckrnmnimo0019f4u0hgt84s3k","tag_id":"ckrnmnin6003gf4u0faub31ts","_id":"ckrnmning0050f4u05geyhnx0"},{"post_id":"ckrnmnimo0019f4u0hgt84s3k","tag_id":"ckrnmnimv0021f4u0722ne8iy","_id":"ckrnmning0052f4u0hz1wc7x8"},{"post_id":"ckrnmnimo0019f4u0hgt84s3k","tag_id":"ckrnmning004xf4u01vcfdpan","_id":"ckrnmninh0053f4u000bfc1gt"},{"post_id":"ckrnmnimp001df4u0f0zg3du3","tag_id":"ckrnmning004yf4u0g360grcr","_id":"ckrnmninh0055f4u048pvdx9w"},{"post_id":"ckrnmnimp001ff4u04umt6z1r","tag_id":"ckrnmnimv001xf4u0gbycau85","_id":"ckrnmninh0057f4u0hvn32t0c"},{"post_id":"ckrnmnimp001ff4u04umt6z1r","tag_id":"ckrnmninh0054f4u0b1f1b7sc","_id":"ckrnmninh0058f4u046t1htra"},{"post_id":"ckrnmnimp001ff4u04umt6z1r","tag_id":"ckrnmning004xf4u01vcfdpan","_id":"ckrnmninh0059f4u0fln73fij"}],"Tag":[{"name":"hexo","_id":"ckrnmnim70005f4u0b202bbpw"},{"name":"git","_id":"ckrnmnim9000af4u085v3dm2h"},{"name":"github","_id":"ckrnmnimc000ff4u021vod180"},{"name":"typora","_id":"ckrnmnimf000lf4u09jja03b7"},{"name":"next","_id":"ckrnmnimh000qf4u06f8zdo3k"},{"name":"unity","_id":"ckrnmnimk000xf4u0hvb7ggol"},{"name":"c#","_id":"ckrnmnimn0014f4u0c44ohu7t"},{"name":"unityhub","_id":"ckrnmnimo001bf4u05qx92x89"},{"name":"2d","_id":"ckrnmnims001hf4u00fqr3r17"},{"name":"windows","_id":"ckrnmnimu001sf4u0f24taoem"},{"name":"c++","_id":"ckrnmnimv001xf4u0gbycau85"},{"name":"滑动窗口法","_id":"ckrnmnimv0020f4u0aizeezym"},{"name":"数组","_id":"ckrnmnimv0021f4u0722ne8iy"},{"name":"ps","_id":"ckrnmnimx0027f4u00e0faza8"},{"name":"像素","_id":"ckrnmnimx0028f4u0hur0flgx"},{"name":"joint","_id":"ckrnmnimz002ff4u0ecnw6s1o"},{"name":"collider","_id":"ckrnmnimz002gf4u026066t7f"},{"name":"animator","_id":"ckrnmnin0002nf4u0fcmtgnnl"},{"name":"trigger","_id":"ckrnmnin1002of4u0el6ddl6t"},{"name":"prefab","_id":"ckrnmnin2002wf4u0c7jse5ni"},{"name":"collision","_id":"ckrnmnin40034f4u07z7kfl82"},{"name":"awake","_id":"ckrnmnin5003bf4u0esbu1uk3"},{"name":"canvas","_id":"ckrnmnin5003cf4u02dbka9vs"},{"name":"动态规划","_id":"ckrnmnin6003gf4u0faub31ts"},{"name":"tile","_id":"ckrnmnina0040f4u00ue939mx"},{"name":"update","_id":"ckrnmninb0049f4u0000r2i6h"},{"name":"time","_id":"ckrnmninc004af4u05lt4fxg0"},{"name":"raycast","_id":"ckrnmninc004ef4u040k1cxqy"},{"name":"原地算法","_id":"ckrnmnind004kf4u069cdhoau"},{"name":"链表","_id":"ckrnmnine004mf4u0ak2e00ci"},{"name":"camera","_id":"ckrnmnine004nf4u081icbnpz"},{"name":"vector","_id":"ckrnmning004xf4u01vcfdpan"},{"name":"pr","_id":"ckrnmning004yf4u0g360grcr"},{"name":"map","_id":"ckrnmninh0054f4u0b1f1b7sc"}]}}