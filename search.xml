<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Top</title>
    <url>/2021/07/09/%E7%BD%AE%E9%A1%B6%E9%A1%B5%E9%9D%A2Top/</url>
    <content><![CDATA[<h1 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a><center>备忘</center></h1><p>​    <span id="more"></span></p>
<h3 id="大坏蛋，-爱偷看"><a href="#大坏蛋，-爱偷看" class="headerlink" title="大坏蛋，.爱偷看"></a><center>大坏蛋，.爱偷看</center></h3><h3 id="版本："><a href="#版本：" class="headerlink" title="版本："></a>版本：</h3><p><code>hexo 5.4</code></p>
<p><code>next 7.8</code></p>
<h3 id="hexo-github-常用指令及个性化步骤："><a href="#hexo-github-常用指令及个性化步骤：" class="headerlink" title="hexo + github 常用指令及个性化步骤："></a>hexo + github 常用指令及个性化步骤：</h3><p>新建文章：<code>hexo n 文章名</code></p>
<p>发布到本地：<code>hexo s</code></p>
<p>部署到github：<code>hexo clean</code> ， <code>hexo g -d</code></p>
<p>备份源文件到github：<code>git add .</code> ， <code>git commit -m 备注</code> ，  <code>git push origin hexo</code></p>
<p>更改背景图案：将图片放入<code>Blog → blog → themes → next → source → assets</code>，在<code>Blog → blog → source → _data</code>中调整图片</p>
]]></content>
      <categories>
        <category>琐碎</category>
      </categories>
  </entry>
  <entry>
    <title>搭建免费个人图床</title>
    <url>/2022/07/02/2022-07-02-%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<h3 id="始、前言"><a href="#始、前言" class="headerlink" title="始、前言"></a>始、前言</h3><p>创建我的个人博客已经一年了，想要找点新东西改变一下现在的模式</p>
<p>第一个想到的就是文章中的图片问题，之前是秉承能用文字描述就用文字，现在果然还是超想加图片的呢</p>
<p>尝试过将图片放入博客源文件中，用绝对路径展示图片，但是这种方法会让源文件越来越大，后面每次部署和备份博客都要上传大量数据</p>
<p>直到我找到了它：PicGo + Github 的永久免费个人图床！方便，稳定，个人专属。</p>
<span id="more"></span>

<hr>
<h3 id="一、PicGo"><a href="#一、PicGo" class="headerlink" title="一、PicGo"></a>一、PicGo</h3><p><strong><a href="https://github.com/Molunerfinn/PicGo">PicGo</a>: 一个用于快速上传图片并获取图片 URL 链接的工具</strong></p>
<p>PicGo 本体支持如下图床：</p>
<ul>
<li><code>七牛图床</code> v1.0</li>
<li><code>腾讯云 COS v4\v5 版本</code> v1.1 &amp; v1.5.0</li>
<li><code>又拍云</code> v1.2.0</li>
<li><code>GitHub</code> v1.5.0</li>
<li><code>SM.MS V2</code> v2.3.0-beta.0</li>
<li><code>阿里云 OSS</code> v1.6.0</li>
<li><code>Imgur</code> v1.6.0</li>
</ul>
<p>本体不再增加默认的图床支持。自行开发第三方图床插件详见 <a href="https://picgo.github.io/PicGo-Core-Doc/">PicGo-Core</a>。</p>
<p><strong>1.Windows 用户点击<a href="https://github.com/Molunerfinn/PicGo/releases">此处</a>下载最新版本的 <code>exe</code> 文件。</strong></p>
<p><strong>2.我下载的是<code>PicGo-Setup-2.3.0-x64.exe</code></strong></p>
<p>应用界面：</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/NobitaChan/picBed/img/20220702214942.png"></p>
<p>官方演示：</p>
<p><img data-src="https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo-2.0.gif" alt="picgo-2.0.gif"></p>
<hr>
<h3 id="二、Github图床"><a href="#二、Github图床" class="headerlink" title="二、Github图床"></a>二、Github图床</h3><p>既然已经用Github存放博客了，那就顺便也用Github存放图片吧！</p>
<p><strong>1.创建新的Repository</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/NobitaChan/picBed/img/20220702215610.png"></p>
<p><strong>2.设置Repository</strong></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/NobitaChan/picBed/img/20220702215920.png"></p>
<p>仓库名可以随便建，方便记住就好</p>
<p>设为Public公开</p>
<p><strong>3.生成Token</strong></p>
<p>打开Github的 Settings → Developer settings → Personal access tokens，点击<code>Generate new token</code></p>
<p><img data-src="https://cdn.jsdelivr.net/gh/NobitaChan/picBed/img/20220702220626.png"></p>
<p>填写描述，选择<code>repo</code>，然后点击<code>Generate token</code>按钮</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/NobitaChan/picBed/img/20220702220745.png"></p>
<p>成功后就会显示一串字符</p>
<p><strong>注意</strong>：Token只会显示一次，请马上保存且不要泄露！</p>
<hr>
<h3 id="三、配置PicGo"><a href="#三、配置PicGo" class="headerlink" title="三、配置PicGo"></a>三、配置PicGo</h3><p>打开PicGo（默认最小化），找到Github图床的设置</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/NobitaChan/picBed/img/20220702221139.png"></p>
<p>设定仓库名：“账户名/仓库名”</p>
<p>设定分支名：填写“master”（Github创建仓库时可能会默认main为主分支，需要修改分支名）</p>
<p>设定Token：将之前的Token黏贴在这里</p>
<p>指定存储路径：这样子写会在repository下创建一个“img”文件夹来存放图片</p>
<p>设定自定义域名：自定义域名需要按照这样去填写，在上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接<code>https://raw.githubusercontent.com/用户名/RepositoryName/分支名，</code>或者使用cdn加速</p>
<p><code>https://cdn.jsdelivr.net/gh/用户名/RepositoryName</code>来进行加速</p>
<p>这样之后就可以在文档中加入图片了，同时图片也可以在github仓库中查看到</p>
<p>建议开启上传前重命名功能，因为有时候可能因为某些图片是中文的，导致错误，打开后可以把图片设置为数字时间格式，这样方便很多。</p>
<p><img data-src="https://cdn.jsdelivr.net/gh/NobitaChan/picBed/img/20220702222347.png"></p>
<p><strong>小知识：</strong></p>
<p>1）CDN(Content Delivery Network)是指内容分发网络，也称为内容传送网络，这个概念始于1996年，是美国麻省理工学院的一个研究小组为改善互联网的服务质量而提出的。为了能在传统IP网上发布丰富的宽带媒体内容，他们提出在现有互联网基础上建立一个内容分发平台专门为网站提供服务，并于1999年成立了专门的CDN服务公司，为Yahoo提供专业服务。由于CDN是为加快网络访问速度而被优化的网络覆盖层，因此被形象地称为“网络加速器”。 </p>
<p>2）jsDelivr是在中国大陆唯一有 license 的公有 CDN</p>
]]></content>
      <categories>
        <category>琐碎</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>picgo</tag>
        <tag>cdn</tag>
        <tag>jsdelivr</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu锐捷认证校园网并设置开机自启动</title>
    <url>/2022/04/03/2022-04-03-Ubuntu%E9%94%90%E6%8D%B7%E8%AE%A4%E8%AF%81%E6%A0%A1%E5%9B%AD%E7%BD%91%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h3 id="始、前言"><a href="#始、前言" class="headerlink" title="始、前言"></a>始、前言</h3><p>深度学习离不开Linux系统，装好系统第一时间必须得是联网，这里总结一下我成功联网并实现开机自启动的过程，感叹一下这个锐捷校园网也是够复杂的。</p>
<p>适用于台式机有线连接。</p>
<p>如果过程中提示缺了什么就安装什么，基础功能的安装一般都只要一个命令，可以百度一下。</p>
<span id="more"></span>

<hr>
<h3 id="一、下载校园网官网提供的锐捷安装包Linux版并联网"><a href="#一、下载校园网官网提供的锐捷安装包Linux版并联网" class="headerlink" title="一、下载校园网官网提供的锐捷安装包Linux版并联网"></a>一、下载校园网官网提供的锐捷安装包Linux版并联网</h3><p>下载解压后是一个名为rjsupplicant的文件，将它放到你的home文件夹下，比如我的路径是 /home/xiong/Mywork/Tool/rjsupplicant</p>
<p>我们只需要写一个脚本调用文件中的rjsupplicant.sh（也是一个脚本）。我在rjsupplicant同级的文件夹下打开终端（ctrl+alt+t），输入<code>touch rjzdrz.sh</code>，打开这个新建的脚本文件，可以在文件夹中双击，也可以继续在终端中输入<code>gedit rjzdrz.sh</code>。在脚本中编写如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">sudo /home/xiong/Mywork/Tool/rjsupplicant/rjsupplicant.sh -u 123456789 -p 123456789 -d 1 -a 1</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong></p>
<p><strong>1、sudo后面的路径要改成你放锐捷文件的路径</strong></p>
<p><strong>2、-u 后面是学号，-p 后面是密码，我都用123456789代替了</strong></p>
<p><strong>3、ubuntu中#表示注释，但这里的第一行不能省略</strong></p>
<p>给脚本添加可执行权限<code>chmod +x rjzdrz.sh</code>，<code>chmod +x rjsupplicant.sh</code></p>
<p>这样一来我们就用了一个脚本来调用锐捷的联网认证了，可能由于不同学校或者软件更新导致认证需要填入的参数不同，可以打开锐捷的说明文档来差看相应的规则，需要联网时只要调用这个脚本就行，打开终端输入<code>bash rjzdrz.sh</code>，成功上网</p>
<p>至此我们已经完成了：下载安装锐捷→编写脚本调用锐捷认证→调用脚本实现联网</p>
<hr>
<h3 id="二、图形方法实现开机自启动"><a href="#二、图形方法实现开机自启动" class="headerlink" title="二、图形方法实现开机自启动"></a>二、图形方法实现开机自启动</h3><p>现在我们需要设置开机自动认证联网，毕竟除了特殊情况外谁也不希望每次开机都要找到文件夹打开终端手动输入一次<code>bash rjzdrz.sh</code></p>
<p>在ubuntu中搜索启动应用程序，在弹出的窗口中添加额外的启动程序，在“命令”一行写入<code>gnome-terminal -x bash &quot;/home/xiong/Mywork/Tool/rjzdrz.sh&quot;</code>，同样是改成自己相应的脚本存放位置</p>
<p>由于我们执行sudo之类的命令时要输入密码，开机自启动脚本就会失效，所以要给脚本添加不需要密码的权限</p>
<p>终端中输入<code>sudo gedit /etc/sudoers</code>，在打开的文件中末尾添加一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xiong	All = NOPASSWD: /home/xiong/Mywork/Tool/rjsupplicant/rjsupplicant.sh</span><br></pre></td></tr></table></figure>

<p>这里xiong是我的用户名，请替换自己的用户名和锐捷文件存放路径。</p>
<p>重启电脑，开机自动弹出终端认证，自动联网</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题方法总结（链表基础）</title>
    <url>/2022/02/03/%E6%9B%B42022-02-03-%E7%AE%97%E6%B3%95%E9%A2%98%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="始、"><a href="#始、" class="headerlink" title="始、"></a>始、</h3>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>三维重建简述</title>
    <url>/2022/01/31/%E6%9B%B42022-01-31-%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<h3 id="始、前言"><a href="#始、前言" class="headerlink" title="始、前言"></a>始、前言</h3><span id="more"></span>

<hr>
<p><strong>基于RGB-D相机的三维重建”和传统的SFM和SLAM算法有什么区别？</strong></p>
<p><strong>首先，输入数据流不同</strong>。在基于RGB-D相机的三维重建中，输入有深度信息和彩色信息，并且深度信息起主导作用，而在SLAM和SFM算法中输入的是主要是彩色信息，个别工作也有结合深度信息。</p>
<p><strong>其次，侧重点不同</strong>。SLAM框架类算法中，<strong>定位还是主体</strong>。我们通常需要定位能实时响应，而稠密地图的构建通常规模和计算量都较大，因此地图的构建却不一定需要实时。当然，地图比较稀疏时，也能实时建图，但并不满足实际需求。另一种思路是<strong>以建图为主体</strong>，定位次之，旨在构建稠密准确的高质量地图，这种高质量地图可以提供给SLAM算法定位使用，而基于RGB-D相机的三维重建”便是满足上述需求的一种方法。</p>
<p>“基于RGB-D相机的三维重建”以及“基于深度相机的三维重建“和“基于fusion系列方法的三维重建”其实是三种等价的说法。由于该领域发表的大多数工作都在标题里带有“fusion”，业内也简称这些相关工作为“基于fusion系列方法”，所以本文中也使用“基于fusion系列方法”来描述<strong>。</strong></p>
<p>基于fusion系列的三维重建其实可以大体分为两种，一种是对于静态场景的三维重建，以KinectFusion为典型代表，一种是对于动态场景的三维重建，以<strong>DynamicFusion为典型代表</strong>。而不论是静态场景亦或是动态场景的fusion系列重建，最大特点就是使用了<strong>TSDF</strong>模型（截断符号距离函数模型），当然也有个别工作使用了<strong>面元</strong>（Surfel）的表示方法（面元简单来讲就是<strong>点，法线，颜色，权重，半径以及时间戳</strong>等属性的集合）。<strong>值得一提的是，基于动态场景的三维重建的难度远大于基于静态场景的三维重建</strong>，当然，对于拓扑不会发生变化的重建（比如驱动一个三维网格模板模型），难度会下降很多。</p>
<p>为了更好的理解fusion系列方法，这里在介绍下TSDF模型。TSDF全称是Truncated Signed Distance Function缩写，译为<strong>截断符号距离函数</strong>。通常我们先选定要建模的三维空间，比如2m×2m×2m那么大，然后将这个三维空间分割成许多小块，分辨率通常为256×256×256或是128×128×128，每一个小块被称为<strong>体素</strong>。</p>
<p><strong>TSDF模型中每个体素存储的是该小块与其最近的物体表面的距离。</strong>如果该小块在该物体表面的的前面，则它存储一个正值；如果该小块位于物体表面之后，那么就存储一个负值。进一步，通常认为物体表面是有厚度的，所以把值太大和值太小的都置为1或是-1，这样就得到了截断之后的距离，也就是所谓的TSDF模型。最后按照定义，<strong>TSDF为0的地方就是重建表面所在</strong>。换种说法就是TSDF数值由负数过渡到正数的地方。如下图中人脸就出现在TSDF值改变符号，即TSDF值为0的地方，如下图。</p>
<p><img data-src="https://pic4.zhimg.com/80/v2-9542f99293ed80f3a3f05d023eacd517_720w.jpg" alt="img"></p>
<p>再来说说Surfel，如下图。</p>
<p><img data-src="https://pic3.zhimg.com/80/v2-60b965826defb4d73fbe6d95535db1fa_720w.jpg" alt="img"></p>
<p>Surfel这种表示方法最早于2000年提出用于模型渲染，如下图所示，每一个Surfel可以理解成一个小面片，包含以下要素：</p>
<ul>
<li>空间点坐标，即面片位置；</li>
<li>空间法向量，即面片方向；</li>
<li>颜色；</li>
<li>权重，即根据当前点到相机的距离进行初始化，距离越远，权重越小</li>
<li>半径，即由当前表面到相机光心的距离决定，距离越大，半径越大</li>
<li>时间戳</li>
</ul>
<h2 id="基于静态场景的三维重建"><a href="#基于静态场景的三维重建" class="headerlink" title="基于静态场景的三维重建"></a><strong>基于静态场景的三维重建</strong></h2><p><strong>1.KinectFusion</strong></p>
<p>Newcombe的经典之作</p>
<p><img data-src="https://pic1.zhimg.com/80/v2-619cd97b69cf003f02cb3206f61cb700_720w.jpg" alt="img"></p>
<p><img data-src="https://pic3.zhimg.com/80/v2-b1617ed03da04f9156f0c1e2c8d328fa_720w.jpg" alt="img"></p>
<p>KinectFusion是Richard A. Newcombe的经典之作。该系统仅需要一个移动的低成本深度相机，便可以重建任意并且较为复杂的室内场景。其核心思想将Kinect传感器采集的深度数据流实时融入到（fusion into）一个当前场景对应的全局的隐式表面模型（TSDF模型）中，并使用一个由粗到精的迭代最近点（ICP）算法跟踪当前采集的深度帧数据与上文的全局的隐式表面模型之间的相对关系，从而获得Kinect传感器的位姿变化。</p>
<p>同时这个系统也有着不足之处，该系统只能重建小于7立方米的体空间。主要原因有两点：由于该系统采用稠密的体积表示方式，因此需要消耗大量内存；另外在重建较大建筑时不断累积的误差会造成“飘移”现象。以上两点原因使得Kinectfusion无法重建较大建筑。</p>
<p><strong>paper:</strong></p>
<p><a href="https://link.zhihu.com/?target=https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/ismar2011.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/ismar2011.pdfwww.microsoft.com/en-us/research/wp-content/uploads/2016/02/ismar2011.pdf</a></p>
<p><strong>code:</strong></p>
<p><a href="https://link.zhihu.com/?target=https://github.com/ParikaGoel/KinectFusion">https://github.com/ParikaGoel/KinectFusiongithub.com/ParikaGoel/KinectFusion</a></p>
<p><strong>demo:</strong></p>
<p><img data-src="https://pic3.zhimg.com/80/v2-1abad42abdcb3e69d249d10951a58bbe_720w.jpg" alt="img"></p>
<p><a href="https://www.zhihu.com/zvideo/1312756015705174016">KinectFusion668 播放 · 0 赞同视频<img data-src="https://pic2.zhimg.com/v2-79cd571b10b43eb22c2497f7a82ed7cb_r.jpg?source=2231c908" alt="点击可播放视频"></a></p>
<p><strong>2.Kintinuous</strong></p>
<p><img data-src="https://pic2.zhimg.com/80/v2-1cca3a2e5d0c4f945b0202b6ab55fd09_720w.jpg" alt="img"></p>
<p>上述 KinectFusion 算法使用固定体积的网格模型（如256<em>256</em>256）表示重建的三维场景，从而使得只能重建固定大小的场景；另外当重建体积较大，或者网格的空间分辨率较高时很消耗显存。而且 KinectFusion 算法没有回环检测和回环优化，这也造成当相机移动距离大时，不可避免的会有累积误差。这个算法是比较完善的三维重建系统，融合了回环检测和回环优化，还在实时三维刚体重建中使用了deformation graph做非刚体变换，根据回环优化的结果，更新点的坐标，使得回环的地方两次重建的可以对齐。该算法适合大场景的三维重建。</p>
<p><strong>paper:</strong></p>
<p><a href="https://link.zhihu.com/?target=http://www.thomaswhelan.ie/Whelan12rssw.pdf">http://www.thomaswhelan.ie/Whelan12rssw.pdfwww.thomaswhelan.ie/Whelan12rssw.pdf</a></p>
<p><strong>code：</strong></p>
<p><a href="https://link.zhihu.com/?target=https://github.com/mp3guy/Kintinuous">mp3guy/Kintinuousgithub.com/mp3guy/Kintinuous<img data-src="https://pic1.zhimg.com/v2-8a714b5587bbbbfd3be334777ee09184_ipico.jpg" alt="img"></a></p>
<p><strong>demo：</strong></p>
<p><img data-src="https://pic1.zhimg.com/80/v2-5465c1c5f0ac5d38cfe9c9c9ad742654_720w.jpg" alt="img"></p>
<p><a href="https://www.zhihu.com/zvideo/1312754191023460352">Kintinuous1662 播放 · 1 赞同视频<img data-src="https://pic2.zhimg.com/v2-f523cae44fe1e964cae9b1bda9983e78_r.jpg?source=2231c908" alt="点击可播放视频"></a></p>
<p><strong>3.ElasticFusion</strong></p>
<p><img data-src="https://pic3.zhimg.com/80/v2-abacf0e0bd9f2bacad0e7bc6f43ca34a_720w.png" alt="img"></p>
<p><img data-src="https://pic1.zhimg.com/80/v2-c47b89784256afde2a4578ec1f8d448c_720w.jpg" alt="img"></p>
<p>该算法的作者同时也是Kintinuous的作者，不同于Kintinuous的是，ElasticFusion使用了面元（Surfel）的表示方法，并且是用于小场景重建。该工作的主要贡献有两点：将许多“model-to-model”的<strong>局部闭环</strong>和较大规模的<strong>全局闭环</strong>结合在一起。因此可以保证重建地图的分布的尽可能相近，并且保证了重建结果的<strong>全局一致性</strong>；另外该算法对探测<strong>离散的多点光源环境</strong>比较高效，也能在该条件下获得较好的重建结果。</p>
<p>另外该算法也面临巨大的挑战，如何解决整个房间以外的<strong>地图可扩展性</strong>问题以及如何随着时间变化，保证重建地图的全局一致的稳定性。</p>
<p><strong>paper:</strong></p>
<p><a href="https://link.zhihu.com/?target=http://roboticsproceedings.org/rss11/p01.pdf">http://roboticsproceedings.org/rss11/p01.pdfroboticsproceedings.org/rss11/p01.pdf</a></p>
<p><a href="https://link.zhihu.com/?target=http://www.thomaswhelan.ie/Whelan16ijrr.pdf">http://www.thomaswhelan.ie/Whelan16ijrr.pdfwww.thomaswhelan.ie/Whelan16ijrr.pdf</a></p>
<p><strong>code:</strong></p>
<p><a href="https://link.zhihu.com/?target=https://github.com/mp3guy/ElasticFusion">mp3guy/ElasticFusiongithub.com/mp3guy/ElasticFusion<img data-src="https://pic1.zhimg.com/v2-8a714b5587bbbbfd3be334777ee09184_ipico.jpg" alt="img"></a></p>
<p><strong>demo:</strong></p>
<p><img data-src="https://pic3.zhimg.com/80/v2-b51c35810774995f3496fcf8c90a004e_720w.jpg" alt="img"></p>
<p><a href="https://www.zhihu.com/zvideo/1312758997905575936">ElasticFusion431 播放 · 0 赞同视频<img data-src="https://pic2.zhimg.com/v2-5041edda607db5009dd6e4ed5942ad60_r.jpg?source=2231c908" alt="点击可播放视频"></a></p>
<p><strong>4.ElasticReconstruction</strong></p>
<p><img data-src="https://pic3.zhimg.com/80/v2-773100250df48f58f670615e77f7f7e6_720w.jpg" alt="img"></p>
<p>该工作提供一种从RGB-D视频重建室内场景重建的方法，其核心思想在于将场景片段的几何配准和全局优化相结合。场景片段是通过将输入RGB-D视频流分割成若干帧为一组的场景片段得到的。这种以场景片段为单位进行深度信息的融合可以有效地去除深度图的噪声，从而获得更加准确的表面法向信息以及重建结果。</p>
<p><strong>paper:</strong></p>
<p><a href="https://link.zhihu.com/?target=http://vladlen.info/papers/indoor.pdf">http://vladlen.info/papers/indoor.pdfvladlen.info/papers/indoor.pdf</a></p>
<p><strong>code:</strong></p>
<p><a href="https://link.zhihu.com/?target=https://github.com/qianyizh/ElasticReconstruction">qianyizh/ElasticReconstructiongithub.com/qianyizh/ElasticReconstruction<img data-src="https://pic3.zhimg.com/v2-5fa7073e912e00a315244af54a571062_ipico.jpg" alt="img"></a></p>
<p><strong>demo:</strong></p>
<p><img data-src="https://pic1.zhimg.com/80/v2-26004796e70c577d97a562fa6e5adb3c_720w.jpg" alt="img"></p>
<p><strong>5.InfiniTAM</strong></p>
<p><img data-src="https://pic3.zhimg.com/80/v2-e0e69c760c335b9ee1f8ef58070734ae_720w.jpg" alt="img"></p>
<p>InfiniTAM是一个开源、跨平台、实时的大范围深度信息融合与跟踪技术框架。该算法有好几个版本，有很大的借鉴意义。值得一提的是，InfiniTAM能够比KinectFusion重建更加大范围的3D环境，其关键因素在于InfiniTAM采用了<strong>哈希表</strong>的方式来存储隐式的体积表示，极大地节省了内存空间的消耗。</p>
<p><strong>paper：</strong></p>
<p><a href="https://link.zhihu.com/?target=https://arxiv.org/abs/1708.00783">InfiniTAM v3: A Framework for Large-Scale 3D Reconstruction with Loop Closurearxiv.org/abs/1708.00783</a></p>
<p><strong>code:</strong></p>
<p><a href="https://link.zhihu.com/?target=https://github.com/victorprad/InfiniTAM">https://github.com/victorprad/InfiniTAMgithub.com/victorprad/InfiniTAM</a></p>
<p><strong>demo:</strong></p>
<p><a href="https://www.zhihu.com/zvideo/1312759319193030656">InfiniTAM1541 播放 · 0 赞同视频<img data-src="https://pic2.zhimg.com/v2-10854bf25ca385e8086852e53f2e3d7a_r.jpg?source=2231c908" alt="点击可播放视频"></a></p>
<p><strong>6.BundleFusion</strong></p>
<p><img data-src="https://pic1.zhimg.com/80/v2-96b0422e0f0ed576d1599186f414ee14_720w.jpg" alt="img"></p>
<p>Bundlefusion应该是目前静态场景重建效果最佳的方案了。该方法提出一个并行化的优化框架，充分利用了基于<strong>稀疏特征</strong>以及<strong>稠密几何</strong>和<strong>光度匹配</strong>提取的对应关系，实时地估计了BA优化的姿态，并具有从追踪失败中恢复（即<strong>重定位</strong>）的鲁棒追踪能力。</p>
<p><strong>paper：</strong></p>
<p><a href="https://link.zhihu.com/?target=https://arxiv.org/pdf/1604.01093.pdf">https://arxiv.org/pdf/1604.01093.pdfarxiv.org/pdf/1604.01093.pdf</a></p>
<p><strong>code:</strong></p>
<p><a href="https://link.zhihu.com/?target=https://github.com/niessner/BundleFusion">niessner/BundleFusiongithub.com/niessner/BundleFusion<img data-src="https://pic4.zhimg.com/v2-30d16c7a432c57530cf4b0066bcc0527_ipico.jpg" alt="img"></a></p>
<p><strong>demo:</strong></p>
<p><a href="https://link.zhihu.com/?target=https://www.youtube.com/watch?v=keIirXrRb1k&ab_channel=MatthiasNiessner">https://www.youtube.com/watch?v=keIirXrRb1k&amp;ab_channel=MatthiasNiessnerwww.youtube.com/watch?v=keIirXrRb1k&amp;ab_channel=MatthiasNiessner</a></p>
<p><img data-src="https://pic1.zhimg.com/80/v2-0d7c726ed2f74b84246d3f80b1050108_720w.jpg" alt="img"></p>
<p><a href="https://www.zhihu.com/zvideo/1312763867630620672">BundleFusion808 播放 · 0 赞同视频<img data-src="https://pic2.zhimg.com/v2-6b1d5d3464ba3e38bff89f2a3f1e44f2_r.jpg?source=2231c908" alt="点击可播放视频"></a></p>
<hr>
<h2 id="基于动态场景的三维重建"><a href="#基于动态场景的三维重建" class="headerlink" title="基于动态场景的三维重建"></a><strong>基于动态场景的三维重建</strong></h2><p><strong>1.DynamicFusion</strong></p>
<p><img data-src="https://pic2.zhimg.com/80/v2-8543226a82013230a17b61f5d8576f99_720w.jpg" alt="img"></p>
<p>DynamicFusion获得了2015年CVPR的<strong>Best Paper Award</strong>，其作者是Newcombe，和KinectFusion是一个作者。DynamicFusion是<strong>不基于任何模板先验信息</strong>的动态重建算法，可是说是<strong>实时动态重建</strong>的开山之作。DynamicFusion系统在重建场景的<strong>几何</strong>的同时也在估计稠密体积表示的<strong>6D形变域</strong>。类似KinectFusion，该系统能随着深度数据的采集，而获得一个<strong>逐渐去噪，保留细节并且较为完整</strong>的重建结果。</p>
<p>但同时由于DynamicFusion没有采用任何先验信息使得该算法对于帧间<strong>较大的运动</strong>以及<strong>遮挡区域的运动</strong>都不具备鲁棒性；此外DynamicFusion可以较好得处理封闭拓扑的表面重建，对于<strong>拓扑发生变化</strong>就无能为力了。例如我们嘴一开始闭着，后面再打开的情况就没法处理；另外由于追踪的累积误差，使得<strong>回环闭合失败</strong>。</p>
<p><strong>paper:</strong></p>
<p><a href="https://link.zhihu.com/?target=https://rse-lab.cs.washington.edu/papers/dynamic-fusion-cvpr-2015.pdf">https://rse-lab.cs.washington.edu/papers/dynamic-fusion-cvpr-2015.pdfrse-lab.cs.washington.edu/papers/dynamic-fusion-cvpr-2015.pdf</a></p>
<p><strong>demo:</strong></p>
<p><img data-src="https://pic4.zhimg.com/80/v2-cee4b5b21e97e1091a1c0510f41bd4e7_720w.jpg" alt="img"></p>
<p><a href="https://www.zhihu.com/zvideo/1312754544720715776">dynamicFusion1381 播放 · 4 赞同视频<img data-src="https://pic3.zhimg.com/v2-0a0a221397857409844c6097df0a6f12_r.jpg?source=2231c908" alt="点击可播放视频"></a></p>
<p><strong>2.volumeDeform</strong></p>
<p><img data-src="https://pic2.zhimg.com/80/v2-96c43c20ae8e4be5c9223019e892e149_720w.jpg" alt="img"></p>
<p>volumeDeform算法和dynamicFusion类似，都无需预先定义的模板，同样采用体积表示（volumetric representation）的方法来<strong>参数化重建模型的几何以及运动</strong>。该算法的运动追踪基于提取的<strong>全局稀疏彩色特征</strong>（如SIFT算子）以及<strong>稠密的深度</strong>图两者的结合，增强了特征匹配点寻找准确的鲁棒性，进而极大地减小了重建模型的累积误差以及漂移现象 。</p>
<p>该算法的不足之处在于尽管全局SITF特征算子的匹配提高了系统的鲁棒性，减小了对齐的误差，但<strong>漂移</strong>现象仍然不能完全消除；另外由于<strong>正则项</strong>的设置使得极度弯曲的物体的重建结果在运动上会显得平滑，变得不那么弯曲。</p>
<p><strong>paper:</strong></p>
<p><a href="https://link.zhihu.com/?target=https://graphics.stanford.edu/~niessner/papers/2016/5volumeDeform/innmann2016deform.pdf">https://graphics.stanford.edu/<del>niessner/papers/2016/5volumeDeform/innmann2016deform.pdfgraphics.stanford.edu/</del>niessner/papers/2016/5volumeDeform/innmann2016deform.pdf</a></p>
<p><strong>demo:</strong></p>
<p><a href="https://www.zhihu.com/zvideo/1312761662470922240">VolumeDeform930 播放 · 0 赞同视频<img data-src="https://pic1.zhimg.com/v2-03054fef6494f52d0685ea48be02ecb7_r.jpg?source=2231c908" alt="点击可播放视频"></a></p>
<p><strong>3.BodyFusion</strong></p>
<p><img data-src="https://pic4.zhimg.com/80/v2-6412cb80de82beacc35ace75d0a8722f_720w.jpg" alt="img"></p>
<p>从BodyFusion开始就变得更有意思了。BodyFusion使用<strong>人体骨架</strong>作为先验信息，实现鲁棒了的人体动态重建。人体骨架的引入减少了重建表面图节点的<strong>非刚性形变参数化的歧义性</strong>，也是在一定程度上缩小了解空间。</p>
<p>不足之处在于所使用的人体骨骼所包含的<strong>关节点太过稀疏</strong>，并且运动较快时，会在深度图上出现<strong>运动模糊</strong>的情况，从而造成重建方法受限。</p>
<p><strong>paper:</strong></p>
<p><a href="https://link.zhihu.com/?target=http://www.liuyebin.com/bodyfusion/bodyfusion_files/BdyFu_ICCV17.pdf">http://www.liuyebin.com/bodyfusion/bodyfusion_files/BdyFu_ICCV17.pdfwww.liuyebin.com/bodyfusion/bodyfusion_files/BdyFu_ICCV17.pdf</a></p>
<p><strong>demo:</strong></p>
<p><a href="https://www.zhihu.com/zvideo/1312763630241042432">BodyFusion994 播放 · 5 赞同视频<img data-src="https://pic2.zhimg.com/v2-073bb2cb52b044ab4c5958668338acf1_r.jpg?source=2231c908" alt="点击可播放视频"></a></p>
<p><strong>4.DoubleFusion</strong></p>
<p><img data-src="https://pic4.zhimg.com/80/v2-b40ee37a1fc167b2ab129dcbbfef453b_720w.jpg" alt="img"></p>
<p>DoubleFusion非常惊艳，该系统将<strong>数字驱动的模板</strong>（SMPL模型）以及实时重建的稠密<strong>几何</strong>、<strong>非刚性运动</strong>以及<strong>内层人体形状</strong>充分结合在一起。该系统的关键贡献之一在于提出了<strong>双层表面</strong>的表示，这里的两层主要是指里层的<strong>参数化模型表面</strong>（inner body），也就是SMPL模型的shape，以及外层通过<strong>深度融合得到的表面</strong>（outer surface）。该算法的另一个关键贡献在于提出了一个基于双层表面表示的<strong>联合运动追踪</strong>，使得整个系统可以在快速运动的情况下仍然具有鲁棒性。</p>
<p>不足之处在于当用户穿着比较肥大的时候，估计的人体也偏胖;并且无法处理外层表面发生分离的情况，以及无法处理<strong>人和物体交互</strong>的情况。</p>
<p><strong>paper:</strong></p>
<p><a href="https://link.zhihu.com/?target=http://www.liuyebin.com/doublefusion/doublefusion_files/doublefusion.pdf">http://www.liuyebin.com/doublefusion/doublefusion_files/doublefusion.pdfwww.liuyebin.com/doublefusion/doublefusion_files/doublefusion.pdf</a></p>
<p><strong>demo:</strong></p>
<p><img data-src="https://pic3.zhimg.com/80/v2-c427780b5e638801891de34e861eb4f6_720w.jpg" alt="img"></p>
<p><a href="https://www.zhihu.com/zvideo/1312763353522077696">DoubleFusion1156 播放 · 3 赞同视频<img data-src="https://pic2.zhimg.com/v2-be4fb906c3c64e6704ddac03253f35e2_r.jpg?source=2231c908" alt="点击可播放视频"></a></p>
<p><strong>5.UnstructuredFusion</strong></p>
<p><img data-src="https://pic1.zhimg.com/80/v2-d5166bcbed84e2ef62c988c511d7301c_720w.jpg" alt="img"></p>
<p>通常多相机系统需要一些特殊设计的相机以及预先精细的相机标定操作，但UnstructuredFusion算法可以使用<strong>未经预先标定以及同步</strong>的三个深度相机以一种互补并灵活的方式覆盖整个人体，从而实现实时，高质量，完整的动态人体重建。</p>
<p>该算法也有不足之处。由于输入深度图分辨率受限，该算法无法重建目标非常细小的部分，比如人的脸部区域；该算法也无法处理<strong>网格拓扑分离</strong>的情况；该算法也无法处理人-物交互情况。</p>
<p><strong>paper:</strong></p>
<p><a href="https://link.zhihu.com/?target=https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8708933&tag=1">UnstructuredFusion: Realtime 4D Geometry and Texture Reconstruction Using Commercial RGBD Camerasieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=8708933&amp;tag=1</a></p>
<p><strong>demo:</strong></p>
<p><img data-src="https://pic4.zhimg.com/80/v2-e82be7fc57bc0b7b7780249a85c37413_720w.jpg" alt="img"></p>
<p><a href="https://www.zhihu.com/zvideo/1312762042022281216">UnstructuredFusion746 播放 · 1 赞同视频<img data-src="https://pic1.zhimg.com/v2-91e5e42f4199d02ac5d3f0c2b9d9c419_r.jpg?source=2231c908" alt="点击可播放视频"></a></p>
<p><strong>6.RobustFusion</strong></p>
<p><img data-src="https://pic1.zhimg.com/80/v2-e93307eb56f5a80b3af86e60ca7b1d70_720w.jpg" alt="img"></p>
<p>诚如算法名字所示，该算法使用了各种数据驱动的视觉线索提高动态重建算法的鲁棒性。</p>
<p><img data-src="https://pic3.zhimg.com/80/v2-c5e2de7641b09a40a642ebc5c6cbd676_720w.jpg" alt="img"></p>
<p>诚如算法名字RobustFusion所示，该算法使用了各种<strong>数据驱动的视觉线索</strong>提高动态重建算法的鲁棒性。这些数据驱动的视觉线索具体包括Occupancy Network，Pose&amp;Shape Network以及Semantic Network。 该算法充分利用了上述数据驱动的视觉线索，避免了预先扫描模板的使用，具备了重新初始化的能力，使得该系统能够处理极具挑战性的运动和几何的重建。</p>
<p>该系统的不足之处有：该系统无法实时运行；不能处理重建<strong>网格拓扑发生分离</strong>的情况，比如脱掉衣服；不能实现<strong>人和物的交互</strong>；当一些极端运动姿态在上述网络训练时没有出现过，那上述数据驱动的视觉线索就不能很好地提供先验信息。</p>
<p><strong>paper:</strong></p>
<p><a href="https://link.zhihu.com/?target=https://www.ecva.net/papers/eccv_2020/papers_ECCV/papers/123490239.pdf">https://www.ecva.net/papers/eccv_2020/papers_ECCV/papers/123490239.pdfwww.ecva.net/papers/eccv_2020/papers_ECCV/papers/123490239.pdf</a></p>
<p><strong>demo:</strong></p>
<p><a href="https://www.zhihu.com/zvideo/1312762970301034496">RobustFusion1123 播放 · 1 赞同视频<img data-src="https://pic1.zhimg.com/v2-caa8bba14205b491d96b6ea428a56519_r.jpg?source=2231c908" alt="点击可播放视频"></a></p>
<p><strong>7.KillingFusion</strong></p>
<p><img data-src="https://pic3.zhimg.com/80/v2-70af628ca0bb461bcaa80195a46e4802_720w.jpg" alt="img"></p>
<p>KillFusion是基于Killing Vector Fields提出的实时三维重建方法，也是不需要任何预先扫描的模板信息以或是形状先验。KillingFusion<strong>不需要显式地进行对应匹配点的搜索</strong>，当给定感兴趣区域的一对SDF（signed distance fields）,该算法可以估计出一个稠密形变域来对齐给定的SDF。具体的，该算法定义一个和SDF相同分辨率的位移向量域（displacement vector field）,并通过最优化迭代求解。</p>
<p>该算法的不足之处也是由于其优点造成，<strong>不显式地寻找对应点也使得该算法在某些需要显式的对应点的操作上无法应用</strong>，比如<strong>纹理映射</strong>就需要显式的对应点。</p>
<p><strong>paper:</strong></p>
<p><a href="https://link.zhihu.com/?target=http://campar.in.tum.de/pub/slavcheva2017cvpr/slavcheva2017cvpr.pdf">http://campar.in.tum.de/pub/slavcheva2017cvpr/slavcheva2017cvpr.pdfcampar.in.tum.de/pub/slavcheva2017cvpr/slavcheva2017cvpr.pdf</a></p>
<p><strong>demo:</strong></p>
<p><img data-src="https://pic3.zhimg.com/80/v2-8413ee52a1a7eb690d1443eee43603e2_720w.jpg" alt="img"></p>
<p><a href="https://www.zhihu.com/zvideo/1312760841906405376">KillingFusion353 播放 · 1 赞同视频<img data-src="https://pic1.zhimg.com/v2-6b2c2a78879c7e1aadb6d8cb64f66ed5_r.jpg?source=2231c908" alt="点击可播放视频"></a></p>
<p><strong>8.SurfelWarp</strong></p>
<p><img data-src="https://pic2.zhimg.com/80/v2-1595f8e62c848bbbea2ae884a3e0ea7d_720w.jpg" alt="img"></p>
<p>SurfelWarp是三维动态重建方案中为数不多的基于面元的算法。类似的，该算法输入一个深度图序列，对非刚性场景进行实时重建，无需任何模板或是先验信息。与现有的方法相比，该算法<strong>无需维持体积数据结构</strong>，比如TSDF模型，该系统采用面元（surfel）的几何表示，极大地增强了拓扑发生改变时的追踪能力，从而获得一致的重建结果。</p>
<p>该算法的不足之处在于，模型重初始化可以极大地提高系统的鲁棒性，然而清除错误的面元会<strong>破坏模型的完整性</strong>。</p>
<p><strong>paper:</strong></p>
<p><a href="https://link.zhihu.com/?target=https://arxiv.org/pdf/1904.13073.pdf">https://arxiv.org/pdf/1904.13073.pdfarxiv.org/pdf/1904.13073.pdf</a></p>
<p><strong>code:</strong></p>
<p><a href="https://link.zhihu.com/?target=https://github.com/weigao95/surfelwarp">https://github.com/weigao95/surfelwarpgithub.com/weigao95/surfelwarp</a></p>
<p><strong>demo:</strong></p>
<p><a href="https://www.zhihu.com/zvideo/1312762272759042048">SurfelWarp1306 播放 · 0 赞同视频<img data-src="https://pic2.zhimg.com/v2-2fb8f03e5c62cf5cac8327abf46c843e_r.jpg?source=2231c908" alt="点击可播放视频"></a></p>
<p><strong>9.Fusion4D</strong></p>
<p><img data-src="https://pic3.zhimg.com/80/v2-74f7fb911749c57d9e2d64ba8e8e3dea_720w.jpg" alt="img"></p>
<p>Fusion4D的重建结果也非常惊艳。该算法是基于<strong>多视角</strong>方案，没有使用任何先验信息，因此理论上可以重建任何场景或是物体。如视频所示，除了对人体动态重建，还能对狗子动态重建。该算法很重要的一点贡献是引入了<strong>key volume</strong>,因此对于<strong>较大的帧间运动</strong>以及<strong>网格拓扑发生改变</strong>时都有很强的鲁棒性；另外Fusion4D还引入了<strong>体素碰撞检测</strong>，从而得到正确的TSDF模型。</p>
<p>该系统不足之处在于当RGBD输入流<strong>帧率过低或者帧间运动过大</strong>时，会使帧间对应匹配点估计不准确，造成非刚性对齐过程无法收敛。</p>
<p><strong>paper：</strong></p>
<p><a href="https://link.zhihu.com/?target=https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/a114-dou.pdf">https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/a114-dou.pdfwww.microsoft.com/en-us/research/wp-content/uploads/2016/11/a114-dou.pdf</a></p>
<p><strong>demo:</strong></p>
<p><a href="https://www.zhihu.com/zvideo/1312762543794958336">Fusion4D818 播放 · 2 赞同视频<img data-src="https://pic3.zhimg.com/v2-6ed4e9c6f1cca6799f2719f304e160df_r.jpg?source=2231c908" alt="点击可播放视频"></a></p>
<p><img data-src="https://pic2.zhimg.com/80/v2-9d4606f115f51721fe32e73d70bc23cd_720w.jpg" alt="img"></p>
<p><img data-src="https://pic1.zhimg.com/80/v2-290390c2892e260a838f32ca8bf6e9f8_720w.jpg" alt="img"></p>
<h2 id="总结不易，喜欢的话就点个赞呗～"><a href="#总结不易，喜欢的话就点个赞呗～" class="headerlink" title="总结不易，喜欢的话就点个赞呗～"></a><strong>总结不易，喜欢的话就点个赞呗～</strong></h2>]]></content>
      <categories>
        <category>琐碎</category>
      </categories>
      <tags>
        <tag>三维点云</tag>
        <tag>3d</tag>
        <tag>kinect</tag>
        <tag>三维重建</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题方法总结（数组基础）</title>
    <url>/2022/01/21/2022-01-21-%E7%AE%97%E6%B3%95%E9%A2%98%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="始、前言"><a href="#始、前言" class="headerlink" title="始、前言"></a>始、前言</h3><p>有时候碰到一些以前做过的算法题，还是会忘记经典解法。</p>
<p>是不是在记录题目的同时，也应该记录一下不同的解法呢？</p>
<span id="more"></span>

<hr>
<h3 id="一、二分查找"><a href="#一、二分查找" class="headerlink" title="一、二分查找"></a>一、二分查找</h3><p>场景：遍历有序数组</p>
<p>效果：使时间复杂度O(n)的遍历操作降低为O(logn)</p>
<p>注意“循环不变量”规则，是左闭右闭<code>[left,  right]</code>还是左闭右开<code>[left, right)</code>，每一轮循环结束都要处理好边界，循环的判断条件也需要对应调整。</p>
<p>求<code>mid</code>时为了防止计算过程中的数值溢出，要使用<code>mid = left + (right - left) / 2</code>而不是<del><code>mid = (left + right) / 2</code></del></p>
<h3 id="二、双指针法（快慢指针法）"><a href="#二、双指针法（快慢指针法）" class="headerlink" title="二、双指针法（快慢指针法）"></a>二、双指针法（快慢指针法）</h3><p>场景：双层循环</p>
<p>效果：一个循环内完成两个循环的工作，使时间复杂度O(n2)的遍历操作降低为O(n)</p>
<p>注意指针在不同情况下的不同跳转位置，以及两个指针之间的差异</p>
<h3 id="三、滑动窗口"><a href="#三、滑动窗口" class="headerlink" title="三、滑动窗口"></a>三、滑动窗口</h3><p>场景：双层循环</p>
<p>效果：不断调节窗口的起始位置和终止位置，使时间复杂度O(n2)的遍历操作降低为O(n)</p>
<p>滑动窗口也可以理解为双指针法的一种，但是需要指针之间的数据，所以称之为窗口。</p>
<p>重点是找到移动窗口起始位置和终止位置的条件</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>《Computational Methods of Acquisition and Processing of 3D Point Cloud Data for Construction Applications》阅读笔记</title>
    <url>/2021/10/30/2021-10-30-%E3%80%8AComputational%20Methods%20of%20Acquisition%20and%20Processing%20of%203D%20Point%20Cloud%20Data%20for%20Construction%20Applications%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="一、信息"><a href="#一、信息" class="headerlink" title="一、信息"></a>一、信息</h3><p>Qian Wang1 · Yi Tan2,3  · Zhongya Mei4<br>Received: 12 August 2018 / Accepted: 18 February 2019<br>© CIMNE, Barcelona, Spain 2019</p>
<p>Archives of Computational Methods in Engineering </p>
<p><a href="https://doi.org/10.1007/s11831-019-09320-4">https://doi.org/10.1007/s11831-019-09320-4</a></p>
<span id="more"></span>

<hr>
<h3 id="二、点云数据采集方法"><a href="#二、点云数据采集方法" class="headerlink" title="二、点云数据采集方法"></a>二、点云数据采集方法</h3><p>1.<strong>3D激光扫描</strong>：</p>
<p>激光扫描仪通过发射激光束来测量与目标的距离并从目标中检测反射信号。主要有两种不同的测量方法，飞行时间技术和相移技术。</p>
<p>飞行时间技术：使用飞行时间技术的扫描仪发射激光脉冲并测量反射脉冲的行 进时间t。由于激光的速度是已知的，因此可以从行进时间推断距离测量T。</p>
<p>相移技术：使用相移技术的扫描仪发出幅度调制的连续波（AMCW）并测量发射和反射信号之间的相移。可以基于相位获得距离测量转换和调制连续波的波长。</p>
<p>使用相移原理的扫描仪比使用飞行时间技术的扫描仪的测距精度和测量速度更高 ，使用飞行时间技术的扫描仪有更大的测量范围。</p>
<p>2.<strong>摄影测量</strong>：</p>
<p>摄影测量定义为获得有关物理对象和环境的可靠信息的艺术、科学和技术，是一种通过记录、测量和解释摄影图像和记录的辐射图案、电磁能量和其他现象的过程。</p>
<p>这些图像仅使用来自不同位置的相机拍摄，从而捕获目标对象的不同部分。然后，算法将估计这些图像的相对位置，并最终将这些图像转换为3D点云。</p>
<p>3.<strong>视频测量</strong>：</p>
<p>类似于摄影测量，但将视频流作为输入数据而不是图像集合。视频测量可以使点云数据逐步重建，因为视频帧是连续的并且信息都建立在前一帧的基础上。</p>
<p>视频测量对比摄影测量的一个优点是重建过程中较少的人工干预，因为可以通过测量或跟踪连续的视频帧之间的有趣特征来实现不同图像中的目标点的搜索。</p>
<p>4.<strong>RGB-D相机</strong>：</p>
<p>由RGB相机和深度传感器组成，RGB相机采用RGB图像，深度传感器以每像素为基础找到深度信息。最终，通过用深度信息映射RGB图像来生成彩色点云（包含XYZ坐标和RGB颜色）。</p>
<p>5.<strong>立体相机</strong>：</p>
<p>立体相机是一种相机系统，具有两个或多个具有单独图像传感器的镜头。由于一个镜头相对于另一个镜头的相对位置和方向已知，因此可以基于所获取的2D图像获得3D点云数据。</p>
<hr>
<h3 id="三、点云数据处理过程"><a href="#三、点云数据处理过程" class="headerlink" title="三、点云数据处理过程"></a>三、点云数据处理过程</h3><p>1.<strong>数据清洗</strong>：</p>
<p>由于实际施工现场环境的复杂性，所获取的点云数据始终包含各种类型的噪声数据，这对于预期目的而言是无用的。此外，由于特定传感器的局限性，也发生各种类型的错误数据。因此，需要用于滤除噪声的算法来滤除无用数据并仅保留感兴趣的数据。</p>
<p>混合像素：一种错误的激光扫描点，它发生在激光束正好落在物体边缘并一分为二的时候。激光束的两个部分落在两个不同的物体上，产生两种不同的反射激光信号。最后，激光扫描仪接收到两个反射信号并产生混合像素。</p>
<p>传感器环绕噪声：激光扫描数据中另一种类型的噪声数据，当距离扫描仪到目标对象的实际距离超过激光扫描仪的非模糊距离时发生。</p>
<p>幽灵几何：在激光扫描数据中捕获人或设备是不可避免的，这种移动物体只出现在一些扫描中， 并导致多次扫描数据不一致。</p>
<p>2.<strong>数据配准</strong>：</p>
<p>对准从公共坐标系中的不同位置收集的多个点云。由于大尺寸对象和遮挡物体，始终需要在不同位置进行数据采集（特别是激光扫描）以捕获目标对象的不同部分。在共享坐标系中对齐这些点云的过程称为数据配准，数据配准可以分为粗配准和精细配准。</p>
<p>粗配准：包括点描述符定义，关键点检测，粗配准。首先定义点描述符描述每个点，突出重要特征，然后从点云检测关键点，原始点云减少到稀疏的关键点集。最后，通过两个点云重叠区域上检测到的关键点提取变换矩阵并配准两个点云。</p>
<p>精细配准：最常用的方法是迭代最接近点（ICP）算法。</p>
<p>3.<strong>数据分割</strong>：</p>
<p>将点云数据分段为多个有意义的段或群集。这些段可以代表不同的对象或者代表可以促进点云数据的进一步处理的不同几何基元。所有方法都分为六个类别，包括基于聚类、基于边缘、基于区域、基于图形、基于模型拟合、混合的。</p>
<p><strong>基于聚类</strong>：根据点的某些特征使用聚类算法进行分段点云数据。</p>
<p><strong>基于边缘</strong>：基于边缘的分割算法检测3D点云数据中区域的边界以获得分段区域。</p>
<p><strong>基于区域</strong>：通常从一个或多个种子点开始一个区域 ，然后迭代地生长区域以包括根据某些标准的相邻点。但也存在一些不需要种子点的方法。这种类别的方法称为未特性区域分割方法。</p>
<p><strong>基于图形</strong>：在图形模型中，每个顶点对应于点云数据中的点，而图形的边缘用于连接相邻点。</p>
<p><strong>基于模型拟合的分段方法</strong>：基于模型拟合的分段方法起源于人造物体通常可以分解成简单的几何基元，例如平面、球形、圆柱体和其他基元。因此 ，原始形状装配到点云数据中，具有相同数学表示的点被标记为一个段。在现有的基于模型拟合的分段方法中，Hough 变换（HT）和随机样本共识（RANSAC）方法是最广泛的采用。</p>
<p><strong>混合</strong>：在混合技术中，组合两个或多于两种方法以从点云数据中检测。</p>
<p><strong>优缺点</strong>：</p>
<p>基于聚类：优点：易于理解和实现。缺点：准确性问题，对数据中的噪声敏感，受邻域定义的影响。</p>
<p>基于边缘：优点：快速分割。缺点：精度问题，对噪声敏感，对不均匀密度的点云敏感。</p>
<p>基于区域：优点：处理噪音更准确。缺点：在分割和确定区域边界的准确性上有问题。</p>
<p>基于图形：优点：处理不均匀密度或噪音复杂点云数据有更好的性能。缺点：无法实时处理，并且需要培训或其他系统来协助。</p>
<p>基于模型拟合的分段方法：</p>
<p>1.Hough变换（HT）：优点：快速且稳健地对抗异常值。缺点：较慢，对分段参数更敏感；</p>
<p>2.随机样本共识（RANSAC）：优点：快速且稳健地对抗异常值，能够在合理短的时间段内处理大量点云数据。缺点：在处理不同点云源时的数据准确性。</p>
<p>混合：优点：多种方法的优点使结果更准确。缺点：包含所选方法的所有缺点</p>
<p>4.<strong>对象识别</strong>：</p>
<p>识别点云数据中的某些对象。例如，要从点云数据中创建语义丰富的建筑物，建筑元素，如墙壁，窗口和门，必须从点云数据中识别。</p>
<p><strong>几何形状描述符</strong>：不同的对象实例或对象类通常具有不同的几何形状。因此，几何形状描述符描述了基于某些几何特征的对象形状，通常用于识别某个对象实例或对象类。通常以三个步骤执行：离线库生成，在线搜索，最终验证。</p>
<p><strong>硬编码知识</strong>：对于墙壁、屋顶和地板等主要建筑部件，它们通常具有不同的几何特性，使用硬编码知识将这些段分类为对象类法是一种简单有效的识别算法。但是，它仅适用于在硬编码知识中定义的约束情况，难以将该方法扩展到具有更复杂几何形状的其他物体类别。</p>
<p><strong>监督学习</strong>：使用机器学习算法来训练可以将点云数据分类为对象类的分类器。基于学习的物体识别有两种策略，基于点的分类，每个点使用点的本地特征分别分类为对象类。对于基于段的分类，点云数据通常使用数据分段算法划分为有意义的段，并且每个数据段都使用每个段的特征分类为对象类。</p>
<p><strong>BIM‑vs‑Scan</strong>：当整个结构建筑信息模型（Building Information Modeling）可用时，普遍采用更简单的基于BIM‑vs‑Scan的对象识别方法。</p>
<hr>
<h3 id="四、参考文献（前20）"><a href="#四、参考文献（前20）" class="headerlink" title="四、参考文献（前20）"></a>四、参考文献（前20）</h3><p>1.Bradley C, Vickers G, Milroy M (1994) Reverse engineering of  quadric surfaces employing threedimensional laser scanning.  Proc Inst Mech Eng Part B J Eng Manuf 208(1):21–28</p>
<p>2.Son S, Park H, Lee KH (2002) Automated laser scanning system for reverse engineering and inspection. Int J Mach Tools  Manuf 42(8):889–897</p>
<p>3.Varady T, Martin RR, Cox J (1997) Reverse engineering  of geometric models—an introduction. Comput Aided Des  29(4):255–268</p>
<p>4.Yu X, Hyyppä J, Kaartinen H, Maltamo M (2004) Automatic detection of harvested trees and determination of forest  growth using airborne laser scanning. Remote Sens Environ  90(4):451–462</p>
<p>5.Gaveau DL, Hill RA (2003) Quantifying canopy height underestimation by laser pulse penetration in small-footprint airborne laser scanning data. Can J Remote Sens 29(5):650–657</p>
<p>6.Hollaus M, Wagner W, Maier B, Schadauer K (2007) Airborne  laser scanning of forest stem volume in a mountainous environment. Sensors 7(8):1559–1577</p>
<p>7.Rosser N, Petley D, Lim M, Dunning S, Allison R (2005) Terrestrial laser scanning for monitoring the process of hard rock  coastal clif erosion. Q J Eng Geol Hydrogeol 38(4):363–375</p>
<p>8.Heritage GL, Milan DJ (2009) Terrestrial laser scanning  of grain roughness in a gravel-bed river. Geomorphology  113(1–2):4–11</p>
<p>9.Liu X (2008) Airborne LiDAR for DEM generation: some critical issues. Prog Phys Geogr 32(1):31–49</p>
<p>10.Fröhlich C, Mettenleiter M (2004) Terrestrial laser scanning— new perspectives in 3D surveying. Int Arch Photogramm  Remote Sens Spat Inf Sci 36(Part 8):W2</p>
<p>11.Olsen MJ, Kuester F, Chang BJ, Hutchinson TC (2009) Terrestrial laser scanning-based structural damage assessment. J  Comput Civ Eng 24(3):264–272</p>
<p>12.Zhang C, Arditi D (2013) Automated progress control using  laser scanning technology. Autom Constr 36:108–116</p>
<p>13.Leite F, Cho Y, Behzadan AH, Lee S, Choe S, Fang Y, Akhavian R, Hwang S (2016) Visualization, information modeling,  and simulation: grand challenges in the construction industry.  J Comput Civ Eng 30(6):04016035</p>
<p>14.Kwon S, Lee M, Lee M, Lee S, Lee J (2013) Development of  optimized point cloud merging algorithms for accurate processing to create earthwork site models. Autom Constr 35:618–624</p>
<p>15.Bosche F, Haas CT, Akinci B (2009) Automated recognition  of 3D CAD objects in site laser scans for project 3D status  visualization and performance control. J Comput Civ Eng  23(6):311–318</p>
<p>16.Wang C, Cho YK (2015) Smart scanning and near real-time  3D surface modeling of dynamic construction equipment from  a point cloud. Autom Constr 49:239–249</p>
<p>17.Tang P, Huber D, Akinci B, Lipman R, Lytle A (2010) Automatic reconstruction of as-built building information models  from laser-scanned point clouds: a review of related techniques. Autom Constr 19(7):829–843</p>
<p>18.Wang Q, Kim M-K, Cheng JC, Sohn H (2016) Automated quality  assessment of precast concrete elements with geometry irregularities using terrestrial laser scanning. Autom Constr 68:170–182</p>
<p>19.Volk R, Stengel J, Schultmann F (2014) Building information  modeling (BIM) for existing buildings—literature review and  future needs. Autom Constr 38:109–127</p>
<p>20.Kim M-K, Cheng JC, Sohn H, Chang C-C (2015) A framework for dimensional and surface quality assessment of precast  concrete elements using BIM and 3D laser scanning. Autom  Constr 49:225-238</p>
]]></content>
      <categories>
        <category>阅读笔记</category>
      </categories>
      <tags>
        <tag>三维点云</tag>
      </tags>
  </entry>
  <entry>
    <title>八爪鱼零编程爬虫入门</title>
    <url>/2021/10/16/2021-10-16-%E5%85%AB%E7%88%AA%E9%B1%BC%E9%9B%B6%E7%BC%96%E7%A8%8B%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="始、前言"><a href="#始、前言" class="headerlink" title="始、前言"></a>始、前言</h3><p>“还在捣鼓python爬虫？不如先来试试零编程爬虫”</p>
<p>最近需要爬很多很多数据集，尝试了一下python爬虫，出现很多奇奇怪怪的问题，还是先来学习下八爪鱼无编程爬虫怎么用吧</p>
<p>这次的任务是<strong>在百度搜索中获取“鸡”的图片</strong></p>
<span id="more"></span>

<hr>
<h3 id="一、图片链接采集"><a href="#一、图片链接采集" class="headerlink" title="一、图片链接采集"></a>一、图片链接采集</h3><p>1.在首页【输入框】中输入目标网址  <code>https://image.baidu.com/search/index?tn=baiduimage&amp;ipn=r&amp;ct=201326592&amp;cl=2&amp;lm=-1&amp;st=-1&amp;fm=result&amp;fr=&amp;sf=1&amp;fmq=1586763732362_R&amp;pv=&amp;ic=&amp;nc=1&amp;z=&amp;hd=&amp;latest=&amp;copyright=&amp;se=1&amp;showtab=0&amp;fb=0&amp;width=&amp;height=&amp;face=0&amp;istype=2&amp;ie=utf-8&amp;sid=&amp;word=鸡</code>，点击【开始采集】，八爪鱼自动打开网页。（打开网页后，如果开始【自动识别】，请点击【不再自动识别】或【取消识别】将其关掉。）</p>
<p>2.添加一个【循环】，进入【循环】设置页面。选择循环方式为【文本列表】，点击编辑按钮，将我们准备好的关键字输进去后保存。（可同时输入多个关键字，一行一个即可，如“公鸡”、“母鸡”、“小鸡”，可根据自身需求进行替换）</p>
<p>3.选中页面中的搜索框，在黄色操作提示框中，选择【输入文本】后点击【确定】，将【输入文本】步骤拖入【循环】中。<strong>然后进入【输入文本】设置页面，勾选【使用当前循环里的文本来填充输入框】后保存。</strong></p>
<p>4.在【循环】中选择一个关键词，再点击【输入文本】，可以看到，关键词成功输入进网页的文本框中。然后选中【百度一下】按钮，在操作提示框中点击【点击该按钮】，出现关键词的搜索结果列表页。</p>
<p>5.向下滚动页面，会加载出新的图片列表，在八爪鱼中也需设置滚动，进入【点击元素】设置页面，点开【页面加载后】，设置【页面加载后向下滚动】，滚动方式为【滚动到底部】，【滚动次数】为10次，【每次间隔】1秒 ，设置后保存。</p>
<p>同时也可以设置 【Ajax超时】10秒 和【执行前等待】3 秒，以便采集更全数据。</p>
<p>6.创建【循环列表】，采集所有图片地址：</p>
<p>① 选中页面上1个图片列表</p>
<p>② 在黄色操作提示框中，点击【选中全部】</p>
<p>③ 点击【采集以下图片地址】</p>
<p>7.自动生成的【循环列表】定位<code>XPath</code>，默认只定位到前21个图片。我们需要修改一下，使其定位到所有的图片。进入【循环列表】设置界面，修改<code>XPath</code>为：**<code>//div[@class=&quot;imgpage&quot;]/ul/li</code>** 后保存。</p>
<p>8.八爪鱼自动为我们提取了列表中的所有字段。但是有些字段没提取到，比如关键词的文本。我们可以手动提取。选中页面的输入框，在操作提示框中选择【采集文本框的值】，将输入的关键词文本采集下来。</p>
<p>9.在【当前页面数据预览】页面，可删除多余字段，修改字段名，移动字段顺序等。</p>
<p>10.单击【采集】并【启动本地采集】。启动后八爪鱼开始自动采集数据。采集完成后，选择合适的导出方式导出数据。支持导出为Excel、CSV、HTML、数据库等。这里导出为Excel。</p>
<p>经过如上操作，我们已经得到了要采集的图片的URL。</p>
<p>接下来，可通过八爪鱼提供的图片批量下载工具，将采集到的图片URL中的图片，下载并保存到本地电脑中。</p>
<hr>
<h3 id="二、图片保存及处理"><a href="#二、图片保存及处理" class="headerlink" title="二、图片保存及处理"></a>二、图片保存及处理</h3><p>1.下载八爪鱼图片批量下载工具：**[<a href="https://pan.baidu.com/s/1c2n60NI]**%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E5%8F%8C%E5%87%BB%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%60MyDownloader.app.exe%60%EF%BC%8C%E6%89%93%E5%BC%80%E8%BD%AF%E4%BB%B6%EF%BC%8C%E7%82%B9%E5%87%BB%E3%80%90File%E3%80%91%EF%BC%8C%E9%80%89%E6%8B%A9%E4%BB%8EEXCEL%E5%AF%BC%E5%85%A5%EF%BC%88%E7%9B%AE%E5%89%8D%E5%8F%AA%E6%94%AF%E6%8C%81EXCEL%E6%A0%BC%E5%BC%8F%E6%96%87%E4%BB%B6%EF%BC%89">https://pan.baidu.com/s/1c2n60NI]**下载完成后，双击文件中的`MyDownloader.app.exe`，打开软件，点击【File】，选择从EXCEL导入（目前只支持EXCEL格式文件）</a></p>
<p>2.进行相关设置：</p>
<p>选择EXCEL文件：导入需要下载图片地址的EXCEL文件</p>
<p>EXCEL表名：对应数据表的名称</p>
<p>文件URL列名：表内图片URL所在的列名称  </p>
<p>保存文件夹列名：EXCEL中需要单独一个列，列出图片想要保存到本地的路径（哪个文件夹）。</p>
<p>列名可自定义设置。</p>
<p>列中的数据有固定格式：【D:\图片保存文件夹名\】，其中存储盘和文件夹名可自定义设置，【D:\】需在英文状态下输入，不可用中文输入。<strong>（注意路径结尾还有一个“\”）</strong></p>
<p>配置完成后，点击【OK】保存。</p>
<p>3.在文件夹内新建文本文档，文档名称随意，在文档内输入 <code>ren *.* *.jpg</code>，另保存为【新建文本文档.bat】，运行文件（bat是dos下的批处理文件）</p>
<p>这样就将文件夹内所有图片转换成<code>.jpg</code>格式</p>
]]></content>
      <categories>
        <category>琐碎</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter Notebook修改默认路径</title>
    <url>/2021/10/14/2021-10-14-Jupyter%20Notebook%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h3 id="始、修改默认路径"><a href="#始、修改默认路径" class="headerlink" title="始、修改默认路径"></a>始、修改默认路径</h3><p>1.打开Anaconda Prompt，输入<code>jupyter notebook --generate-config</code></p>
<p>2.打开上一步生成的配置文件：</p>
<p><code>C:\Users\Administrator\.jupyter\jupyter_notebook_config.py</code></p>
<p>其中C:\Users\Administrator就是<code>Jupyter notebook</code>的默认路径：</p>
<p>3.打开<code>jupyter_notebook_config.py</code>，搜索<code>#c.NotebookApp.notebook_dir = &#39;&#39;</code>（214行），删除井号修改成你希望设置的目录路径，这里我修改成<code>c.NotebookApp.notebook_dir = &#39;D:\DeskTopD\JupyterProject&#39;</code></p>
<p>4.在win开始菜单中找到<code>jupyter notebook</code>快捷图标，鼠标右键&gt;&gt;属性&gt;&gt;快捷方式&gt;&gt;目标</p>
<p>删除最后的 <code>&quot;%USERPROFILE%/&quot;</code> ，如果是通过<code>Anaconda</code>控制台打开<code>jupyter notebook</code>则无需更改此项</p>
]]></content>
      <categories>
        <category>琐碎</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习日志Day3</title>
    <url>/2021/10/06/2021-10-06-Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97Day3/</url>
    <content><![CDATA[<h3 id="始、Python数据类型"><a href="#始、Python数据类型" class="headerlink" title="始、Python数据类型"></a>始、Python数据类型</h3><p>序列：一组按照顺序排列的数据集合</p>
<p>Python中有三种内置的序列类型：<strong>字符串、列表、元组</strong></p>
<p>​    优点：支持<strong>索引</strong>和<strong>切片</strong>操作</p>
<p>​    特征：第一个正索引为0，指向左端，第一个索引为<strong>负</strong>数的时候指向<strong>右</strong>端</p>
<span id="more"></span>

<hr>
<h3 id="一、字符串"><a href="#一、字符串" class="headerlink" title="一、字符串"></a>一、字符串</h3><p>切片：截取字符串中的其中一段内容</p>
<p>语法：[起始下标：结束下标：步长]，<code>[start: end: step]</code>，不包含end，step默认是1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#切片</span><br><span class="line">strMsg = &#x27;hello world&#x27;</span><br><span class="line">#slice[start: end: step] 左闭右开</span><br><span class="line">print(strMsg)</span><br><span class="line">print(strMsg[2: 7: 1])</span><br><span class="line">print(strMsg[2:])</span><br><span class="line">print(strMsg[: 3])</span><br><span class="line">print(strMsg[: : -1])</span><br><span class="line">print(strMsg[: : -2])</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i love python</span><br><span class="line">I LOVE PYTHON</span><br><span class="line">hello world</span><br><span class="line">llo w</span><br><span class="line">llo world</span><br><span class="line">hel</span><br><span class="line">dlrow olleh</span><br><span class="line">drwolh</span><br></pre></td></tr></table></figure>

<p><strong>下标会越界，切片不会</strong></p>
<p>常用函数：</p>
<p>1.<code>capitalize()</code>：将字符串首字母变成大写</p>
<p>2.<code>strip()</code>：去除字符串中的空格</p>
<p>3.<code>lstrip()</code>：去除字符串左边空格</p>
<p>4.<code>rstrip()</code>：去除字符串右边空格</p>
<p>5.<code>id()</code>：查看对象的内存地址</p>
<p>6.<code>find()</code>：查找对象是否在序列中，返回第一个对象下标，不存在返回<code>-1</code></p>
<p>7.<code>index()</code>：检测字符串中是否包含子字符串，返回下标，不存在则报错</p>
<p>8.<code>startswith()</code>：判断是否以某子串开头</p>
<p>9.<code>endswith()</code>：判断是否以某子串结尾</p>
<p>10.<code>lower()</code>：转换成小写</p>
<p>11.<code>upper()</code>：转换成大写</p>
<p>12.<code>join()</code>：循环取出所有值用xx去连接</p>
<p>13.<code>split()</code>：切割字符串</p>
<p>14.<code>count()</code>：统计出现的次数</p>
<p>…</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#常用函数</span><br><span class="line">name = &#x27;peter&#x27;</span><br><span class="line">print(name.capitalize())</span><br><span class="line">#</span><br><span class="line">a = &#x27;          hello    &#x27;</span><br><span class="line">b = a.strip()</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">#</span><br><span class="line">b = a</span><br><span class="line">print(&#x27;a的内存地址%d&#x27;%id(a))</span><br><span class="line">print(&#x27;b的内存地址%d&#x27;%id(b))</span><br><span class="line">#</span><br><span class="line">dataStr = &#x27;I love python&#x27;</span><br><span class="line">print(dataStr.find(&#x27;p&#x27;))</span><br><span class="line">print(dataStr.find(&#x27;a&#x27;))</span><br><span class="line">print(dataStr.index(&#x27;o&#x27;))</span><br><span class="line">#</span><br><span class="line">print(dataStr.startswith(&#x27;I&#x27;))</span><br><span class="line">print(dataStr.endswith(&#x27;o&#x27;))</span><br><span class="line">#</span><br><span class="line">print(dataStr.lower())</span><br><span class="line">print(dataStr.upper())</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Peter</span><br><span class="line">          hello</span><br><span class="line">hello</span><br><span class="line">a的内存地址2290605664992</span><br><span class="line">b的内存地址2290605664992</span><br><span class="line">7</span><br><span class="line">3</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">i love python</span><br><span class="line">I LOVE PYTHON</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="二、元组"><a href="#二、元组" class="headerlink" title="二、元组"></a>二、元组</h3><p>元组是一种不可变的序列，创建之后不能做任何的修改，特点：</p>
<p>​    1.不可变</p>
<p>​    2.用（）创建元组类型，数据项之间用逗号分隔，数据项可以是任意数据类型</p>
<p>​    3.元组中只有一个元素时，要加逗号以免被当作其他类型</p>
<p>​    4.支持切片操作</p>
<p><strong>元组不可修改，但是元组中的列表中的元素可以修改</strong></p>
<p>常用方法与列表相似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tupleA = (1, )</span><br><span class="line">print(type(tupleA))</span><br><span class="line">print(id(tupleA))</span><br><span class="line"></span><br><span class="line">tupleA = (&#x27;abcd&#x27;, 66, 1.255, [22, &#x27;fafa&#x27;])</span><br><span class="line">print(tupleA)</span><br><span class="line">print(id(tupleA))</span><br><span class="line"></span><br><span class="line">for item in tupleA:</span><br><span class="line">    print(item, end = &#x27; &#x27;)</span><br><span class="line">    pass</span><br><span class="line">print()</span><br><span class="line"></span><br><span class="line">print(tupleA[2: 4])</span><br><span class="line">print(tupleA[-1: -4: -2]) #反向遍历下标从-1开始</span><br><span class="line">print(tupleA[-4: -2: ])</span><br><span class="line"></span><br><span class="line">tupleA[3][0] = 66</span><br><span class="line">print(tupleA)</span><br><span class="line"></span><br><span class="line">print(tupleA.count(66)) #统计元素出现的次数</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;tuple&#x27;&gt;</span><br><span class="line">1350340798616</span><br><span class="line">(&#x27;abcd&#x27;, 66, 1.255, [22, &#x27;fafa&#x27;])</span><br><span class="line">1350340804424</span><br><span class="line">abcd 66 1.255 [22, &#x27;fafa&#x27;]</span><br><span class="line">(1.255, [22, &#x27;fafa&#x27;])</span><br><span class="line">([22, &#x27;fafa&#x27;], 66)</span><br><span class="line">(&#x27;abcd&#x27;, 66)</span><br><span class="line">(&#x27;abcd&#x27;, 66, 1.255, [66, &#x27;fafa&#x27;])</span><br><span class="line">1</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h3><p>列表是一种有序的数据集合，特点：</p>
<p>​    1.支持增删查改</p>
<p>​    2.列表中的数据可以变化</p>
<p>​    3.用[ ]表示列表类型，数据项之间用逗号分隔，数据项可以是任意数据类型</p>
<p>​    4.支持索引和切片操作</p>
<p>常用方法：</p>
<p>1.<code>append()</code>：在列表后面追加元素</p>
<p>2.<code>count()</code>：统计元素出现的次数</p>
<p>3.<code>extend()</code>：扩展，相当于批量添加</p>
<p>4.<code>index()</code>：获取指定元素索引号</p>
<p>5.<code>insert()</code>：在指定位置插入</p>
<p>6.<code>pop()</code>：删除最后一个元素</p>
<p>7.<code>remove()</code>：移除左边找到的第一个元素</p>
<p>8.<code>reverse()</code>：反转列表</p>
<p>9.<code>sort()</code>：列表排序</p>
<p>10.<code>len()</code>：获取列表对象的数据个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#列表</span><br><span class="line">li = []</span><br><span class="line">print(type(li))</span><br><span class="line">li = [1, 2, 3, &#x27;你好&#x27;]</span><br><span class="line">print(len(li))</span><br><span class="line"></span><br><span class="line">#查找、遍历</span><br><span class="line">listA = [&#x27;abcd&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True]</span><br><span class="line">print(listA[3])</span><br><span class="line">print(listA[1: 4]) #左闭右开</span><br><span class="line">print(listA * 3)</span><br><span class="line">print(listA.index(True))</span><br><span class="line"></span><br><span class="line">#增加</span><br><span class="line">listA.append([&#x27;fff&#x27;, &#x27;ddd&#x27;])</span><br><span class="line">print(listA)</span><br><span class="line">listA.insert(1, &#x27;插入&#x27;)</span><br><span class="line">print(listA)</span><br><span class="line">rsData = list(range(10))</span><br><span class="line">listA.append(rsData)</span><br><span class="line">print(listA)</span><br><span class="line"></span><br><span class="line">#修改</span><br><span class="line">listA[0] = &#x27;peter&#x27;</span><br><span class="line">print(listA)</span><br><span class="line"></span><br><span class="line">#删除</span><br><span class="line">del listA[7]</span><br><span class="line">print(listA)</span><br><span class="line">del listA[1: 7: 5] #切片批量删除</span><br><span class="line">print(listA)</span><br><span class="line">listA.remove(785)</span><br><span class="line">print(listA)</span><br><span class="line">listA.pop()</span><br><span class="line">print(listA)</span><br><span class="line">listA.pop(0)</span><br><span class="line">print(listA)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;list&#x27;&gt;</span><br><span class="line">4</span><br><span class="line">qiuzhi</span><br><span class="line">[785, 12.23, &#x27;qiuzhi&#x27;]</span><br><span class="line">[&#x27;abcd&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, &#x27;abcd&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, &#x27;abcd&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True]</span><br><span class="line">4</span><br><span class="line">[&#x27;abcd&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, [&#x27;fff&#x27;, &#x27;ddd&#x27;]]</span><br><span class="line">[&#x27;abcd&#x27;, &#x27;插入&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, [&#x27;fff&#x27;, &#x27;ddd&#x27;]]</span><br><span class="line">[&#x27;abcd&#x27;, &#x27;插入&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, [&#x27;fff&#x27;, &#x27;ddd&#x27;], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]</span><br><span class="line">[&#x27;peter&#x27;, &#x27;插入&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, [&#x27;fff&#x27;, &#x27;ddd&#x27;], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]</span><br><span class="line">[&#x27;peter&#x27;, &#x27;插入&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True, [&#x27;fff&#x27;, &#x27;ddd&#x27;]]</span><br><span class="line">[&#x27;peter&#x27;, 785, 12.23, &#x27;qiuzhi&#x27;, True]</span><br><span class="line">[&#x27;peter&#x27;, 12.23, &#x27;qiuzhi&#x27;, True]</span><br><span class="line">[&#x27;peter&#x27;, 12.23, &#x27;qiuzhi&#x27;]</span><br><span class="line">[12.23, &#x27;qiuzhi&#x27;]</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="四、字典"><a href="#四、字典" class="headerlink" title="四、字典"></a>四、字典</h3><p>字典是以键值对 <code>&#123;‘key&#39;: &#39;value’&#125;</code> 的形式创建并可以存储任意对象的数据类型</p>
<p>键（key）不能重复，值（value）可以重复</p>
<p>键（key）只能是不可变类型，如数字、字符串、元组</p>
<p>字典不是序列类型， <strong>没有下标</strong>的概念，是一个无序的键值集合</p>
<p>常用方法：</p>
<p>1.<code>keys()</code>：获取所有的键</p>
<p>2.<code>values()</code>：获取所有的值</p>
<p>3.<code>items()</code>：获取所有的键值对</p>
<p>4.<code>update()</code>：更新键值对，可以修改也可以添加</p>
<p>5.<code>pop()</code>：删除指定键</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#初始化</span><br><span class="line">from typing import ItemsView</span><br><span class="line">dictA = &#123;&#x27;pro&#x27;: &#x27;艺术&#x27;, &#x27;school&#x27;: &#x27;北影&#x27;&#125;</span><br><span class="line">print(type(dictA))</span><br><span class="line">#赋值</span><br><span class="line">dictA[&#x27;name&#x27;] = &#x27;刘德华&#x27;</span><br><span class="line">dictA[&#x27;age&#x27;] = &#x27;50&#x27;</span><br><span class="line">dictA[&#x27;pos&#x27;] = &#x27;影星&#x27;</span><br><span class="line">print(dictA)</span><br><span class="line">print(len(dictA))</span><br><span class="line">print(dictA[&#x27;name&#x27;])</span><br><span class="line">#修改</span><br><span class="line">dictA[&#x27;name&#x27;] = &#x27;张家辉&#x27;</span><br><span class="line">dictA[&#x27;school&#x27;] = &#x27;港大&#x27;</span><br><span class="line">dictA.update(&#123;&#x27;age&#x27;: &#x27;40&#x27;&#125;)</span><br><span class="line">dictA.update(&#123;&#x27;height&#x27;: &#x27;180&#x27;&#125;)</span><br><span class="line">print(dictA)</span><br><span class="line">#输出</span><br><span class="line">print(dictA.keys())</span><br><span class="line">print(dictA.values())</span><br><span class="line">print(dictA.items())</span><br><span class="line">for key,value in dictA.items():</span><br><span class="line">    print(&#x27;%s==%s&#x27;%(key, value))</span><br><span class="line">    pass</span><br><span class="line">#删除</span><br><span class="line">del dictA[&#x27;name&#x27;]</span><br><span class="line">dictA.pop(&#x27;age&#x27;)</span><br><span class="line">print(dictA)</span><br><span class="line">#排序</span><br><span class="line">print(sorted(dictA.items(), key = lambda d: d[0]))</span><br><span class="line">print(sorted(dictA.items(), key = lambda d: d[1]))</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br><span class="line">&#123;&#x27;pro&#x27;: &#x27;艺术&#x27;, &#x27;school&#x27;: &#x27;北影&#x27;, &#x27;name&#x27;: &#x27;刘德华&#x27;, &#x27;age&#x27;: &#x27;50&#x27;, &#x27;pos&#x27;: &#x27;影星&#x27;&#125;</span><br><span class="line">5</span><br><span class="line">刘德华</span><br><span class="line">&#123;&#x27;pro&#x27;: &#x27;艺术&#x27;, &#x27;school&#x27;: &#x27;港大&#x27;, &#x27;name&#x27;: &#x27;张家辉&#x27;, &#x27;age&#x27;: &#x27;40&#x27;, &#x27;pos&#x27;: &#x27;影星&#x27;, &#x27;height&#x27;: &#x27;180&#x27;&#125;</span><br><span class="line">dict_keys([&#x27;pro&#x27;, &#x27;school&#x27;, &#x27;name&#x27;, &#x27;age&#x27;, &#x27;pos&#x27;, &#x27;height&#x27;])</span><br><span class="line">dict_values([&#x27;艺术&#x27;, &#x27;港大&#x27;, &#x27;张家辉&#x27;, &#x27;40&#x27;, &#x27;影星&#x27;, &#x27;180&#x27;])</span><br><span class="line">dict_items([(&#x27;pro&#x27;, &#x27;艺术&#x27;), (&#x27;school&#x27;, &#x27;港大&#x27;), (&#x27;name&#x27;, &#x27;张家辉&#x27;), (&#x27;age&#x27;, &#x27;40&#x27;), (&#x27;pos&#x27;, &#x27;影星&#x27;), (&#x27;height&#x27;, &#x27;180&#x27;)])</span><br><span class="line">pro==艺术</span><br><span class="line">school==港大</span><br><span class="line">name==张家辉</span><br><span class="line">age==40</span><br><span class="line">pos==影星</span><br><span class="line">height==180</span><br><span class="line">&#123;&#x27;pro&#x27;: &#x27;艺术&#x27;, &#x27;school&#x27;: &#x27;港大&#x27;, &#x27;pos&#x27;: &#x27;影星&#x27;, &#x27;height&#x27;: &#x27;180&#x27;&#125;</span><br><span class="line">[(&#x27;height&#x27;, &#x27;180&#x27;), (&#x27;pos&#x27;, &#x27;影星&#x27;), (&#x27;pro&#x27;, &#x27;艺术&#x27;), (&#x27;school&#x27;, &#x27;港大&#x27;)]</span><br><span class="line">[(&#x27;height&#x27;, &#x27;180&#x27;), (&#x27;pos&#x27;, &#x27;影星&#x27;), (&#x27;school&#x27;, &#x27;港大&#x27;), (&#x27;pro&#x27;, &#x27;艺术&#x27;)]</span><br></pre></td></tr></table></figure>







<hr>
<h3 id="五、通用操作"><a href="#五、通用操作" class="headerlink" title="五、通用操作"></a>五、通用操作</h3><p>1.<code>+</code>：合并两个对象</p>
<p>2.<code>*</code>：对象自身按指定次数复制合并</p>
<p>3.<code>in</code>：判断元素是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line">strA = &#x27;人生苦短&#x27;</span><br><span class="line">strB = &#x27;我用Python&#x27;</span><br><span class="line">print(strA + strB)</span><br><span class="line">listA = list(range(11))</span><br><span class="line">listB = list(range(11, 20))</span><br><span class="line">print(listA + listB)</span><br><span class="line">#</span><br><span class="line">print(strA * 3)</span><br><span class="line">print(listA * 2)</span><br><span class="line">#</span><br><span class="line">print(&#x27;生&#x27; in strA)</span><br><span class="line">print(8 in listA)</span><br><span class="line">print(10 in listB)</span><br><span class="line">dictA = &#123;&#x27;name&#x27;: &#x27;peter&#x27;&#125;</span><br><span class="line">print(&#x27;name&#x27; in dictA)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">人生苦短我用Python</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span><br><span class="line">人生苦短人生苦短人生苦短</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode.284】顶端迭代器</title>
    <url>/2021/10/05/2021-10-05-%E3%80%90LeetCode.284%E3%80%91%E9%A1%B6%E7%AB%AF%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h3 id="题目：顶端迭代器"><a href="#题目：顶端迭代器" class="headerlink" title="题目：顶端迭代器"></a>题目：顶端迭代器</h3><p>请你设计一个迭代器，除了支持 <code>hasNext</code> 和 <code>next</code> 操作外，还支持 <code>peek</code> 操作。</p>
<p>实现 <code>PeekingIterator</code> 类：</p>
<p><code>PeekingIterator(int[] nums)</code> 使用指定整数数组 <code>nums</code> 初始化迭代器。<br><code>int next()</code> 返回数组中的下一个元素，并将指针移动到下个元素处。<br><code>bool hasNext()</code> 如果数组中存在下一个元素，返回 <code>true</code> ；否则，返回 <code>false</code> 。<br><code>int peek()</code> 返回数组中的下一个元素，但 <strong>不</strong> 移动指针。</p>
<span id="more"></span>




<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;PeekingIterator&quot;, &quot;next&quot;, &quot;peek&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;]</span><br><span class="line">[[[1, 2, 3]], [], [], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, 2, 2, 3, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]</span><br><span class="line">peekingIterator.next();    // 返回 1 ，指针移动到下一个元素 [1,2,3]</span><br><span class="line">peekingIterator.peek();    // 返回 2 ，指针未发生移动 [1,2,3]</span><br><span class="line">peekingIterator.next();    // 返回 2 ，指针移动到下一个元素 [1,2,3]</span><br><span class="line">peekingIterator.next();    // 返回 3 ，指针移动到下一个元素 [1,2,3]</span><br><span class="line">peekingIterator.hasNext(); // 返回 False</span><br></pre></td></tr></table></figure>



<p>提示：</p>
<p><code>1 &lt;= nums.length &lt;= 1000</code><br><code>1 &lt;= nums[i] &lt;= 1000</code><br><code>对 next 和 peek 的调用均有效</code><br><code>next、hasNext 和 peek 最多调用  1000 次</code></p>
<p>进阶：你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？</p>
<hr>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>顶端迭代器需要实现以下三种操作：</p>
<p><code>next</code>：返回迭代器的下一个元素，并将指针向后移动一位；</p>
<p><code>hasNext</code>：判断迭代器中是否还有剩余的元素；</p>
<p><code>peek</code>：返回迭代器的下一个元素，不改变指针。</p>
<p>每种编程语言自带的迭代器可能支持上述一种或多种操作，但是不一定支持上述全部操作。如果编程语言自带的迭代器本身就支持上述操作，可以直接使用，否则需要自定义实现。</p>
<ol>
<li>C++中<code>PeekingIterator</code>继承父类<code>Iterator</code>，<code>Iterator</code>已经实现方法<code>next</code>和<code>hasNext</code>，在此我们在<code>PeekingIterator</code>中主要实现<code>peek</code>方法即可。我们使用<code>flag</code>标记迭代器是否还有剩余元素，使用<code>nextElement</code>存储迭代器的下一个元素。</li>
</ol>
<p><code>next</code>：首先用<code>ret</code>存储<code>nextElement</code>表示返回值，<code>flag</code>保存<code>Iterator</code>调用<code>hasNext</code>方法的返回结果，然后将<code>nextElement</code>向后移动一位，最后返回<code>ret</code>；</p>
<p><code>hasNext</code>：返回<code>flag</code>；</p>
<p><code>peek</code>：由于peek操作不改变指针，因此返回<code>nextElement</code>。</p>
<ol start="2">
<li>C#的<code>IEnumerator</code>接口包含属性Current和方法<code>MoveNext</code>（该方法的返回值类型是<code>bool</code>，表示是否成功移动到下一个元素），三种操作都需要自定义实现，需要使用flag存储迭代器是否还有剩余的元素。</li>
</ol>
<p><code>next</code>：首先用<code>ret</code>存储<code>iterator.Current</code>表示返回值，然后对<code>iterator</code>调用<code>MoveNext</code>方法使其向后移动一位并将该方法的结果赋值给<code>flag</code>，最后返回<code>ret</code>；</p>
<p><code>hasNext</code>：返回flag；</p>
<p><code>peek</code>：由于<code>peek</code>操作不改变指针，因此返回<code>iterator.Current</code>。</p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><ol>
<li>C++</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekingIterator</span> :</span> <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">PeekingIterator</span>(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; nums) : <span class="built_in">Iterator</span>(nums) &#123;</span><br><span class="line">	    <span class="comment">// Initialize any member here.</span></span><br><span class="line">	    <span class="comment">// **DO NOT** save a copy of nums and manipulate it directly.</span></span><br><span class="line">	    <span class="comment">// You should only use the Iterator interface methods.</span></span><br><span class="line">	    flag = Iterator::<span class="built_in">hasNext</span>();</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            nextElement = Iterator::<span class="built_in">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextElement;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// hasNext() and next() should behave the same as in the Iterator interface.</span></span><br><span class="line">	<span class="comment">// Override them if needed.</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">int</span> ret = nextElement;</span><br><span class="line">        flag = Iterator::<span class="built_in">hasNext</span>();</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            nextElement = Iterator::<span class="built_in">next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> flag;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> flag;</span><br><span class="line">    <span class="keyword">int</span> nextElement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>C#</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class PeekingIterator &#123;</span><br><span class="line">    private IEnumerator&lt;int&gt; iterator;</span><br><span class="line">    private bool flag;</span><br><span class="line"></span><br><span class="line">    // iterators refers to the first element of the array.</span><br><span class="line">    public PeekingIterator(IEnumerator&lt;int&gt; iterator) &#123;</span><br><span class="line">        // initialize any member here.</span><br><span class="line">        this.iterator = iterator;</span><br><span class="line">        flag = true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Returns the next element in the iteration without advancing the iterator.</span><br><span class="line">    public int Peek() &#123;</span><br><span class="line">        return iterator.Current;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Returns the next element in the iteration and advances the iterator.</span><br><span class="line">    public int Next() &#123;</span><br><span class="line">        int ret = iterator.Current;</span><br><span class="line">        flag = iterator.MoveNext();</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Returns false if the iterator is refering to the end of the array of true otherwise.</span><br><span class="line">    public bool HasNext() &#123;</span><br><span class="line">        return flag;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h3><p><strong>进阶问题</strong><br>进阶问题要求拓展顶端迭代器的设计，使其适用于所有类型，不局限于整数。</p>
<p>对于动态类型语言如 <code>JavaScript</code> 和 <code>Python</code>，不需要拓展上述设计。</p>
<p>对于静态类型语言如 <code>Java</code>、<code>C#</code> 和 <code>C++</code>，可以通过使用泛型的方式拓展设计，在 <code>PeekingIterator</code> 类中定义泛型，使用时可以用任意类型。</p>
<hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>以前习惯将迭代器当作指针来看到，因为感觉上是大同小异，现在加深了对两者区别的理解：迭代器像是有固定方法的指针，不像指针那么随意，更像是名称所展示的那样包含“迭代”的思想</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>c++</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习日志Day2</title>
    <url>/2021/10/05/2021-10-05-Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97Day2/</url>
    <content><![CDATA[<h3 id="一、if-else语句"><a href="#一、if-else语句" class="headerlink" title="一、if-else语句"></a>一、if-else语句</h3><p>1.单分支if-else</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">score = 60</span><br><span class="line">if score &gt;= 60:</span><br><span class="line">    print(&#x27;成绩及格&#x27;)</span><br><span class="line">    pass</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;成绩不及格&#x27;)</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<span id="more"></span>



<p>2.多分支elif</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">score = 75</span><br><span class="line">if score &gt;= 90:</span><br><span class="line">    print(&#x27;您的成绩是A&#x27;)</span><br><span class="line">    pass</span><br><span class="line">elif score &gt;= 80:</span><br><span class="line">    print(&#x27;您的成绩是B&#x27;)</span><br><span class="line">    pass</span><br><span class="line">elif score &gt;= 70:</span><br><span class="line">    print(&#x27;您的成绩是C&#x27;)</span><br><span class="line">    pass</span><br><span class="line">elif score &gt;= 60:</span><br><span class="line">    print(&#x27;您的成绩是D&#x27;)</span><br><span class="line">    pass</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;您的成绩是E&#x27;)</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>3.多分支if-else嵌套</p>
<hr>
<h3 id="二、while循环"><a href="#二、while循环" class="headerlink" title="二、while循环"></a>二、while循环</h3><p>1.猜拳机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#猜拳机</span><br><span class="line">import random</span><br><span class="line">i = 1</span><br><span class="line">while i &lt;= 3:</span><br><span class="line">    person = int(input(&#x27;请出拳：[0：石头、1：剪刀、2：布]：&#x27;))</span><br><span class="line">    computer = random.randint(0, 2)</span><br><span class="line">    if person == 2 and computer == 0:</span><br><span class="line">        print(&#x27;胜利！&#x27;)</span><br><span class="line">        pass</span><br><span class="line">    elif person == 1 and computer == 2:</span><br><span class="line">        print(&#x27;胜利！&#x27;)</span><br><span class="line">        pass</span><br><span class="line">    elif person == 0 and computer == 1:</span><br><span class="line">        print(&#x27;胜利！&#x27;)</span><br><span class="line">        pass</span><br><span class="line">    elif person == computer:</span><br><span class="line">        print(&#x27;平局&#x27;)</span><br><span class="line">        pass</span><br><span class="line">    else:</span><br><span class="line">        print(&#x27;失败~&#x27;)</span><br><span class="line">        pass</span><br><span class="line">    i += 1</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="三、for循环"><a href="#三、for循环" class="headerlink" title="三、for循环"></a>三、for循环</h3><p>1.遍历容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for data in range(1, 101):</span><br><span class="line">    print(data, end = &#x27; &#x27;)</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="四、break、continue语句"><a href="#四、break、continue语句" class="headerlink" title="四、break、continue语句"></a>四、break、continue语句</h3><p>1.break和continue语句必须在循环当中使用</p>
<p>2.continue结束当前循环并进入下一个循环</p>
<p>3.break结束整个循环不再继续（while-else结构、for-else结构也是如此，不再执行else）</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pyhton</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习日志Day1</title>
    <url>/2021/09/30/2021-09-30-Python%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97Day1/</url>
    <content><![CDATA[<h3 id="一、Python注释"><a href="#一、Python注释" class="headerlink" title="一、Python注释"></a>一、Python注释</h3><p>1.单行注释<code>#</code></p>
<p>2.多行注释<code>&#39;&#39;&#39; &#39;&#39;&#39;</code></p>
<span id="more"></span>

<hr>
<h3 id="二、数据类型和命名"><a href="#二、数据类型和命名" class="headerlink" title="二、数据类型和命名"></a>二、数据类型和命名</h3><p>1.数字int、布尔值bool、字符串str、字典dict、元组tuple、列表list</p>
<p>2.type()方法可以查看类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#数据类型</span><br><span class="line">a = 10086</span><br><span class="line">print(type(a))</span><br><span class="line">a = &#x27;fa♂q&#x27;</span><br><span class="line">print(type(a))</span><br><span class="line">a = 12.45</span><br><span class="line">print(type(a))</span><br><span class="line">a = True</span><br><span class="line">print(type(a))</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">#高级类型</span><br><span class="line">b = ()</span><br><span class="line">print(type(b))</span><br><span class="line">b = []</span><br><span class="line">print(type(b))</span><br><span class="line">b = &#123;&#125;</span><br><span class="line">print(type(b))</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;class &#x27;int&#x27;&gt;</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line">&lt;class &#x27;float&#x27;&gt;</span><br><span class="line">&lt;class &#x27;bool&#x27;&gt;</span><br><span class="line">True</span><br><span class="line">&lt;class &#x27;tuple&#x27;&gt;</span><br><span class="line">&lt;class &#x27;list&#x27;&gt;</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="三、基本操作符"><a href="#三、基本操作符" class="headerlink" title="三、基本操作符"></a>三、基本操作符</h3><p>1.算数运算符：+、-、*、/、**、//</p>
<p>2.比较运算符：==、！=、&gt;、&lt;、&gt;=、&lt;=</p>
<p>3.逻辑运算符：and、or、not</p>
<p>4.赋值运算符：=、+=、-=、*=、/=、%=、**=、//=</p>
<hr>
<h3 id="四、格式化输入和输出"><a href="#四、格式化输入和输出" class="headerlink" title="四、格式化输入和输出"></a>四、格式化输入和输出</h3><p>1.输入：<code>input</code></p>
<p>2.输出：<code>%s</code>  <code>%d</code>  <code>%f</code>  <code>&#123;&#125;.format</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#格式化输出</span><br><span class="line">name = &#x27;张三&#x27;</span><br><span class="line">age = 25</span><br><span class="line">print(&#x27;我的名字是：%s, \n我今年%d岁&#x27;%(name, age))</span><br><span class="line">print(&#x27;姓名：&#123;&#125;，年龄：&#123;&#125;&#x27;.format(name,age))</span><br><span class="line"></span><br><span class="line">#input输入</span><br><span class="line">name = input(&#x27;请输入你的名字：&#x27;)</span><br><span class="line">print(&#x27;姓名：&#123;&#125;&#x27;.format(name))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Pytorch深度学习环境配置</title>
    <url>/2021/09/29/2021-09-29-Pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="始、Pytorch深度学习快速入门【小土堆】"><a href="#始、Pytorch深度学习快速入门【小土堆】" class="headerlink" title="始、Pytorch深度学习快速入门【小土堆】"></a>始、Pytorch深度学习快速入门【小土堆】</h3><p><strong>版本：</strong></p>
<p>Anaconda：Anaconda3-5.2.0-Windows-x86.64</p>
<p>Cuda：10.2</p>
<p><strong>报错汇总：</strong></p>
<p>1.python.exe无法找到入口</p>
<p>解决方法：找到报错路径下的pythoncom36.dll并删除</p>
<span id="more"></span>

<hr>
<h3 id="一、安装Anaconda"><a href="#一、安装Anaconda" class="headerlink" title="一、安装Anaconda"></a>一、安装Anaconda</h3><p>1.进入Anaconda历史版本页面：<a href="https://repo.anaconda.com/">https://repo.anaconda.com/</a></p>
<p>2.选择下载<code>Anaconda3-5.2.0-Windows-x86.64.exe</code></p>
<p>3.跳过安装vs</p>
<hr>
<h3 id="二、管理环境"><a href="#二、管理环境" class="headerlink" title="二、管理环境"></a>二、管理环境</h3><p>1.创建环境：打开Anaconda Prompt，输入<code>conda create -n pytorch python=3.6</code></p>
<p>2.激活环境：输入<code>conda activate pytorch</code></p>
<p>3.查看环境包体：<code>pip list</code></p>
<hr>
<h3 id="三、安装Pytorch"><a href="#三、安装Pytorch" class="headerlink" title="三、安装Pytorch"></a>三、安装Pytorch</h3><p><strong>普通方法：</strong></p>
<p>1.打开<code>Pytorch</code>首页：<a href="https://pytorch.org/">https://pytorch.org/</a></p>
<p>2.依次选择<code>Stable1.9.1</code>→<code>Windows</code>→<code>Conda</code>→<code>Python</code>→<code>CUDA10.2</code>，执行下方代码行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install pytorch torchvision torchaudio cudatoolkit=10.2 -c pytorch</span><br></pre></td></tr></table></figure>



<p><strong>清华源方法：</strong></p>
<p>1.先添加清华镜像channel：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">conda config --set show_channel_urls yes</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/</span><br></pre></td></tr></table></figure>

<p>2.执行安装代码行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install pytorch torchvision cudatoolkit=10.2</span><br></pre></td></tr></table></figure>

<p>3.验证是否安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure>

<p>查看环境中是否有torch工具包</p>
<hr>
<h3 id="四、验证CUDA"><a href="#四、验证CUDA" class="headerlink" title="四、验证CUDA"></a>四、验证CUDA</h3><p>1.按顺序输入以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line">import torch</span><br><span class="line">torch.cuda.is_available()</span><br></pre></td></tr></table></figure>

<p>如果返回True，则表示Pytorch可以正常使用GPU</p>
<hr>
<h3 id="五、编辑器"><a href="#五、编辑器" class="headerlink" title="五、编辑器"></a>五、编辑器</h3><p><strong>vscode</strong>：</p>
<p>1.打开vscode官网下载：<a href="https://code.visualstudio.com/docs/?dv=win64user%EF%BC%8C%E5%AE%89%E8%A3%85%E5%8C%85%E4%BC%9A%E8%87%AA%E5%8A%A8%E4%B8%8B%E8%BD%BD">https://code.visualstudio.com/docs/?dv=win64user，安装包会自动下载</a></p>
<p><strong>jupyter：</strong></p>
<p>1.在pytorch环境中安装jupyter：打开Anaconda Prompt并进入pytorch环境然后输入<code>conda install nb_conda</code></p>
<p>2.验证是否安装成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure>

<p>查看环境中是否有ipykernel工具包</p>
<p>3.启动jupyter：输入<code>jupyter notebook</code></p>
]]></content>
      <categories>
        <category>琐碎</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
        <tag>python</tag>
        <tag>anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode.650】只有两个键的键盘</title>
    <url>/2021/09/19/2021-09-19-%E3%80%90LeetCode.650%E3%80%91%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98/</url>
    <content><![CDATA[<h3 id="题目：只有两个键的键盘"><a href="#题目：只有两个键的键盘" class="headerlink" title="题目：只有两个键的键盘"></a>题目：只有两个键的键盘</h3><p>最初记事本上只有一个字符 <code>&#39;A&#39;</code> 。你每次可以对这个记事本进行两种操作：</p>
<p><code>Copy All</code>（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。<br><code>Paste</code>（粘贴）：粘贴 <strong>上一次</strong> 复制的字符。<br>给你一个数字 <code>n</code> ，你需要使用最少的操作次数，在记事本上输出 <strong>恰好</strong> <code>n</code> 个 <code>&#39;A&#39;</code> 。返回能够打印出 <code>n</code> 个 <code>&#39;A&#39;</code> 的最少操作次数。</p>
 <span id="more"></span>



<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：3</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">最初, 只有一个字符 &#x27;A&#x27;。</span><br><span class="line">第 1 步, 使用 Copy All 操作。</span><br><span class="line">第 2 步, 使用 Paste 操作来获得 &#x27;AA&#x27;。</span><br><span class="line">第 3 步, 使用 Paste 操作来获得 &#x27;AAA&#x27;。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<p><code>1 &lt;= n &lt;= 1000</code></p>
<hr>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>总问题可以由小问题逐步扩大得到，考虑动态规划</p>
<p>只有复制和粘贴两种操作，如果要得到 i ，那么就一定要先得到它的其中一个因数 j ，由 j 粘贴 i / j - 1 次得到 i </p>
<p>设动态规划数组 <code>dp[i]</code> 表示得到 i 个字母需要的最少操作次数</p>
<p>需要从 1 到 i - 1 寻找 i 的因数，可得状态转移方程：<code>dp[i] = min( (1 ~ i-1) dp[j] * i/j)</code></p>
<p>初始边界条件：<code>dp[1] = 0</code></p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minSteps(int n) &#123;</span><br><span class="line">        vector&lt;int&gt; dp(n + 1);</span><br><span class="line">        dp[1] = 0;</span><br><span class="line">        for(int i = 2; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i] = INT_MAX;</span><br><span class="line">            for(int j = 1; j * j &lt;= i; j++)&#123;</span><br><span class="line">                if(i % j == 0) &#123;</span><br><span class="line">                    dp[i] = min(dp[i], dp[j] + i / j);</span><br><span class="line">                    dp[i] = min(dp[i], dp[i / j] + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n根号n)，空间复杂度O(n)</p>
<hr>
<h3 id="细节："><a href="#细节：" class="headerlink" title="细节："></a>细节：</h3><p>如果 j 是 i 的因数，那么 i / j 必然也是 i 的因数，因此我们只需要检测到根号 i 为止就足够了，有效降低时间复杂度</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>《Robbie Swifthand》Unity2d独立游戏学习（八）</title>
    <url>/2021/09/13/2021-09-13-%E3%80%8ARobbie%20Swifthand%E3%80%8BUnity2d%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89/</url>
    <content><![CDATA[<h3 id="始、前言"><a href="#始、前言" class="headerlink" title="始、前言"></a>始、前言</h3><p>先解决之前遗留下来的问题：场景重置时重复生成Audio Manager，导致声音重复并且游戏卡顿。</p>
<span id="more"></span>

<p>修改Audio Manager脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void Awake()</span><br><span class="line">&#123;</span><br><span class="line">    if(current != null)</span><br><span class="line">    &#123;</span><br><span class="line">        Destroy(gameObject);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    current = this;</span><br><span class="line">    //切换场景也不会销毁这个物体</span><br><span class="line">    DontDestroyOnLoad(gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在场景初始化时添加判断<code>if(current != null)</code>，当场景中已经存在此类物体时摧毁刚生成的新物体并且不再执行以下代码</p>
<hr>
<h3 id="一、GameManager"><a href="#一、GameManager" class="headerlink" title="一、GameManager"></a>一、GameManager</h3><p>1.新建物体GameManager</p>
<p>1.新建脚本GameManager（注意拼写，拼写正确时脚本图标会变成齿轮），挂载到GameManager物体下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using UnityEngine.SceneManagement;</span><br><span class="line"></span><br><span class="line">public class GameManager : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    static GameManager instance;</span><br><span class="line"></span><br><span class="line">    private void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        if(instance != null)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        instance = this;</span><br><span class="line"></span><br><span class="line">        DontDestroyOnLoad(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void PlayerDied()</span><br><span class="line">    &#123;</span><br><span class="line">        //经过1.5s后重新加载场景</span><br><span class="line">        instance.Invoke(&quot;RestartScene&quot;, 1.5f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void RestartScene()</span><br><span class="line">    &#123;</span><br><span class="line">        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成角色死亡时重新加载场景的代码</p>
<p>3.然后在PalyerHealth脚本中调用GameManager.PlayerDied();</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line"> &#123;</span><br><span class="line">     if(collision.gameObject.layer == trapsLayer)</span><br><span class="line">     &#123;</span><br><span class="line">         Instantiate(deathVFXPrefab, transform.position, transform.rotation);</span><br><span class="line">         gameObject.SetActive(false);</span><br><span class="line"></span><br><span class="line">         AudioManager.PlayDeathAudio();</span><br><span class="line"></span><br><span class="line">        /* SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);*/</span><br><span class="line">        //调用GameManager中的方法来实现场景重置</span><br><span class="line">         GameManager.PlayerDied();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>4.添加重启场景的动画效果</p>
<p>…</p>
<p>…</p>
<p>…</p>
<hr>
<h3 id="终、遗憾"><a href="#终、遗憾" class="headerlink" title="终、遗憾"></a>终、遗憾</h3><p>由于不可抗因素，工程文件丢失，系列完结</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title>《多视角深度相机的猪体三维点云重构及体尺测量》阅读笔记</title>
    <url>/2021/09/12/2021-09-12-%E3%80%8A%E5%A4%9A%E8%A7%86%E8%A7%92%E6%B7%B1%E5%BA%A6%E7%9B%B8%E6%9C%BA%E7%9A%84%E7%8C%AA%E4%BD%93%E4%B8%89%E7%BB%B4%E7%82%B9%E4%BA%91%E9%87%8D%E6%9E%84%E5%8F%8A%E4%BD%93%E5%B0%BA%E6%B5%8B%E9%87%8F%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="一、信息"><a href="#一、信息" class="headerlink" title="一、信息"></a>一、信息</h3><p>尹 令，蔡更元，田绪红，孙爱东，石 帅，钟浩杰，梁世豪.多视角深度相机的猪体三维点云重构及体尺测量[J]. 农业工程学报，2019，35(23)：201－208. </p>
<p>Yin Ling, Cai Gengyuan, Tian Xuhong, Sun Aidong, Shi Shuai, Zhong Haojie, Liang Shihao. Three dimensional point cloud  reconstruction and body size measurement of pigs based on multi-view depth camera[J]. Transactions of the Chinese Society of  Agricultural Engineering (Transactions of the CSAE), 2019, 35(23): 201－208. (in Chinese with English abstract) </p>
<p>doi： 10.11975/j.issn.1002-6819.2019.23.025 </p>
<p><a href="http://www.tcsae.org/">http://www.tcsae.org</a> </p>
<span id="more"></span>

<hr>
<h3 id="二、对比"><a href="#二、对比" class="headerlink" title="二、对比"></a>二、对比</h3><p>1.测量方法：</p>
<p>人工皮尺测量：容易造成牲畜驱赶应激、人工测量准确性差、测定效率低、复杂性状难以度量等问题</p>
<p><strong>人工智能无应激识别系统和体况自动评价系统</strong>：有效解决传统测量方法的效率、精度和动物福利问题</p>
<p>2.参数采集：</p>
<p>热成像技术：能较清晰捕获动物表面轮廓信息，但热成像设备昂贵，且需从视频流中手动分离相应数据帧，无法实现完全自动化</p>
<p>图像处理技术：参数大多以像素为单位，当相机参数或物距发生改变时，模型可能不再适用，因此通用性差。另外获取图像时天气、拍摄角度、光照条件影响比较大</p>
<p>单视角：采集简单不需要融合配准，但只能获取体长、体宽、体高等体尺数据，腹围等体尺无法估测。</p>
<p><strong>多视角</strong>：获取牲畜各部分深度图像进行各部分点云配准融合、非刚体三维模型点云匹配、体表轮廓描述、家畜体测量交互式软件设计等关键技术都有研究报道。</p>
<hr>
<h3 id="三、难点"><a href="#三、难点" class="headerlink" title="三、难点"></a>三、难点</h3><p>当扫描较大面积物体时数据精度丢失严重，同时扫描活体动物时如时间较长容易出现非刚性形变。牲畜全局三维点云重构时，处理数据量大对存储和计算能力要求很高，实时处理是难点。</p>
<p><strong>解决方案</strong>：</p>
<p>在测量通道上固定 3 个 KinectV2 相机，通道只能有一头猪单独通过，猪进入相机最佳拍摄位置时，3个深度相机瞬间同步抓取局部点云。采用基于轮廓连贯性点云配准融合全局点云，提取猪体长、体高、体宽、腹围等体尺特征实现对猪的非接触式体尺自动测量。该方法对通道预先设定最佳拍摄位置减少扫描范围，提高数据精度；多视角深度相机同步瞬间抓取减少活体动物运动时非刚性形变；提出各种体尺测量方法，尤其测量腹围时极坐标转换法一方面可以弥补由栏杆遮挡和相机视角未覆盖缺失的点云，另一方面对局部点云相交处轮廓精细配准；并且 KinectV2 为消费级深度设备成本低廉，易于实现产业化。</p>
<hr>
<h3 id="四、方法"><a href="#四、方法" class="headerlink" title="四、方法"></a>四、方法</h3><p>1.同时获取瞬间局部点云</p>
<p>2.采用基于距离查询区域增长方法滤除掉远离群点</p>
<p>3.对近离群点的消除采用 SVLOF 算法</p>
<p>4.粗配准：多个深度摄像设备标定中得到相邻子区域的空间变换矩阵和平移向量变换到同一坐标系下</p>
<p>5.精细配准：配准融合问题就变成一个多目标优化问题，使得顶点融合度和邻层轮廓覆盖率都最小化</p>
<p>6.最小二乘法拟合中轴平面，确定起始和终止点，微分求体长</p>
<hr>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>1.采用 3 个方 向深度相机完成猪体三维重构，与猪体长、体高、胸宽、腹围自动测算试验，其测量数据与实测数据相对误差分析表明本文提出的猪体三维重构和多体尺检测算法稳定、效果较好。</p>
<p>2.一方面是猪动态行走时姿态不固定，有扭转、拱背、低头等多种形态动作，影响测量准确性，另外人工在猪动态环境下测量准确率也降低。</p>
<p>3.腹围等 3 围度的测量需要依赖三维点云拼接融合效果，今后需要进一步研究三维点云拼接融合和空缺部分的填补算法。 </p>
<hr>
<h3 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h3><p>1.Halachmi I, Klopčič M, Polak P, et al. Automatic assessment  of dairy cattle body condition score using thermal imaging[J].  Computers &amp; Electronics in Agriculture, 2013, 99(6): 35－ 40. </p>
<p>2.Azzaro G, Caccamo M, Ferguson J D, et al. Objective  estimation of body condition score by modeling cow body  shape from digital images[J]. Journal of Dairy Science, 2011,  94(4): 2126－2137.</p>
<p>3.Tedin R , Becerra J A , Duro R J , et al. Computational  intelligence based construction of a body condition  assessment system for cattle[C]// Computational Intelligence  and Virtual Environments for Measurement Systems and  Applications (CIVEMSA), 2013 IEEE International  Conference on. IEEE, 2013.</p>
<p>4.Bercovich A, Edan Y, Alchanatis V, et al. Development of an  automatic cow body condition scoring using body shape  signature and Fourier descriptors.[J]. Journal of Dairy  Science, 2013, 96(12): 8047－8059. </p>
<p>5.Kashiha M A, Bahr C, Ott S, et al. Automatic monitoring of  pig locomotion using image analysis[J]. Livestock Science,  2014, 159(1): 141－148.</p>
<p>6.Vieira A, Brand, O S, Monteiro A, et al. Development and  validation of a visual body condition scoring system for dairy  goats with picture-based training[J]. Journal of Dairy Science,  2015, 98(9): 6597－608.</p>
<p>7.陈菁菁，彭彦昆. 基于机器视觉技术的生猪活体监测系统[J].  食品安全质量检测学报，2012，3(6)：600－602. </p>
<p>8.刘建飞. 图像识别技术在奶牛体况评分中的应用研究[D].  济南：山东大学，2012. </p>
<p>9.吴复争，姜威，张美杰. 核-主成分分析在奶牛体况自动评 分中的应用[J]. 光学技术，2013，39(3)：222－227. </p>
<p>10.刘同海，滕光辉，付为森，等. 基于机器视觉的猪体体尺 测点提取算法与应用[J]. 农业工程学报，2013，29(2)： 161－168. </p>
<p>11.Menesatti P, Costa C, Antonucci F, et al. A low-cost  stereovision system to estimate size and weight of live  sheep[J]. Computers &amp; Electronics in Agriculture, 2014,  103(2): 33－38.</p>
<p>12.Salau J, Haas J H, Junge W, et al. Feasibility of automated  body trait determination using the SR4K time-of-flight  camera in cow barns[J]. Springer Plus, 2014, 3(1): 225. </p>
<p>13.Weber A, Salau J, Haas J H, et al. Estimation of backfat  thickness using extracted traits from an automatic 3D optical  system in lactating Holstein-Friesian cows[J]. Livestock  Science, 2014, 165(1): 129－137.</p>
<p>14.Kuzuhara Y, Kawamura K, Yoshitoshi R, et al. A  preliminarily study for predicting body weight and milk  properties in lactating Holstein cows using a threedimensional camera system[J]. Computers &amp; Electronics in  Agriculture, 2015, 111: 186－193.</p>
<p>15.Fischer A, Luginbühl T, Delattre L, et al. Rear shape in 3  dimensions summarized by principal component analysis is a  good predictor of body condition score in Holstein dairy  cows[J]. Journal of Dairy Science, 2015, 98(7): 4465－4476. </p>
<p>16.Pezzuolo A, Guarino M, Sartori L, et al. On-barn pig weight  estimation based on body measurements by a Kinect v1 depth  camera[J]. Computers &amp; Electronics in Agriculture, 2018,  148: 29－36. </p>
<p>17.付为森，滕光辉. 基于双目视觉技术的猪生长监测系统标 定模式[J]. 农业机械学报，2009，40(S1)：223－227. </p>
<p>18.李卓，毛涛涛，刘同海，等. 基于机器视觉的猪体质量估 测模型比较与优化[J]. 农业工程学报，2015，31(2)：155－ 161. </p>
<p>19.Salau J, Haas J H, Junge W, et al. Extrinsic calibration of a  multi-Kinect camera scanning passage for measuring  functional traits in dairy cows[J]. Biosystems Engineering,  2016, 151: 409－424. </p>
<p>20.王龙. 机器视觉在奶牛体况评定中的应用[D]. 上海：东华 大学，2014. </p>
<p>21.张温. 基于机器视觉的牲畜体征测量系统的研究[D]. 包 头：内蒙古科技大学，2014. </p>
<p>22.郭浩. 动物体表三维数据获取与处理算法研究[D]. 北京： 中国农业大学，2015. </p>
<p>23.李卓，毛涛涛，刘同海，等. 基于机器视觉的猪体质量估 测模型比较与优化[J]. 农业工程学报，2015，31(2)：155－ 161. </p>
<p>24.司永胜，安露露，刘刚，等. 基于 Kinect 相机的猪体理想 姿态检测与体尺测量[J]. 农业机械学报，2019，50(1)：58－ 65. </p>
<p>25.王可，郭浩，刘威林，等. 基于点云旋转归一化的猪体体 尺测点提取方法[J]. 农业工程学报，2017，33(增刊 1)： 253－259.</p>
<p>26.Guo H, Ma X, Ma Q, et al. LSSA_CAU:An interactive 3d  point clouds analysis software for body measurement of  livestock with similar forms of cows or pigs[J]. Computers &amp;  Electronics in Agriculture, 2017, 138: 60－68.</p>
<p>27.聂建辉，胡英，马孜. 散乱点云离群点的分类识别算法[J].  计算机辅助设计与图形学学报，2011，23(9)：1526－1532.</p>
]]></content>
      <categories>
        <category>阅读笔记</category>
      </categories>
      <tags>
        <tag>三维重构</tag>
        <tag>图像处理</tag>
        <tag>三维点云</tag>
        <tag>体尺测量</tag>
      </tags>
  </entry>
  <entry>
    <title>《Robbie Swifthand》Unity2d独立游戏学习（七）</title>
    <url>/2021/09/12/2021-09-12-%E3%80%8ARobbie%20Swifthand%E3%80%8BUnity2d%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89/</url>
    <content><![CDATA[<h3 id="始、回顾"><a href="#始、回顾" class="headerlink" title="始、回顾"></a>始、回顾</h3><p>（忙完开学的琐事）</p>
<p>先回顾上一回完成的内容，我们制作了会让角色死亡的尖刺，还加上了死亡效果配套的特效和声音。场景中添加了游戏的主要任务——收集宝珠，同样也有配套的特效和声音</p>
<span id="more"></span>

<hr>
<h3 id="一、更炫酷的视觉效果"><a href="#一、更炫酷的视觉效果" class="headerlink" title="一、更炫酷的视觉效果"></a>一、更炫酷的视觉效果</h3><p>1.检查插件Post Processing是否已安装，Window → Package Manage</p>
<p>2.为主摄像机添加组件Post Processing Layer</p>
<p>3.新建空项目Global Post Processing，将Layer 改成 Post Processing（新建）</p>
<p>4.将主摄像机中Post Processing Layer的Layer设置成Post Processing，这样主摄像机就会观察新项目的特效</p>
<p>5.为Global Post Processing添加组件Post Processing Volume，勾选is Global</p>
<p>6.为Global Post Processing新建一个Profile（new）用来承载即将要设置的特效，Add effect 可以添加各种视觉效果：</p>
<p>Bloom：泛光效果</p>
<p>Color Grading：镜头调色</p>
<p>Chromatic Aberration：场景畸变效果</p>
<p>Lens Distortion：镜头畸变效果9</p>
<p>Vignette：边缘阴影效果</p>
<p>7.调好特效了吗，调好了偏不用，就是玩儿。在Assets → VFX → Profiles 中找到Global Reference预制体，拖入Global Post Processing → Post Processing Volume → Profile（如果场景过亮可以在Lightning → Environment Lighting调整场景亮度）</p>
<hr>
<h3 id="二、摄像头震动效果"><a href="#二、摄像头震动效果" class="headerlink" title="二、摄像头震动效果"></a>二、摄像头震动效果</h3><p>1.在跟随人物的2D摄像机中的Extension添加新的组件Cinemachine Impulse Listener</p>
<p>2.在宝珠Shrine → Orb预制体中添加新组件Cinemachine Collision Impulse Sourse（就像音效系统一样，有一个接收器接收声音并且播放，有一个物体设定条件发出声音）</p>
<p>3.将Assets → VFX → Profiles中的Explosion Shake 拖入Cinemachine Collision Impulse Sourse → Raw Signal</p>
<p>4.设置触发此特效的Layer ，将Cinemachine Collision Impulse Sourse → Layer Mask 设置成Player，我们希望当Layer为Player的物体触碰到Orb时就会触发摄像头震动效果</p>
<p>5.还可以在Cinemachine Collision Impulse Sourse → Frequency Gain 设置成100，这个数值越高，震动的频率越高，更快完成</p>
<hr>
<h3 id="终、休整"><a href="#终、休整" class="headerlink" title="终、休整"></a>终、休整</h3><p>到此为止，我们已经实现了游戏大部分刚需内容，接下来把目光转移到游戏整体管理，还有一些细节的修补</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode.552】学生出勤记录 II</title>
    <url>/2021/08/18/2021-08-18-%E3%80%90LeetCode.552%E3%80%91%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95%20II/</url>
    <content><![CDATA[<h3 id="题目：学生出勤记录-II"><a href="#题目：学生出勤记录-II" class="headerlink" title="题目：学生出勤记录 II"></a>题目：学生出勤记录 II</h3><p>可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：<br>‘A’：Absent，缺勤<br>‘L’：Late，迟到<br>‘P’：Present，到场<br>如果学生能够 <strong>同时</strong> 满足下面两个条件，则可以获得出勤奖励：</p>
<p>按 <strong>总出勤</strong> 计，学生缺勤（’A’）<strong>严格</strong> 少于两天。<br>学生 <strong>不会</strong> 存在 <strong>连续</strong> 3 天或 <strong>连续</strong> 3 天以上的迟到（’L’）记录。<br>给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 <strong>数量</strong> 。答案可能很大，所以返回对 109 + 7 <strong>取余</strong> 的结果。</p>
 <span id="more"></span>



<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：</span><br><span class="line">有 8 种长度为 2 的记录将被视为可奖励：</span><br><span class="line">&quot;PP&quot; , &quot;AP&quot;, &quot;PA&quot;, &quot;LP&quot;, &quot;PL&quot;, &quot;AL&quot;, &quot;LA&quot;, &quot;LL&quot; </span><br><span class="line">只有&quot;AA&quot;不会被视为可奖励，因为缺勤次数为 2 次（需要少于 2 次）。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 10101</span><br><span class="line">输出：183236316</span><br></pre></td></tr></table></figure>



<p>提示：</p>
<p><code>1 &lt;= n &lt;= 105</code></p>
<hr>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>动态规划做多了，一来就想到动态规划，都忘了还能模拟遍历（不过以我击败5%的结果用暴力法必定超时）</p>
<p>考虑最简单的<code>dp</code>数组<code>dp[i]</code>表示有i天时可获得奖励的天数，<code>0 &lt;= i &lt;= n</code>。但是还需要记录有i天时的缺勤天数和结尾连续迟到天数，为什么是结尾连续迟到天数呢，因为一旦连续迟到天数达到3天，就将<code>dp</code>置0。所以要将<code>dp</code>数组升维再升维变成<code>dp[i][j][k]</code></p>
<p><code>dp[i][j][k]</code>表示 “有i天、缺勤j天、结尾连续迟到k天” 的可获得奖励天数</p>
<p>边界：<code>dp[0][0][0] = 1</code>即还没开始上课，这时可以获得出勤奖励</p>
<p>状态转移分为三种情况：到场、迟到、缺勤</p>
<p>到场：今天上课到场，于是迟到天数清零，缺勤保持不变，将前一天不同j和不同k的<code>dp</code>加起来</p>
<p>迟到：今天上课迟到，前一天的迟到天数只能在0和1之间，因为一旦前一天的结尾迟到天数到达2，今天再迟到就没有奖励了，<code>dp</code>置零（置零不用特别计算，新建的未初始化数组就是0，不影响后续计算调用），于是迟到天数加一，缺勤保持不变，将前一天不同j和k - 1的<code>dp</code>加起来</p>
<p>缺勤：今天上课缺勤，前一天的缺勤天数只能是0，理由同上，于是迟到天数清零，缺勤天数加一，将前一天j = 0和不同k的<code>dp</code>加起来</p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int checkRecord(int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n + 1, vector&lt;vector&lt;int&gt;&gt;(2, vector&lt;int&gt;(3)));</span><br><span class="line">        dp[0][0][0] = 1;</span><br><span class="line">        int mod = pow(10, 9) + 7;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            //P</span><br><span class="line">            for(int j = 0; j &lt;= 1; j++)&#123;</span><br><span class="line">                for(int k = 0; k &lt;= 2; k++)&#123;</span><br><span class="line">                    dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //L</span><br><span class="line">            for(int j = 0; j &lt;= 1; j++)&#123;</span><br><span class="line">                for(int k = 1; k &lt;= 2; k++)&#123;</span><br><span class="line">                    dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //A</span><br><span class="line">            for(int k = 0; k &lt;= 2; k++)&#123;</span><br><span class="line">                dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int j = 0; j &lt;= 1; j++)&#123;</span><br><span class="line">            for(int k = 0; k &lt;= 2; k++)&#123;</span><br><span class="line">                ans = (ans + dp[n][j][k]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h3><p>动态规划解题思路的一次更新，对于<code>dp</code>数组升维这件事一直都把握不住，这道题目的条件让人容易找到升维切入点，真是受益良多</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>《Robbie Swifthand》Unity2d独立游戏学习（六）</title>
    <url>/2021/08/14/2021-08-14-%E3%80%8ARobbie%20Swifthand%E3%80%8BUnity2d%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<h3 id="始、前言"><a href="#始、前言" class="headerlink" title="始、前言"></a>始、前言</h3><p>距离上次琢磨unity已经半个月了，希望没有生疏（打开unity已经有点懵逼了）</p>
<span id="more"></span>

<p><code>^(*￣(oo)￣)^</code></p>
<hr>
<h3 id="一、死亡机制"><a href="#一、死亡机制" class="headerlink" title="一、死亡机制"></a>一、死亡机制</h3><p>1.找到Props文件夹中的尖刺Spikes，可以逐个添加并且对齐，但没必要</p>
<p>2.打开Tile Palette，在左下角有个选择笔刷的选项，选择GameObject Brush并且在Cells中添加尖刺的预制体Spikes</p>
<p>3.Active Tilemap选择Platforms，就可以在场景中快乐涂鸦啦，生成的尖刺会成为Platforms物体的子物体</p>
<p>4.新建Traps的Layer，给尖刺更换Layer，利用预制体Apply All</p>
<p>5.新建脚本PlayerHealth，挂到Robbie上，编写代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PalyerHealth : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    int trapsLayer;</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        trapsLayer = LayerMask.NameToLayer(&quot;Traps&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        if(collision.gameObject.layer == trapsLayer)</span><br><span class="line">        &#123;</span><br><span class="line">            gameObject.SetActive(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里当角色触碰到尖刺时就会被摧毁消失</p>
<p>7.添加死亡烟雾效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class PalyerHealth : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public GameObject deathVFXPrefab;</span><br><span class="line">    </span><br><span class="line">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        if(collision.gameObject.layer == trapsLayer)</span><br><span class="line">        &#123;</span><br><span class="line">            Instantiate(deathVFXPrefab, transform.position, transform.rotation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到烟雾特效并添加进来，在角色死亡时顺便用Instantiate(）播放烟雾特效</p>
<p>8.在Audio Manage脚本中添加代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Header(&quot;主角音效&quot;)]</span><br><span class="line">//动作声</span><br><span class="line">public AudioClip deathClip;</span><br><span class="line">//说话声</span><br><span class="line">public AudioClip deathVoiceClip;</span><br><span class="line"></span><br><span class="line">[Header(&quot;特效音效&quot;)]</span><br><span class="line">public AudioClip deathVFXClip;</span><br></pre></td></tr></table></figure>

<p>找到对应声音素材并添加到变量中</p>
<p>9.继续修改Audio Manage脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void PlayDeathAudio()</span><br><span class="line">&#123;</span><br><span class="line">    current.playerSource.clip = current.deathClip;</span><br><span class="line">    current.playerSource.Play();</span><br><span class="line"></span><br><span class="line">    current.voiceSource.clip = current.deathVoiceClip;</span><br><span class="line">    current.voiceSource.Play();</span><br><span class="line"></span><br><span class="line">    current.fxSource.clip = current.deathVFXClip;</span><br><span class="line">    current.fxSource.Play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和之前的声音播放方法一样，添加音效并且播放音效</p>
<p>10.在PlayerHealth中调用死亡声音：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">&#123;</span><br><span class="line">    if(collision.gameObject.layer == trapsLayer)</span><br><span class="line">    &#123;</span><br><span class="line">        AudioManager.PlayDeathAudio();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>11.死亡后重置场景：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using UnityEngine.SceneManagement;</span><br><span class="line"></span><br><span class="line">	private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        if(collision.gameObject.layer == trapsLayer)</span><br><span class="line">        &#123;</span><br><span class="line">            SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>并且在Unity中找到File → Build Setting 并且点击Add Open Scenes，这样就会在角色死亡时重置当前场景</p>
<p>测试了几次发现虽然实现了重置场景时不会摧毁声音管理，但是这个声音管理又会无限重复生成，暂时不知道怎么解决，先把<code>DontDestroyOnLoad(gameObject);</code>注释掉，嘿嘿</p>
<hr>
<h3 id="二、收集物体"><a href="#二、收集物体" class="headerlink" title="二、收集物体"></a>二、收集物体</h3><p>1.在Props中找到宝珠预制体Shrine，同上的方法添加到Brush中并且随意画到场景中</p>
<p>2.更改Shrine的Layer成为Ground，并且应用到预制体中</p>
<p>3.新建脚本Orb挂到orb物体中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class Orb : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    int player;</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        player = LayerMask.NameToLayer(&quot;Player&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        if (collision.gameObject.layer == player)</span><br><span class="line">        &#123;</span><br><span class="line">            gameObject.SetActive(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像角色触碰尖刺就消失一样，这里当角色接触宝珠就会让宝珠消失（记得检查一下角色的Layer是不是Player）</p>
<p>4.添加爆炸特效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Orb : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public GameObject exposionVFXPrefab;</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        player = LayerMask.NameToLayer(&quot;Player&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        if (collision.gameObject.layer == player)</span><br><span class="line">        &#123;</span><br><span class="line">            Instantiate(exposionVFXPrefab, transform.position, transform.rotation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在VFX文件夹中找到Explosion添加到变量中</p>
<p>5.添加音效，在AudioManage脚本中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Header(&quot;主角音效&quot;)]</span><br><span class="line">//说话声</span><br><span class="line">public AudioClip orbVoiceClip;</span><br><span class="line"></span><br><span class="line">[Header(&quot;特效音效&quot;)]</span><br><span class="line">public AudioClip orbFXClip;</span><br><span class="line"></span><br><span class="line">    public static void PlayOrbAudio()</span><br><span class="line">&#123;</span><br><span class="line">    current.voiceSource.clip = current.orbVoiceClip;</span><br><span class="line">    current.voiceSource.Play();</span><br><span class="line"></span><br><span class="line">    current.fxSource.clip = current.orbFXClip;</span><br><span class="line">    current.fxSource.Play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将音效素材添加到变量中，并且记得在Orb脚本中调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">&#123;</span><br><span class="line">    if (collision.gameObject.layer == player)</span><br><span class="line">    &#123;</span><br><span class="line">        AudioManager.PlayOrbAudio();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="终、总结"><a href="#终、总结" class="headerlink" title="终、总结"></a>终、总结</h3><p>本次主要添加了场景中主要的角色互动物体，分别是让游戏结束的<strong>尖刺</strong>和游戏目标需要收集的<strong>宝珠</strong>，总体来说两个物体的添加、与角色之间的互动制作都比较相似</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>c#</tag>
        <tag>tilemap</tag>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中map和unordered_map的区别和使用</title>
    <url>/2021/08/11/2021-08-11-C++%E4%B8%ADmap%E5%92%8Cunordered_map%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="始、前言"><a href="#始、前言" class="headerlink" title="始、前言"></a>始、前言</h3><p>在平时刷题需要使用map时，官方题解用的unordered_map，而我用的是map执行时间相对较慢，这就来看看两者有啥区别</p>
<span id="more"></span>

<hr>
<h3 id="一、需要引入的头文件不同"><a href="#一、需要引入的头文件不同" class="headerlink" title="一、需要引入的头文件不同"></a>一、需要引入的头文件不同</h3><p><strong>map</strong>: </p>
<p><code>#include &lt; map &gt;</code></p>
<p><strong>unordered_map</strong>:</p>
<p> <code>#include &lt; unordered_map &gt;</code></p>
<hr>
<h3 id="二、内部实现机理不同"><a href="#二、内部实现机理不同" class="headerlink" title="二、内部实现机理不同"></a>二、内部实现机理不同</h3><p><strong>map</strong>： </p>
<p>map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。</p>
<p><strong>unordered_map</strong>: </p>
<p>unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。</p>
<hr>
<h3 id="三、优缺点以及适用处"><a href="#三、优缺点以及适用处" class="headerlink" title="三、优缺点以及适用处"></a>三、优缺点以及适用处</h3><p><strong>map</strong>：</p>
<p>优点：</p>
<p>有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作<br>红黑树，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高</p>
<p>缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间</p>
<p>适用处：对于那些有顺序要求的问题，用map会更高效一些</p>
<p><strong>unordered_map</strong>：</p>
<p>优点： 因为内部实现了哈希表，因此其查找速度非常的快</p>
<p>缺点： 哈希表的建立比较耗费时间</p>
<p>适用处：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map</p>
<p><strong>总结</strong>：</p>
<p>内存占有率的问题就转化成红黑树 VS hash表 , 还是unordered_map占用的内存要高。<br>但是unordered_map执行效率要比map高很多<br>对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的</p>
<hr>
<h3 id="四、map和unordered-map的使用"><a href="#四、map和unordered-map的使用" class="headerlink" title="四、map和unordered_map的使用"></a>四、map和unordered_map的使用</h3><p>unordered_map的用法和map是一样的，提供了 insert，size，count等操作，并且里面的元素也是以pair类型来存贮的。其底层实现是完全不同的，上方已经解释了，但是就外部使用来说却是一致的。</p>
<p><strong>常用操作汇总举例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;unordered_map&gt;  </span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string&gt;  </span><br><span class="line">using namespace std;  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">	//注意：C++11才开始支持括号初始化</span><br><span class="line">    unordered_map&lt;int, string&gt; myMap=&#123;&#123; 5, &quot;张大&quot; &#125;,&#123; 6, &quot;李五&quot; &#125;&#125;;//使用&#123;&#125;赋值</span><br><span class="line">    myMap[2] = &quot;李四&quot;;  //使用[ ]进行单个插入，若已存在键值2，则赋值修改，若无则插入。</span><br><span class="line">    myMap.insert(pair&lt;int, string&gt;(3, &quot;陈二&quot;));//使用insert和pair插入</span><br><span class="line">  </span><br><span class="line">	//遍历输出+迭代器的使用</span><br><span class="line">    auto iter = myMap.begin();</span><br><span class="line">    //auto自动识别为迭代器类型unordered_map&lt;int,string&gt;::iterator</span><br><span class="line">    </span><br><span class="line">    while (iter!= myMap.end())</span><br><span class="line">    &#123;  </span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; iter-&gt;second &lt;&lt; endl;  </span><br><span class="line">        ++iter;  </span><br><span class="line">    &#125;  </span><br><span class="line">	</span><br><span class="line">	//查找元素并输出+迭代器的使用</span><br><span class="line">    auto iterator = myMap.find(2);//find()返回一个指向2的迭代器</span><br><span class="line">    if (iterator != myMap.end())</span><br><span class="line">	    cout &lt;&lt; endl&lt;&lt; iterator-&gt;first &lt;&lt; &quot;,&quot; &lt;&lt; iterator-&gt;second &lt;&lt; endl;  </span><br><span class="line">    system(&quot;pause&quot;);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<p>此时用的是unordered_map，输出的结果为：</p>
<p>3,陈二</p>
<p>2,李四</p>
<p>6,李五</p>
<p>5,张大</p>
<p>2,李四</p>
<p>若把unordered_map换成map，输出的结果为：</p>
<p>2,李四</p>
<p>3,陈二</p>
<p>5,张大</p>
<p>6,李五</p>
<p>2,李四</p>
<hr>
<h3 id="终、补充"><a href="#终、补充" class="headerlink" title="终、补充"></a>终、补充</h3><p>unordered_map插入顺序不固定，按编译器的规定，这里的是头插</p>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode.446】等差数列划分 II - 子序列</title>
    <url>/2021/08/11/2021-08-11-%E3%80%90LeetCode.446%E3%80%91%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86%20II%20-%20%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目：等差数列划分-II-子序列"><a href="#题目：等差数列划分-II-子序列" class="headerlink" title="题目：等差数列划分 II - 子序列"></a>题目：等差数列划分 II - 子序列</h3><p>给你一个整数数组 <code>nums</code> ，返回 nums 中所有 等差子序列 的数目。</p>
<p>如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。</p>
<p>例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。<br>再例如，[1, 1, 2, 5, 7] 不是等差序列。<br>数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。</p>
<p>例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。<br>题目数据保证答案是一个 32-bit 整数。</p>
<span id="more"></span>

<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,4,6,8,10]</span><br><span class="line">输出：7</span><br><span class="line">解释：所有的等差子序列为：</span><br><span class="line">[2,4,6]</span><br><span class="line">[4,6,8]</span><br><span class="line">[6,8,10]</span><br><span class="line">[2,4,6,8]</span><br><span class="line">[4,6,8,10]</span><br><span class="line">[2,4,6,8,10]</span><br><span class="line">[2,6,10]</span><br></pre></td></tr></table></figure>



<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7]</span><br><span class="line">输出：16</span><br><span class="line">解释：数组中的任意子序列都是等差子序列。</span><br></pre></td></tr></table></figure>



<p>提示：</p>
<p><code>1  &lt;= nums.length &lt;= 1000</code><br><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></p>
<hr>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>给定数组为[1,2,3,4,5]，求等差子数组，我们使用动态规划的过程，一次遍历：</p>
<p>遍历到3，发现它跟[1,2]可以组成子数组[1,2,3]，满足等差子数组要求，记<code>dp[3]=1</code>。</p>
<p>遍历到4，发现它跟[2,3]可以组成子数组[2,3,4]，满足等差子数组要求，而它的前一位即3本来就有一个等差子数组，我们在它的基础上可以延续出来一个新的等差子数组[1,2,3,4]，所以，<code>dp[4]=dp[3]+1=2</code>，<code>dp[3]</code>表示原来3的基础上延续出来的[1,2,3,4]，+1表示全新的[2,3,4]。</p>
<p>遍历到5，发现它跟[3,4]可以组成子数组[3,4,5]，满足等差子数组要求，而它的前一位即4本来是有两个等差子数组，我们在它的基础上可以延续出来两个新的等差子数组分别为[1,2,3,4,5]和[2,3,4,5]，所以，dp[5]=dp[4]+1=3，解释同上。<br>这样，我们把<code>dp[3]+dp[4]+dp[5]=1+2+3=6</code>就是答案。</p>
<p>方法一、动态规划<br>好了，本题还是以[1,2,3,4,5]为例，[1,3,5]也是一个合格的答案，所以，我们可以转换成昨天的题目，我们求出每一个以<code>nums[i]</code>结尾的公差d的元素个数，再按照上述求等差子数组的思路很容易求出以<code>nums[i]</code>结尾等着为d的等差子数组的数量，把所有这些等差d加一起就是以<code>nums[i]</code>结尾的等差子序列的数量，列举所有的i即可求得结果，所以，我们定义如下：</p>
<p>状态定义：<code>dp[i][d]</code>表示以<code>nums[i]</code>结尾，公差为d的等差子数组的数量。</p>
<p>状态转移：<code>dp[i][d]=dp[j][d]+1</code>，其中j表示以<code>nums[i]</code>结尾等着为d的前面那个数<code>nums[j]</code>的下标。</p>
<p>这样定义看似没有问题，实际运行的过程其实是有问题的：</p>
<p>问题一：以[1,2,3,4,5]为例，遍历到2（下标为1）的时候，它与下标0的元素1的差值为1，按照公式应该得到：<code>dp[1][1]=dp[0][1]+1=1</code>,但是这个结果并不符合题目的要求，题目要求长度至少为3，那么，我们怎么才能知道下标j前面还有没有元素呢？如果只有<code>[nums[j], nums[i]]</code>是无法满足长度3的要求的。<br>问题二：以[7,7,7,7,7]为例，遍历到第4个7（下标为3）的时候，它的等差子序列有4个，分别为[7(0),7(1),7(3)]、[7(0),7(2),7(3)]、[7(1),7(2),7(3)]、[7(0),7(1),7(2),7(3)]，按照<code>dp[i][d]=dp[j][d]+1</code>的规则去计算也是不对的。<br>似乎没有思路了。再仔细想一下，既然三个长度的子序列是由两个长度的子序列升级来的，那么，我们能不能在统计结果的时候从两个长度的子序列开始计算呢，这样，三个长度的子序列就不用计算了。比如，以[1,2,3,4,5]为例：</p>
<p>遍历到2时，以2结尾的子序列只有一个，即[1,2]，我们记为<code>dp2=1</code>。<br>遍历到3时，以3结尾的子序列有三个，分别为[1,2,3]、[1,3]、[2,3]，我们分别记为<code>dp[3][1]=dp[2][1]+1=2</code>和<code>dp[3][2]=dp[1][2]+1=1</code>，可以看到，只有<code>dp[2][1]</code>升级上来的那个子序列才可以作为结果，所以，我们在这里<code>ans += dp[2][1]</code>。<br>遍历到4时，以4结尾的子序列有多少个呢？它与前面元素的公差分别有1、2、3，我们按照公式可得<code>dp[4][1]=dp[3][1]+1=3</code>、<code>dp[4][2]=dp[2][2]+1=1</code>、<code>dp[4][3]=dp[1][3]+1=1</code>，一共五个，分别是[1,4]、[2,4]、[3,4]、[2,3,4]、[1,2,3,4]，可以看到，只有<code>dp[3][1]</code>升级上来的那两个子序列才满足条件，所以，ans += <code>dp[3][1]</code>。<br>再来看看[7,7,7,7,7]这种特殊用例，遍历到第4个7的时候，它与前面任意元素的差值都是0，按照前面的公式<code>dp[i][0]=dp[j][0]+1</code>就不行了，这时候我们可以换成累加就可以轻松解决了，<code>dp[i][0]+=dp[j][0]+1</code>。</p>
<p>最后，题目限定<code>nums[i]</code>的范围为<code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code>，有可能溢出，而且，我们也不知道等差d有多少个，所以，使用<code>HashMap</code>来存储key为公差的等差子数组数量。</p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //动态规划，vector&lt;map&lt;int, int&gt;&gt; dp(n)</span><br><span class="line">    //dp[j][diff]表示以 nums[j] 为结尾、 diff 为等差数的等差序列个数</span><br><span class="line">    int numberOfArithmeticSlices(vector&lt;int&gt; &amp;nums) &#123;</span><br><span class="line">        const int n = nums.size();</span><br><span class="line">        int ans = 0;</span><br><span class="line">        vector&lt;unordered_map&lt;long long, int&gt;&gt; dp(n);</span><br><span class="line">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">                long long diff = 1ll * nums[i] - nums[j]; //差值</span><br><span class="line">                auto it = dp[j].find(diff);  //查找这个地方是否有差值满足条件</span><br><span class="line">                int cnt = it == dp[j].end() ? 0 : it-&gt;second; //没有记录0，有则取出</span><br><span class="line">                ans += cnt;  //放入答案</span><br><span class="line">                dp[i][diff] += cnt + 1; //此位置为原位置 + 1，下次取出时会直接放入答案</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="感想："><a href="#感想：" class="headerlink" title="感想："></a>感想：</h3><p>第一眼就是动态规划，可是<code>dp</code>数组的含义没有确定好，也找不准状态转移方程，导致写了一大片冗余且错误的代码。</p>
<p>看了官方题解才恍然大悟，评论区有一个观点也让我受益良多：动态规划就是逆向反推，又最后需要求得的答案反推到前面的转移方程。看似自底向上从无到有，实则逆向反推寻找来路</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode.457】环形数组是否存在循环</title>
    <url>/2021/08/08/2021-08-08-%E3%80%90LeetCode.457%E3%80%91%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h3 id="题目：环形数组是否存在循环"><a href="#题目：环形数组是否存在循环" class="headerlink" title="题目：环形数组是否存在循环"></a>题目：环形数组是否存在循环</h3><p>存在一个不含 0 的 环形 数组 <code>nums</code> ，每个 <code>nums[i]</code> 都表示位于下标 i 的角色应该向前或向后移动的下标个数：</p>
<p>如果 <code>nums[i]</code> 是<strong>正数</strong>，向前 移动 <code>nums[i]</code> 步<br>如果 <code>nums[i]</code> 是<strong>负数</strong>，向后 移动 <code>nums[i]</code> 步<br>因为数组是 环形 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。</p>
<p>数组中的 循环 由长度为 k 的下标序列 <code>seq</code> ：</p>
<p>遵循上述移动规则将导致重复下标序列 <code>seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...</code><br>所有 <code>nums[seq[j]]</code> 应当不是 <strong>全正</strong> 就是 <strong>全负</strong><br>k &gt; 1<br>如果 <code>nums</code> 中存在循环，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<span id="more"></span>

<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,-1,1,2,2]</span><br><span class="line">输出：true</span><br><span class="line">解释：存在循环，按下标 0 -&gt; 2 -&gt; 3 -&gt; 0 。循环长度为 3 。</span><br></pre></td></tr></table></figure>



<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：按下标 1 -&gt; 1 -&gt; 1 ... 的运动无法构成循环，因为循环的长度为 1 。根据定义，循环的长度必须大于 1 。</span><br></pre></td></tr></table></figure>



<p>示例 3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-2,1,-1,-2,-2]</span><br><span class="line">输出：false</span><br><span class="line">解释：按下标 1 -&gt; 2 -&gt; 1 -&gt; ... 的运动无法构成循环，因为 nums[1] 是正数，而 nums[2] 是负数。</span><br><span class="line">所有 nums[seq[j]] 应当不是全正就是全负。</span><br></pre></td></tr></table></figure>



<p>提示：</p>
<p><code>1 &lt;= nums.length &lt;= 5000</code><br><code>-1000 &lt;= nums[i] &lt;= 1000</code><br><code>nums[i] != 0</code></p>
<hr>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>我们可以将环形数组理解为图中的 n 个点，<code>nums[i]</code> 表示 i 号点向 <code>(i+nums[i]) mod n</code> 号点连有一条单向边。</p>
<p>注意到这张图中的每个点有且仅有一条出边，这样我们从某一个点出发，沿着单向边不断移动，最终必然会进入一个环中。</p>
<p>我们检查每一个节点，令快慢指针从当前点出发，快指针每次移动两步，慢指针每次移动一步，期间每移动一次，我们都需要检查当前单向边的方向是否与初始方向是否一致，如果不一致，我们即可停止遍历，因为当前路径必然不满足条件。为了降低时间复杂度，我们可以标记每一个点是否访问过，过程中如果我们的下一个节点为已经访问过的节点，则可以停止遍历。</p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //快慢指针</span><br><span class="line">    bool circularArrayLoop(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        auto next = [&amp;](int cur) &#123;</span><br><span class="line">            return ((cur + nums[cur]) % n + n) % n; // 保证返回值在 [0,n) 中</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            //遍历过的自然验证了此处出发是否存在回路</span><br><span class="line">            if (!nums[i]) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            int slow = i, fast = next(i);</span><br><span class="line">            // 判断非零且方向相同</span><br><span class="line">            while (nums[slow] * nums[fast] &gt; 0 &amp;&amp; nums[slow] * nums[next(fast)] &gt; 0) &#123;</span><br><span class="line">                if (slow == fast) &#123;</span><br><span class="line">                    if (slow != next(slow)) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                slow = next(slow);</span><br><span class="line">                fast = next(next(fast));</span><br><span class="line">            &#125;</span><br><span class="line">            //将本轮遍历过的结点置零</span><br><span class="line">            int add = i;</span><br><span class="line">            while (nums[add] * nums[next(add)] &gt; 0) &#123;</span><br><span class="line">                int tmp = add;</span><br><span class="line">                add = next(add);</span><br><span class="line">                nums[tmp] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="难点："><a href="#难点：" class="headerlink" title="难点："></a>难点：</h3><p>1.数据结构的知识如何应用在具体问题中</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode.611】有效三角形的个数</title>
    <url>/2021/08/04/2021-08-04-%E3%80%90LeetCode.611%E3%80%91%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h3 id="题目：有效三角形的个数"><a href="#题目：有效三角形的个数" class="headerlink" title="题目：有效三角形的个数"></a>题目：有效三角形的个数</h3><p>给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。</p>
<p>示例 1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [2,2,3,4]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">有效的组合是: </span><br><span class="line">2,3,4 (使用第一个 2)</span><br><span class="line">2,3,4 (使用第二个 2)</span><br><span class="line">2,2,3</span><br></pre></td></tr></table></figure>



<span id="more"></span>

<p>注意:</p>
<p><code>数组长度不超过1000。</code><br><code>数组里整数的范围为 [0, 1000]。</code></p>
<hr>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>首先，能够组成三角形三条边的条件是 <code>a + b &gt; c</code> ，其中a和b为较小边，那就可以先将数组升序排序。</p>
<p>暴力解法是三重循环枚举数组，找出符合条件的组合并计数，时间复杂度<code>O(n^3)</code></p>
<p>对于需要循环遍历的算法，有个常用的优化时间方法就是二分法，本题中前两个数字用循环遍历，最后一个数字使用二分法，时间复杂度<code>O(n^2 * logn)</code></p>
<p>还可以进一步优化，就是双指针法，可以发现，如果我们固定 i，那么随着 j 的递增，不等式 <code>nums[i]+ nums[j]</code> 也是递增的，因此 k 也是递增的，这样一来，我们就可以将 j 和 k 看成两个同向（递增）移动的指针</p>
<p>在第一个数字的循环中，就定义最后一个数字，即第二个数字和最后一个数字都有各自的递增路线，只要找到各自符合的位置即可，时间复杂度<code>O(n * (n + n) = O(n^2)</code></p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //排序 + 双指针法</span><br><span class="line">    int triangleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        if(nums.size() &lt; 3) return 0;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        int ret = 0;</span><br><span class="line">        for(int i = 0; i &lt;= nums.size() - 3; ++i)&#123;</span><br><span class="line">            int k = i + 2;</span><br><span class="line">            for(int j = i + 1; j &lt;= nums.size() - 2; ++j)&#123;</span><br><span class="line">                while(k &lt; nums.size() &amp;&amp; nums[i] + nums[j] &gt; nums[k]) k++;</span><br><span class="line">                ret += max(--k - j, 0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //排序 + 二分法</span><br><span class="line">    // int triangleNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    //     if(nums.size() &lt; 3) return 0;</span><br><span class="line">    //     sort(nums.begin(), nums.end());</span><br><span class="line">    //     int ret = 0;</span><br><span class="line">    //     for(int i = 0; i &lt;= nums.size() - 3; ++i)&#123;</span><br><span class="line">    //         for(int j = i + 1; j &lt;= nums.size() - 2; ++j)&#123;</span><br><span class="line">    //             int k = j;</span><br><span class="line">    //             int left = j + 1, right = nums.size() - 1;</span><br><span class="line">    //             while(left &lt;= right)&#123;</span><br><span class="line">    //                 int mid = (right - left) / 2 + left;</span><br><span class="line">    //                 if(nums[i] + nums[j] &gt; nums[mid]) &#123;</span><br><span class="line">    //                     left = mid + 1;</span><br><span class="line">    //                     k =  mid;</span><br><span class="line">    //                 &#125;</span><br><span class="line">    //                 else right = mid - 1;</span><br><span class="line">    //             &#125;</span><br><span class="line">    //             ret += k - j;</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     return ret;</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="收获："><a href="#收获：" class="headerlink" title="收获："></a>收获：</h3><p>1.优化循环遍历可以用二分法</p>
<p>2.根据公式如何找出潜在的规律，逃出多重循环</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>双指针法</tag>
      </tags>
  </entry>
  <entry>
    <title>《Robbie Swifthand》Unity2d独立游戏学习（五）</title>
    <url>/2021/07/30/2021-07-30-%E3%80%8ARobbie%20Swifthand%E3%80%8BUnity2d%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<h3 id="始、前言"><a href="#始、前言" class="headerlink" title="始、前言"></a>始、前言</h3><p>一个小知识，预制体放入场景中后，如果在场景中的物体修改完想同步到预制体，需要选择场景中物体的 Inspector → Prefab → Overrides → Apply All</p>
<span id="more"></span>

<hr>
<h3 id="一、角色动画"><a href="#一、角色动画" class="headerlink" title="一、角色动画"></a>一、角色动画</h3><p>1.打开Robbie 文件夹将资源里的材质拖拽到场景中主角的子物体中，并关闭原父物体的Render</p>
<p>2.发现新加的body 里骨骼的Sorting Layer 全是Default ，直接修改Sorting Layer 的顺序好了，把Default 移动到背景的下方，这样就会显示在背景的前面</p>
<p>3.打开body的Animator 看看，已经有几个变量和连接好的状态机</p>
<p>4.新建脚本PlayerAnimation 挂到body上 ，先获取组件和变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Animator anim;</span><br><span class="line">   PlayerMovement movement;</span><br><span class="line">   Rigidbody2D rb;</span><br><span class="line">   </span><br><span class="line">   void Start()</span><br><span class="line">   &#123;</span><br><span class="line">       anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">       movement = GetComponentInParent&lt;PlayerMovement&gt;();</span><br><span class="line">       rb = GetComponentInParent&lt;Rigidbody2D&gt;();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>GetComponentInParent可以获取父级的组件</p>
<p>状态机中已经添加了很多动画效果，但是跳跃的还没有，那现在就来自己添加跳跃的动画效果</p>
<p>5.打开混合树Mid Air，同时打开资源中动画资源的MId Air文件夹，给混合树添加7个MId Air的动画资源，设置参考变量为verticalVelocity，然后按照动作设置好各自的值（值的大小就参照跳跃时Rigidbody的Velocity.y 的值）</p>
<p>6..获取角色移动代码PlayerMovement中的变量，记得先改成Public类型。然后用编号法给动画变量赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//动画状态编号</span><br><span class="line">int groundID;</span><br><span class="line">int speedID;</span><br><span class="line">int crouchID;</span><br><span class="line">int hangingID;</span><br><span class="line">int fallID;</span><br><span class="line"></span><br><span class="line">void Start()</span><br><span class="line">&#123;</span><br><span class="line">    groundID = Animator.StringToHash(&quot;isOnGround&quot;);</span><br><span class="line">    speedID = Animator.StringToHash(&quot;speed&quot;);</span><br><span class="line">    hangingID = Animator.StringToHash(&quot;isHanging&quot;);</span><br><span class="line">    crouchID = Animator.StringToHash(&quot;isCrouching&quot;);</span><br><span class="line">    fallID = Animator.StringToHash(&quot;verticalVelocity&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Update()</span><br><span class="line">&#123;</span><br><span class="line">    anim.SetFloat(speedID, Mathf.Abs(movement.xVelocity));//撞墙也会继续跑</span><br><span class="line">    /*anim.SetFloat(speedID, Mathf.Abs(rb.velocity.x));*/ //撞墙停下</span><br><span class="line">    anim.SetBool(groundID, movement.isOnGround);</span><br><span class="line">    anim.SetBool(crouchID, movement.isCrouch);</span><br><span class="line">    anim.SetBool(hangingID, movement.isHanging);</span><br><span class="line">    anim.SetFloat(fallID, rb.velocity.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Animator.StringToHash() 可以获取变量在变量列表中的编号</p>
<p>为什么官方推荐用编号来赋值呢？给出的解释是这样可以避免移动端可能产生的一些错误</p>
<hr>
<h3 id="二、音效控制"><a href="#二、音效控制" class="headerlink" title="二、音效控制"></a>二、音效控制</h3><p>在角色的走路和下蹲走路的动画中都插入了一些音效，模拟脚步的声音，现在就来补上这些音效</p>
<p>1.在PlayerAnimation 脚本中添加对应的发声函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void StepAudio()</span><br><span class="line">&#123;</span><br><span class="line">    AudioManager.PlayFootstepAudio();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void CrouchStepAudio()</span><br><span class="line">&#123;</span><br><span class="line">    AudioManager.PlayCrouchFootstepAudio();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>名字不同的话记得修改动画中调用的函数</p>
<p>2.将Audios文件夹中的预制体Audio Manager加入场景中</p>
<p>3.新建AudioManager脚本挂在Audio Manager物体中（绕口令？），先新建一些变量来存放音效资源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static AudioManager current;</span><br><span class="line"></span><br><span class="line">[Header(&quot;环境声音&quot;)]</span><br><span class="line">public AudioClip ambientClip;</span><br><span class="line">public AudioClip musicClip;</span><br><span class="line"></span><br><span class="line">[Header(&quot;主角音效&quot;)]</span><br><span class="line">public AudioClip[] walkStepClips;</span><br><span class="line">public AudioClip[] crouchStepClips;</span><br><span class="line">public AudioClip jumpClip;</span><br><span class="line">public AudioClip jumpVoiceClip;</span><br></pre></td></tr></table></figure>

<p>然后将资源里的音效资源拖拽到相应的变量位置，这样就可以在代码中控制音效播放</p>
<p>4.我们需要在游戏一开始就处理好音效的事情，所以用Awake函数来进行各种设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void Awake()</span><br><span class="line">&#123;</span><br><span class="line">    current = this;</span><br><span class="line"></span><br><span class="line">    //切换场景也不会销毁这个物体</span><br><span class="line">    DontDestroyOnLoad(gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>5.为了避免在属性界面中处理太多的组件，选择在代码中添加组件，这样有助于同一管理并且减少失误的发生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//声音播放组件</span><br><span class="line">AudioSource ambientSource;</span><br><span class="line">AudioSource musicSource;</span><br><span class="line">AudioSource fxSource;</span><br><span class="line">AudioSource playerSource;</span><br><span class="line">AudioSource voiceSource;</span><br><span class="line"></span><br><span class="line">private void Awake()</span><br><span class="line">&#123;</span><br><span class="line">    ambientSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class="line">    musicSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class="line">    fxSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class="line">    playerSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class="line">    voiceSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>6.编写背景声音的发声函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void StartLevelAudio()</span><br><span class="line">&#123;</span><br><span class="line">    current.ambientSource.clip = current.ambientClip;</span><br><span class="line">    current.ambientSource.loop = true;</span><br><span class="line">    current.ambientSource.Play();</span><br><span class="line"></span><br><span class="line">    current.musicSource.clip = current.musicClip;</span><br><span class="line">    current.musicSource.loop = true;</span><br><span class="line">    current.musicSource.Play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本脚本Awake()调用，一开始运行游戏就有背景声音</p>
<p>7.编写脚步声音的两种发声函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void PlayFootstepAudio()</span><br><span class="line">&#123;</span><br><span class="line">    int index = Random.Range(0, current.walkStepClips.Length);</span><br><span class="line"></span><br><span class="line">    current.playerSource.clip = current.walkStepClips[index];</span><br><span class="line">    current.playerSource.Play();</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">public static void PlayCrouchFootstepAudio()</span><br><span class="line">&#123;</span><br><span class="line">    int index = Random.Range(0, current.crouchStepClips.Length);</span><br><span class="line"></span><br><span class="line">    current.playerSource.clip = current.crouchStepClips[index];</span><br><span class="line">    current.playerSource.Play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在PlayerAnimation脚本中调用，因为这是在动画中调用的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void StepAudio()</span><br><span class="line">&#123;</span><br><span class="line">    AudioManager.PlayFootstepAudio();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void CrouchStepAudio()</span><br><span class="line">&#123;</span><br><span class="line">    AudioManager.PlayCrouchFootstepAudio();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>8.编写跳跃声音的发声函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void PlayJumpAudio()</span><br><span class="line">&#123;</span><br><span class="line">    current.playerSource.clip = current.jumpClip;</span><br><span class="line">    current.playerSource.Play();</span><br><span class="line"></span><br><span class="line">    current.voiceSource.clip = current.jumpVoiceClip;</span><br><span class="line">    current.voiceSource.Play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中包括了起跳的脚步声和人物声，在PlayerMovement脚本中的跳跃函数中的起跳部分调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   void MidAirMovement()//空中移动</span><br><span class="line">   &#123;</span><br><span class="line">       if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump &amp;&amp; !isHeadBlocked)//起跳</span><br><span class="line">       &#123;</span><br><span class="line">           AudioManager.PlayJumpAudio();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="终、本节总结"><a href="#终、本节总结" class="headerlink" title="终、本节总结"></a>终、本节总结</h3><p>测试游戏，移动时发现主角的反光情况有些不对劲，原因是角色移动时图案的翻转代码中用的是二维的向量，这样就会使得z 轴大小变为0 ，即厚度没了人物瘪了光也反不了了，要改成三维向量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void flipDirection()//改变角色图案方向</span><br><span class="line">&#123;</span><br><span class="line">    if (xVelocity &gt; 0) transform.localScale = new Vector3 (1, 1, 1);</span><br><span class="line">    else if (xVelocity &lt; 0) transform.localScale = new Vector3(-1, 1, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面记录一下这次新增的两个脚本内容：</p>
<p>PlayerAnimation脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class PlayerAnimation : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Animator anim;</span><br><span class="line">    PlayerMovement movement;</span><br><span class="line">    Rigidbody2D rb;</span><br><span class="line"></span><br><span class="line">    //动画状态编号</span><br><span class="line">    int groundID;</span><br><span class="line">    int speedID;</span><br><span class="line">    int crouchID;</span><br><span class="line">    int hangingID;</span><br><span class="line">    int fallID;</span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">        movement = GetComponentInParent&lt;PlayerMovement&gt;();</span><br><span class="line">        rb = GetComponentInParent&lt;Rigidbody2D&gt;();</span><br><span class="line"></span><br><span class="line">        groundID = Animator.StringToHash(&quot;isOnGround&quot;);</span><br><span class="line">        speedID = Animator.StringToHash(&quot;speed&quot;);</span><br><span class="line">        hangingID = Animator.StringToHash(&quot;isHanging&quot;);</span><br><span class="line">        crouchID = Animator.StringToHash(&quot;isCrouching&quot;);</span><br><span class="line">        fallID = Animator.StringToHash(&quot;verticalVelocity&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        anim.SetFloat(speedID, Mathf.Abs(movement.xVelocity));//撞墙也会继续跑</span><br><span class="line">        /*anim.SetFloat(speedID, rb.velocity.x);*/ //撞墙停下</span><br><span class="line">        anim.SetBool(groundID, movement.isOnGround);</span><br><span class="line">        anim.SetBool(crouchID, movement.isCrouch);</span><br><span class="line">        anim.SetBool(hangingID, movement.isHanging);</span><br><span class="line">        anim.SetFloat(fallID, rb.velocity.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void StepAudio()</span><br><span class="line">    &#123;</span><br><span class="line">        AudioManager.PlayFootstepAudio();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void CrouchStepAudio()</span><br><span class="line">    &#123;</span><br><span class="line">        AudioManager.PlayCrouchFootstepAudio();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>AudioManager脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">using UnityEngine.Audio;</span><br><span class="line"></span><br><span class="line">public class AudioManager : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    static AudioManager current;</span><br><span class="line"></span><br><span class="line">    [Header(&quot;环境声音&quot;)]</span><br><span class="line">    public AudioClip ambientClip;</span><br><span class="line">    public AudioClip musicClip;</span><br><span class="line"></span><br><span class="line">    [Header(&quot;主角音效&quot;)]</span><br><span class="line">    public AudioClip[] walkStepClips;</span><br><span class="line">    public AudioClip[] crouchStepClips;</span><br><span class="line">    public AudioClip jumpClip;</span><br><span class="line">    public AudioClip jumpVoiceClip;</span><br><span class="line"></span><br><span class="line">    //声音播放组件</span><br><span class="line">    AudioSource ambientSource;</span><br><span class="line">    AudioSource musicSource;</span><br><span class="line">    AudioSource fxSource;</span><br><span class="line">    AudioSource playerSource;</span><br><span class="line">    AudioSource voiceSource;</span><br><span class="line"></span><br><span class="line">    private void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        current = this;</span><br><span class="line"></span><br><span class="line">        //切换场景也不会销毁这个物体</span><br><span class="line">        DontDestroyOnLoad(gameObject);</span><br><span class="line"></span><br><span class="line">        ambientSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class="line">        musicSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class="line">        fxSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class="line">        playerSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class="line">        voiceSource = gameObject.AddComponent&lt;AudioSource&gt;();</span><br><span class="line"></span><br><span class="line">        StartLevelAudio();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void StartLevelAudio()</span><br><span class="line">    &#123;</span><br><span class="line">        current.ambientSource.clip = current.ambientClip;</span><br><span class="line">        current.ambientSource.loop = true;</span><br><span class="line">        current.ambientSource.Play();</span><br><span class="line"></span><br><span class="line">        current.musicSource.clip = current.musicClip;</span><br><span class="line">        current.musicSource.loop = true;</span><br><span class="line">        current.musicSource.Play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void PlayFootstepAudio()</span><br><span class="line">    &#123;</span><br><span class="line">        int index = Random.Range(0, current.walkStepClips.Length);</span><br><span class="line"></span><br><span class="line">        current.playerSource.clip = current.walkStepClips[index];</span><br><span class="line">        current.playerSource.Play();</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    public static void PlayCrouchFootstepAudio()</span><br><span class="line">    &#123;</span><br><span class="line">        int index = Random.Range(0, current.crouchStepClips.Length);</span><br><span class="line"></span><br><span class="line">        current.playerSource.clip = current.crouchStepClips[index];</span><br><span class="line">        current.playerSource.Play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void PlayJumpAudio()</span><br><span class="line">    &#123;</span><br><span class="line">        current.playerSource.clip = current.jumpClip;</span><br><span class="line">        current.playerSource.Play();</span><br><span class="line"></span><br><span class="line">        current.voiceSource.clip = current.jumpVoiceClip;</span><br><span class="line">        current.voiceSource.Play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>c#</tag>
        <tag>animator</tag>
        <tag>audio</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode.1143】最长公共子序列</title>
    <url>/2021/07/26/2021-07-26-%E3%80%90LeetCode.1143%E3%80%91%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h3 id="题目：-最长公共子序列"><a href="#题目：-最长公共子序列" class="headerlink" title="题目： 最长公共子序列"></a>题目： 最长公共子序列</h3><p>​    给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 公共子序列 ，返回 <code>0</code> 。</p>
<p>​    一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<p>​    例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。<br>​    两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<span id="more"></span>

<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure>



<p>提示：</p>
<p><code>1 &lt;= text1.length, text2.length &lt;= 1000</code><br><code>text1 和 text2 仅由小写英文字符组成。</code></p>
<hr>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>定义 <code>dp[i][j]</code> 表示 <code>text1[0:i]</code> 和 <code>text2[0:j]</code> 的最长公共子序列，其中 <code>text1[0:i]</code> 表示数组中从<code>0</code>到<code>i</code>长度为 <code>i + 1</code>的子数组</p>
<p>当 <code>text1[i - 1] == text2[j - 1]</code> 时，说明两个子字符串的最后一位相等，所以最长公共子序列又增加了 <code>1</code>，所以 <code>dp[i][j] = dp[i - 1][j - 1] + 1</code>；举个例子，比如对于 <code>ac</code> 和 <code>bc</code> 而言，他们的最长公共子序列的长度等于 <code>a</code> 和 <code>b</code> 的最长公共子序列长度 <code>0 + 1 = 1</code>。<br>当 <code>text1[i - 1] != text2[j - 1]</code> 时，说明两个子字符串的最后一位不相等，那么此时的状态 <code>dp[i][j]</code> 应该是 <code>dp[i - 1][j]</code> 和 <code>dp[i][j - 1]</code> 的最大值。举个例子，比如对于 <code>ace</code> 和 <code>bc</code> 而言，他们的最长公共子序列的长度等于 ① <code>ace</code> 和 <code>b</code> 的最长公共子序列长度<code>0</code> 与 ② <code>ac</code> 和 <code>bc</code> 的最长公共子序列长度<code>1</code> 的最大值，即 <code>1</code>。</p>
<p>综上状态转移方程为：</p>
<p><code>dp[i][j] = dp[i - 1][j - 1] + 1, 当 text1[i - 1] == text2[j - 1];text1[i−1]==text2[j−1];</code><br><code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]), 当 text1[i - 1] != text2[j - 1]text1[i−1]!=text2[j−1]</code></p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">	//动态规划</span><br><span class="line">    int longestCommonSubsequence(string text1, string text2) &#123;</span><br><span class="line">        int n = text1.size(), m = text2.size();</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1));</span><br><span class="line">        //逐渐将text1[i - 1]和text2[j - 1]纳入考虑，更新dp数组</span><br><span class="line">        for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">            char c1 = text1[i - 1];</span><br><span class="line">            for(int j = 1; j &lt;= m; j++)&#123;</span><br><span class="line">                char c2 = text2[j - 1];</span><br><span class="line">                if(c1 == c2) dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">                else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>遇到考查动态规划的题也算有点头绪了，我的感悟是这是一种从无到有的思想：一步一步将单个信息纳入考虑范围，然后按照条件更新已知的情报。其中的难点在于<code>dp</code>数组的定义，怎么样的定义才能有效快捷地达成目的呢？</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>《Robbie Swifthand》Unity2d独立游戏学习（四）</title>
    <url>/2021/07/23/2021-07-23-%E3%80%8ARobbie%20Swifthand%E3%80%8BUnity2d%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h3 id="始、前言"><a href="#始、前言" class="headerlink" title="始、前言"></a>始、前言</h3><p>接下来做一些视觉上的东西，首先是让镜头跟随主角移动，还有场景的灯光效果</p>
<span id="more"></span>

<hr>
<h3 id="一、摄像机"><a href="#一、摄像机" class="headerlink" title="一、摄像机"></a>一、摄像机</h3><p>1.可以选择Camera 修改背景颜色</p>
<p>2.将摄像机的Projection 修改为Perspective，这样就设置成了透视模式，可以通过修改图层深度来产生景深效果</p>
<p>3.为了产生景深效果，将Grid 中的Background 的Transform → Position → z 设置为 1， 同样地，将Background Details 设置为0.99，Platforms 不变， Shadow 为 - 0.1</p>
<p>4.在unity界面Window → Package Manager 中添加 Cinemachine</p>
<p>5.创建2D Camera物体，将主角拖拽到相机的Follow中，摄像机会跟随角色移动</p>
<p>6.可以设置Camera Distance 到一个合适的位置，这个选项会影响游戏画面的远近</p>
<p>7.选择2D Camera → Extensions → Add Extension 添加一个CinemachineConfiner</p>
<p>8.新建空项目，添加多边形碰撞体，设置成触发器，拖拽到2D摄像机的Confiner中。这样就可以通过调整多边形的形状来限制摄像机的移动范围啦</p>
<p>完成，调试</p>
<p>发现阴影没有遮挡角色，要把Shadow 的Sorting Layer 修改成Foreground</p>
<hr>
<h3 id="二、2D灯光效果"><a href="#二、2D灯光效果" class="headerlink" title="二、2D灯光效果"></a>二、2D灯光效果</h3><p>1.在Props 中找到墙灯，打开预制体修改父物体和子物体的Sorting Layer为Background（粒子效果又是一个大坑）</p>
<p>2.拖入场景之前添加点光源，设置光源的z 轴为 -0.2 ，这样就可以在所有背景的前面照亮它们（更靠近摄像机），还可以修改颜色的照明距离等</p>
<p>拖入火炬后为什么场景没有被照亮呢？因为场景中的物体都还没添加法线贴图</p>
<p>3.打开Level 文件夹，将Platform 和Background 的材质球拖入对应的场景物体中（材质会自动对应瓦片）</p>
<p>4.打开Props 添加另外一种灯：悬挂蓝灯，蓝灯会左右摇摆，因为它有一个动画效果修改z 轴旋转</p>
<p>5.调整场景的整体灯光，打开Window → Rendering → Lighting，在Environment Lighting 中可以调整颜色和亮度</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>c#</tag>
        <tag>camera</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode.138】 复制带随机指针的链表</title>
    <url>/2021/07/22/2021-07-22-%E3%80%90LeetCode.138%E3%80%91%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="题目：复制带随机指针的链表"><a href="#题目：复制带随机指针的链表" class="headerlink" title="题目：复制带随机指针的链表"></a>题目：复制带随机指针的链表</h3><p>​    给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>
<p>​    构造这个链表的 <strong>深拷贝</strong>。 深拷贝应该正好由 <code>n</code> 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。</p>
<p>​    例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 x 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p>
<p>​    返回复制链表的头节点。</p>
<p>​    用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p>
<p><strong>val</strong>：一个表示 <code>Node.val</code> 的整数。<br><strong>random_index</strong>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为  <code>null</code> 。<br>    你的代码 只 接受原链表的头节点 <code>head</code> 作为传入参数。</p>
 <span id="more"></span>

<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [[1,1],[2,1]]</span><br><span class="line">输出：[[1,1],[2,1]]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [[3,null],[3,0],[3,null]]</span><br><span class="line">输出：[[3,null],[3,0],[3,null]]</span><br></pre></td></tr></table></figure>

<p>示例 4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br><span class="line">解释：给定的链表为空（空指针），因此返回 null。</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<p><code>0 &lt;= n &lt;= 1000</code><br><code>-10000 &lt;= Node.val &lt;= 10000</code><br><code>Node.random 为空（null）或指向链表中的节点。</code></p>
<hr>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>​    首先将该链表中每一个节点拆分为两个相连的节点，例如对于链表 <code>A→B→C</code>，我们可以将其拆分为 <code>A→A ′ →B→B ′ →C→C ′</code> 。对于任意一个原节点 <code>S</code>，其拷贝节点 <code>S ′</code> 即为其后继节点。</p>
<p>​    这样，我们可以直接找到每一个拷贝节点 <code>S ′</code> 的随机指针应当指向的节点，即为其原节点 <code>S</code> 的随机指针指向的节点 <code>T</code> 的后继节点 <code>T ′</code> 。需要注意原节点的随机指针可能为空，我们需要特别判断这种情况。</p>
<p>当我们完成了拷贝节点的随机指针的赋值，我们只需要将这个链表按照原节点与拷贝节点的种类进行拆分即可，只需要遍历一次。同样需要注意最后一个拷贝节点的后继节点为空，我们需要特别判断这种情况。</p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    Node* copyRandomList(Node* head) &#123;</span><br><span class="line">        if(!head) return NULL;</span><br><span class="line">        Node * ret = head;</span><br><span class="line">        </span><br><span class="line">        // 将A→B→C，拆分为 A→A ′ →B→B ′ →C→C ′</span><br><span class="line">        while(ret)&#123;</span><br><span class="line">            Node *q = new Node(ret-&gt;val);</span><br><span class="line">            q-&gt;next = ret-&gt;next;   </span><br><span class="line">            ret-&gt;next = q;      </span><br><span class="line">            ret = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = head;</span><br><span class="line">        </span><br><span class="line">        // S ′ 指向其原节点 S 的随机指针指向的节点 T 的后继节点 T ′</span><br><span class="line">        while(ret)&#123;</span><br><span class="line">            Node* pre = ret;</span><br><span class="line">            ret = ret-&gt;next;</span><br><span class="line">            if(pre-&gt;random) ret-&gt;random = pre-&gt;random-&gt;next;</span><br><span class="line">            else ret-&gt;random = NULL;            </span><br><span class="line">            ret = ret-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = head-&gt;next;</span><br><span class="line">        Node* p = head;</span><br><span class="line">        Node * q = ret;</span><br><span class="line">        Node * now = ret;</span><br><span class="line">        </span><br><span class="line">        //拆分原数组和拷贝数组</span><br><span class="line">        while(p-&gt;next)&#123;</span><br><span class="line">            now = now-&gt;next;</span><br><span class="line">            q = p-&gt;next;</span><br><span class="line">            p-&gt;next = now;          </span><br><span class="line">            p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>原地算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>《Robbie Swifthand》Unity2d独立游戏学习（三）</title>
    <url>/2021/07/20/2021-07-20-%E3%80%8ARobbie%20Swifthand%E3%80%8BUnity2d%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h3 id="始、前言"><a href="#始、前言" class="headerlink" title="始、前言"></a>始、前言</h3><p>简单的角色移动已经完成了，这次来学习用Raycast 射线检测的方法让角色的状态检测变得更细致</p>
<span id="more"></span>

<hr>
<h3 id="一、Physics2D-Raycast-脚本API"><a href="#一、Physics2D-Raycast-脚本API" class="headerlink" title="一、Physics2D.Raycast 脚本API"></a>一、Physics2D.Raycast 脚本API</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static RaycastHit2D Raycast (Vector2 origin, Vector2 direction, float distance= Mathf.Infinity, int layerMask= DefaultRaycastLayers, float minDepth= -Mathf.Infinity, float maxDepth= Mathf.Infinity);</span><br></pre></td></tr></table></figure>

<p>参数</p>
<table>
<thead>
<tr>
<th>origin</th>
<th>射线在 2D 空间中的起点。</th>
</tr>
</thead>
<tbody><tr>
<td>direction</td>
<td>表示射线方向的矢量。</td>
</tr>
<tr>
<td>distance</td>
<td>射线的最大投射距离。</td>
</tr>
<tr>
<td>layerMask</td>
<td>过滤器，用于仅在特定层上检测碰撞体。</td>
</tr>
<tr>
<td>minDepth</td>
<td>仅包括 Z 坐标（深度）大于或等于该值的对象。</td>
</tr>
<tr>
<td>maxDepth</td>
<td>仅包括 Z 坐标（深度）小于或等于该值的对象。</td>
</tr>
</tbody></table>
<p>返回**<code>RaycastHit2D</code>** 返回的投射数量。</p>
<p>描述：</p>
<p>向场景中的碰撞体投射射线。</p>
<p>从概念上说，<em>射线投射</em> 类似于从空间中的某个点朝特定方向发射一条光束。在该过程中，可以检测并报告与光束接触的任何对象。</p>
<p>函数返回一个 <code>RaycastHit</code> 对象，该对象引用了射线命中的碰撞体（如果未命中任何对象，则结果的碰撞体属性将为 NULL）。*<code>layerMask</code>* 可用于仅在特定层上有选择地检测对象（例如，这让您能够仅将检测应用于敌人角色）。</p>
<p>使用 <code>contactFilter</code> 的此方法重载可以按 <code>ContactFilter2D</code> 中提供的选项筛选结果。</p>
<p>对于确定视线、炮火击中的目标以及游戏中的许多其他目的来说，射线投射很有用。</p>
<p>此外，这还将检测位于射线起点的碰撞体。在这种情况下，射线从碰撞体内部开始，并且不与碰撞体表面交叠。这意味着无法计算碰撞法线，在这种情况下，返回的碰撞法线设置为正在测试的射线向量的倒数。这可轻松检测到，因为此类结果始终是 <code>RaycastHit2D</code> 分数为零。</p>
<hr>
<h3 id="二、脚部、头顶碰撞"><a href="#二、脚部、头顶碰撞" class="headerlink" title="二、脚部、头顶碰撞"></a>二、脚部、头顶碰撞</h3><ol>
<li>在<code>[Header(&quot;环境检测&quot;)]</code>新建几个需要用到的变量</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Header(&quot;环境检测&quot;)]</span><br><span class="line">public LayerMask groundLayer;</span><br><span class="line">public float footOffset = 0.35f;</span><br><span class="line">public float headClearance = 0.5f;</span><br><span class="line">public float groundDistance = 0.2f;</span><br></pre></td></tr></table></figure>



<p>2.重写一个射线检测的方法，包含射线可视化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer)//自己封装的射线检测方法</span><br><span class="line">&#123;</span><br><span class="line">    Vector2 pos = transform.position;</span><br><span class="line">    RaycastHit2D hit = Physics2D.Raycast(pos + offset, rayDirection, length, layer);</span><br><span class="line">    Debug.DrawRay(pos + offset, rayDirection, hit ? Color.red : Color.green);</span><br><span class="line">    return hit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3.更改地面检测函数<code>PhysicsCheck()</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class="line">&#123;</span><br><span class="line">    RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class="line">    RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class="line">    isOnGround = leftCheck || rightCheck;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存回到unity，运行</p>
<p>角色碰撞体左右脚下方都出现了射线，并且会按照射线方向检测是否碰撞到地面，以此改变<code>isOnGround</code>，可以调整参数让检测距离更 “舒服”</p>
<p>下面来增加头顶的检测</p>
<p>4.在<code>[Header(&quot;角色状态&quot;)]</code>中增加头顶状态 <code>public bool isHeadBlocked;</code></p>
<p>5.修改<code>PhysicsCheck()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class="line">&#123;</span><br><span class="line">    RaycastHit2D leftCheck = Raycast(new Vector2(-footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class="line">    RaycastHit2D rightCheck = Raycast(new Vector2(footOffset, 0.2f), Vector2.down, groundDistance, groundLayer);</span><br><span class="line">    isOnGround = leftCheck || rightCheck;</span><br><span class="line"></span><br><span class="line">    RaycastHit2D headCheck = Raycast(new Vector2(0f, cd.size.y), Vector2.up, headClearance, groundLayer);</span><br><span class="line">    isHeadBlocked = headCheck;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，修改<code>public</code>参数就可以调整检测距离（注意射线的长度不等于检测距离）</p>
<hr>
<h3 id="三、悬挂检测"><a href="#三、悬挂检测" class="headerlink" title="三、悬挂检测"></a>三、悬挂检测</h3><p>判断悬挂需要三条射线，分别是头顶射线，眼部射线，垂直射线。</p>
<p>悬挂在边缘的条件：头顶射线<strong>无</strong>碰撞，眼部射线有碰撞，垂直射线<strong>有</strong>碰撞</p>
<p>1.在<code>[Header(&quot;环境检测&quot;)]</code>添加变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Header(&quot;环境检测&quot;)]</span><br><span class="line">//悬挂</span><br><span class="line">public float playerHeight = 2f;</span><br><span class="line">public float playerEyeHeight = 1.5f;</span><br><span class="line">public float grabDistance = 0.2f;</span><br><span class="line">public float reachOffset = 0.5f;</span><br></pre></td></tr></table></figure>



<p>2.在<code>[Header(&quot;角色状态&quot;)]</code>添加状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Header(&quot;角色状态&quot;)]</span><br><span class="line">   public bool isHanging;</span><br></pre></td></tr></table></figure>



<p>3.在<code>PhysicsCheck()</code>中添加悬挂的各种射线生成以及悬挂状态判断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void PhysicsCheck()//物理检测，并修改状态</span><br><span class="line">&#123;</span><br><span class="line">    //悬挂系列射线</span><br><span class="line">    float direction = transform.localScale.x;</span><br><span class="line">    Vector2 grabDirection = new Vector2(direction, 0f);</span><br><span class="line">    RaycastHit2D blockedCheck = Raycast(new Vector2(direction * footOffset, playerHeight), grabDirection, grabDistance, groundLayer);</span><br><span class="line">    RaycastHit2D wallCheck = Raycast(new Vector2(direction * footOffset, playerEyeHeight), grabDirection, grabDistance, groundLayer);</span><br><span class="line">    RaycastHit2D ledgeCheck = Raycast(new Vector2(direction * reachOffset, playerHeight), Vector2.down, grabDistance, groundLayer);</span><br><span class="line">    if (!isOnGround &amp;&amp; !blockedCheck &amp;&amp; wallCheck &amp;&amp; ledgeCheck &amp;&amp; rb.velocity.y &lt; 0f)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 pos = transform.position;</span><br><span class="line">        pos.x += (wallCheck.distance - 0.05f) * direction;</span><br><span class="line">        pos.y -= ledgeCheck.distance;</span><br><span class="line">        transform.position = pos; </span><br><span class="line">        rb.bodyType = RigidbodyType2D.Static;</span><br><span class="line">        isHanging = true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>pos.x += (wallCheck.distance - 0.05f) * direction;</code>稍微调整一下悬挂的位置，可以按照图案的位置来调整</p>
<p>4.悬挂状态已经设置好了，现在我们希望在悬挂时按跳跃键会有一个固定的跳跃高度，并且会取消刚体的锁定</p>
<p>在<code>[Header(&quot;跳跃参数&quot;)]</code>中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Header(&quot;跳跃参数&quot;)]</span><br><span class="line">   public float hangingJumpForce = 15f;</span><br></pre></td></tr></table></figure>



<p>5.在<code>MidAirMovement()</code>添加悬挂跳跃：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void MidAirMovement()//空中移动</span><br><span class="line">&#123;</span><br><span class="line">    if (isHanging)//悬挂时两种选择</span><br><span class="line">    &#123;</span><br><span class="line">        if (jumpPressed)</span><br><span class="line">        &#123;</span><br><span class="line">            rb.bodyType = RigidbodyType2D.Dynamic;</span><br><span class="line">            rb.AddForce(new Vector2(0f, hangingJumpForce), ForceMode2D.Impulse);</span><br><span class="line">            //rb.velocity = new Vector2(rb.velocity.x, hangingJumpForce);</span><br><span class="line">            isHanging = false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (crouchPressed)</span><br><span class="line">        &#123;</span><br><span class="line">            rb.bodyType = RigidbodyType2D.Dynamic;</span><br><span class="line">            crouchPressed = false;</span><br><span class="line">            isHanging = false;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>crouchPressed</code>要在<code>[Header(&quot;按键状态&quot;)]</code>中设置好，并且在<code>Update()</code>中赋值，以此来和<code>crouchHeld</code>分开</p>
<hr>
<h3 id="终、阶段总结"><a href="#终、阶段总结" class="headerlink" title="终、阶段总结"></a>终、阶段总结</h3><p>到此为止，已经完成了各种基础运动的逻辑</p>
<p>自我感觉有些状态的判断没有很好的归类，比如悬挂状态，应该和下蹲&amp;站立一样新建一个悬挂的函数，在悬挂函数中完成悬挂的各种处理，最后使<code>isHanging = true</code>，这样代码应该会比较 ”整齐”</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>c#</tag>
        <tag>raycast</tag>
      </tags>
  </entry>
  <entry>
    <title>《Robbie Swifthand》Unity2d独立游戏学习（二）</title>
    <url>/2021/07/19/2021-07-19-%E3%80%8ARobbie%20Swifthand%E3%80%8BUnity2d%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h3 id="一、添加物理组件"><a href="#一、添加物理组件" class="headerlink" title="一、添加物理组件"></a>一、添加物理组件</h3><p>1.给Platforms 添加Tilemap Collider 2D，勾选Used By Composite，添加Composite Collider 2D</p>
<p>2.将Platforms自动添加的Rigidbody 2D 选择成Static 模式</p>
<p>3.给主角添加Rigidbody 2D，把Collision Detection选择成Continuous连续不断地检测碰撞，把Interpolate 设置成Interpolate产生碰撞时会有一个缓冲的效果</p>
<p>4.添加Box Collider 2D，调整主角碰撞器大小，size - y 最好设置在 2 以下，这样就可以通过两格高的空间</p>
<p>5.运行，发现在角落处下落会导致角色翻转，需要在主角Rigidbody 2D 中锁定 z 轴</p>
<p>6.为了避免角色碰到墙壁时会卡进墙体里，给主角Box Collider 2D添加Material 物理材质Teflon（资源包里的，摩擦力和弹力都是0）</p>
<p>7.新增Layer ，主角设置成Player，Platforms 设置成Ground，以供后面进行碰撞检测</p>
<span id="more"></span>



<hr>
<h3 id="二、角色移动"><a href="#二、角色移动" class="headerlink" title="二、角色移动"></a>二、角色移动</h3><p>1.在Scripts文件夹新建PlayerMovement脚本，编写代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class PlayerMovement : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    private Rigidbody2D rb;</span><br><span class="line"></span><br><span class="line">    [Header(&quot;移动参数&quot;)]</span><br><span class="line">    public float speed = 10f;</span><br><span class="line">    public float crouchSpeedDivisor = 5f;</span><br><span class="line">    private float xVelocity;</span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Update()//每帧调用</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void FixedUpdate()//每一段时间调用，默认0.02s</span><br><span class="line">    &#123;</span><br><span class="line">        GroundMovement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void GroundMovement()</span><br><span class="line">    &#123;</span><br><span class="line">        xVelocity = Input.GetAxis(&quot;Horizontal&quot;);//-1f ~ 1f</span><br><span class="line">        //在FixedUpdate()中调用无需Time.deltatime</span><br><span class="line">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class="line">        flipDirection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void flipDirection()</span><br><span class="line">    &#123;</span><br><span class="line">        if (xVelocity &gt; 0) transform.localScale = new Vector2 (1, 1);</span><br><span class="line">        else if (xVelocity &lt; 0) transform.localScale = new Vector2(-1, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>键盘左右键可以让主角左右移动，并且会改变图案方向</p>
<hr>
<h3 id="三、下蹲"><a href="#三、下蹲" class="headerlink" title="三、下蹲"></a>三、下蹲</h3><p>1.打开Edit - Project Settings - Input ，复制Jump 命名为Crouch，Positive Button 改为down，Alt Positive Button 改为 s</p>
<p>2.修改角色移动代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class PlayerMovement : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    private Rigidbody2D rb;</span><br><span class="line">    private BoxCollider2D cd;</span><br><span class="line"></span><br><span class="line">    [Header(&quot;移动参数&quot;)]</span><br><span class="line">    public float speed = 10f;</span><br><span class="line">    public float crouchSpeedFactor = 0.5f;</span><br><span class="line">    private float xVelocity;</span><br><span class="line"></span><br><span class="line">    [Header(&quot;角色状态&quot;)]</span><br><span class="line">    public bool isCrouch;</span><br><span class="line"></span><br><span class="line">    //碰撞体尺寸</span><br><span class="line">    private Vector2 crouchOffset;</span><br><span class="line">    private Vector2 crouchSize;</span><br><span class="line">    private Vector2 standOffset;</span><br><span class="line">    private Vector2 standSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        cd = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class="line"></span><br><span class="line">        standOffset = cd.offset;</span><br><span class="line">        standSize = cd.size;</span><br><span class="line">        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);</span><br><span class="line">        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void Update()//每帧调用</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void FixedUpdate()//每一段时间调用，默认0.02s</span><br><span class="line">    &#123;</span><br><span class="line">        GroundMovement();</span><br><span class="line">    &#125;</span><br><span class="line">    void GroundMovement()//移动的各种数值</span><br><span class="line">    &#123;</span><br><span class="line">        xVelocity = Input.GetAxis(&quot;Horizontal&quot;);//-1f ~ 1f</span><br><span class="line">        if (Input.GetButton(&quot;Crouch&quot;)) Crouch();</span><br><span class="line">        else if (isCrouch) StandUp();</span><br><span class="line"></span><br><span class="line">        //在FixedUpdate()中调用无需Time.deltatime</span><br><span class="line">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class="line">        flipDirection();</span><br><span class="line">    &#125;</span><br><span class="line">    void flipDirection()//改变角色图案方向</span><br><span class="line">    &#123;</span><br><span class="line">        if (xVelocity &gt; 0) transform.localScale = new Vector2 (1, 1);</span><br><span class="line">        else if (xVelocity &lt; 0) transform.localScale = new Vector2(-1, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Crouch()//下蹲时的各种改变</span><br><span class="line">    &#123;</span><br><span class="line">        isCrouch = true;</span><br><span class="line">        xVelocity *= crouchSpeedFactor;</span><br><span class="line">        cd.size = crouchSize;</span><br><span class="line">        cd.offset = crouchOffset;</span><br><span class="line">    &#125;</span><br><span class="line">    void StandUp()//从下蹲转变为站立时各种变化</span><br><span class="line">    &#123;</span><br><span class="line">        isCrouch = false;</span><br><span class="line">        xVelocity /= crouchSpeedFactor;</span><br><span class="line">        cd.size = standSize;</span><br><span class="line">        cd.offset = standOffset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺便给每个函数添加了注释</p>
<p>现在，按下s键或者方向下键就会让角色的碰撞体 “蹲下” （移动速度变慢并且碰撞体高度减半）</p>
<p>测试一下确实可以通过高度为1的障碍了，但是在经过障碍的途中如果松开下蹲键，就会穿模卡在墙里，因为缺少了在通过障碍时需要持续下蹲的判断，这一部分放到后面再处理</p>
<hr>
<h3 id="四、跳跃"><a href="#四、跳跃" class="headerlink" title="四、跳跃"></a>四、跳跃</h3><p>1.打开Edit - Project Setting - Physics 2D，将 y 轴重力改大一点，这里改为-50</p>
<p>2.先添加与跳跃有关的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Header(&quot;跳跃参数&quot;)]</span><br><span class="line">public float jumpForce = 5f;</span><br><span class="line">public float jumpHoldForce = 3f;</span><br><span class="line">public float jumpHoldDuration = 0.1f;</span><br><span class="line">public float crouchJumpBoost = 3f;</span><br><span class="line">float jumpTime;</span><br></pre></td></tr></table></figure>

<p>其中jumpTime 是允许长按跳跃加高的时间</p>
<p>3.添加判断各种状态的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Header(&quot;按键状态&quot;)]</span><br><span class="line">public bool jumpPressed;</span><br><span class="line">public bool jumpHeld;</span><br><span class="line">public bool crouchHeld;</span><br><span class="line"></span><br><span class="line">[Header(&quot;角色状态&quot;)]</span><br><span class="line">public bool isCrouch;</span><br><span class="line">public bool isOnGround;</span><br><span class="line">public bool isJump;</span><br><span class="line"></span><br><span class="line">[Header(&quot;环境检测&quot;)]</span><br><span class="line">public LayerMask groundLayer;</span><br></pre></td></tr></table></figure>

<p>同时可以更新一下之前的下蹲判断，用刚刚定义的状态参数</p>
<p>4.在Update（）中获取按键信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Update()//每帧调用</span><br><span class="line">&#123;</span><br><span class="line">    //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化</span><br><span class="line">    if (Input.GetButtonDown(&quot;Jump&quot;)) jumpPressed = true;</span><br><span class="line"></span><br><span class="line">    jumpHeld = Input.GetButton(&quot;Jump&quot;);</span><br><span class="line">    crouchHeld = Input.GetButton(&quot;Crouch&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>5.添加判断是否在地面上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class="line">   &#123;</span><br><span class="line">       isOnGround = cd.IsTouchingLayers(groundLayer);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>记得在FixedUpdate（）中调用，物理性质都推荐放在FixedUpdate中</p>
<p>6.添加跳跃函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void MidAirMovement()//跳跃移动</span><br><span class="line">&#123;</span><br><span class="line">    if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump)//起跳</span><br><span class="line">    &#123;</span><br><span class="line">        if(crouchHeld)//判断是否要蹲跳</span><br><span class="line">        &#123;</span><br><span class="line">            rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);</span><br><span class="line">        &#125;</span><br><span class="line">        jumpTime = Time.time + jumpHoldDuration;</span><br><span class="line">        rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);</span><br><span class="line">        jumpPressed = false;</span><br><span class="line">        isJump = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else if(isJump)</span><br><span class="line">    &#123;</span><br><span class="line">        if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);</span><br><span class="line">        if (jumpTime &lt; Time.time) isJump = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>精髓就是<code>jumpTime = Time.time + jumpHoldDuration;</code>，<code>if (jumpTime &lt; Time.time) isJump = false;</code> </p>
<p>这两句代码可以很好地对能否在空中持续加速进行判断</p>
<hr>
<h3 id="终、总结"><a href="#终、总结" class="headerlink" title="终、总结"></a>终、总结</h3><p>这次的跳跃代码真的收获不少，Update和FixedUpdate可以理解成完全独立的两个函数</p>
<p>这一波折腾下来角色控制脚本 PlayerMovement 有点长了，这里先全部放上来记录一下，以便日后回顾</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class PlayerMovement : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    //组件</span><br><span class="line">    private Rigidbody2D rb;</span><br><span class="line">    private BoxCollider2D cd;</span><br><span class="line"></span><br><span class="line">    [Header(&quot;移动参数&quot;)]</span><br><span class="line">    public float speed = 10f;</span><br><span class="line">    public float crouchSpeedFactor = 0.5f;</span><br><span class="line">    float xVelocity;</span><br><span class="line"></span><br><span class="line">    [Header(&quot;跳跃参数&quot;)]</span><br><span class="line">    public float jumpForce = 5f;</span><br><span class="line">    public float jumpHoldForce = 3f;</span><br><span class="line">    public float jumpHoldDuration = 0.1f;</span><br><span class="line">    public float crouchJumpBoost = 3f;</span><br><span class="line">    float jumpTime;</span><br><span class="line"></span><br><span class="line">    [Header(&quot;按键状态&quot;)]</span><br><span class="line">    public bool jumpPressed;</span><br><span class="line">    public bool jumpHeld;</span><br><span class="line">    public bool crouchHeld;</span><br><span class="line"></span><br><span class="line">    [Header(&quot;角色状态&quot;)]</span><br><span class="line">    public bool isCrouch;</span><br><span class="line">    public bool isOnGround;</span><br><span class="line">    public bool isJump;</span><br><span class="line"></span><br><span class="line">    [Header(&quot;环境检测&quot;)]</span><br><span class="line">    public LayerMask groundLayer;</span><br><span class="line"></span><br><span class="line">    //碰撞体尺寸</span><br><span class="line">    private Vector2 crouchOffset;</span><br><span class="line">    private Vector2 crouchSize;</span><br><span class="line">    private Vector2 standOffset;</span><br><span class="line">    private Vector2 standSize;</span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        //获取组件</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        cd = GetComponent&lt;BoxCollider2D&gt;();</span><br><span class="line"></span><br><span class="line">        //初始化</span><br><span class="line">        standOffset = cd.offset;</span><br><span class="line">        standSize = cd.size;</span><br><span class="line">        crouchOffset = new Vector2(standOffset.x, standOffset.y * 0.5f);</span><br><span class="line">        crouchSize = new Vector2(standSize.x, standSize.y * 0.5f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void Update()//每帧调用</span><br><span class="line">    &#123;</span><br><span class="line">        //GetButtonDown不能直接等于，FixedUpdate中的函数可能会检测不到Update中的变化</span><br><span class="line">        if (Input.GetButtonDown(&quot;Jump&quot;)) jumpPressed = true;</span><br><span class="line"></span><br><span class="line">        jumpHeld = Input.GetButton(&quot;Jump&quot;);</span><br><span class="line">        crouchHeld = Input.GetButton(&quot;Crouch&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private void FixedUpdate()//每一段时间调用，unity默认0.02s</span><br><span class="line">    &#123;</span><br><span class="line">        PhysicsCheck();</span><br><span class="line">        GroundMovement();</span><br><span class="line">        MidAirMovement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void PhysicsCheck()//检测是否在地面，并修改状态</span><br><span class="line">    &#123;</span><br><span class="line">        isOnGround = cd.IsTouchingLayers(groundLayer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void GroundMovement()//移动的各种数值</span><br><span class="line">    &#123;</span><br><span class="line">        xVelocity = Input.GetAxis(&quot;Horizontal&quot;);//-1f ~ 1f</span><br><span class="line">        if (crouchHeld &amp;&amp; !isCrouch &amp;&amp; isOnGround) Crouch();</span><br><span class="line">        else if ((isCrouch &amp;&amp; !crouchHeld) || isJump) StandUp();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //在FixedUpdate()中调用无需Time.deltatime</span><br><span class="line">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class="line">        flipDirection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void MidAirMovement()//跳跃移动</span><br><span class="line">    &#123;</span><br><span class="line">        if(jumpPressed &amp;&amp; isOnGround &amp;&amp; !isJump)//起跳</span><br><span class="line">        &#123;</span><br><span class="line">            if(crouchHeld)//判断是否要蹲跳</span><br><span class="line">            &#123;</span><br><span class="line">                rb.AddForce(new Vector2(0f, crouchJumpBoost), ForceMode2D.Impulse);</span><br><span class="line">            &#125;</span><br><span class="line">            jumpTime = Time.time + jumpHoldDuration;</span><br><span class="line">            rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);</span><br><span class="line">            jumpPressed = false;</span><br><span class="line">            isJump = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        else if(isJump)</span><br><span class="line">        &#123;</span><br><span class="line">            if (jumpHeld) rb.AddForce(new Vector2(0f, jumpHoldForce), ForceMode2D.Impulse);</span><br><span class="line">            if (jumpTime &lt; Time.time) isJump = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void flipDirection()//改变角色图案方向</span><br><span class="line">    &#123;</span><br><span class="line">        if (xVelocity &gt; 0) transform.localScale = new Vector2 (1, 1);</span><br><span class="line">        else if (xVelocity &lt; 0) transform.localScale = new Vector2(-1, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Crouch()//下蹲时的各种改变</span><br><span class="line">    &#123;</span><br><span class="line">        isCrouch = true;</span><br><span class="line">        xVelocity *= crouchSpeedFactor;</span><br><span class="line">        cd.size = crouchSize;</span><br><span class="line">        cd.offset = crouchOffset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void StandUp()//从下蹲转变为站立时各种变化</span><br><span class="line">    &#123;</span><br><span class="line">        isCrouch = false;</span><br><span class="line">        xVelocity /= crouchSpeedFactor;</span><br><span class="line">        cd.size = standSize;</span><br><span class="line">        cd.offset = standOffset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>c#</tag>
        <tag>update</tag>
      </tags>
  </entry>
  <entry>
    <title>《Robbie Swifthand》Unity2d独立游戏学习（一）</title>
    <url>/2021/07/18/2021-07-18-%E3%80%8ARobbie%20Swifthand%E3%80%8BUnity2d%E7%8B%AC%E7%AB%8B%E6%B8%B8%E6%88%8F%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="始、前言"><a href="#始、前言" class="headerlink" title="始、前言"></a>始、前言</h3><p>继续跟M大学习unity2d开发，这次是《从独立游戏学习开发》系列，我们将从一款已经上架steam的独立游戏《Robbie Swifthand and the Orb of Mysteries》中学习</p>
<p>版本：</p>
<p>unity 2021.1.12f1c1</p>
<p>vs 2019</p>
<p>unityhub 2.1.14</p>
<span id="more"></span>

<hr>
<h3 id="一、导入资源"><a href="#一、导入资源" class="headerlink" title="一、导入资源"></a>一、导入资源</h3><p>1.资源地址：<a href="https://pan.baidu.com/s/1c0I1pO7Rr8w4s4SGcfscHA">https://pan.baidu.com/s/1c0I1pO7Rr8w4s4SGcfscHA</a></p>
<p>提取码:   a338</p>
<p>2.新建2d unity项目，界面左上角工具栏中Assets - import package - custom assets ，导入刚刚下载的资源</p>
<p>3.导入过程中提示更新API，选择“Yes”</p>
<p>4.导入完成后发现脚本报错，原因是我的新版unity自带的脚本和资源里的有冲突，需要删除对应的新脚本</p>
<hr>
<h3 id="二、整理资源"><a href="#二、整理资源" class="headerlink" title="二、整理资源"></a>二、整理资源</h3><p>导入工作完成后Assets文件夹下出现了大量的文件夹，先看看他们都是些什么</p>
<p>1._Extended：额外的扩展包，后期需要用到的资源</p>
<p>2.Addons：插件，新版本unity有自带的，这里需要删掉</p>
<p>3.Audio：音乐素材</p>
<p>4.Fonts：字体</p>
<p>5.Gizmos：小插件，这里包含2D摄像机跟踪</p>
<p>6.Level：背景前景素材，用于制作透视效果</p>
<p>7.Props：道具，里面是一些游戏元素的预制体</p>
<p>8.Robbie：本游戏主角，包含主角的素材、动画等</p>
<p>9.Scripts：脚本，包含几个简单代码，其他的自己写</p>
<p>10.Tilemaps：用来存放游戏素材，即项目中正在用的素材（为啥得用他给我的文件夹，我就不）</p>
<p>11.UI：用户界面用到的素材</p>
<p>12.VFX：特效</p>
<hr>
<h3 id="三、绘制背景准备工作"><a href="#三、绘制背景准备工作" class="headerlink" title="三、绘制背景准备工作"></a>三、绘制背景准备工作</h3><p>1.找到windows - 2D - Tile Palette调出调色板窗口</p>
<p>2.新建调色板，起名Background，存放到Tilemap文件夹里新建的Palettes文件夹</p>
<p>3.将Level中的素材BG walls 拖入调色板里，保存到Tilemap - Tile 新建的Background文件夹</p>
<p>4.重复2~3步骤，制作Platform和Shadow的调色板，同样管理好切割的瓦片</p>
<p>5.在调色板界面中点击Edit 就可以修改调色板的素材（界面中几个画画工具都玩一下）</p>
<p>6.在Hierarchy中新建2D Object - Tilemap ，命名为Background</p>
<p>7.在调色板Active Tilemap 中可以选择要绘制的对象</p>
<p>8.同样地，在Grid 父物体下新建Tilemap 三个物体，分别命名Background Detailed、Shadow、Platform</p>
<p>9.设置Sorting Layer，添加四种，分别为Background、Platform、Player、Foreground（Sorting Layer 中越往下排的层级在镜头中越靠前）</p>
<p>10.分别设置Tilemap的Sorting Layer ，其中Order In Layer 又可以在同Layer 中再排序一次</p>
<p>（设置都要套娃？）</p>
<p>11.拖入主角Robbie，设置Sorting Layer 为Player</p>
<hr>
<h3 id="四、设置Rule-Tile"><a href="#四、设置Rule-Tile" class="headerlink" title="四、设置Rule Tile"></a>四、设置Rule Tile</h3><p>Rule Tile 是超强的瓦片绘制工具，通过设定瓦片生成规则，实现利用一个瓦片就可以任意拖拽生成各种不规则图案。新版本的unity已经成为内置功能，可以直接创建使用</p>
<p>1.在Tilemaps - Tile - Backgrounds中新建Rule Tile，命名为BG rule ，默认图片随便选个背景瓦片</p>
<p>2.添加瓦片，并给每个瓦片设置规则，上面的规则比下面的规则优先。</p>
<p>规则为：检测九宫格中是否存在其他同样在列表中的瓦片，绿色箭头表示那个方向<strong>必</strong>存在此类瓦片，红色叉叉表示<strong>必</strong>不存在此类瓦片，没有设置的方向就是没要求</p>
<p>3.设置好每个瓦片后，将BG rule 拖入调色板Palette 中， 这样就可以用这个瓦片随意画图啦！</p>
<p>4.多设置几个功能瓦片堆积在一起可以变成大瓦片，方便大面积作图</p>
<p>5.同上，设置Shadows 瓦片的Rule Tile</p>
<p>6.设置Platforms 瓦片的Rule Tile 时，我们希望平台瓦片随机生成，而不用某种特定规则。在Rule Tile 下添加一个瓦片，在Output中选择Random，Size设置为4，将要随机生成的四种瓦片拖入空格中</p>
<hr>
<h3 id="五、绘制地图"><a href="#五、绘制地图" class="headerlink" title="五、绘制地图"></a>五、绘制地图</h3><p>可以随意绘制地图，但是有几个注意点：</p>
<p>1.在调色板中选取瓦片时，要记得在Active Tilemap 中选择要绘制的对象</p>
<p>2.瓦片要绘制两层以上，因为各种规则瓦片在只有一层时会非常难看</p>
<p>3.Shadows 瓦片覆盖在在Platforms 瓦片上面，后面调灯光的时候就会有很美妙的效果</p>
<p>4.地图记得留一个出口位置</p>
<hr>
<h3 id="终、睡觉"><a href="#终、睡觉" class="headerlink" title="终、睡觉"></a>终、睡觉</h3><p>画地图还挺过瘾的，先这样了，洗澡睡觉！</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>c#</tag>
        <tag>tilemap</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode.剑指Offer.42】连续子数组的最大和</title>
    <url>/2021/07/17/2021-07-17-%E3%80%90LeetCode.%E5%89%91%E6%8C%87Offer.42%E3%80%91%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<h3 id="题目：连续子数组的最大和"><a href="#题目：连续子数组的最大和" class="headerlink" title="题目：连续子数组的最大和"></a>题目：连续子数组的最大和</h3><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的<strong>最大值</strong>。</p>
<p>要求时间复杂度为**O(n)**。</p>
<p>示例1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>提示：</p>
<p><code>1 &lt;= arr.length &lt;= 10^5</code><br><code>-100 &lt;= arr[i] &lt;= 100</code></p>
<hr>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>我们用<code> f(i)</code>代表以第<code>i</code>个数结尾的「连续子数组的最大和」</p>
<p>只需要求出每个位置的<code> f(i)</code>，然后返回 <code>f </code>数组中的最大值即可。那么我们如何求<code>f(i)</code>呢？</p>
<p>我们可以考虑 <code>nums[i] </code>单独成为一段还是加入<code>f(i-1)</code>对应的那一段，这取决于<code>nums[i]</code>和<code>f(i−1) + nums[i] </code>的大小，我们希望获得一个比较大的</p>
<p>于是可以写出这样的动态规划转移方程：<br><code>f(i) = max&#123; f(i−1) + nums[i], nums[i] &#125;</code></p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        vector&lt;int&gt; f(n);</span><br><span class="line">        f[0] = nums[0];</span><br><span class="line">        int ret = nums[0];</span><br><span class="line"></span><br><span class="line">        for (int i =  1; i &lt; n; i++) &#123;</span><br><span class="line">            f[i] = max(f[i - 1] + nums[i], nums[i]);</span><br><span class="line">            ret = max(f[i], ret);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(n)</p>
<hr>
<h3 id="改进："><a href="#改进：" class="headerlink" title="改进："></a>改进：</h3><p>由于 <code>f[i]</code> 只是与 <code>f[i - 1]</code> 和 <code>nums[i]</code> 有关，且 <code>ret</code> 只与当前的 <code>f[i]</code> 有关，不需要存储整个数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int nowMax = 0;</span><br><span class="line">        int ret = nums[0];</span><br><span class="line">        for (auto x : nums) &#123;</span><br><span class="line">            nowMax = max(nowMax + x, x);</span><br><span class="line">            ret = max(nowMax, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n)，空间复杂度O(1)</p>
<hr>
<h3 id="细节："><a href="#细节：" class="headerlink" title="细节："></a>细节：</h3><p>1.只需求出最大值，不用求出最大的子数组</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>《Speed Down》Unity2d游戏开发（完）</title>
    <url>/2021/07/16/2021-07-16-%E3%80%8ASpeed%20Down%E3%80%8BUnity2d%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E5%AE%8C%EF%BC%89/</url>
    <content><![CDATA[<h3 id="始、前言"><a href="#始、前言" class="headerlink" title="始、前言"></a>始、前言</h3><p>”《Speed Down》Unity2d游戏开发“系列已经完结，这篇文章主要是复盘这次学习中遇到的问题和一些名词的解释，以供未来的我快速回顾，最后还会附上所有的脚本</p>
<span id="more"></span>

<hr>
<h3 id="一、素材"><a href="#一、素材" class="headerlink" title="一、素材"></a>一、素材</h3><p>素材这块完全不用自己制作嘛，光是这个Assetstore就有挺多素材的，而且很多无限制商用的，有空要收集一些可以白嫖的网站</p>
<hr>
<h3 id="二、2D-复合碰撞体-Composite-Collider-2D"><a href="#二、2D-复合碰撞体-Composite-Collider-2D" class="headerlink" title="二、2D 复合碰撞体 (Composite Collider 2D)"></a>二、2D 复合碰撞体 (Composite Collider 2D)</h3><p>2D 复合碰撞体组件是用于 2D 物理的碰撞体。与大多数碰撞体不同，此碰撞体没有定义固有的形状。相反，此碰撞体将合并所设置的 2D 盒型碰撞体 (Box Collider 2D) 或 2D 多边形碰撞体 (Polygon Collider 2D) 的形状。2D 复合碰撞体使用所有此类碰撞体的顶点（几何体），并将这些顶点合并为由 2D 复合碰撞体本身控制的新几何体。</p>
<p>2D 盒型碰撞体和 2D 多边形碰撞体组件具有 Used By Composite 复选框。勾选此复选框即可将这些碰撞体附加到 2D 复合碰撞体。这些碰撞体还与 2D 复合碰撞体附加到同一 2D 刚体。启用 Used by Composite 时，其他属性会从该组件中消失，因为这些属性现在由附加的 2D 复合碰撞体控制。</p>
<hr>
<h3 id="三、Pixels-Per-Unit（PPU）"><a href="#三、Pixels-Per-Unit（PPU）" class="headerlink" title="三、Pixels Per Unit（PPU）"></a>三、Pixels Per Unit（PPU）</h3><p>在Inspector面板的图像设置中有一个Pixels Per Unit参数。它代表Unity的一个单位长度包含本图片多少个像素<br> 在Unity中创建的Cube等基本图形默认就是一个Unity单位长度，一个单位长度在unity世界坐标中代表1米<br> 例如默认值为100，则代表一个Unity单位包含本图片中100个像素</p>
<hr>
<h3 id="四、关节（joint）"><a href="#四、关节（joint）" class="headerlink" title="四、关节（joint）"></a>四、关节（joint）</h3><p>关节组件可以添加至多个游戏对象中，而添加关节的游戏对象将通过关节连接在一起并且感觉连带的物理效果。需要注意的是：关节必须依赖于刚体组件。所有 2D 关节的名称都以“2D”结尾。名称不以“2D”结尾的关节是 3D 关节。2D 关节用于 2D 游戏对象，而 3D 关节用于 3D 游戏对象。</p>
<p><strong>3D关节</strong>：</p>
<p><strong>链条关节（hinge joint）</strong>：将两个物体以链条的形式绑在一起，当力量大于链条的固定力矩时，两个物体就会产生相互的拉力。</p>
<p><strong>固定关节（fixed joint）</strong>：将两个物体永远以相对的位置固定在一起，即使发生物理改变，它们之间的相对位置也将不变。</p>
<p><strong>弹簧关节（spring joint）</strong>：将两个物体以弹簧的形式绑定在一起，挤压它们会得到向外的力，拉伸它们将得到向里的力。</p>
<p><strong>角色关节（character joint）</strong>：可以模拟角色的骨骼关节。</p>
<p><strong>可配置关节（configurable joint）</strong>：可以模拟任意关节的效果。</p>
<p><strong>2D关节</strong>：</p>
<p><strong>2D 距离关节 (Distance Joint 2D)</strong> - 连接由刚体物理组件控制的两个游戏对象，使这两个对象保持一定距离。</p>
<p><strong>2D 固定关节 (Fixed Joint 2D)</strong> - 将两个对象保持在相对于彼此的位置，确保对象始终以给定位置和角度偏移。例如，对象好像是采用刚性连接方式相连一样：对象不能彼此远离，不能相互靠近，也不能相对于彼此旋转。还可以使用此关节来创建刚度稍低的柔性连接。</p>
<p><strong>2D 摩擦关节 (Friction Joint 2D)</strong> - 将刚体物理组件控制的两个游戏对象之间的线速度和角速度降低到零（即：此关节使对象减速并停止）。例如，一个平台在旋转但抵抗该运动。</p>
<p><strong>2D 铰链关节 (Hinge Joint 2D)</strong> - 允许由刚体物理组件控制的游戏对象连接到空间中的一个点，使游戏对象可围绕该点旋转。例如，一把剪刀上的轴心。</p>
<p><strong>2D 相对关节 (Relative Joint 2D)</strong> - 允许由刚体物理组件控制的两个游戏对象基于彼此的位置来保持相对位置。使用此关节可将两个对象保持相互偏移。例如，在空间射击游戏中，玩家身后有额外的排炮。</p>
<p><strong>2D 滑动关节 (Slider Joint 2D)</strong> - 允许由刚体物理组件控制的游戏对象沿着空间中的一条线滑动（例如滑门）。</p>
<p><strong>2D 弹簧关节 (Spring Joint 2D)</strong> - 允许由刚体物理组件控制的两个游戏对象就像通过弹簧连接在一起一样。</p>
<p><strong>2D 目标关节 (Target Joint 2D)</strong> - 连接到指定目标，而不是像其他关节那样连接到另一个刚体对象。这是一种弹簧式关节，例如可将其用于拾取和移动处于重力作用下的对象。</p>
<p><strong>2D 车轮关节 (Wheel Joint 2D)</strong> - 模拟车轮和悬架。</p>
<p>在关节这方面2D的花样比3D多</p>
<hr>
<h3 id="五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）"><a href="#五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）" class="headerlink" title="五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）"></a>五、刚体（Rigidbody），碰撞器（Collider），触发器（Trigger）</h3><p>要产生碰撞必须为游戏对象添加刚体（Rigidbody）和碰撞器，刚体可以让物体在物理影响下运动。碰撞体是物理组件的一类，它要与刚体一起添加到游戏对象上才能触发碰撞。如果两个刚体相互撞在一起，除非两个对象有碰撞体时物理引擎才会计算碰撞，在物理模拟中，没有碰撞体的刚体会彼此相互穿过。</p>
<p><strong>物体发生碰撞的必要条件</strong>：</p>
<p>两个物体都必须带有碰撞器(Collider)，其中一个物体还必须带有Rigidbody刚体。</p>
<p>在unity3d中，能检测碰撞发生的方式有两种，一种是利用碰撞器，另一种则是利用触发器。</p>
<p>碰撞器：一群组件，它包含了很多种类，比如：Box Collider（盒碰撞体），Mesh Collider（网格碰撞体）等，这些碰撞器应用的场合不同，但都必须加到GameObjecet身上。</p>
<p>触发器：只需要在检视面板中的碰撞器组件中勾选IsTrigger属性选择框。</p>
<p><strong>触发信息检测</strong>：</p>
<p>1.MonoBehaviour.OnTriggerEnter(Collider collider)当进入触发器</p>
<p>2.MonoBehaviour.OnTriggerExit(Collider collider)当退出触发器</p>
<p>3.MonoBehaviour.OnTriggerStay(Collider collider)当逗留触发器</p>
<p><strong>碰撞信息检测</strong>：</p>
<p>1.MonoBehaviour.OnCollisionEnter(Collision collision) 当进入碰撞器</p>
<p>2.MonoBehaviour.OnCollisionExit(Collision collision) 当退出碰撞器</p>
<p>3.MonoBehaviour.OnCollisionStay(Collision collision) 当逗留碰撞器</p>
<p><strong>碰撞器和触发器的区别？</strong></p>
<p>碰撞器是触发器的载体，而触发器只是碰撞器身上的一个属性</p>
<p>当Is Trigger=false时，碰撞器根据物理引擎引发碰撞，产生碰撞的效果，可以调用OnCollisionEnter/Stay/Exit函数；</p>
<p>当Is Trigger=true时，碰撞器被物理引擎所忽略，没有碰撞效果，可以调用OnTriggerEnter/Stay/Exit函数。</p>
<p>也就是说在一次碰撞中，碰撞函数和触发函数只能二选一</p>
<hr>
<h3 id="六、预制体（Prefab）"><a href="#六、预制体（Prefab）" class="headerlink" title="六、预制体（Prefab）"></a>六、预制体（Prefab）</h3><p>什么是预制体：</p>
<p>在进行一些功能开发的时候, 我们常常将一些能够复用的对象制作成.prefab的预制体，然后将预制体存放到 Resources 目录之下, 使用时再动态加载到场景中并进行实例化. 例如 : 子弹、特效甚至音频等, 都能制作成预制体.</p>
<p>预制体英文名称即 Prefab 是一种资源类型 —— 存储在项目视图中的一种可重复使用的游戏对象.</p>
<p>预制体的优点：<br>预制体可以多次放入到多个场景中;<br>当你添加一个预制体到场景中, 就创建了它的一个实例;<br>所有的预制体实例链接到原始预制, 基本上等于就是它的克隆;<br>不管你的项目存在多少实例, 当你对预制体进行任何更改, 你将看到这些更改将应用于所有的实例上;</p>
<hr>
<h3 id="七、画布（Canvas）"><a href="#七、画布（Canvas）" class="headerlink" title="七、画布（Canvas）"></a>七、画布（Canvas）</h3><p>Canvas (画布) 是所有 UI 组件的父物体 , 也就是说每一个 UI 组件都必须在 Canvas 下 , 作为 Canvas 的子物体 , 当你创建一个 UI 控件时 , 如果在 Hierarchy 视图没有 Canvas 组件的话 , unity会自动帮你创建一个 Canvas , 并将你想创建的 UI 控件置于 Canvas 下.</p>
<p>Canvas 的 Render Mode (渲染模式) 有三种 ：</p>
<p>1.<strong>Screen Space - Overlay</strong></p>
<p>这种渲染模式表示 Canvas 下的所有的 UI 控件永远位于屏幕的前面 , 不管有没有相机 , UI元素永远在屏幕最前面</p>
<p>2.<strong>Screen Space - Camera</strong></p>
<p>这种渲染模式 Canvas 和 摄像机之间有一定的距离 , 可以在摄像机和 Canvas 之间播放一些粒子特效</p>
<p>3.<strong>World Space</strong></p>
<p>这种模式下 Canvas 就和普通的 3D 物体一样了 , 可以控制它的大小,旋转,缩放等 , 一般用来做血条</p>
<hr>
<h3 id="终、总结"><a href="#终、总结" class="headerlink" title="终、总结"></a>终、总结</h3><p>作为unity回坑第一课收获还是蛮丰富的，以前一直没有做笔记的习惯，东西学了又忘，忘了还没地方复习，以后要养成写学习日记的习惯。</p>
<p>这次写的脚本都没有写注释，希望未来的我回来看的时候不会头大吧哈哈哈（这么简单的代码应该不至于吧吧吧吧🐷）</p>
<hr>
<h3 id="附录、脚本"><a href="#附录、脚本" class="headerlink" title="附录、脚本"></a>附录、脚本</h3><p>1.角色控制脚本，控制角色移动和检测角色状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class PlayerController : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    Rigidbody2D rb;</span><br><span class="line">    Animator anim;</span><br><span class="line">    public float speed;</span><br><span class="line">    float xVelocity;</span><br><span class="line"></span><br><span class="line">    public bool isOnGround;</span><br><span class="line">    public float checkRadius;</span><br><span class="line">    public LayerMask layer;</span><br><span class="line">    public GameObject groundCheck;</span><br><span class="line"></span><br><span class="line">    public bool playerDead;</span><br><span class="line"></span><br><span class="line">    public float bounceH;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        Movement();</span><br><span class="line">        isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);</span><br><span class="line">        anim.SetBool(&quot;isOnGround&quot;, isOnGround);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Movement()</span><br><span class="line">    &#123;</span><br><span class="line">        xVelocity = Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br><span class="line">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class="line">        anim.SetFloat(&quot;speed&quot;, Mathf.Abs(rb.velocity.x));</span><br><span class="line"></span><br><span class="line">        if(xVelocity != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.localScale = new Vector3(xVelocity, 1, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnCollisionEnter2D(Collision2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        if (collision.gameObject.CompareTag(&quot;Fan&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            rb.velocity = new Vector2(rb.velocity.x, bounceH);</span><br><span class="line">        &#125;</span><br><span class="line">        if (collision.gameObject.CompareTag(&quot;Spike&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            anim.SetTrigger(&quot;isDead&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        if (collision.CompareTag(&quot;Spike&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            anim.SetTrigger(&quot;isDead&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void PlayerDead()</span><br><span class="line">    &#123;</span><br><span class="line">        playerDead = true;</span><br><span class="line">        GameManage.GameOver(playerDead);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnDrawGizmosSelected()</span><br><span class="line">    &#123;</span><br><span class="line">        Gizmos.color = Color.green;</span><br><span class="line">        Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.游戏管理脚本，涉及游戏重开和退出，以及控制界面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">using UnityEngine.UI;</span><br><span class="line">using UnityEngine.SceneManagement;</span><br><span class="line"></span><br><span class="line">public class GameManage : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    static GameManage instance;</span><br><span class="line">    public Text score;</span><br><span class="line"></span><br><span class="line">    public GameObject gameOverUI;</span><br><span class="line"></span><br><span class="line">    private void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        if(instance != null)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">        instance = this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        score.text = Time.timeSinceLevelLoad.ToString(&quot;000&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void RestartGame()</span><br><span class="line">    &#123;</span><br><span class="line">        SceneManager.LoadScene(SceneManager.GetActiveScene().name);</span><br><span class="line">        Time.timeScale = 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Exit()</span><br><span class="line">    &#123;</span><br><span class="line">        Application.Quit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void GameOver(bool dead)</span><br><span class="line">    &#123;</span><br><span class="line">        if (dead)</span><br><span class="line">        &#123;</span><br><span class="line">            Time.timeScale = 0f;</span><br><span class="line">            instance.gameOverUI.SetActive(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3.平台生成脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class Spawner : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public List&lt;GameObject&gt; platform = new List&lt;GameObject&gt;();</span><br><span class="line"></span><br><span class="line">    public float spawnTime;</span><br><span class="line">    float countTime;</span><br><span class="line">    Vector3 spawnPosition;</span><br><span class="line"></span><br><span class="line">    int spikeBallNum = 0;</span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        SpawnPlatform();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SpawnPlatform()</span><br><span class="line">    &#123;</span><br><span class="line">        countTime += Time.deltaTime;</span><br><span class="line">        spawnPosition = transform.position;</span><br><span class="line">        spawnPosition.x = Random.Range(-3f, 3f);</span><br><span class="line"></span><br><span class="line">        if(countTime &gt; spawnTime)</span><br><span class="line">        &#123;</span><br><span class="line">            CreatePlatform();</span><br><span class="line">            countTime = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void CreatePlatform()</span><br><span class="line">    &#123;</span><br><span class="line">        int index = Random.Range(0, platform.Count);</span><br><span class="line"></span><br><span class="line">        if (index == 3)</span><br><span class="line">        &#123;</span><br><span class="line">            spikeBallNum++;</span><br><span class="line">            if(spikeBallNum &gt; 2)</span><br><span class="line">            &#123;</span><br><span class="line">                index = 0;</span><br><span class="line">                spikeBallNum = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class="line">        newPlatform.transform.SetParent(transform);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>4.平台上升脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class PlatformUp : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    Vector3 movement;</span><br><span class="line">    public float speed;</span><br><span class="line">    GameObject topLine;</span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        movement.y = speed;</span><br><span class="line">        topLine = GameObject.Find(&quot;TopLine&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        MovePlatform();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void MovePlatform()</span><br><span class="line">    &#123;</span><br><span class="line">        transform.position += movement * Time.deltaTime;</span><br><span class="line">        if(transform.position.y &gt; topLine.transform.position.y)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>5.链锤画线脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class SpikeBallLine : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    LineRenderer line;</span><br><span class="line">    public Transform begin;</span><br><span class="line">    public Transform end;</span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        line = GetComponent&lt;LineRenderer&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        line.SetPosition(0, begin.position);</span><br><span class="line">        line.SetPosition(1, end.position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>6.跳跃平台旋转动画脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class FanRun : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    Animator animator;</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnCollisionEnter2D(Collision2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        if (collision.gameObject.CompareTag(&quot;Player&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            animator.Play(&quot;Fan_run&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>c#</tag>
        <tag>joint</tag>
        <tag>collider</tag>
        <tag>trigger</tag>
        <tag>prefab</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>《Speed Down》Unity2d游戏开发（六）</title>
    <url>/2021/07/15/2021-07-15-%E3%80%8ASpeed%20Down%E3%80%8BUnity2d%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    <content><![CDATA[<h3 id="始、前言"><a href="#始、前言" class="headerlink" title="始、前言"></a>始、前言</h3><p>《Speed Down》开发已经接近尾声啦！最后再来完善一下，变成真正能玩的游戏！</p>
<span id="more"></span>

<hr>
<h3 id="一、分数统计"><a href="#一、分数统计" class="headerlink" title="一、分数统计"></a>一、分数统计</h3><p>1.新建UI → Text 物体，发现自动创建了Canvas并将Text作为子物体添加</p>
<p>2.调整Text的位置大小等参数直到满意</p>
<p>3.新建空物体命名GameManage，新建脚本也命名GameManage并挂载到空物体GameManage上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">using UnityEngine.UI;</span><br><span class="line">using UnityEngine.SceneManagement;</span><br><span class="line"></span><br><span class="line">public class GameManage : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    static GameManage instance;</span><br><span class="line">    public Text score;</span><br><span class="line"></span><br><span class="line">    private void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        if(instance != null)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">        instance = this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        score.text = Time.time.ToString(&quot;000&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Awake会在所有的Start之前调用，适合用作游戏的初始化</p>
<p>返回unity就可以看到随时间增加分数</p>
<hr>
<h3 id="二、失败界面"><a href="#二、失败界面" class="headerlink" title="二、失败界面"></a>二、失败界面</h3><p>1.在Canvas下添加Panel并按自己喜欢布置界面，添加两个按钮用作重新开始游戏和退出游戏</p>
<p>2.在GameManage脚本中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void RestartGame()</span><br><span class="line">&#123;</span><br><span class="line">    SceneManager.LoadScene(SceneManager.GetActiveScene().name);</span><br><span class="line">    Time.timeScale = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    public void Exit()</span><br><span class="line">&#123;</span><br><span class="line">    Application.Quit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.给两个按钮添加刚刚新建的方法</p>
<p>按钮的功能已经设置好，其中退出游戏的功能需要在项目build之后才能看到效果。现在我们希望游戏失败界面在失败后出现</p>
<p>4.取消勾选Panel的标签上面的框，这样就平时就不会显示Panel</p>
<p>5.在GameManage中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void GameOver(bool dead)</span><br><span class="line">&#123;</span><br><span class="line">    if (dead)</span><br><span class="line">    &#123;</span><br><span class="line">        Time.timeScale = 0f;</span><br><span class="line">        instance.gameOverUI.SetActive(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：想要在其他脚本中调用方法，需要定义方法成static类型</p>
<p>6.在PlayerController脚本中修改PlayerDead方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void PlayerDead()</span><br><span class="line">&#123;</span><br><span class="line">    playerDead = true;</span><br><span class="line">    GameManage.GameOver(playerDead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当角色死亡时就会弹出失败界面</p>
<hr>
<h3 id="终、测试"><a href="#终、测试" class="headerlink" title="终、测试"></a>终、测试</h3><p>最后测试了一下，发现重新开始游戏时不会将分数重置，需要将GameManage脚本中的<code>Time.time.ToString</code>改成<code>Time.timeSinceLevelLoad.ToString</code>，这样一来时间计数就会在场景重置时重置。</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>c#</tag>
        <tag>canvas</tag>
        <tag>awake</tag>
      </tags>
  </entry>
  <entry>
    <title>《Speed Down》Unity2d游戏开发（五）</title>
    <url>/2021/07/15/2021-07-15-%E3%80%8ASpeed%20Down%E3%80%8BUnity2d%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    <content><![CDATA[<h3 id="一、随机生成平台"><a href="#一、随机生成平台" class="headerlink" title="一、随机生成平台"></a>一、随机生成平台</h3><p>1.可以删除其他平台，只留下一个开局的平台</p>
<p>2.新建一个空物体作为平台出生点，调整大小，添加碰撞体，勾选is trigger，修改标签为spike</p>
<span id="more"></span>

<p>3.新建脚本挂载到平台出生点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class Spawner : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public List&lt;GameObject&gt; platform = new List&lt;GameObject&gt;();</span><br><span class="line"></span><br><span class="line">    public float spawnTime;</span><br><span class="line">    float countTime;</span><br><span class="line">    Vector3 spawnPosition;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        SpawnPlatform();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void SpawnPlatform()</span><br><span class="line">    &#123;</span><br><span class="line">        countTime += Time.deltaTime;</span><br><span class="line">        spawnPosition = transform.position;</span><br><span class="line">        spawnPosition.x = Random.Range(-3f, 3f);</span><br><span class="line"></span><br><span class="line">        if(countTime &gt; spawnTime)</span><br><span class="line">        &#123;</span><br><span class="line">            CreatePlatform();</span><br><span class="line">            countTime = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void CreatePlatform()</span><br><span class="line">    &#123;</span><br><span class="line">        int index = Random.Range(0, platform.Count);</span><br><span class="line">        Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.回到unity设置脚本中平台列表的大小为3并且拖入三种基础平台</p>
<p>5.设置好生成速度Spawn Time就可以开始玩啦！</p>
<hr>
<h3 id="二、细节调整"><a href="#二、细节调整" class="headerlink" title="二、细节调整"></a>二、细节调整</h3><p>1.将链锤的锤子设置标签为spike（不小心删了链锤的预制体，我是sb，以后碰到警告操作不可撤回的要万分小心）</p>
<p>2.角色检测碰到尖刺死亡的代码是在OnTriggerEnter2D中的，而顶部尖刺是触发器，链锤是碰撞器，需要将死亡代码复制到OnCollisionEnter2D中。注意两个函数接收的变量不同，需要按照提示修改一下</p>
<p>3.改变平台列表的大小并拖入不同的平台，这样就可以调整游戏难度以及未来新增其他平台或者陷阱</p>
<p>4.在平台出生点中修改代码，添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class="line">newPlatform.transform.SetParent(transform);</span><br></pre></td></tr></table></figure>

<p>这样就可以让新生成的平台作为平台出生点的子物体</p>
<p>5.为了不让链锤连续生成太多以至于游戏难度过大，修改spawn代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int spikeBallNum = 0;</span><br><span class="line"></span><br><span class="line">    public void CreatePlatform()</span><br><span class="line">&#123;</span><br><span class="line">    int index = Random.Range(0, platform.Count);</span><br><span class="line"></span><br><span class="line">    if (index == 3)</span><br><span class="line">    &#123;</span><br><span class="line">        spikeBallNum++;</span><br><span class="line">        if(spikeBallNum &gt; 2)</span><br><span class="line">        &#123;</span><br><span class="line">            index = 0;</span><br><span class="line">            spikeBallNum = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GameObject newPlatform = Instantiate(platform[index], spawnPosition, Quaternion.identity );</span><br><span class="line">    newPlatform.transform.SetParent(transform);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当连续出现链锤时变成普通平台，免得出现必死局</p>
<hr>
<h3 id="终、总结"><a href="#终、总结" class="headerlink" title="终、总结"></a>终、总结</h3><p>到此为止主要游戏内容都已经完成啦！最后就是制作一些UI管理游戏</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>c#</tag>
        <tag>trigger</tag>
        <tag>collision</tag>
      </tags>
  </entry>
  <entry>
    <title>《Speed Down》Unity2d游戏开发（四）</title>
    <url>/2021/07/14/2021-07-14-%E3%80%8ASpeed%20Down%E3%80%8BUnity2d%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h3 id="始、阶段调整"><a href="#始、阶段调整" class="headerlink" title="始、阶段调整"></a>始、阶段调整</h3><p>这次不做新功能，先停一停把之前的东西调整一下，细节<del>太细了</del></p>
<span id="more"></span>

<hr>
<h3 id="一、图案模糊"><a href="#一、图案模糊" class="headerlink" title="一、图案模糊"></a>一、图案模糊</h3><p>顶部尖刺看起来有些模糊</p>
<p>1.找到尖刺的图案，将Advanced → Filter Mode 修改成Point</p>
<p>检查所有的图案是否模糊，套用这个方法</p>
<hr>
<h3 id="二、修改背景颜色"><a href="#二、修改背景颜色" class="headerlink" title="二、修改背景颜色"></a>二、修改背景颜色</h3><p>1.选择主相机，修改Camera → Background 到喜欢的颜色</p>
<hr>
<h3 id="三、给链锤添加链子？"><a href="#三、给链锤添加链子？" class="headerlink" title="三、给链锤添加链子？"></a>三、给链锤添加链子？</h3><p>听起来有点奇怪，但是我的链锤现在确实是没有链子，看起来像是原力驱动</p>
<p>1.给链锤整体添加组件Line Renderer，选择喜欢材质、颜色、粗细，并把Position → Size改成2</p>
<p>2.添加脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class SpikeBallLine : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    LineRenderer line;</span><br><span class="line">    public Transform begin;</span><br><span class="line">    public Transform end;</span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        line = GetComponent&lt;LineRenderer&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        line.SetPosition(0, begin.position);</span><br><span class="line">        line.SetPosition(1, end.position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>挂载到链锤父物体上，注意脚本和线组件是同一级别的</p>
<hr>
<h3 id="四、保存预制体"><a href="#四、保存预制体" class="headerlink" title="四、保存预制体"></a>四、保存预制体</h3><p>为了可以持续不断地随机生成平台，需要将平台保存为预制体</p>
<p>1.创建prefabs文件夹，并把平台和人物添加到其中</p>
<p><strong>Prefab是什么？</strong></p>
<p>当制作好了游戏组件（场景中的任意一个gameobject）,我们希望将它制作成一个组件模版，用于批量的套用工作，例如说场景中本质上要重复使用的东西，比如：敌人、士兵、子弹或者一个砖块完全相同的墙体。这里说本质是因为默认生成的prefab其实和模版是一模一样的。就像是克隆体，但生成的位置、角度或者一些属性不同（这个就好像c++里边的类一样）；</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>c#</tag>
        <tag>prefab</tag>
      </tags>
  </entry>
  <entry>
    <title>《Speed Down》Unity2d游戏开发（三）</title>
    <url>/2021/07/14/2021-07-14-%E3%80%8ASpeed%20Down%E3%80%8BUnity2d%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h3 id="始、前言"><a href="#始、前言" class="headerlink" title="始、前言"></a>始、前言</h3><p>背景和障碍物都搭建完毕了，现在来制作我们操作的主角！（洗个衣服先…）</p>
<span id="more"></span>

<hr>
<h3 id="一、添加动画及组件"><a href="#一、添加动画及组件" class="headerlink" title="一、添加动画及组件"></a>一、添加动画及组件</h3><p>1.先选中资源中喜欢的角色，修改所有精灵图的ppu为32</p>
<p>2.制作动画，idle、run、jump、hit</p>
<p>3.添加组件rigidbody 2d并且勾选constraints → freeze rotation → z 以此锁定z轴，防止碰撞时产生z轴翻转</p>
<p>4.添加碰撞组件box collider 2d</p>
<hr>
<h3 id="二、脚本控制主角"><a href="#二、脚本控制主角" class="headerlink" title="二、脚本控制主角"></a>二、脚本控制主角</h3><p>添加脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class PlayerController : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    Rigidbody2D rb;</span><br><span class="line">    Animator anim;</span><br><span class="line">    public float speed;</span><br><span class="line">    float xVelocity;</span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        rb = GetComponent&lt;Rigidbody2D&gt;();</span><br><span class="line">        anim = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        Movement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Movement()</span><br><span class="line">    &#123;</span><br><span class="line">        xVelocity = Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br><span class="line">        rb.velocity = new Vector2(xVelocity * speed, rb.velocity.y);</span><br><span class="line"></span><br><span class="line">        if(xVelocity != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.localScale = new Vector3(xVelocity, 1, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>挂载到角色上，就可以用方向键控制左右移动了（wsad也可以）</p>
<p>并且<code>transform.localScale = new Vector3(xVelocity, 1, 1);</code>还实现了图案的左右翻转（之前我还傻傻地自己画各个方向的图）</p>
<hr>
<h3 id="三、切换跑步动画"><a href="#三、切换跑步动画" class="headerlink" title="三、切换跑步动画"></a>三、切换跑步动画</h3><p>1.打开player的Animator界面，相互连接idle和run，新建speed变量，设置idle转换为run的条件为speed大于0.1，run转换为idle的条件为speed小于0.1，同时记得调整转换时间和混合时间等设置（这里全部取消）</p>
<p>2.在<code>void Movement()</code>中添加代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">anim.SetFloat(&quot;speed&quot;, Mathf.Abs(rb.velocity.x));</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="四、切换下落动画"><a href="#四、切换下落动画" class="headerlink" title="四、切换下落动画"></a>四、切换下落动画</h3><p>1.动画all和idle相互连接，创建isOnGround变量来检测是否在平台上，把所有平台的Layer都改成新的Platform</p>
<p>2.添加代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool isOnGround;</span><br><span class="line">public float checkRadius;</span><br><span class="line">public LayerMask layer;</span><br><span class="line">public GameObject groundCheck;</span><br><span class="line"></span><br><span class="line">void Update()</span><br><span class="line">&#123;</span><br><span class="line">    Movement();</span><br><span class="line">    isOnGround = Physics2D.OverlapCircle(groundCheck.transform.position, checkRadius, layer);</span><br><span class="line">    anim.SetBool(&quot;isOnGround&quot;, isOnGround);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>3.在角色物体下方添加子物体CheckPoint并拖拽入角色的检测点位置</p>
<p>4.修改参数就可以实现踩到平台时触发isOnGround，并且由fall动画转换到idle动画</p>
<p>但是现在看不见检测范围，只能大致估计，怎么办呢？</p>
<p>小技巧：添加代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void OnDrawGizmosSelected()</span><br><span class="line">&#123;</span><br><span class="line">    Gizmos.color = Color.green;</span><br><span class="line">    Gizmos.DrawWireSphere(groundCheck.transform.position, checkRadius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码是unity内置的方法，可以把检测范围可视化</p>
<hr>
<h3 id="五、切换死亡动画"><a href="#五、切换死亡动画" class="headerlink" title="五、切换死亡动画"></a>五、切换死亡动画</h3><p>1.修改尖刺的tag为新的Spike，状态机新建trigger型变量isDead，将Any State 连接到hit调整转换条件，这样就可以从任何状态转换到死亡状态</p>
<p>2.添加代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">&#123;</span><br><span class="line">    if (collision.CompareTag(&quot;Spike&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        anim.SetTrigger(&quot;isDead&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就实现了播放死亡动画，接下来再加一个表示角色死亡的标志</p>
<p>3.添加代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public bool playerDead;</span><br><span class="line"></span><br><span class="line">public void PlayerDead()</span><br><span class="line">&#123;</span><br><span class="line">    playerDead = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.找到玩家死亡的动画效果，在最后一帧添加函数<code>PlayerDead()</code></p>
<hr>
<h3 id="六、实现跳跃平台的跳跃效果"><a href="#六、实现跳跃平台的跳跃效果" class="headerlink" title="六、实现跳跃平台的跳跃效果"></a>六、实现跳跃平台的跳跃效果</h3><p>1.设置跳跃平台的tag为新的Fan</p>
<p>2.添加代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public float bounceH;</span><br><span class="line"></span><br><span class="line">private void OnCollisionEnter2D(Collision2D collision)</span><br><span class="line">&#123;</span><br><span class="line">    if (collision.gameObject.CompareTag(&quot;Fan&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity = new Vector2(rb.velocity.x, bounceH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样以来，角色碰到跳跃平台时就会给rigidbody产生向上的大小为bounceH的力（就是被打飞了）</p>
<p>发现之前说好的跳跃平台碰到角色会转起来现在好像没有转，原来是主角的tag没有设置成Player</p>
<p>完美！</p>
<hr>
<h3 id="终、吐槽"><a href="#终、吐槽" class="headerlink" title="终、吐槽"></a>终、吐槽</h3><p>角色的各种动画转换也太复杂了！难道每次添加一个新的动作就要和所有的动作一起调整吗，天啊！有没有简单的方法啊，快浇浇我吧！</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>c#</tag>
        <tag>collider</tag>
        <tag>animator</tag>
        <tag>trigger</tag>
      </tags>
  </entry>
  <entry>
    <title>《Speed Down》Unity2d游戏开发（二）</title>
    <url>/2021/07/13/2021-07-13-%E3%80%8ASpeed%20Down%E3%80%8BUnity2d%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h3 id="始、前言"><a href="#始、前言" class="headerlink" title="始、前言"></a>始、前言</h3><p>上一次已经完成了场景搭建，那么这次的主要任务就是制作跳跃平台</p>
<span id="more"></span>

<hr>
<h3 id="一、普通平台"><a href="#一、普通平台" class="headerlink" title="一、普通平台"></a>一、普通平台</h3><p>1.选中pixel adventure 1 → assets → traps → falling platform 设置pixels per unit为16</p>
<p>2.拖拽第一张图案到场景中，命名为BasePlatform</p>
<p>3.新建BasePlatform的动画，将四个图案拖拽进动画中并调整采样率</p>
<p>4.为BasePlatform添加碰撞器box collider 2d 并调整碰撞体积</p>
<hr>
<h3 id="二、旋转平台"><a href="#二、旋转平台" class="headerlink" title="二、旋转平台"></a>二、旋转平台</h3><p>1.前面的操作与上述普通平台相同，设置大小，命名，新建动画，添加碰撞器</p>
<p>2.为了实现平台被碰撞时发生翻转，添加组件hinge joint 2d，可以设置旋转角度和速度等</p>
<p>自动添加了rigidbody 2d，但是不取消也不会掉下来，为什么呢？</p>
<p>猜测是joint关节会固定在背景里，超过一定的力才会 “脱臼”</p>
<hr>
<h3 id="三、弹跳平台"><a href="#三、弹跳平台" class="headerlink" title="三、弹跳平台"></a>三、弹跳平台</h3><p>1.找到pixel adventure 1 → assets → traps → fan ，设置大小，命名，添加碰撞器</p>
<p>2.这里新建两个动画，一个是静止时的动画，一个是启动时的动画（弹跳）</p>
<p>3.新建脚本，实现碰撞时平台切换到弹跳动画：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class FanRun : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    Animator animator;</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        animator = GetComponent&lt;Animator&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    private void OnCollisionEnter2D(Collision2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        if (collision.gameObject.CompareTag(&quot;Player&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            animator.Play(&quot;Fan_run&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当标签为Player的物体碰撞到此平台时就会切换到启动动画啦</p>
<hr>
<h3 id="四、摆动链锤"><a href="#四、摆动链锤" class="headerlink" title="四、摆动链锤"></a>四、摆动链锤</h3><p>1.新建空物体SpikeBall，分别添加两个子物体pixel adventure 1 → assets → traps → spiked ball → 轴心和大锤</p>
<p>2.调整父子物体的相对位置</p>
<p>3.给大锤添加组件Distance Joint 2D，给轴心添加rigid body 2d并拖拽到大锤的链接体</p>
<p>4.给大锤添加碰撞体circle collider 2d</p>
<hr>
<h3 id="五、脚本实现平台上升"><a href="#五、脚本实现平台上升" class="headerlink" title="五、脚本实现平台上升"></a>五、脚本实现平台上升</h3><p>新建脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class PlatformUp : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    Vector3 movement;</span><br><span class="line">    public float speed;</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        movement.y = speed;</span><br><span class="line">    &#125;</span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        MovePlatform();</span><br><span class="line">    &#125;</span><br><span class="line">    void MovePlatform()</span><br><span class="line">    &#123;</span><br><span class="line">        transform.position += movement * Time.deltaTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并挂载到所有的平台建筑下，这样就实现了平台的持续上升</p>
<hr>
<h3 id="六、设置平台天花板"><a href="#六、设置平台天花板" class="headerlink" title="六、设置平台天花板"></a>六、设置平台天花板</h3><p>平台总不能一直上升，要设置一个天花板，当平台到达天花板时就摧毁物体</p>
<p>1.新建空物体TopLine移动到上方合适的位置，作为天花板</p>
<p>2.在平台的上升代码中添加判断到达天花板的检测：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class PlatformUp : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    Vector3 movement;</span><br><span class="line">    public float speed;</span><br><span class="line">    GameObject topLine;</span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        movement.y = speed;</span><br><span class="line">        topLine = GameObject.Find(&quot;TopLine&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        MovePlatform();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void MovePlatform()</span><br><span class="line">    &#123;</span><br><span class="line">        transform.position += movement * Time.deltaTime;</span><br><span class="line">        if(transform.position.y &gt; topLine.transform.position.y)</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成！平台到位自动销毁</p>
<hr>
<h3 id="终、总结"><a href="#终、总结" class="headerlink" title="终、总结"></a>终、总结</h3><p>平台的制作到这就结束了！用到了几个joint组件，十分有趣</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>c#</tag>
        <tag>joint</tag>
        <tag>collider</tag>
      </tags>
  </entry>
  <entry>
    <title>C++STL</title>
    <url>/2021/07/09/%E6%9B%B42021-07-09-C++STL/</url>
    <content><![CDATA[<h3 id="始、STL初识"><a href="#始、STL初识" class="headerlink" title="始、STL初识"></a>始、STL初识</h3><p>STL(standard template library)标准模板库</p>
<p>广义上分为容器、算法、迭代器（容器和算法之间通过迭代器无缝连接）</p>
<p>六大组件：容器、算法、迭代器、仿函数、适配器、空间配置器</p>
<p><strong>主要学习以下四个：</strong></p>
<p>​    <strong>容器</strong>：vector、list、deque、set、map等</p>
<p>​    **算法(Algorithms)**：sort、find、copy、for_each等</p>
<p>​    <strong>迭代器</strong>：扮演容器与算法之间的胶合剂（每个容器都有自己专属的迭代器），迭代器可以理解成<strong>指针</strong></p>
<p>​    <strong>仿函数</strong>：类似函数，可作为算法的某种策略</p>
<span id="more"></span>

<hr>
<h3 id="一、vector容器"><a href="#一、vector容器" class="headerlink" title="一、vector容器"></a>一、vector容器</h3><p>vector容器可以理解成<strong>数组</strong></p>
<p>初始化：<code>vector&lt;数据类型&gt; 容器名 (容器大小)</code></p>
<p>容器输入：<code>容器名. push_back(数据)</code>，尾插法插入数据</p>
<p>起始迭代器：<code>容器名. begin()</code>，指向第一个元素</p>
<p>结束迭代器：<code>容器名. end()</code>，指向最后一个元素的下一个位置</p>
<p>自定义专属迭代器：<code>vector&lt;数据类型&gt; : : iterator 迭代器名</code></p>
<hr>
<h3 id="二、遍历算法：for-each"><a href="#二、遍历算法：for-each" class="headerlink" title="二、遍历算法：for_each"></a>二、遍历算法：<code>for_each</code></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for_each(InputIterator beg, InputIterator end, Function f) &#123;</span><br><span class="line">  while(beg != end) </span><br><span class="line">    f(*beg++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="三、map-multimap容器"><a href="#三、map-multimap容器" class="headerlink" title="三、map/multimap容器"></a>三、map/multimap容器</h3><p>map容器可以理解成<strong>哈希表</strong>（第三常用）</p>
<p><strong>map中每个元素都是pair(对组元素)</strong></p>
<p>pair中第一个元素为key(键值)，第二个元素为value(实值)</p>
<p>所有元素会根据键值自动排序</p>
<p>map不允许容器中有重复的key值，multimap允许容器中有重复的key值</p>
<p>默认构造：<code>map&lt;key类型, value类型&gt; 容器名</code></p>
<p>拷贝构造：<code>map&lt;key类型, value类型&gt; 容器名 (拷贝容器名)</code></p>
<p>赋值：<code>容器名 = 目标容器名</code></p>
<p>插入数据：<code>容器名. insert(pair&lt;key类型, value类型&gt;(key, value))</code></p>
<hr>
<h3 id="四、stack容器"><a href="#四、stack容器" class="headerlink" title="四、stack容器"></a>四、stack容器</h3><p>stack容器可以理解成<strong>栈</strong></p>
<p>栈是一种**先进后出(FILO)**的数据结构，只有一个出入口</p>
<p>栈不允许有遍历行为，但可以判断是否为空、可以获取元素个数</p>
<p>默认构造：<code>stack&lt;数据类型&gt; 容器名</code></p>
<p>拷贝构造：<code>stack&lt;数据类型&gt; 容器名 (拷贝容器名)</code></p>
<p>赋值操作：<code>容器名 = 目标容器名</code></p>
<p>入栈：<code>push(elem)</code></p>
<p>出栈：<code>pop()</code></p>
<p>栈顶：<code>top()</code></p>
<p>判空：<code>empty()</code></p>
<p>获取大小：<code>size()</code></p>
<hr>
]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>vector</tag>
        <tag>map</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title>再临Unity</title>
    <url>/2021/07/08/2021-07-08-%E5%86%8D%E4%B8%B4Unity/</url>
    <content><![CDATA[<h3 id="始、整理"><a href="#始、整理" class="headerlink" title="始、整理"></a>始、整理</h3><p>​    闲来无事，想捣鼓一下unity，打开界面一脸懵逼。明明大学玩过一段时间的，这知识咋就不进脑子呢，又得重新学习</p>
<span id="more"></span>

<hr>
<h3 id="一、Unity快速入门"><a href="#一、Unity快速入门" class="headerlink" title="一、Unity快速入门"></a>一、Unity快速入门</h3><p>​    unity的布局和一些用过的工具多少有些联系，搞懂界面还是不难的，先从常用操作入手吧！正好找到一个最近的精简unity入门视频：</p>
<p><a href="ttps://www.bilibili.com/video/BV1Yh411h7zk?p=2">游戏开发-Unity 光速入门</a></p>
<hr>
<h3 id="二、C"><a href="#二、C" class="headerlink" title="二、C#"></a>二、C#</h3><p>​    unity脚本编写用到c#，这语言光说入门还是比较轻松的：</p>
<p><a href="https://www.bilibili.com/video/BV1sy4y1u7cw">快速学完C#编程</a></p>
<hr>
<h3 id="三、像素画资源"><a href="#三、像素画资源" class="headerlink" title="三、像素画资源"></a>三、像素画资源</h3><p>​    做点2D像素风练练手，资源就用PS自己画吧：</p>
<p><a href="https://www.bilibili.com/video/BV1o4411V7dv">使用Photoshop绘制像素画</a></p>
<hr>
<h3 id="四、教程视频"><a href="#四、教程视频" class="headerlink" title="四、教程视频"></a>四、教程视频</h3><p>M大的教学对新手玩家真的友好，不愧是unity官方认证</p>
<p><a href="https://space.bilibili.com/370283072?spm_id_from=333.788.b_636f6d6d656e74.1">M_Studio的个人空间</a></p>
]]></content>
      <categories>
        <category>琐碎</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>c#</tag>
        <tag>ps</tag>
        <tag>像素</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode.930】和相同的二元子数组</title>
    <url>/2021/07/08/2021-07-08-%E3%80%90LeetCode.930%E3%80%91%E5%92%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8C%E5%85%83%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="题目：和相同的二元子数组"><a href="#题目：和相同的二元子数组" class="headerlink" title="题目：和相同的二元子数组"></a>题目：和相同的二元子数组</h3><p>​    给你一个二元数组 <code>nums</code> ，和一个整数 <code>goal</code> ，请你统计并返回有多少个和为 <code>goal</code> 的 <strong>非空</strong> 子数组。</p>
<p>​    <strong>子数组</strong> 是数组的一段连续部分。</p>
<p>示例 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,0,1,0,1], goal = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0,0,0], goal = 0</span><br><span class="line">输出：15</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<p><code>1 &lt;= nums.length &lt;= 3 * 104</code></p>
<p><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></p>
<p><code>0 &lt;= goal &lt;= nums.length</code></p>
<hr>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    //滑动窗口法</span><br><span class="line">    //右指针逐渐向右，左一指针找到第一个符合的位置，左二指针找到最后一个符合的位置</span><br><span class="line">    int numSubarraysWithSum(vector&lt;int&gt;&amp; nums, int goal) &#123;</span><br><span class="line">        int left1 = 0, left2 = 0;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int sum1 = 0, sum2 = 0;</span><br><span class="line">        int ret = 0;</span><br><span class="line"></span><br><span class="line">        for(int right = 0; right &lt; n; right++)&#123;</span><br><span class="line">            sum2 += nums[right];</span><br><span class="line">            sum1 += nums[right];</span><br><span class="line">            while(left2 &lt;= right &amp;&amp; sum2 &gt;= goal)&#123;</span><br><span class="line">                sum2 -= nums[left2];</span><br><span class="line">                left2++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            while(left1 &lt; left2 &amp;&amp; sum1 &gt; goal)&#123;</span><br><span class="line">                sum1 -= nums[left1];</span><br><span class="line">                left1++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ret += left2 - left1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="易错点："><a href="#易错点：" class="headerlink" title="易错点："></a>易错点：</h3><p>1.提示2<code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code>，所以不用判断相等的情况<code>if(sum == goal)</code></p>
<p>2.三个只指针对应的大小关系，其中<code>left1 &lt;= left2 &lt;= right &lt;= nums.size()</code></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>滑动窗口法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>《Speed Down》Unity2d游戏开发（一）</title>
    <url>/2021/07/06/2021-07-06-%E3%80%8ASpeed%20Down%E3%80%8BUnity2d%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h3 id="始、前言"><a href="#始、前言" class="headerlink" title="始、前言"></a>始、前言</h3><p>跟随M大学习unity2d游戏开发，先来一个简单的下100层游戏！</p>
<p>版本：</p>
<p>unity 2021.1.12f1c1</p>
<p>unityhub 2.4.13</p>
<p>vs 2019</p>
<span id="more"></span>

<hr>
<h3 id="一、导入素材"><a href="#一、导入素材" class="headerlink" title="一、导入素材"></a>一、导入素材</h3><p>1.新建unity2d项目</p>
<p>2.在assetstore中查找 Pixel Adventure 1并添加到我的资源</p>
<p>3.在unity中打开Package Manager → My Assets → Pixel Adventure 1，下载并导入项目中</p>
<p>资源栏就出现这个包啦！</p>
<hr>
<h3 id="二、切换发布平台"><a href="#二、切换发布平台" class="headerlink" title="二、切换发布平台"></a>二、切换发布平台</h3><p>1.点击file → build setting → Android → switch platform</p>
<p>2.发现自己unity没有这个模块，要手动在unityhub安装模块</p>
<p>3.发现没有添加模块的按钮，要移除版本，前往官网找到改版本并选择从unityhub中下载</p>
<p>4.添加下载Android Target Support</p>
<hr>
<h3 id="三、背景图案设置"><a href="#三、背景图案设置" class="headerlink" title="三、背景图案设置"></a>三、背景图案设置</h3><p>1.新建3d object → quad，reset位置，设置scale中x为9，y为16</p>
<p>2.调整主摄像机，包裹场景</p>
<p>3.新建材质球background，修改shader为unlit → texture</p>
<p>4.选择喜欢的背景图案，更改pixel per unit为64，拖到材质球中</p>
<p>5.添加材质球到quad中</p>
<p>6.相机中没有图片，因为相机和场景重叠了，修改相机z轴位置为-10</p>
<p>简单的背景图片出现了，现在想要背景图案变成多个重复的图案，并且可以循环移动：</p>
<p>7.设置图案advanced → wrap mode → repeat，表示图案是可以循环重复的（记得apply）</p>
<p>8.更改材质球的tilling就可以看到场景图案铺垫的样子，可以看到改变offset的值就可以让场景移动</p>
<hr>
<h3 id="四、脚本实现背景移动"><a href="#四、脚本实现背景移动" class="headerlink" title="四、脚本实现背景移动"></a>四、脚本实现背景移动</h3><p>1.新建c#脚本，等unity加载完毕（右下角有转圈标识，没加载完就操作会出现奇怪的错误）</p>
<p>2.编写脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class BackgroundMove : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    Material material;</span><br><span class="line">    Vector2 movement;</span><br><span class="line"></span><br><span class="line">    public Vector2 speed;</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        material = GetComponent&lt;Renderer&gt;().material;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        movement += speed * Time.deltaTime;</span><br><span class="line">        material.mainTextureOffset = movement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：获取material时是获取组件Renderer中的material，即“material是Renderer的material”</p>
<p>这样就可以通过改变背景脚本一栏中的speed来改变背景移动速度</p>
<hr>
<h3 id="五、添加顶部尖刺"><a href="#五、添加顶部尖刺" class="headerlink" title="五、添加顶部尖刺"></a>五、添加顶部尖刺</h3><p>1.找到素材中的spikes，修改pixel per unit 为16</p>
<p>2.新建空物体TopSpikes用来存储所有的顶部尖刺</p>
<p>3.将尖刺图案拖拽到TopSpikes下方成为子物体</p>
<p>4.修改尖刺的rotation → z 为18翻转尖刺，修改scale → y为2延长图案</p>
<p>5.按住<code>V</code>可以选择锚点对齐放置，<code>ctrl + d</code>复制物体，重复步骤直到填满顶部</p>
<p>6.全选尖刺，添加组件polygon collider 2d 多边形碰撞体，打勾used by composite，即把这些尖刺的碰撞体合并起来</p>
<p>7.添加组件composite collider 2d ，此时会自动添加rigibody 2d</p>
<p>8.将rigibody 2d → body type改为static，这样尖刺就保持在原地不会掉下去</p>
<p>9.调整composite collider 2d → offset 可以改变碰撞体的位置</p>
<hr>
<h3 id="终、未完待续"><a href="#终、未完待续" class="headerlink" title="终、未完待续"></a>终、未完待续</h3><p>基本的场景搭建已经完成！</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>c#</tag>
        <tag>unityhub</tag>
        <tag>2d</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Github无法访问</title>
    <url>/2021/07/06/2021-07-06-%E8%A7%A3%E5%86%B3Github%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h3 id="一、修改host文件"><a href="#一、修改host文件" class="headerlink" title="一、修改host文件"></a>一、修改host文件</h3><p>​    在<strong>C:\Windows\System32\drivers\etc</strong>中打开<strong>host</strong>文件（可以用记事本打开），在该文件中添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># GitHub Start </span><br><span class="line">140.82.114.4 github.com</span><br><span class="line">140.82.114.4 gist.github.com</span><br><span class="line">185.199.108.153 assets-cdn.github.com</span><br><span class="line">151.101.64.133 raw.githubusercontent.com</span><br><span class="line">151.101.108.133 gist.githubusercontent.com</span><br><span class="line">151.101.108.133 cloud.githubusercontent.com</span><br><span class="line">151.101.108.133 camo.githubusercontent.com</span><br><span class="line">151.101.108.133 avatars0.githubusercontent.com</span><br><span class="line">151.101.108.133 avatars1.githubusercontent.com</span><br><span class="line">151.101.108.133 avatars2.githubusercontent.com</span><br><span class="line">151.101.108.133 avatars3.githubusercontent.com</span><br><span class="line">151.101.108.133 avatars4.githubusercontent.com</span><br><span class="line">151.101.108.133 avatars5.githubusercontent.com</span><br><span class="line">151.101.108.133 avatars6.githubusercontent.com</span><br><span class="line">151.101.108.133 avatars7.githubusercontent.com</span><br><span class="line">151.101.108.133 avatars8.githubusercontent.com </span><br><span class="line"># GitHub End</span><br></pre></td></tr></table></figure>

<p>保存文件，再次打开github速度飞快</p>
<span id="more"></span>

<hr>
<h3 id="二、win10修改文件读写的权限"><a href="#二、win10修改文件读写的权限" class="headerlink" title="二、win10修改文件读写的权限"></a>二、win10修改文件读写的权限</h3><p>​    windows系统可能遇到无法修改系统文件的问题</p>
<p>​    1.找到要修改的文件</p>
<p>​    2.右键→属性→安全→编辑→user</p>
<p>​    3.在允许编辑那一栏打勾</p>
]]></content>
      <categories>
        <category>琐碎</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人博客总结</title>
    <url>/2021/07/04/2021-07-04-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="始、报错汇总"><a href="#始、报错汇总" class="headerlink" title="始、报错汇总"></a>始、报错汇总</h3><p>1.输入<code>git g -d</code>后报错：<strong>fatal:  unable to access ‘h…://github.com/….github.io.git/</strong></p>
<p>解决方法1：重置一下git的代理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --unset git.proxy</span><br></pre></td></tr></table></figure>

<p>解决方法2：删掉<code>node_modules</code>文件夹</p>
<p>解决方法3：<code>git g</code> 和 <code>git d</code> 分两步输入</p>
<p>解决方法4：挂梯子</p>
 <span id="more"></span>

<hr>
<h3 id="一、用Hexo在本地生成博客并部署（白嫖）到github"><a href="#一、用Hexo在本地生成博客并部署（白嫖）到github" class="headerlink" title="一、用Hexo在本地生成博客并部署（白嫖）到github"></a>一、用Hexo在本地生成博客并部署（白嫖）到github</h3><p>后半部分个性化博客的教学先不看：</p>
<p><a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a></p>
<hr>
<h3 id="二、将博客的源代码也放到github托管"><a href="#二、将博客的源代码也放到github托管" class="headerlink" title="二、将博客的源代码也放到github托管"></a>二、将博客的源代码也放到github托管</h3><p>文章最后面还有作者引用的原文，两篇文章结合一起看：</p>
<p><a href="https://www.jianshu.com/p/baab04284923">Hexo | 怎么去备份你的Hexo博客</a></p>
<hr>
<h3 id="三、最后就是用我们的Typora来写作啦"><a href="#三、最后就是用我们的Typora来写作啦" class="headerlink" title="三、最后就是用我们的Typora来写作啦"></a>三、最后就是用我们的Typora来写作啦</h3><p><strong>注：在2021年11月23日，Typora 正式发布 1.0 版本，进入了付费时代。1.0 版本是一次性付费而非订阅的，只要支付人民币 89 元，可以在 3 台设备里使用。</strong></p>
<p><strong>如果不想付费，可以使用付费前的最新版本0.11.17，但无法享受之后的更新和维护</strong></p>
<p>快捷键记不记无所谓，typora工具栏全都有：</p>
<p><a href="https://zhuanlan.zhihu.com/p/156915260">Hexo博客写文章及基本操作</a></p>
<hr>
<h3 id="四、应用next主题以及个性化"><a href="#四、应用next主题以及个性化" class="headerlink" title="四、应用next主题以及个性化"></a>四、应用next主题以及个性化</h3><p>next和hexo好像还有版本适配的问题，我用旧版的next会把博客变成乱码，最终是这篇文章中的新版本适合我：</p>
<p><a href="https://zhuanlan.zhihu.com/p/60424755">hexo的next主题个性化配置</a></p>
<hr>
]]></content>
      <categories>
        <category>琐碎</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
        <tag>github</tag>
        <tag>typora</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
